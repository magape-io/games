function $extend(a, b) {
    function c() {}
    c.prototype = a;
    var d = new c;
    for (var e in b) d[e] = b[e];
    return b.toString !== Object.prototype.toString && (d.toString = b.toString), d
}

function $bind(a, b) {
        if (null == b) return null;
        null == b.__id__ && (b.__id__ = $fid++);
        var c;
        return null == a.hx__closures__ ? a.hx__closures__ = {} : c = a.hx__closures__[b.__id__], null == c && (c = function() {
            return c.method.apply(c.scope, arguments)
        }, c.scope = a, c.method = b, a.hx__closures__[b.__id__] = c), c
    }! function(a) {
        if ("object" == typeof exports) module.exports = a();
        else if ("function" == typeof define, 1) {
            var b;
            "undefined" != typeof window ? b = window : "undefined" != typeof global ? b = global : "undefined" != typeof self && (b = self), b.p2 = a()
        } else define(a)
    }(function() {
        return function a(b, c, d) {
            function e(g, h) {
                if (!c[g]) {
                    if (!b[g]) {
                        var i = "function" == typeof require && require;
                        if (!h && i) return i(g, !0);
                        if (f) return f(g, !0);
                        throw new Error("Cannot find module '" + g + "'")
                    }
                    var j = c[g] = {
                        exports: {}
                    };
                    b[g][0].call(j.exports, function(a) {
                        var c = b[g][1][a];
                        return e(c ? c : a)
                    }, j, j.exports, a, b, c, d)
                }
                return c[g].exports
            }
            for (var f = "function" == typeof require && require, g = 0; g < d.length; g++) e(d[g]);
            return e
        }({
            1: [
                function(a, b, c) {
                    function d() {}
                    var e = a("./Scalar");
                    b.exports = d, d.lineInt = function(a, b, c) {
                        c = c || 0;
                        var d, f, g, h, i, j, k, l = [0, 0];
                        return d = a[1][1] - a[0][1], f = a[0][0] - a[1][0], g = d * a[0][0] + f * a[0][1], h = b[1][1] - b[0][1], i = b[0][0] - b[1][0], j = h * b[0][0] + i * b[0][1], k = d * i - h * f, e.eq(k, 0, c) || (l[0] = (i * g - f * j) / k, l[1] = (d * j - h * g) / k), l
                    }, d.segmentsIntersect = function(a, b, c, d) {
                        var e = b[0] - a[0],
                            f = b[1] - a[1],
                            g = d[0] - c[0],
                            h = d[1] - c[1];
                        if (g * f - h * e == 0) return !1;
                        var i = (e * (c[1] - a[1]) + f * (a[0] - c[0])) / (g * f - h * e),
                            j = (g * (a[1] - c[1]) + h * (c[0] - a[0])) / (h * e - g * f);
                        return i >= 0 && i <= 1 && j >= 0 && j <= 1
                    }
                }, {
                    "./Scalar": 4
                }
            ],
            2: [
                function(a, b, c) {
                    function d() {}
                    b.exports = d, d.area = function(a, b, c) {
                        return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1])
                    }, d.left = function(a, b, c) {
                        return d.area(a, b, c) > 0
                    }, d.leftOn = function(a, b, c) {
                        return d.area(a, b, c) >= 0
                    }, d.right = function(a, b, c) {
                        return d.area(a, b, c) < 0
                    }, d.rightOn = function(a, b, c) {
                        return d.area(a, b, c) <= 0
                    };
                    var e = [],
                        f = [];
                    d.collinear = function(a, b, c, g) {
                        if (g) {
                            var h = e,
                                i = f;
                            h[0] = b[0] - a[0], h[1] = b[1] - a[1], i[0] = c[0] - b[0], i[1] = c[1] - b[1];
                            var j = h[0] * i[0] + h[1] * i[1],
                                k = Math.sqrt(h[0] * h[0] + h[1] * h[1]),
                                l = Math.sqrt(i[0] * i[0] + i[1] * i[1]),
                                m = Math.acos(j / (k * l));
                            return m < g
                        }
                        return 0 == d.area(a, b, c)
                    }, d.sqdist = function(a, b) {
                        var c = b[0] - a[0],
                            d = b[1] - a[1];
                        return c * c + d * d
                    }
                }, {}
            ],
            3: [
                function(a, b, c) {
                    function d() {
                        this.vertices = []
                    }

                    function e(a, b, c, d, e) {
                        e = e || 0;
                        var f = b[1] - a[1],
                            g = a[0] - b[0],
                            i = f * a[0] + g * a[1],
                            j = d[1] - c[1],
                            k = c[0] - d[0],
                            l = j * c[0] + k * c[1],
                            m = f * k - j * g;
                        return h.eq(m, 0, e) ? [0, 0] : [(k * i - g * l) / m, (f * l - j * i) / m]
                    }
                    var f = a("./Line"),
                        g = a("./Point"),
                        h = a("./Scalar");
                    b.exports = d, d.prototype.at = function(a) {
                        var b = this.vertices,
                            c = b.length;
                        return b[a < 0 ? a % c + c : a % c]
                    }, d.prototype.first = function() {
                        return this.vertices[0]
                    }, d.prototype.last = function() {
                        return this.vertices[this.vertices.length - 1]
                    }, d.prototype.clear = function() {
                        this.vertices.length = 0
                    }, d.prototype.append = function(a, b, c) {
                        if ("undefined" == typeof b) throw new Error("From is not given!");
                        if ("undefined" == typeof c) throw new Error("To is not given!");
                        if (c - 1 < b) throw new Error("lol1");
                        if (c > a.vertices.length) throw new Error("lol2");
                        if (b < 0) throw new Error("lol3");
                        for (var d = b; d < c; d++) this.vertices.push(a.vertices[d])
                    }, d.prototype.makeCCW = function() {
                        for (var a = 0, b = this.vertices, c = 1; c < this.vertices.length; ++c)(b[c][1] < b[a][1] || b[c][1] == b[a][1] && b[c][0] > b[a][0]) && (a = c);
                        g.left(this.at(a - 1), this.at(a), this.at(a + 1)) || this.reverse()
                    }, d.prototype.reverse = function() {
                        for (var a = [], b = 0, c = this.vertices.length; b !== c; b++) a.push(this.vertices.pop());
                        this.vertices = a
                    }, d.prototype.isReflex = function(a) {
                        return g.right(this.at(a - 1), this.at(a), this.at(a + 1))
                    };
                    var i = [],
                        j = [];
                    d.prototype.canSee = function(a, b) {
                        var c, d, e = i,
                            h = j;
                        if (g.leftOn(this.at(a + 1), this.at(a), this.at(b)) && g.rightOn(this.at(a - 1), this.at(a), this.at(b))) return !1;
                        d = g.sqdist(this.at(a), this.at(b));
                        for (var k = 0; k !== this.vertices.length; ++k)
                            if ((k + 1) % this.vertices.length !== a && k !== a && g.leftOn(this.at(a), this.at(b), this.at(k + 1)) && g.rightOn(this.at(a), this.at(b), this.at(k)) && (e[0] = this.at(a), e[1] = this.at(b), h[0] = this.at(k), h[1] = this.at(k + 1), c = f.lineInt(e, h), g.sqdist(this.at(a), c) < d)) return !1;
                        return !0
                    }, d.prototype.copy = function(a, b, c) {
                        var e = c || new d;
                        if (e.clear(), a < b)
                            for (var f = a; f <= b; f++) e.vertices.push(this.vertices[f]);
                        else {
                            for (var f = 0; f <= b; f++) e.vertices.push(this.vertices[f]);
                            for (var f = a; f < this.vertices.length; f++) e.vertices.push(this.vertices[f])
                        }
                        return e
                    }, d.prototype.getCutEdges = function() {
                        for (var a = [], b = [], c = [], e = new d, f = Number.MAX_VALUE, g = 0; g < this.vertices.length; ++g)
                            if (this.isReflex(g))
                                for (var h = 0; h < this.vertices.length; ++h)
                                    if (this.canSee(g, h)) {
                                        b = this.copy(g, h, e).getCutEdges(), c = this.copy(h, g, e).getCutEdges();
                                        for (var i = 0; i < c.length; i++) b.push(c[i]);
                                        b.length < f && (a = b, f = b.length, a.push([this.at(g), this.at(h)]))
                                    }
                        return a
                    }, d.prototype.decomp = function() {
                        var a = this.getCutEdges();
                        return a.length > 0 ? this.slice(a) : [this]
                    }, d.prototype.slice = function(a) {
                        if (0 == a.length) return [this];
                        if (a instanceof Array && a.length && a[0] instanceof Array && 2 == a[0].length && a[0][0] instanceof Array) {
                            for (var b = [this], c = 0; c < a.length; c++)
                                for (var d = a[c], e = 0; e < b.length; e++) {
                                    var f = b[e],
                                        g = f.slice(d);
                                    if (g) {
                                        b.splice(e, 1), b.push(g[0], g[1]);
                                        break
                                    }
                                }
                            return b
                        }
                        var d = a,
                            c = this.vertices.indexOf(d[0]),
                            e = this.vertices.indexOf(d[1]);
                        return c != -1 && e != -1 && [this.copy(c, e), this.copy(e, c)]
                    }, d.prototype.isSimple = function() {
                        for (var a = this.vertices, b = 0; b < a.length - 1; b++)
                            for (var c = 0; c < b - 1; c++)
                                if (f.segmentsIntersect(a[b], a[b + 1], a[c], a[c + 1])) return !1;
                        for (var b = 1; b < a.length - 2; b++)
                            if (f.segmentsIntersect(a[0], a[a.length - 1], a[b], a[b + 1])) return !1;
                        return !0
                    }, d.prototype.quickDecomp = function(a, b, c, f, h, i) {
                        h = h || 100, i = i || 0, f = f || 25, a = "undefined" != typeof a ? a : [], b = b || [], c = c || [];
                        var j = [0, 0],
                            k = [0, 0],
                            l = [0, 0],
                            m = 0,
                            n = 0,
                            o = 0,
                            p = 0,
                            q = 0,
                            r = 0,
                            s = 0,
                            t = new d,
                            u = new d,
                            v = this,
                            w = this.vertices;
                        if (w.length < 3) return a;
                        if (i++, i > h) return a;
                        for (var x = 0; x < this.vertices.length; ++x)
                            if (v.isReflex(x)) {
                                b.push(v.vertices[x]), m = n = Number.MAX_VALUE;
                                for (var y = 0; y < this.vertices.length; ++y) g.left(v.at(x - 1), v.at(x), v.at(y)) && g.rightOn(v.at(x - 1), v.at(x), v.at(y - 1)) && (l = e(v.at(x - 1), v.at(x), v.at(y), v.at(y - 1)), g.right(v.at(x + 1), v.at(x), l) && (o = g.sqdist(v.vertices[x], l), o < n && (n = o, k = l, r = y))), g.left(v.at(x + 1), v.at(x), v.at(y + 1)) && g.rightOn(v.at(x + 1), v.at(x), v.at(y)) && (l = e(v.at(x + 1), v.at(x), v.at(y), v.at(y + 1)), g.left(v.at(x - 1), v.at(x), l) && (o = g.sqdist(v.vertices[x], l), o < m && (m = o, j = l, q = y)));
                                if (r == (q + 1) % this.vertices.length) l[0] = (k[0] + j[0]) / 2, l[1] = (k[1] + j[1]) / 2, c.push(l), x < q ? (t.append(v, x, q + 1), t.vertices.push(l), u.vertices.push(l), 0 != r && u.append(v, r, v.vertices.length), u.append(v, 0, x + 1)) : (0 != x && t.append(v, x, v.vertices.length), t.append(v, 0, q + 1), t.vertices.push(l), u.vertices.push(l), u.append(v, r, x + 1));
                                else {
                                    if (r > q && (q += this.vertices.length), p = Number.MAX_VALUE, q < r) return a;
                                    for (var y = r; y <= q; ++y) g.leftOn(v.at(x - 1), v.at(x), v.at(y)) && g.rightOn(v.at(x + 1), v.at(x), v.at(y)) && (o = g.sqdist(v.at(x), v.at(y)), o < p && (p = o, s = y % this.vertices.length));
                                    x < s ? (t.append(v, x, s + 1), 0 != s && u.append(v, s, w.length), u.append(v, 0, x + 1)) : (0 != x && t.append(v, x, w.length), t.append(v, 0, s + 1), u.append(v, s, x + 1))
                                }
                                return t.vertices.length < u.vertices.length ? (t.quickDecomp(a, b, c, f, h, i), u.quickDecomp(a, b, c, f, h, i)) : (u.quickDecomp(a, b, c, f, h, i), t.quickDecomp(a, b, c, f, h, i)), a
                            }
                        return a.push(this), a
                    }, d.prototype.removeCollinearPoints = function(a) {
                        for (var b = 0, c = this.vertices.length - 1; this.vertices.length > 3 && c >= 0; --c) g.collinear(this.at(c - 1), this.at(c), this.at(c + 1), a) && (this.vertices.splice(c % this.vertices.length, 1), c--, b++);
                        return b
                    }
                }, {
                    "./Line": 1,
                    "./Point": 2,
                    "./Scalar": 4
                }
            ],
            4: [
                function(a, b, c) {
                    function d() {}
                    b.exports = d, d.eq = function(a, b, c) {
                        return c = c || 0, Math.abs(a - b) < c
                    }
                }, {}
            ],
            5: [
                function(a, b, c) {
                    b.exports = {
                        Polygon: a("./Polygon"),
                        Point: a("./Point")
                    }
                }, {
                    "./Point": 2,
                    "./Polygon": 3
                }
            ],
            6: [
                function(a, b, c) {
                    b.exports = {
                        name: "p2",
                        version: "0.7.0",
                        description: "A JavaScript 2D physics engine.",
                        author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                        keywords: ["p2.js", "p2", "physics", "engine", "2d"],
                        main: "./src/p2.js",
                        engines: {
                            node: "*"
                        },
                        repository: {
                            type: "git",
                            url: "https://github.com/schteppe/p2.js.git"
                        },
                        bugs: {
                            url: "https://github.com/schteppe/p2.js/issues"
                        },
                        licenses: [{
                            type: "MIT"
                        }],
                        devDependencies: {
                            grunt: "^0.4.5",
                            "grunt-contrib-jshint": "^0.11.2",
                            "grunt-contrib-nodeunit": "^0.4.1",
                            "grunt-contrib-uglify": "~0.4.0",
                            "grunt-contrib-watch": "~0.5.0",
                            "grunt-browserify": "~2.0.1",
                            "grunt-contrib-concat": "^0.4.0"
                        },
                        dependencies: {
                            "poly-decomp": "0.1.0"
                        }
                    }
                }, {}
            ],
            7: [
                function(a, b, c) {
                    function d(a) {
                        this.lowerBound = e.create(), a && a.lowerBound && e.copy(this.lowerBound, a.lowerBound), this.upperBound = e.create(), a && a.upperBound && e.copy(this.upperBound, a.upperBound)
                    }
                    var e = a("../math/vec2");
                    a("../utils/Utils"), b.exports = d;
                    var f = e.create();
                    d.prototype.setFromPoints = function(a, b, c, d) {
                        var g = this.lowerBound,
                            h = this.upperBound;
                        "number" != typeof c && (c = 0), 0 !== c ? e.rotate(g, a[0], c) : e.copy(g, a[0]), e.copy(h, g);
                        for (var i = Math.cos(c), j = Math.sin(c), k = 1; k < a.length; k++) {
                            var l = a[k];
                            if (0 !== c) {
                                var m = l[0],
                                    n = l[1];
                                f[0] = i * m - j * n, f[1] = j * m + i * n, l = f
                            }
                            for (var o = 0; o < 2; o++) l[o] > h[o] && (h[o] = l[o]), l[o] < g[o] && (g[o] = l[o])
                        }
                        b && (e.add(this.lowerBound, this.lowerBound, b), e.add(this.upperBound, this.upperBound, b)), d && (this.lowerBound[0] -= d, this.lowerBound[1] -= d, this.upperBound[0] += d, this.upperBound[1] += d)
                    }, d.prototype.copy = function(a) {
                        e.copy(this.lowerBound, a.lowerBound), e.copy(this.upperBound, a.upperBound)
                    }, d.prototype.extend = function(a) {
                        for (var b = 2; b--;) {
                            var c = a.lowerBound[b];
                            this.lowerBound[b] > c && (this.lowerBound[b] = c);
                            var d = a.upperBound[b];
                            this.upperBound[b] < d && (this.upperBound[b] = d)
                        }
                    }, d.prototype.overlaps = function(a) {
                        var b = this.lowerBound,
                            c = this.upperBound,
                            d = a.lowerBound,
                            e = a.upperBound;
                        return (d[0] <= c[0] && c[0] <= e[0] || b[0] <= e[0] && e[0] <= c[0]) && (d[1] <= c[1] && c[1] <= e[1] || b[1] <= e[1] && e[1] <= c[1])
                    }, d.prototype.containsPoint = function(a) {
                        var b = this.lowerBound,
                            c = this.upperBound;
                        return b[0] <= a[0] && a[0] <= c[0] && b[1] <= a[1] && a[1] <= c[1]
                    }, d.prototype.overlapsRay = function(a) {
                        var b = 1 / a.direction[0],
                            c = 1 / a.direction[1],
                            d = (this.lowerBound[0] - a.from[0]) * b,
                            e = (this.upperBound[0] - a.from[0]) * b,
                            f = (this.lowerBound[1] - a.from[1]) * c,
                            g = (this.upperBound[1] - a.from[1]) * c,
                            h = Math.max(Math.max(Math.min(d, e), Math.min(f, g))),
                            i = Math.min(Math.min(Math.max(d, e), Math.max(f, g)));
                        return i < 0 ? -1 : h > i ? -1 : h
                    }
                }, {
                    "../math/vec2": 30,
                    "../utils/Utils": 57
                }
            ],
            8: [
                function(a, b, c) {
                    function d(a) {
                        this.type = a, this.result = [], this.world = null, this.boundingVolumeType = d.AABB
                    }
                    var e = a("../math/vec2"),
                        f = a("../objects/Body");
                    b.exports = d, d.AABB = 1, d.BOUNDING_CIRCLE = 2, d.prototype.setWorld = function(a) {
                        this.world = a
                    }, d.prototype.getCollisionPairs = function(a) {};
                    var g = e.create();
                    d.boundingRadiusCheck = function(a, b) {
                        e.sub(g, a.position, b.position);
                        var c = e.squaredLength(g),
                            d = a.boundingRadius + b.boundingRadius;
                        return c <= d * d
                    }, d.aabbCheck = function(a, b) {
                        return a.getAABB().overlaps(b.getAABB())
                    }, d.prototype.boundingVolumeCheck = function(a, b) {
                        var c;
                        switch (this.boundingVolumeType) {
                            case d.BOUNDING_CIRCLE:
                                c = d.boundingRadiusCheck(a, b);
                                break;
                            case d.AABB:
                                c = d.aabbCheck(a, b);
                                break;
                            default:
                                throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType)
                        }
                        return c
                    }, d.canCollide = function(a, b) {
                        var c = f.KINEMATIC,
                            d = f.STATIC;
                        return !(a.type === d && b.type === d || a.type === c && b.type === d || a.type === d && b.type === c || a.type === c && b.type === c || a.sleepState === f.SLEEPING && b.sleepState === f.SLEEPING || a.sleepState === f.SLEEPING && b.type === d || b.sleepState === f.SLEEPING && a.type === d)
                    }, d.NAIVE = 1, d.SAP = 2
                }, {
                    "../math/vec2": 30,
                    "../objects/Body": 31
                }
            ],
            9: [
                function(a, b, c) {
                    function d() {
                        e.call(this, e.NAIVE)
                    }
                    var e = (a("../shapes/Circle"), a("../shapes/Plane"), a("../shapes/Shape"), a("../shapes/Particle"), a("../collision/Broadphase"));
                    a("../math/vec2"), b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.getCollisionPairs = function(a) {
                        var b = a.bodies,
                            c = this.result;
                        c.length = 0;
                        for (var d = 0, f = b.length; d !== f; d++)
                            for (var g = b[d], h = 0; h < d; h++) {
                                var i = b[h];
                                e.canCollide(g, i) && this.boundingVolumeCheck(g, i) && c.push(g, i)
                            }
                        return c
                    }, d.prototype.aabbQuery = function(a, b, c) {
                        c = c || [];
                        for (var d = a.bodies, e = 0; e < d.length; e++) {
                            var f = d[e];
                            f.aabbNeedsUpdate && f.updateAABB(), f.aabb.overlaps(b) && c.push(f)
                        }
                        return c
                    }
                }, {
                    "../collision/Broadphase": 8,
                    "../math/vec2": 30,
                    "../shapes/Circle": 39,
                    "../shapes/Particle": 43,
                    "../shapes/Plane": 44,
                    "../shapes/Shape": 45
                }
            ],
            10: [
                function(a, b, c) {
                    function d() {
                        this.contactEquations = [], this.frictionEquations = [], this.enableFriction = !0, this.enabledEquations = !0, this.slipForce = 10, this.frictionCoefficient = .3, this.surfaceVelocity = 0, this.contactEquationPool = new k({
                            size: 32
                        }), this.frictionEquationPool = new l({
                            size: 64
                        }), this.restitution = 0, this.stiffness = n.DEFAULT_STIFFNESS, this.relaxation = n.DEFAULT_RELAXATION, this.frictionStiffness = n.DEFAULT_STIFFNESS, this.frictionRelaxation = n.DEFAULT_RELAXATION, this.enableFrictionReduction = !0, this.collidingBodiesLastStep = new m, this.contactSkinSize = .01
                    }

                    function e(a, b) {
                        g.set(a.vertices[0], .5 * -b.length, -b.radius), g.set(a.vertices[1], .5 * b.length, -b.radius), g.set(a.vertices[2], .5 * b.length, b.radius), g.set(a.vertices[3], .5 * -b.length, b.radius)
                    }

                    function f(a, b, c, d) {
                        for (var e = T, f = U, j = V, k = W, l = a, m = b.vertices, n = null, o = 0; o !== m.length + 1; o++) {
                            var p = m[o % m.length],
                                q = m[(o + 1) % m.length];
                            g.rotate(e, p, d), g.rotate(f, q, d), i(e, e, c), i(f, f, c), h(j, e, l), h(k, f, l);
                            var r = g.crossLength(j, k);
                            if (null === n && (n = r), r * n <= 0) return !1;
                            n = r
                        }
                        return !0
                    }
                    var g = a("../math/vec2"),
                        h = g.sub,
                        i = g.add,
                        j = g.dot,
                        k = (a("../utils/Utils"), a("../utils/ContactEquationPool")),
                        l = a("../utils/FrictionEquationPool"),
                        m = a("../utils/TupleDictionary"),
                        n = a("../equations/Equation"),
                        o = (a("../equations/ContactEquation"), a("../equations/FrictionEquation"), a("../shapes/Circle")),
                        p = a("../shapes/Convex"),
                        q = a("../shapes/Shape"),
                        r = (a("../objects/Body"), a("../shapes/Box"));
                    b.exports = d;
                    var s = g.fromValues(0, 1),
                        t = g.fromValues(0, 0),
                        u = g.fromValues(0, 0),
                        v = g.fromValues(0, 0),
                        w = g.fromValues(0, 0),
                        x = g.fromValues(0, 0),
                        y = g.fromValues(0, 0),
                        z = g.fromValues(0, 0),
                        A = g.fromValues(0, 0),
                        B = g.fromValues(0, 0),
                        C = g.fromValues(0, 0),
                        D = g.fromValues(0, 0),
                        E = g.fromValues(0, 0),
                        F = g.fromValues(0, 0),
                        G = g.fromValues(0, 0),
                        H = g.fromValues(0, 0),
                        I = g.fromValues(0, 0),
                        J = g.fromValues(0, 0),
                        K = g.fromValues(0, 0),
                        L = [],
                        M = g.create(),
                        N = g.create();
                    d.prototype.bodiesOverlap = function(a, b) {
                        for (var c = M, d = N, e = 0, f = a.shapes.length; e !== f; e++) {
                            var g = a.shapes[e];
                            a.toWorldFrame(c, g.position);
                            for (var h = 0, i = b.shapes.length; h !== i; h++) {
                                var j = b.shapes[h];
                                if (b.toWorldFrame(d, j.position), this[g.type | j.type](a, g, c, g.angle + a.angle, b, j, d, j.angle + b.angle, !0)) return !0
                            }
                        }
                        return !1
                    }, d.prototype.collidedLastStep = function(a, b) {
                        var c = 0 | a.id,
                            d = 0 | b.id;
                        return !!this.collidingBodiesLastStep.get(c, d)
                    }, d.prototype.reset = function() {
                        this.collidingBodiesLastStep.reset();
                        for (var a = this.contactEquations, b = a.length; b--;) {
                            var c = a[b],
                                d = c.bodyA.id,
                                e = c.bodyB.id;
                            this.collidingBodiesLastStep.set(d, e, !0)
                        }
                        for (var f = this.contactEquations, g = this.frictionEquations, h = 0; h < f.length; h++) this.contactEquationPool.release(f[h]);
                        for (var h = 0; h < g.length; h++) this.frictionEquationPool.release(g[h]);
                        this.contactEquations.length = this.frictionEquations.length = 0
                    }, d.prototype.createContactEquation = function(a, b, c, d) {
                        var e = this.contactEquationPool.get();
                        return e.bodyA = a, e.bodyB = b, e.shapeA = c, e.shapeB = d, e.restitution = this.restitution, e.firstImpact = !this.collidedLastStep(a, b), e.stiffness = this.stiffness, e.relaxation = this.relaxation, e.needsUpdate = !0, e.enabled = this.enabledEquations, e.offset = this.contactSkinSize, e
                    }, d.prototype.createFrictionEquation = function(a, b, c, d) {
                        var e = this.frictionEquationPool.get();
                        return e.bodyA = a, e.bodyB = b, e.shapeA = c, e.shapeB = d, e.setSlipForce(this.slipForce), e.frictionCoefficient = this.frictionCoefficient, e.relativeVelocity = this.surfaceVelocity, e.enabled = this.enabledEquations, e.needsUpdate = !0, e.stiffness = this.frictionStiffness, e.relaxation = this.frictionRelaxation, e.contactEquations.length = 0, e
                    }, d.prototype.createFrictionFromContact = function(a) {
                        var b = this.createFrictionEquation(a.bodyA, a.bodyB, a.shapeA, a.shapeB);
                        return g.copy(b.contactPointA, a.contactPointA), g.copy(b.contactPointB, a.contactPointB), g.rotate90cw(b.t, a.normalA), b.contactEquations.push(a), b
                    }, d.prototype.createFrictionFromAverage = function(a) {
                        var b = this.contactEquations[this.contactEquations.length - 1],
                            c = this.createFrictionEquation(b.bodyA, b.bodyB, b.shapeA, b.shapeB),
                            d = b.bodyA;
                        b.bodyB, g.set(c.contactPointA, 0, 0), g.set(c.contactPointB, 0, 0), g.set(c.t, 0, 0);
                        for (var e = 0; e !== a; e++) b = this.contactEquations[this.contactEquations.length - 1 - e], b.bodyA === d ? (g.add(c.t, c.t, b.normalA), g.add(c.contactPointA, c.contactPointA, b.contactPointA), g.add(c.contactPointB, c.contactPointB, b.contactPointB)) : (g.sub(c.t, c.t, b.normalA), g.add(c.contactPointA, c.contactPointA, b.contactPointB), g.add(c.contactPointB, c.contactPointB, b.contactPointA)), c.contactEquations.push(b);
                        var f = 1 / a;
                        return g.scale(c.contactPointA, c.contactPointA, f), g.scale(c.contactPointB, c.contactPointB, f), g.normalize(c.t, c.t), g.rotate90cw(c.t, c.t), c
                    }, d.prototype[q.LINE | q.CONVEX] = d.prototype.convexLine = function(a, b, c, d, e, f, g, h, i) {
                        return !i && 0
                    }, d.prototype[q.LINE | q.BOX] = d.prototype.lineBox = function(a, b, c, d, e, f, g, h, i) {
                        return !i && 0
                    };
                    var O = new r({
                            width: 1,
                            height: 1
                        }),
                        P = g.create();
                    d.prototype[q.CAPSULE | q.CONVEX] = d.prototype[q.CAPSULE | q.BOX] = d.prototype.convexCapsule = function(a, b, c, d, f, h, i, j, k) {
                        var l = P;
                        g.set(l, h.length / 2, 0), g.rotate(l, l, j), g.add(l, l, i);
                        var m = this.circleConvex(f, h, l, j, a, b, c, d, k, h.radius);
                        g.set(l, -h.length / 2, 0), g.rotate(l, l, j), g.add(l, l, i);
                        var n = this.circleConvex(f, h, l, j, a, b, c, d, k, h.radius);
                        if (k && (m || n)) return !0;
                        var o = O;
                        e(o, h);
                        var p = this.convexConvex(a, b, c, d, f, o, i, j, k);
                        return p + m + n
                    }, d.prototype[q.CAPSULE | q.LINE] = d.prototype.lineCapsule = function(a, b, c, d, e, f, g, h, i) {
                        return !i && 0
                    };
                    var Q = g.create(),
                        R = g.create(),
                        S = new r({
                            width: 1,
                            height: 1
                        });
                    d.prototype[q.CAPSULE | q.CAPSULE] = d.prototype.capsuleCapsule = function(a, b, c, d, f, h, i, j, k) {
                        for (var l, m = Q, n = R, o = 0, p = 0; p < 2; p++) {
                            g.set(m, (0 === p ? -1 : 1) * b.length / 2, 0), g.rotate(m, m, d), g.add(m, m, c);
                            for (var q = 0; q < 2; q++) {
                                g.set(n, (0 === q ? -1 : 1) * h.length / 2, 0), g.rotate(n, n, j), g.add(n, n, i), this.enableFrictionReduction && (l = this.enableFriction, this.enableFriction = !1);
                                var r = this.circleCircle(a, b, m, d, f, h, n, j, k, b.radius, h.radius);
                                if (this.enableFrictionReduction && (this.enableFriction = l), k && r) return !0;
                                o += r
                            }
                        }
                        this.enableFrictionReduction && (l = this.enableFriction, this.enableFriction = !1);
                        var s = S;
                        e(s, b);
                        var t = this.convexCapsule(a, s, c, d, f, h, i, j, k);
                        if (this.enableFrictionReduction && (this.enableFriction = l), k && t) return !0;
                        if (o += t, this.enableFrictionReduction) {
                            var l = this.enableFriction;
                            this.enableFriction = !1
                        }
                        e(s, h);
                        var u = this.convexCapsule(f, s, i, j, a, b, c, d, k);
                        return this.enableFrictionReduction && (this.enableFriction = l), !(!k || !u) || (o += u, this.enableFrictionReduction && o && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(o)), o)
                    }, d.prototype[q.LINE | q.LINE] = d.prototype.lineLine = function(a, b, c, d, e, f, g, h, i) {
                        return !i && 0
                    }, d.prototype[q.PLANE | q.LINE] = d.prototype.planeLine = function(a, b, c, d, e, f, k, l, m) {
                        var n = t,
                            o = u,
                            p = v,
                            q = w,
                            r = x,
                            C = y,
                            D = z,
                            E = A,
                            F = B,
                            G = L,
                            H = 0;
                        g.set(n, -f.length / 2, 0), g.set(o, f.length / 2, 0), g.rotate(p, n, l), g.rotate(q, o, l), i(p, p, k), i(q, q, k), g.copy(n, p), g.copy(o, q), h(r, o, n), g.normalize(C, r), g.rotate90cw(F, C), g.rotate(E, s, d), G[0] = n, G[1] = o;
                        for (var I = 0; I < G.length; I++) {
                            var J = G[I];
                            h(D, J, c);
                            var K = j(D, E);
                            if (K < 0) {
                                if (m) return !0;
                                var M = this.createContactEquation(a, e, b, f);
                                H++, g.copy(M.normalA, E), g.normalize(M.normalA, M.normalA), g.scale(D, E, K), h(M.contactPointA, J, D), h(M.contactPointA, M.contactPointA, a.position), h(M.contactPointB, J, k), i(M.contactPointB, M.contactPointB, k), h(M.contactPointB, M.contactPointB, e.position), this.contactEquations.push(M), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(M))
                            }
                        }
                        return !m && (this.enableFrictionReduction || H && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(H)), H)
                    }, d.prototype[q.PARTICLE | q.CAPSULE] = d.prototype.particleCapsule = function(a, b, c, d, e, f, g, h, i) {
                        return this.circleLine(a, b, c, d, e, f, g, h, i, f.radius, 0)
                    }, d.prototype[q.CIRCLE | q.LINE] = d.prototype.circleLine = function(a, b, c, d, e, f, k, l, m, n, o) {
                        var n = n || 0,
                            o = "undefined" != typeof o ? o : b.radius,
                            p = t,
                            q = u,
                            r = v,
                            s = w,
                            H = x,
                            I = y,
                            J = z,
                            K = A,
                            M = B,
                            N = C,
                            O = D,
                            P = E,
                            Q = F,
                            R = G,
                            S = L;
                        g.set(K, -f.length / 2, 0), g.set(M, f.length / 2, 0), g.rotate(N, K, l), g.rotate(O, M, l), i(N, N, k), i(O, O, k), g.copy(K, N), g.copy(M, O), h(I, M, K), g.normalize(J, I), g.rotate90cw(H, J), h(P, c, K);
                        var T = j(P, H);
                        h(s, K, k), h(Q, c, k);
                        var U = o + n;
                        if (Math.abs(T) < U) {
                            g.scale(p, H, T), h(r, c, p), g.scale(q, H, j(H, Q)), g.normalize(q, q), g.scale(q, q, n), i(r, r, q);
                            var V = j(J, r),
                                W = j(J, K),
                                X = j(J, M);
                            if (V > W && V < X) {
                                if (m) return !0;
                                var Y = this.createContactEquation(a, e, b, f);
                                return g.scale(Y.normalA, p, -1), g.normalize(Y.normalA, Y.normalA), g.scale(Y.contactPointA, Y.normalA, o), i(Y.contactPointA, Y.contactPointA, c), h(Y.contactPointA, Y.contactPointA, a.position), h(Y.contactPointB, r, k), i(Y.contactPointB, Y.contactPointB, k), h(Y.contactPointB, Y.contactPointB, e.position), this.contactEquations.push(Y), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Y)), 1
                            }
                        }
                        S[0] = K, S[1] = M;
                        for (var Z = 0; Z < S.length; Z++) {
                            var $ = S[Z];
                            if (h(P, $, c), g.squaredLength(P) < Math.pow(U, 2)) {
                                if (m) return !0;
                                var Y = this.createContactEquation(a, e, b, f);
                                return g.copy(Y.normalA, P), g.normalize(Y.normalA, Y.normalA), g.scale(Y.contactPointA, Y.normalA, o), i(Y.contactPointA, Y.contactPointA, c), h(Y.contactPointA, Y.contactPointA, a.position), h(Y.contactPointB, $, k), g.scale(R, Y.normalA, -n), i(Y.contactPointB, Y.contactPointB, R), i(Y.contactPointB, Y.contactPointB, k), h(Y.contactPointB, Y.contactPointB, e.position), this.contactEquations.push(Y), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Y)), 1
                            }
                        }
                        return 0
                    }, d.prototype[q.CIRCLE | q.CAPSULE] = d.prototype.circleCapsule = function(a, b, c, d, e, f, g, h, i) {
                        return this.circleLine(a, b, c, d, e, f, g, h, i, f.radius)
                    }, d.prototype[q.CIRCLE | q.CONVEX] = d.prototype[q.CIRCLE | q.BOX] = d.prototype.circleConvex = function(a, b, c, d, e, j, k, l, m, n) {
                        for (var n = "number" == typeof n ? n : b.radius, o = t, p = u, q = v, r = w, s = x, y = C, z = D, A = F, B = G, E = H, J = I, K = !1, L = Number.MAX_VALUE, M = j.vertices, N = 0; N !== M.length + 1; N++) {
                            var O = M[N % M.length],
                                P = M[(N + 1) % M.length];
                            if (g.rotate(o, O, l), g.rotate(p, P, l), i(o, o, k), i(p, p, k), h(q, p, o), g.normalize(r, q), g.rotate90cw(s, r), g.scale(B, s, -b.radius), i(B, B, c), f(B, j, k, l)) {
                                g.sub(E, o, B);
                                var Q = Math.abs(g.dot(E, s));
                                Q < L && (g.copy(J, B), L = Q, g.scale(A, s, Q), g.add(A, A, B), K = !0)
                            }
                        }
                        if (K) {
                            if (m) return !0;
                            var R = this.createContactEquation(a, e, b, j);
                            return g.sub(R.normalA, J, c), g.normalize(R.normalA, R.normalA), g.scale(R.contactPointA, R.normalA, n), i(R.contactPointA, R.contactPointA, c), h(R.contactPointA, R.contactPointA, a.position), h(R.contactPointB, A, k), i(R.contactPointB, R.contactPointB, k), h(R.contactPointB, R.contactPointB, e.position), this.contactEquations.push(R), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(R)), 1
                        }
                        if (n > 0)
                            for (var N = 0; N < M.length; N++) {
                                var S = M[N];
                                if (g.rotate(z, S, l), i(z, z, k), h(y, z, c), g.squaredLength(y) < Math.pow(n, 2)) {
                                    if (m) return !0;
                                    var R = this.createContactEquation(a, e, b, j);
                                    return g.copy(R.normalA, y), g.normalize(R.normalA, R.normalA), g.scale(R.contactPointA, R.normalA, n), i(R.contactPointA, R.contactPointA, c), h(R.contactPointA, R.contactPointA, a.position), h(R.contactPointB, z, k), i(R.contactPointB, R.contactPointB, k), h(R.contactPointB, R.contactPointB, e.position), this.contactEquations.push(R), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(R)), 1
                                }
                            }
                        return 0
                    };
                    var T = g.create(),
                        U = g.create(),
                        V = g.create(),
                        W = g.create();
                    d.prototype[q.PARTICLE | q.CONVEX] = d.prototype[q.PARTICLE | q.BOX] = d.prototype.particleConvex = function(a, b, c, d, e, k, l, m, n) {
                        var o = t,
                            p = u,
                            q = v,
                            r = w,
                            s = x,
                            A = y,
                            B = z,
                            D = C,
                            E = F,
                            G = J,
                            H = K,
                            I = Number.MAX_VALUE,
                            L = !1,
                            M = k.vertices;
                        if (!f(c, k, l, m)) return 0;
                        if (n) return !0;
                        for (var N = 0; N !== M.length + 1; N++) {
                            var O = M[N % M.length],
                                P = M[(N + 1) % M.length];
                            g.rotate(o, O, m), g.rotate(p, P, m), i(o, o, l), i(p, p, l), h(q, p, o), g.normalize(r, q), g.rotate90cw(s, r), h(D, c, o), j(D, s), h(A, o, l), h(B, c, l), g.sub(G, o, c);
                            var Q = Math.abs(g.dot(G, s));
                            Q < I && (I = Q, g.scale(E, s, Q), g.add(E, E, c), g.copy(H, s), L = !0)
                        }
                        if (L) {
                            var R = this.createContactEquation(a, e, b, k);
                            return g.scale(R.normalA, H, -1), g.normalize(R.normalA, R.normalA), g.set(R.contactPointA, 0, 0), i(R.contactPointA, R.contactPointA, c), h(R.contactPointA, R.contactPointA, a.position), h(R.contactPointB, E, l), i(R.contactPointB, R.contactPointB, l), h(R.contactPointB, R.contactPointB, e.position), this.contactEquations.push(R), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(R)), 1
                        }
                        return 0
                    }, d.prototype[q.CIRCLE] = d.prototype.circleCircle = function(a, b, c, d, e, f, j, k, l, m, n) {
                        var o = t,
                            m = m || b.radius,
                            n = n || f.radius;
                        h(o, c, j);
                        var p = m + n;
                        if (g.squaredLength(o) > Math.pow(p, 2)) return 0;
                        if (l) return !0;
                        var q = this.createContactEquation(a, e, b, f);
                        return h(q.normalA, j, c), g.normalize(q.normalA, q.normalA), g.scale(q.contactPointA, q.normalA, m), g.scale(q.contactPointB, q.normalA, -n), i(q.contactPointA, q.contactPointA, c), h(q.contactPointA, q.contactPointA, a.position), i(q.contactPointB, q.contactPointB, j), h(q.contactPointB, q.contactPointB, e.position), this.contactEquations.push(q), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(q)), 1
                    }, d.prototype[q.PLANE | q.CONVEX] = d.prototype[q.PLANE | q.BOX] = d.prototype.planeConvex = function(a, b, c, d, e, f, k, l, m) {
                        var n = t,
                            o = u,
                            p = v,
                            q = 0;
                        g.rotate(o, s, d);
                        for (var r = 0; r !== f.vertices.length; r++) {
                            var w = f.vertices[r];
                            if (g.rotate(n, w, l), i(n, n, k), h(p, n, c), j(p, o) <= 0) {
                                if (m) return !0;
                                q++;
                                var x = this.createContactEquation(a, e, b, f);
                                h(p, n, c), g.copy(x.normalA, o);
                                var y = j(p, x.normalA);
                                g.scale(p, x.normalA, y), h(x.contactPointB, n, e.position), h(x.contactPointA, n, p), h(x.contactPointA, x.contactPointA, a.position), this.contactEquations.push(x), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(x))
                            }
                        }
                        return this.enableFrictionReduction && this.enableFriction && q && this.frictionEquations.push(this.createFrictionFromAverage(q)), q
                    }, d.prototype[q.PARTICLE | q.PLANE] = d.prototype.particlePlane = function(a, b, c, d, e, f, i, k, l) {
                        var m = t,
                            n = u;
                        k = k || 0, h(m, c, i), g.rotate(n, s, k);
                        var o = j(m, n);
                        if (o > 0) return 0;
                        if (l) return !0;
                        var p = this.createContactEquation(e, a, f, b);
                        return g.copy(p.normalA, n), g.scale(m, p.normalA, o), h(p.contactPointA, c, m), h(p.contactPointA, p.contactPointA, e.position), h(p.contactPointB, c, a.position), this.contactEquations.push(p), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(p)), 1
                    }, d.prototype[q.CIRCLE | q.PARTICLE] = d.prototype.circleParticle = function(a, b, c, d, e, f, j, k, l) {
                        var m = t;
                        if (h(m, j, c), g.squaredLength(m) > Math.pow(b.radius, 2)) return 0;
                        if (l) return !0;
                        var n = this.createContactEquation(a, e, b, f);
                        return g.copy(n.normalA, m), g.normalize(n.normalA, n.normalA), g.scale(n.contactPointA, n.normalA, b.radius), i(n.contactPointA, n.contactPointA, c), h(n.contactPointA, n.contactPointA, a.position), h(n.contactPointB, j, e.position), this.contactEquations.push(n), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(n)), 1
                    };
                    var X = new o({
                            radius: 1
                        }),
                        Y = g.create(),
                        Z = g.create();
                    g.create(), d.prototype[q.PLANE | q.CAPSULE] = d.prototype.planeCapsule = function(a, b, c, d, e, f, h, j, k) {
                        var l = Y,
                            m = Z,
                            n = X;
                        g.set(l, -f.length / 2, 0), g.rotate(l, l, j), i(l, l, h), g.set(m, f.length / 2, 0), g.rotate(m, m, j), i(m, m, h), n.radius = f.radius;
                        var o;
                        this.enableFrictionReduction && (o = this.enableFriction, this.enableFriction = !1);
                        var p = this.circlePlane(e, n, l, 0, a, b, c, d, k),
                            q = this.circlePlane(e, n, m, 0, a, b, c, d, k);
                        if (this.enableFrictionReduction && (this.enableFriction = o), k) return p || q;
                        var r = p + q;
                        return this.enableFrictionReduction && r && this.frictionEquations.push(this.createFrictionFromAverage(r)), r
                    }, d.prototype[q.CIRCLE | q.PLANE] = d.prototype.circlePlane = function(a, b, c, d, e, f, k, l, m) {
                        var n = a,
                            o = b,
                            p = c,
                            q = e,
                            r = k,
                            w = l;
                        w = w || 0;
                        var x = t,
                            y = u,
                            z = v;
                        h(x, p, r), g.rotate(y, s, w);
                        var A = j(y, x);
                        if (A > o.radius) return 0;
                        if (m) return !0;
                        var B = this.createContactEquation(q, n, f, b);
                        return g.copy(B.normalA, y), g.scale(B.contactPointB, B.normalA, -o.radius), i(B.contactPointB, B.contactPointB, p), h(B.contactPointB, B.contactPointB, n.position), g.scale(z, B.normalA, A), h(B.contactPointA, x, z), i(B.contactPointA, B.contactPointA, r), h(B.contactPointA, B.contactPointA, q.position), this.contactEquations.push(B), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(B)), 1
                    }, d.prototype[q.CONVEX] = d.prototype[q.CONVEX | q.BOX] = d.prototype[q.BOX] = d.prototype.convexConvex = function(a, b, c, e, f, k, l, m, n, o) {
                        var p = t,
                            q = u,
                            r = v,
                            s = w,
                            y = x,
                            C = z,
                            D = A,
                            E = B,
                            F = 0,
                            o = "number" == typeof o ? o : 0,
                            G = d.findSeparatingAxis(b, c, e, k, l, m, p);
                        if (!G) return 0;
                        h(D, l, c), j(p, D) > 0 && g.scale(p, p, -1);
                        var H = d.getClosestEdge(b, e, p, !0),
                            I = d.getClosestEdge(k, m, p);
                        if (H === -1 || I === -1) return 0;
                        for (var J = 0; J < 2; J++) {
                            var K = H,
                                L = I,
                                M = b,
                                N = k,
                                O = c,
                                P = l,
                                Q = e,
                                R = m,
                                S = a,
                                T = f;
                            if (0 === J) {
                                var U;
                                U = K, K = L, L = U, U = M, M = N, N = U, U = O, O = P, P = U, U = Q, Q = R, R = U, U = S, S = T, T = U
                            }
                            for (var V = L; V < L + 2; V++) {
                                var W = N.vertices[(V + N.vertices.length) % N.vertices.length];
                                g.rotate(q, W, R), i(q, q, P);
                                for (var X = 0, Y = K - 1; Y < K + 2; Y++) {
                                    var Z = M.vertices[(Y + M.vertices.length) % M.vertices.length],
                                        $ = M.vertices[(Y + 1 + M.vertices.length) % M.vertices.length];
                                    g.rotate(r, Z, Q), g.rotate(s, $, Q), i(r, r, O), i(s, s, O), h(y, s, r), g.rotate90cw(E, y), g.normalize(E, E), h(D, q, r);
                                    var _ = j(E, D);
                                    (Y === K && _ <= o || Y !== K && _ <= 0) && X++
                                }
                                if (X >= 3) {
                                    if (n) return !0;
                                    var aa = this.createContactEquation(S, T, M, N);
                                    F++;
                                    var Z = M.vertices[K % M.vertices.length],
                                        $ = M.vertices[(K + 1) % M.vertices.length];
                                    g.rotate(r, Z, Q), g.rotate(s, $, Q), i(r, r, O), i(s, s, O), h(y, s, r), g.rotate90cw(aa.normalA, y), g.normalize(aa.normalA, aa.normalA), h(D, q, r);
                                    var _ = j(aa.normalA, D);
                                    g.scale(C, aa.normalA, _), h(aa.contactPointA, q, O), h(aa.contactPointA, aa.contactPointA, C), i(aa.contactPointA, aa.contactPointA, O), h(aa.contactPointA, aa.contactPointA, S.position), h(aa.contactPointB, q, P), i(aa.contactPointB, aa.contactPointB, P), h(aa.contactPointB, aa.contactPointB, T.position), this.contactEquations.push(aa), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(aa))
                                }
                            }
                        }
                        return this.enableFrictionReduction && this.enableFriction && F && this.frictionEquations.push(this.createFrictionFromAverage(F)), F
                    };
                    var $ = g.fromValues(0, 0);
                    d.projectConvexOntoAxis = function(a, b, c, d, e) {
                        var f, h, i = null,
                            k = null,
                            l = $;
                        g.rotate(l, d, -c);
                        for (var m = 0; m < a.vertices.length; m++) f = a.vertices[m], h = j(f, l), (null === i || h > i) && (i = h), (null === k || h < k) && (k = h);
                        if (k > i) {
                            var n = k;
                            k = i, i = n
                        }
                        var o = j(b, d);
                        g.set(e, k + o, i + o)
                    };
                    var _ = g.fromValues(0, 0),
                        aa = g.fromValues(0, 0),
                        ba = g.fromValues(0, 0),
                        ca = g.fromValues(0, 0),
                        da = g.fromValues(0, 0),
                        ea = g.fromValues(0, 0);
                    d.findSeparatingAxis = function(a, b, c, e, f, i, j) {
                        var k = null,
                            l = !1,
                            m = !1,
                            n = _,
                            o = aa,
                            p = ba,
                            q = ca,
                            s = da,
                            t = ea;
                        if (a instanceof r && e instanceof r)
                            for (var u = 0; 2 !== u; u++) {
                                var v = a,
                                    w = c;
                                1 === u && (v = e, w = i);
                                for (var x = 0; 2 !== x; x++) {
                                    0 === x ? g.set(q, 0, 1) : 1 === x && g.set(q, 1, 0), 0 !== w && g.rotate(q, q, w), d.projectConvexOntoAxis(a, b, c, q, s), d.projectConvexOntoAxis(e, f, i, q, t);
                                    var y = s,
                                        z = t,
                                        A = !1;
                                    s[0] > t[0] && (z = s, y = t, A = !0);
                                    var B = z[0] - y[1];
                                    l = B <= 0, (null === k || B > k) && (g.copy(j, q), k = B, m = l)
                                }
                            } else
                                for (var u = 0; 2 !== u; u++) {
                                    var v = a,
                                        w = c;
                                    1 === u && (v = e, w = i);
                                    for (var x = 0; x !== v.vertices.length; x++) {
                                        g.rotate(o, v.vertices[x], w), g.rotate(p, v.vertices[(x + 1) % v.vertices.length], w), h(n, p, o), g.rotate90cw(q, n), g.normalize(q, q), d.projectConvexOntoAxis(a, b, c, q, s), d.projectConvexOntoAxis(e, f, i, q, t);
                                        var y = s,
                                            z = t,
                                            A = !1;
                                        s[0] > t[0] && (z = s, y = t, A = !0);
                                        var B = z[0] - y[1];
                                        l = B <= 0, (null === k || B > k) && (g.copy(j, q), k = B, m = l)
                                    }
                                }
                        return m
                    };
                    var fa = g.fromValues(0, 0),
                        ga = g.fromValues(0, 0),
                        ha = g.fromValues(0, 0);
                    d.getClosestEdge = function(a, b, c, d) {
                        var e = fa,
                            f = ga,
                            i = ha;
                        g.rotate(e, c, -b), d && g.scale(e, e, -1);
                        for (var k = -1, l = a.vertices.length, m = -1, n = 0; n !== l; n++) {
                            h(f, a.vertices[(n + 1) % l], a.vertices[n % l]), g.rotate90cw(i, f), g.normalize(i, i);
                            var o = j(i, e);
                            (k === -1 || o > m) && (k = n % l, m = o)
                        }
                        return k
                    };
                    var ia = g.create(),
                        ja = g.create(),
                        ka = g.create(),
                        la = g.create(),
                        ma = g.create(),
                        na = g.create(),
                        oa = g.create();
                    d.prototype[q.CIRCLE | q.HEIGHTFIELD] = d.prototype.circleHeightfield = function(a, b, c, d, e, f, j, k, l, m) {
                        var n = f.heights,
                            m = m || b.radius,
                            o = f.elementWidth,
                            p = ja,
                            q = ia,
                            r = ma,
                            s = oa,
                            t = na,
                            u = ka,
                            v = la,
                            w = Math.floor((c[0] - m - j[0]) / o),
                            x = Math.ceil((c[0] + m - j[0]) / o);
                        w < 0 && (w = 0), x >= n.length && (x = n.length - 1);
                        for (var y = n[w], z = n[x], A = w; A < x; A++) n[A] < z && (z = n[A]), n[A] > y && (y = n[A]);
                        if (c[1] - m > y) return !l && 0;
                        for (var B = !1, A = w; A < x; A++) {
                            g.set(u, A * o, n[A]), g.set(v, (A + 1) * o, n[A + 1]), g.add(u, u, j), g.add(v, v, j), g.sub(t, v, u), g.rotate(t, t, Math.PI / 2), g.normalize(t, t), g.scale(q, t, -m), g.add(q, q, c), g.sub(p, q, u);
                            var C = g.dot(p, t);
                            if (q[0] >= u[0] && q[0] < v[0] && C <= 0) {
                                if (l) return !0;
                                B = !0, g.scale(p, t, -C), g.add(r, q, p), g.copy(s, t);
                                var D = this.createContactEquation(e, a, f, b);
                                g.copy(D.normalA, s), g.scale(D.contactPointB, D.normalA, -m), i(D.contactPointB, D.contactPointB, c),
                                    h(D.contactPointB, D.contactPointB, a.position), g.copy(D.contactPointA, r), g.sub(D.contactPointA, D.contactPointA, e.position), this.contactEquations.push(D), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(D))
                            }
                        }
                        if (B = !1, m > 0)
                            for (var A = w; A <= x; A++)
                                if (g.set(u, A * o, n[A]), g.add(u, u, j), g.sub(p, c, u), g.squaredLength(p) < Math.pow(m, 2)) {
                                    if (l) return !0;
                                    B = !0;
                                    var D = this.createContactEquation(e, a, f, b);
                                    g.copy(D.normalA, p), g.normalize(D.normalA, D.normalA), g.scale(D.contactPointB, D.normalA, -m), i(D.contactPointB, D.contactPointB, c), h(D.contactPointB, D.contactPointB, a.position), h(D.contactPointA, u, j), i(D.contactPointA, D.contactPointA, j), h(D.contactPointA, D.contactPointA, e.position), this.contactEquations.push(D), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(D))
                                }
                        return B ? 1 : 0
                    };
                    var pa = g.create(),
                        qa = g.create(),
                        ra = g.create(),
                        sa = new p({
                            vertices: [g.create(), g.create(), g.create(), g.create()]
                        });
                    d.prototype[q.BOX | q.HEIGHTFIELD] = d.prototype[q.CONVEX | q.HEIGHTFIELD] = d.prototype.convexHeightfield = function(a, b, c, d, e, f, h, i, j) {
                        var k = f.heights,
                            l = f.elementWidth,
                            m = pa,
                            n = qa,
                            o = ra,
                            p = sa,
                            q = Math.floor((a.aabb.lowerBound[0] - h[0]) / l),
                            r = Math.ceil((a.aabb.upperBound[0] - h[0]) / l);
                        q < 0 && (q = 0), r >= k.length && (r = k.length - 1);
                        for (var s = k[q], t = k[r], u = q; u < r; u++) k[u] < t && (t = k[u]), k[u] > s && (s = k[u]);
                        if (a.aabb.lowerBound[1] > s) return !j && 0;
                        for (var v = 0, u = q; u < r; u++) {
                            g.set(m, u * l, k[u]), g.set(n, (u + 1) * l, k[u + 1]), g.add(m, m, h), g.add(n, n, h);
                            var w = 100;
                            g.set(o, .5 * (n[0] + m[0]), .5 * (n[1] + m[1] - w)), g.sub(p.vertices[0], n, o), g.sub(p.vertices[1], m, o), g.copy(p.vertices[2], p.vertices[1]), g.copy(p.vertices[3], p.vertices[0]), p.vertices[2][1] -= w, p.vertices[3][1] -= w, v += this.convexConvex(a, b, c, d, e, p, o, 0, j)
                        }
                        return v
                    }
                }, {
                    "../equations/ContactEquation": 21,
                    "../equations/Equation": 22,
                    "../equations/FrictionEquation": 23,
                    "../math/vec2": 30,
                    "../objects/Body": 31,
                    "../shapes/Box": 37,
                    "../shapes/Circle": 39,
                    "../shapes/Convex": 40,
                    "../shapes/Shape": 45,
                    "../utils/ContactEquationPool": 48,
                    "../utils/FrictionEquationPool": 49,
                    "../utils/TupleDictionary": 56,
                    "../utils/Utils": 57
                }
            ],
            11: [
                function(a, b, c) {
                    function d(a) {
                        a = a || {}, this.from = a.from ? f.fromValues(a.from[0], a.from[1]) : f.create(), this.to = a.to ? f.fromValues(a.to[0], a.to[1]) : f.create(), this.checkCollisionResponse = void 0 === a.checkCollisionResponse || a.checkCollisionResponse, this.skipBackfaces = !!a.skipBackfaces, this.collisionMask = void 0 !== a.collisionMask ? a.collisionMask : -1, this.collisionGroup = void 0 !== a.collisionGroup ? a.collisionGroup : -1, this.mode = void 0 !== a.mode ? a.mode : d.ANY, this.callback = a.callback || function(a) {}, this.direction = f.create(), this.length = 1, this.update()
                    }

                    function e(a, b, c) {
                        f.sub(h, c, a);
                        var d = f.dot(h, b);
                        return f.scale(i, b, d), f.add(i, i, a), f.squaredDistance(c, i)
                    }
                    b.exports = d;
                    var f = a("../math/vec2");
                    a("../collision/RaycastResult"), a("../shapes/Shape"), a("../collision/AABB"), d.prototype.constructor = d, d.CLOSEST = 1, d.ANY = 2, d.ALL = 4, d.prototype.update = function() {
                        var a = this.direction;
                        f.sub(a, this.to, this.from), this.length = f.length(a), f.normalize(a, a)
                    }, d.prototype.intersectBodies = function(a, b) {
                        for (var c = 0, d = b.length; !a.shouldStop(this) && c < d; c++) {
                            var e = b[c],
                                f = e.getAABB();
                            (f.overlapsRay(this) >= 0 || f.containsPoint(this.from)) && this.intersectBody(a, e)
                        }
                    };
                    var g = f.create();
                    d.prototype.intersectBody = function(a, b) {
                        var c = this.checkCollisionResponse;
                        if (!c || b.collisionResponse)
                            for (var d = g, e = 0, h = b.shapes.length; e < h; e++) {
                                var i = b.shapes[e];
                                if ((!c || i.collisionResponse) && 0 !== (this.collisionGroup & i.collisionMask) && 0 !== (i.collisionGroup & this.collisionMask)) {
                                    f.rotate(d, i.position, b.angle), f.add(d, d, b.position);
                                    var j = i.angle + b.angle;
                                    if (this.intersectShape(a, i, j, d, b), a.shouldStop(this)) break
                                }
                            }
                    }, d.prototype.intersectShape = function(a, b, c, d, f) {
                        var g = this.from,
                            h = e(g, this.direction, d);
                        h > b.boundingRadius * b.boundingRadius || (this._currentBody = f, this._currentShape = b, b.raycast(a, this, d, c), this._currentBody = this._currentShape = null)
                    }, d.prototype.getAABB = function(a) {
                        var b = this.to,
                            c = this.from;
                        f.set(a.lowerBound, Math.min(b[0], c[0]), Math.min(b[1], c[1])), f.set(a.upperBound, Math.max(b[0], c[0]), Math.max(b[1], c[1]))
                    }, f.create(), d.prototype.reportIntersection = function(a, b, c, e) {
                        var g = (this.from, this.to, this._currentShape),
                            h = this._currentBody;
                        if (!(this.skipBackfaces && f.dot(c, this.direction) > 0)) switch (this.mode) {
                            case d.ALL:
                                a.set(c, g, h, b, e), this.callback(a);
                                break;
                            case d.CLOSEST:
                                (b < a.fraction || !a.hasHit()) && a.set(c, g, h, b, e);
                                break;
                            case d.ANY:
                                a.set(c, g, h, b, e)
                        }
                    };
                    var h = f.create(),
                        i = f.create()
                }, {
                    "../collision/AABB": 7,
                    "../collision/RaycastResult": 12,
                    "../math/vec2": 30,
                    "../shapes/Shape": 45
                }
            ],
            12: [
                function(a, b, c) {
                    function d() {
                        this.normal = e.create(), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1
                    }
                    var e = a("../math/vec2"),
                        f = a("../collision/Ray");
                    b.exports = d, d.prototype.reset = function() {
                        e.set(this.normal, 0, 0), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1
                    }, d.prototype.getHitDistance = function(a) {
                        return e.distance(a.from, a.to) * this.fraction
                    }, d.prototype.hasHit = function() {
                        return this.fraction !== -1
                    }, d.prototype.getHitPoint = function(a, b) {
                        e.lerp(a, b.from, b.to, this.fraction)
                    }, d.prototype.stop = function() {
                        this.isStopped = !0
                    }, d.prototype.shouldStop = function(a) {
                        return this.isStopped || this.fraction !== -1 && a.mode === f.ANY
                    }, d.prototype.set = function(a, b, c, d, f) {
                        e.copy(this.normal, a), this.shape = b, this.body = c, this.fraction = d, this.faceIndex = f
                    }
                }, {
                    "../collision/Ray": 11,
                    "../math/vec2": 30
                }
            ],
            13: [
                function(a, b, c) {
                    function d() {
                        f.call(this, f.SAP), this.axisList = [], this.axisIndex = 0;
                        var a = this;
                        this._addBodyHandler = function(b) {
                            a.axisList.push(b.body)
                        }, this._removeBodyHandler = function(b) {
                            var c = a.axisList.indexOf(b.body);
                            c !== -1 && a.axisList.splice(c, 1)
                        }
                    }
                    var e = a("../utils/Utils"),
                        f = a("../collision/Broadphase");
                    b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.setWorld = function(a) {
                        this.axisList.length = 0, e.appendArray(this.axisList, a.bodies), a.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler), a.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler), this.world = a
                    }, d.sortAxisList = function(a, b) {
                        b = 0 | b;
                        for (var c = 1, d = a.length; c < d; c++) {
                            for (var e = a[c], f = c - 1; f >= 0 && !(a[f].aabb.lowerBound[b] <= e.aabb.lowerBound[b]); f--) a[f + 1] = a[f];
                            a[f + 1] = e
                        }
                        return a
                    }, d.prototype.sortList = function() {
                        var a = this.axisList,
                            b = this.axisIndex;
                        d.sortAxisList(a, b)
                    }, d.prototype.getCollisionPairs = function(a) {
                        var b = this.axisList,
                            c = this.result,
                            d = this.axisIndex;
                        c.length = 0;
                        for (var e = b.length; e--;) {
                            var g = b[e];
                            g.aabbNeedsUpdate && g.updateAABB()
                        }
                        this.sortList();
                        for (var h = 0, i = 0 | b.length; h !== i; h++)
                            for (var j = b[h], k = h + 1; k < i; k++) {
                                var l = b[k],
                                    m = l.aabb.lowerBound[d] <= j.aabb.upperBound[d];
                                if (!m) break;
                                f.canCollide(j, l) && this.boundingVolumeCheck(j, l) && c.push(j, l)
                            }
                        return c
                    }, d.prototype.aabbQuery = function(a, b, c) {
                        c = c || [], this.sortList();
                        var d = this.axisIndex,
                            e = "x";
                        1 === d && (e = "y"), 2 === d && (e = "z");
                        for (var f = this.axisList, g = (b.lowerBound[e], b.upperBound[e], 0); g < f.length; g++) {
                            var h = f[g];
                            h.aabbNeedsUpdate && h.updateAABB(), h.aabb.overlaps(b) && c.push(h)
                        }
                        return c
                    }
                }, {
                    "../collision/Broadphase": 8,
                    "../utils/Utils": 57
                }
            ],
            14: [
                function(a, b, c) {
                    function d(a, b, c, d) {
                        this.type = c, d = e.defaults(d, {
                            collideConnected: !0,
                            wakeUpBodies: !0
                        }), this.equations = [], this.bodyA = a, this.bodyB = b, this.collideConnected = d.collideConnected, d.wakeUpBodies && (a && a.wakeUp(), b && b.wakeUp())
                    }
                    b.exports = d;
                    var e = a("../utils/Utils");
                    d.prototype.update = function() {
                        throw new Error("method update() not implmemented in this Constraint subclass!")
                    }, d.DISTANCE = 1, d.GEAR = 2, d.LOCK = 3, d.PRISMATIC = 4, d.REVOLUTE = 5, d.prototype.setStiffness = function(a) {
                        for (var b = this.equations, c = 0; c !== b.length; c++) {
                            var d = b[c];
                            d.stiffness = a, d.needsUpdate = !0
                        }
                    }, d.prototype.setRelaxation = function(a) {
                        for (var b = this.equations, c = 0; c !== b.length; c++) {
                            var d = b[c];
                            d.relaxation = a, d.needsUpdate = !0
                        }
                    }
                }, {
                    "../utils/Utils": 57
                }
            ],
            15: [
                function(a, b, c) {
                    function d(a, b, c) {
                        c = h.defaults(c, {
                            localAnchorA: [0, 0],
                            localAnchorB: [0, 0]
                        }), e.call(this, a, b, e.DISTANCE, c), this.localAnchorA = g.fromValues(c.localAnchorA[0], c.localAnchorA[1]), this.localAnchorB = g.fromValues(c.localAnchorB[0], c.localAnchorB[1]);
                        var d = this.localAnchorA,
                            i = this.localAnchorB;
                        if (this.distance = 0, "number" == typeof c.distance) this.distance = c.distance;
                        else {
                            var j = g.create(),
                                k = g.create(),
                                l = g.create();
                            g.rotate(j, d, a.angle), g.rotate(k, i, b.angle), g.add(l, b.position, k), g.sub(l, l, j), g.sub(l, l, a.position), this.distance = g.length(l)
                        }
                        var m;
                        m = "undefined" == typeof c.maxForce ? Number.MAX_VALUE : c.maxForce;
                        var n = new f(a, b, (-m), m);
                        this.equations = [n], this.maxForce = m;
                        var l = g.create(),
                            o = g.create(),
                            p = g.create(),
                            q = this;
                        n.computeGq = function() {
                            var a = this.bodyA,
                                b = this.bodyB,
                                c = a.position,
                                e = b.position;
                            return g.rotate(o, d, a.angle), g.rotate(p, i, b.angle), g.add(l, e, p), g.sub(l, l, o), g.sub(l, l, c), g.length(l) - q.distance
                        }, this.setMaxForce(m), this.upperLimitEnabled = !1, this.upperLimit = 1, this.lowerLimitEnabled = !1, this.lowerLimit = 0, this.position = 0
                    }
                    var e = a("./Constraint"),
                        f = a("../equations/Equation"),
                        g = a("../math/vec2"),
                        h = a("../utils/Utils");
                    b.exports = d, d.prototype = new e, d.prototype.constructor = d;
                    var i = g.create(),
                        j = g.create(),
                        k = g.create();
                    d.prototype.update = function() {
                        var a = this.equations[0],
                            b = this.bodyA,
                            c = this.bodyB,
                            d = (this.distance, b.position),
                            e = c.position,
                            f = this.equations[0],
                            h = a.G;
                        g.rotate(j, this.localAnchorA, b.angle), g.rotate(k, this.localAnchorB, c.angle), g.add(i, e, k), g.sub(i, i, j), g.sub(i, i, d), this.position = g.length(i);
                        var l = !1;
                        if (this.upperLimitEnabled && this.position > this.upperLimit && (f.maxForce = 0, f.minForce = -this.maxForce, this.distance = this.upperLimit, l = !0), this.lowerLimitEnabled && this.position < this.lowerLimit && (f.maxForce = this.maxForce, f.minForce = 0, this.distance = this.lowerLimit, l = !0), (this.lowerLimitEnabled || this.upperLimitEnabled) && !l) return void(f.enabled = !1);
                        f.enabled = !0, g.normalize(i, i);
                        var m = g.crossLength(j, i),
                            n = g.crossLength(k, i);
                        h[0] = -i[0], h[1] = -i[1], h[2] = -m, h[3] = i[0], h[4] = i[1], h[5] = n
                    }, d.prototype.setMaxForce = function(a) {
                        var b = this.equations[0];
                        b.minForce = -a, b.maxForce = a
                    }, d.prototype.getMaxForce = function() {
                        var a = this.equations[0];
                        return a.maxForce
                    }
                }, {
                    "../equations/Equation": 22,
                    "../math/vec2": 30,
                    "../utils/Utils": 57,
                    "./Constraint": 14
                }
            ],
            16: [
                function(a, b, c) {
                    function d(a, b, c) {
                        c = c || {}, e.call(this, a, b, e.GEAR, c), this.ratio = void 0 !== c.ratio ? c.ratio : 1, this.angle = void 0 !== c.angle ? c.angle : b.angle - this.ratio * a.angle, c.angle = this.angle, c.ratio = this.ratio, this.equations = [new f(a, b, c)], void 0 !== c.maxTorque && this.setMaxTorque(c.maxTorque)
                    }
                    var e = a("./Constraint"),
                        f = (a("../equations/Equation"), a("../equations/AngleLockEquation"));
                    a("../math/vec2"), b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.update = function() {
                        var a = this.equations[0];
                        a.ratio !== this.ratio && a.setRatio(this.ratio), a.angle = this.angle
                    }, d.prototype.setMaxTorque = function(a) {
                        this.equations[0].setMaxTorque(a)
                    }, d.prototype.getMaxTorque = function(a) {
                        return this.equations[0].maxForce
                    }
                }, {
                    "../equations/AngleLockEquation": 20,
                    "../equations/Equation": 22,
                    "../math/vec2": 30,
                    "./Constraint": 14
                }
            ],
            17: [
                function(a, b, c) {
                    function d(a, b, c) {
                        c = c || {}, e.call(this, a, b, e.LOCK, c);
                        var d = "undefined" == typeof c.maxForce ? Number.MAX_VALUE : c.maxForce,
                            h = (c.localAngleB || 0, new g(a, b, (-d), d)),
                            i = new g(a, b, (-d), d),
                            j = new g(a, b, (-d), d),
                            k = f.create(),
                            l = f.create(),
                            m = this;
                        h.computeGq = function() {
                            return f.rotate(k, m.localOffsetB, a.angle), f.sub(l, b.position, a.position), f.sub(l, l, k), l[0]
                        }, i.computeGq = function() {
                            return f.rotate(k, m.localOffsetB, a.angle), f.sub(l, b.position, a.position), f.sub(l, l, k), l[1]
                        };
                        var n = f.create(),
                            o = f.create();
                        j.computeGq = function() {
                            return f.rotate(n, m.localOffsetB, b.angle - m.localAngleB), f.scale(n, n, -1), f.sub(l, a.position, b.position), f.add(l, l, n), f.rotate(o, n, -Math.PI / 2), f.normalize(o, o), f.dot(l, o)
                        }, this.localOffsetB = f.create(), c.localOffsetB ? f.copy(this.localOffsetB, c.localOffsetB) : (f.sub(this.localOffsetB, b.position, a.position), f.rotate(this.localOffsetB, this.localOffsetB, -a.angle)), this.localAngleB = 0, "number" == typeof c.localAngleB ? this.localAngleB = c.localAngleB : this.localAngleB = b.angle - a.angle, this.equations.push(h, i, j), this.setMaxForce(d)
                    }
                    var e = a("./Constraint"),
                        f = a("../math/vec2"),
                        g = a("../equations/Equation");
                    b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.setMaxForce = function(a) {
                        for (var b = this.equations, c = 0; c < this.equations.length; c++) b[c].maxForce = a, b[c].minForce = -a
                    }, d.prototype.getMaxForce = function() {
                        return this.equations[0].maxForce
                    };
                    var h = f.create(),
                        i = f.create(),
                        j = f.create(),
                        k = f.fromValues(1, 0),
                        l = f.fromValues(0, 1);
                    d.prototype.update = function() {
                        var a = this.equations[0],
                            b = this.equations[1],
                            c = this.equations[2],
                            d = this.bodyA,
                            e = this.bodyB;
                        f.rotate(h, this.localOffsetB, d.angle), f.rotate(i, this.localOffsetB, e.angle - this.localAngleB), f.scale(i, i, -1), f.rotate(j, i, Math.PI / 2), f.normalize(j, j), a.G[0] = -1, a.G[1] = 0, a.G[2] = -f.crossLength(h, k), a.G[3] = 1, b.G[0] = 0, b.G[1] = -1, b.G[2] = -f.crossLength(h, l), b.G[4] = 1, c.G[0] = -j[0], c.G[1] = -j[1], c.G[3] = j[0], c.G[4] = j[1], c.G[5] = f.crossLength(i, j)
                    }
                }, {
                    "../equations/Equation": 22,
                    "../math/vec2": 30,
                    "./Constraint": 14
                }
            ],
            18: [
                function(a, b, c) {
                    function d(a, b, c) {
                        c = c || {}, e.call(this, a, b, e.PRISMATIC, c);
                        var d = h.fromValues(0, 0),
                            j = h.fromValues(1, 0),
                            k = h.fromValues(0, 0);
                        c.localAnchorA && h.copy(d, c.localAnchorA), c.localAxisA && h.copy(j, c.localAxisA), c.localAnchorB && h.copy(k, c.localAnchorB), this.localAnchorA = d, this.localAnchorB = k, this.localAxisA = j;
                        var l = this.maxForce = "undefined" != typeof c.maxForce ? c.maxForce : Number.MAX_VALUE,
                            m = new g(a, b, (-l), l),
                            n = new h.create,
                            o = new h.create,
                            p = new h.create,
                            q = new h.create;
                        if (m.computeGq = function() {
                            return h.dot(p, q)
                        }, m.updateJacobian = function() {
                            var c = this.G,
                                e = a.position,
                                f = b.position;
                            h.rotate(n, d, a.angle), h.rotate(o, k, b.angle), h.add(p, f, o), h.sub(p, p, e), h.sub(p, p, n), h.rotate(q, j, a.angle + Math.PI / 2), c[0] = -q[0], c[1] = -q[1], c[2] = -h.crossLength(n, q) + h.crossLength(q, p), c[3] = q[0], c[4] = q[1], c[5] = h.crossLength(o, q)
                        }, this.equations.push(m), !c.disableRotationalLock) {
                            var r = new i(a, b, (-l), l);
                            this.equations.push(r)
                        }
                        this.position = 0, this.velocity = 0, this.lowerLimitEnabled = "undefined" != typeof c.lowerLimit, this.upperLimitEnabled = "undefined" != typeof c.upperLimit, this.lowerLimit = "undefined" != typeof c.lowerLimit ? c.lowerLimit : 0, this.upperLimit = "undefined" != typeof c.upperLimit ? c.upperLimit : 1, this.upperLimitEquation = new f(a, b), this.lowerLimitEquation = new f(a, b), this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0, this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = l, this.motorEquation = new g(a, b), this.motorEnabled = !1, this.motorSpeed = 0;
                        var s = this,
                            t = this.motorEquation;
                        t.computeGW, t.computeGq = function() {
                            return 0
                        }, t.computeGW = function() {
                            var a = this.G,
                                b = this.bodyA,
                                c = this.bodyB,
                                d = b.velocity,
                                e = c.velocity,
                                f = b.angularVelocity,
                                g = c.angularVelocity;
                            return this.gmult(a, d, f, e, g) + s.motorSpeed
                        }
                    }
                    var e = a("./Constraint"),
                        f = a("../equations/ContactEquation"),
                        g = a("../equations/Equation"),
                        h = a("../math/vec2"),
                        i = a("../equations/RotationalLockEquation");
                    b.exports = d, d.prototype = new e, d.prototype.constructor = d;
                    var j = h.create(),
                        k = h.create(),
                        l = h.create(),
                        m = h.create(),
                        n = h.create(),
                        o = h.create();
                    d.prototype.update = function() {
                        var a = this.equations,
                            b = a[0],
                            c = this.upperLimit,
                            d = this.lowerLimit,
                            e = this.upperLimitEquation,
                            f = this.lowerLimitEquation,
                            g = this.bodyA,
                            i = this.bodyB,
                            p = this.localAxisA,
                            q = this.localAnchorA,
                            r = this.localAnchorB;
                        b.updateJacobian(), h.rotate(j, p, g.angle), h.rotate(m, q, g.angle), h.add(k, m, g.position), h.rotate(n, r, i.angle), h.add(l, n, i.position);
                        var s = this.position = h.dot(l, j) - h.dot(k, j);
                        if (this.motorEnabled) {
                            var t = this.motorEquation.G;
                            t[0] = j[0], t[1] = j[1], t[2] = h.crossLength(j, n), t[3] = -j[0], t[4] = -j[1], t[5] = -h.crossLength(j, m)
                        }
                        if (this.upperLimitEnabled && s > c) h.scale(e.normalA, j, -1), h.sub(e.contactPointA, k, g.position), h.sub(e.contactPointB, l, i.position), h.scale(o, j, c), h.add(e.contactPointA, e.contactPointA, o), a.indexOf(e) === -1 && a.push(e);
                        else {
                            var u = a.indexOf(e);
                            u !== -1 && a.splice(u, 1)
                        } if (this.lowerLimitEnabled && s < d) h.scale(f.normalA, j, 1), h.sub(f.contactPointA, k, g.position), h.sub(f.contactPointB, l, i.position), h.scale(o, j, d), h.sub(f.contactPointB, f.contactPointB, o), a.indexOf(f) === -1 && a.push(f);
                        else {
                            var u = a.indexOf(f);
                            u !== -1 && a.splice(u, 1)
                        }
                    }, d.prototype.enableMotor = function() {
                        this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
                    }, d.prototype.disableMotor = function() {
                        if (this.motorEnabled) {
                            var a = this.equations.indexOf(this.motorEquation);
                            this.equations.splice(a, 1), this.motorEnabled = !1
                        }
                    }, d.prototype.setLimits = function(a, b) {
                        "number" == typeof a ? (this.lowerLimit = a, this.lowerLimitEnabled = !0) : (this.lowerLimit = a, this.lowerLimitEnabled = !1), "number" == typeof b ? (this.upperLimit = b, this.upperLimitEnabled = !0) : (this.upperLimit = b, this.upperLimitEnabled = !1)
                    }
                }, {
                    "../equations/ContactEquation": 21,
                    "../equations/Equation": 22,
                    "../equations/RotationalLockEquation": 24,
                    "../math/vec2": 30,
                    "./Constraint": 14
                }
            ],
            19: [
                function(a, b, c) {
                    function d(a, b, c) {
                        c = c || {}, e.call(this, a, b, e.REVOLUTE, c);
                        var d = this.maxForce = "undefined" != typeof c.maxForce ? c.maxForce : Number.MAX_VALUE;
                        this.pivotA = i.create(), this.pivotB = i.create(), c.worldPivot ? (i.sub(this.pivotA, c.worldPivot, a.position), i.sub(this.pivotB, c.worldPivot, b.position), i.rotate(this.pivotA, this.pivotA, -a.angle), i.rotate(this.pivotB, this.pivotB, -b.angle)) : (i.copy(this.pivotA, c.localPivotA), i.copy(this.pivotB, c.localPivotB));
                        var o = this.equations = [new f(a, b, (-d), d), new f(a, b, (-d), d)],
                            p = o[0],
                            q = o[1],
                            r = this;
                        p.computeGq = function() {
                            return i.rotate(j, r.pivotA, a.angle), i.rotate(k, r.pivotB, b.angle), i.add(n, b.position, k), i.sub(n, n, a.position), i.sub(n, n, j), i.dot(n, l)
                        }, q.computeGq = function() {
                            return i.rotate(j, r.pivotA, a.angle), i.rotate(k, r.pivotB, b.angle), i.add(n, b.position, k), i.sub(n, n, a.position), i.sub(n, n, j), i.dot(n, m)
                        }, q.minForce = p.minForce = -d, q.maxForce = p.maxForce = d, this.motorEquation = new g(a, b), this.motorEnabled = !1, this.angle = 0, this.lowerLimitEnabled = !1, this.upperLimitEnabled = !1, this.lowerLimit = 0, this.upperLimit = 0, this.upperLimitEquation = new h(a, b), this.lowerLimitEquation = new h(a, b), this.upperLimitEquation.minForce = 0, this.lowerLimitEquation.maxForce = 0
                    }
                    var e = a("./Constraint"),
                        f = a("../equations/Equation"),
                        g = a("../equations/RotationalVelocityEquation"),
                        h = a("../equations/RotationalLockEquation"),
                        i = a("../math/vec2");
                    b.exports = d;
                    var j = i.create(),
                        k = i.create(),
                        l = i.fromValues(1, 0),
                        m = i.fromValues(0, 1),
                        n = i.create();
                    d.prototype = new e, d.prototype.constructor = d, d.prototype.setLimits = function(a, b) {
                        "number" == typeof a ? (this.lowerLimit = a, this.lowerLimitEnabled = !0) : (this.lowerLimit = a, this.lowerLimitEnabled = !1), "number" == typeof b ? (this.upperLimit = b, this.upperLimitEnabled = !0) : (this.upperLimit = b, this.upperLimitEnabled = !1)
                    }, d.prototype.update = function() {
                        var a = this.bodyA,
                            b = this.bodyB,
                            c = this.pivotA,
                            d = this.pivotB,
                            e = this.equations,
                            f = (e[0], e[1], e[0]),
                            g = e[1],
                            h = this.upperLimit,
                            n = this.lowerLimit,
                            o = this.upperLimitEquation,
                            p = this.lowerLimitEquation,
                            q = this.angle = b.angle - a.angle;
                        if (this.upperLimitEnabled && q > h) o.angle = h, e.indexOf(o) === -1 && e.push(o);
                        else {
                            var r = e.indexOf(o);
                            r !== -1 && e.splice(r, 1)
                        } if (this.lowerLimitEnabled && q < n) p.angle = n, e.indexOf(p) === -1 && e.push(p);
                        else {
                            var r = e.indexOf(p);
                            r !== -1 && e.splice(r, 1)
                        }
                        i.rotate(j, c, a.angle), i.rotate(k, d, b.angle), f.G[0] = -1, f.G[1] = 0, f.G[2] = -i.crossLength(j, l), f.G[3] = 1, f.G[4] = 0, f.G[5] = i.crossLength(k, l), g.G[0] = 0, g.G[1] = -1, g.G[2] = -i.crossLength(j, m), g.G[3] = 0, g.G[4] = 1, g.G[5] = i.crossLength(k, m)
                    }, d.prototype.enableMotor = function() {
                        this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
                    }, d.prototype.disableMotor = function() {
                        if (this.motorEnabled) {
                            var a = this.equations.indexOf(this.motorEquation);
                            this.equations.splice(a, 1), this.motorEnabled = !1
                        }
                    }, d.prototype.motorIsEnabled = function() {
                        return !!this.motorEnabled
                    }, d.prototype.setMotorSpeed = function(a) {
                        if (this.motorEnabled) {
                            var b = this.equations.indexOf(this.motorEquation);
                            this.equations[b].relativeVelocity = a
                        }
                    }, d.prototype.getMotorSpeed = function() {
                        return !!this.motorEnabled && this.motorEquation.relativeVelocity
                    }
                }, {
                    "../equations/Equation": 22,
                    "../equations/RotationalLockEquation": 24,
                    "../equations/RotationalVelocityEquation": 25,
                    "../math/vec2": 30,
                    "./Constraint": 14
                }
            ],
            20: [
                function(a, b, c) {
                    function d(a, b, c) {
                        c = c || {}, e.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = c.angle || 0, this.ratio = "number" == typeof c.ratio ? c.ratio : 1, this.setRatio(this.ratio)
                    }
                    var e = a("./Equation");
                    a("../math/vec2"), b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeGq = function() {
                        return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle
                    }, d.prototype.setRatio = function(a) {
                        var b = this.G;
                        b[2] = a, b[5] = -1, this.ratio = a
                    }, d.prototype.setMaxTorque = function(a) {
                        this.maxForce = a, this.minForce = -a
                    }
                }, {
                    "../math/vec2": 30,
                    "./Equation": 22
                }
            ],
            21: [
                function(a, b, c) {
                    function d(a, b) {
                        e.call(this, a, b, 0, Number.MAX_VALUE), this.contactPointA = f.create(), this.penetrationVec = f.create(), this.contactPointB = f.create(), this.normalA = f.create(), this.restitution = 0, this.firstImpact = !1, this.shapeA = null, this.shapeB = null
                    }
                    var e = a("./Equation"),
                        f = a("../math/vec2");
                    b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeB = function(a, b, c) {
                        var d = this.bodyA,
                            e = this.bodyB,
                            g = this.contactPointA,
                            h = this.contactPointB,
                            i = d.position,
                            j = e.position,
                            k = this.penetrationVec,
                            l = this.normalA,
                            m = this.G,
                            n = f.crossLength(g, l),
                            o = f.crossLength(h, l);
                        m[0] = -l[0], m[1] = -l[1], m[2] = -n, m[3] = l[0], m[4] = l[1], m[5] = o, f.add(k, j, h), f.sub(k, k, i), f.sub(k, k, g);
                        var p, q;
                        this.firstImpact && 0 !== this.restitution ? (q = 0, p = 1 / b * (1 + this.restitution) * this.computeGW()) : (q = f.dot(l, k) + this.offset, p = this.computeGW());
                        var r = this.computeGiMf(),
                            s = -q * a - p * b - c * r;
                        return s
                    }
                }, {
                    "../math/vec2": 30,
                    "./Equation": 22
                }
            ],
            22: [
                function(a, b, c) {
                    function d(a, b, c, e) {
                        this.minForce = "undefined" == typeof c ? -Number.MAX_VALUE : c, this.maxForce = "undefined" == typeof e ? Number.MAX_VALUE : e, this.bodyA = a, this.bodyB = b, this.stiffness = d.DEFAULT_STIFFNESS, this.relaxation = d.DEFAULT_RELAXATION, this.G = new f.ARRAY_TYPE(6);
                        for (var g = 0; g < 6; g++) this.G[g] = 0;
                        this.offset = 0, this.a = 0, this.b = 0, this.epsilon = 0, this.timeStep = 1 / 60, this.needsUpdate = !0, this.multiplier = 0, this.relativeVelocity = 0, this.enabled = !0
                    }
                    b.exports = d;
                    var e = a("../math/vec2"),
                        f = a("../utils/Utils");
                    a("../objects/Body"), d.prototype.constructor = d, d.DEFAULT_STIFFNESS = 1e6, d.DEFAULT_RELAXATION = 4, d.prototype.update = function() {
                        var a = this.stiffness,
                            b = this.relaxation,
                            c = this.timeStep;
                        this.a = 4 / (c * (1 + 4 * b)), this.b = 4 * b / (1 + 4 * b), this.epsilon = 4 / (c * c * a * (1 + 4 * b)), this.needsUpdate = !1
                    }, d.prototype.gmult = function(a, b, c, d, e) {
                        return a[0] * b[0] + a[1] * b[1] + a[2] * c + a[3] * d[0] + a[4] * d[1] + a[5] * e
                    }, d.prototype.computeB = function(a, b, c) {
                        var d = this.computeGW(),
                            e = this.computeGq(),
                            f = this.computeGiMf();
                        return -e * a - d * b - f * c
                    };
                    var g = e.create(),
                        h = e.create();
                    d.prototype.computeGq = function() {
                        var a = this.G,
                            b = this.bodyA,
                            c = this.bodyB,
                            d = (b.position, c.position, b.angle),
                            e = c.angle;
                        return this.gmult(a, g, d, h, e) + this.offset
                    }, d.prototype.computeGW = function() {
                        var a = this.G,
                            b = this.bodyA,
                            c = this.bodyB,
                            d = b.velocity,
                            e = c.velocity,
                            f = b.angularVelocity,
                            g = c.angularVelocity;
                        return this.gmult(a, d, f, e, g) + this.relativeVelocity
                    }, d.prototype.computeGWlambda = function() {
                        var a = this.G,
                            b = this.bodyA,
                            c = this.bodyB,
                            d = b.vlambda,
                            e = c.vlambda,
                            f = b.wlambda,
                            g = c.wlambda;
                        return this.gmult(a, d, f, e, g)
                    };
                    var i = e.create(),
                        j = e.create();
                    d.prototype.computeGiMf = function() {
                        var a = this.bodyA,
                            b = this.bodyB,
                            c = a.force,
                            d = a.angularForce,
                            f = b.force,
                            g = b.angularForce,
                            h = a.invMassSolve,
                            k = b.invMassSolve,
                            l = a.invInertiaSolve,
                            m = b.invInertiaSolve,
                            n = this.G;
                        return e.scale(i, c, h), e.multiply(i, a.massMultiplier, i), e.scale(j, f, k), e.multiply(j, b.massMultiplier, j), this.gmult(n, i, d * l, j, g * m)
                    }, d.prototype.computeGiMGt = function() {
                        var a = this.bodyA,
                            b = this.bodyB,
                            c = a.invMassSolve,
                            d = b.invMassSolve,
                            e = a.invInertiaSolve,
                            f = b.invInertiaSolve,
                            g = this.G;
                        return g[0] * g[0] * c * a.massMultiplier[0] + g[1] * g[1] * c * a.massMultiplier[1] + g[2] * g[2] * e + g[3] * g[3] * d * b.massMultiplier[0] + g[4] * g[4] * d * b.massMultiplier[1] + g[5] * g[5] * f
                    };
                    var k = e.create(),
                        l = e.create(),
                        m = e.create();
                    e.create(), e.create(), e.create(), d.prototype.addToWlambda = function(a) {
                        var b = this.bodyA,
                            c = this.bodyB,
                            d = k,
                            f = l,
                            g = m,
                            h = b.invMassSolve,
                            i = c.invMassSolve,
                            j = b.invInertiaSolve,
                            n = c.invInertiaSolve,
                            o = this.G;
                        f[0] = o[0], f[1] = o[1], g[0] = o[3], g[1] = o[4], e.scale(d, f, h * a), e.multiply(d, d, b.massMultiplier), e.add(b.vlambda, b.vlambda, d), b.wlambda += j * o[2] * a, e.scale(d, g, i * a), e.multiply(d, d, c.massMultiplier), e.add(c.vlambda, c.vlambda, d), c.wlambda += n * o[5] * a
                    }, d.prototype.computeInvC = function(a) {
                        return 1 / (this.computeGiMGt() + a)
                    }
                }, {
                    "../math/vec2": 30,
                    "../objects/Body": 31,
                    "../utils/Utils": 57
                }
            ],
            23: [
                function(a, b, c) {
                    function d(a, b, c) {
                        f.call(this, a, b, -c, c), this.contactPointA = e.create(), this.contactPointB = e.create(), this.t = e.create(), this.contactEquations = [], this.shapeA = null, this.shapeB = null, this.frictionCoefficient = .3
                    }
                    var e = a("../math/vec2"),
                        f = a("./Equation");
                    a("../utils/Utils"), b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.setSlipForce = function(a) {
                        this.maxForce = a, this.minForce = -a
                    }, d.prototype.getSlipForce = function() {
                        return this.maxForce
                    }, d.prototype.computeB = function(a, b, c) {
                        var d = (this.bodyA, this.bodyB, this.contactPointA),
                            f = this.contactPointB,
                            g = this.t,
                            h = this.G;
                        h[0] = -g[0], h[1] = -g[1], h[2] = -e.crossLength(d, g), h[3] = g[0], h[4] = g[1], h[5] = e.crossLength(f, g);
                        var i = this.computeGW(),
                            j = this.computeGiMf(),
                            k = -i * b - c * j;
                        return k
                    }
                }, {
                    "../math/vec2": 30,
                    "../utils/Utils": 57,
                    "./Equation": 22
                }
            ],
            24: [
                function(a, b, c) {
                    function d(a, b, c) {
                        c = c || {}, e.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = c.angle || 0;
                        var d = this.G;
                        d[2] = 1, d[5] = -1
                    }
                    var e = a("./Equation"),
                        f = a("../math/vec2");
                    b.exports = d, d.prototype = new e, d.prototype.constructor = d;
                    var g = f.create(),
                        h = f.create(),
                        i = f.fromValues(1, 0),
                        j = f.fromValues(0, 1);
                    d.prototype.computeGq = function() {
                        return f.rotate(g, i, this.bodyA.angle + this.angle), f.rotate(h, j, this.bodyB.angle), f.dot(g, h)
                    }
                }, {
                    "../math/vec2": 30,
                    "./Equation": 22
                }
            ],
            25: [
                function(a, b, c) {
                    function d(a, b) {
                        e.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE), this.relativeVelocity = 1, this.ratio = 1
                    }
                    var e = a("./Equation");
                    a("../math/vec2"), b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeB = function(a, b, c) {
                        var d = this.G;
                        d[2] = -1, d[5] = this.ratio;
                        var e = this.computeGiMf(),
                            f = this.computeGW(),
                            g = -f * b - c * e;
                        return g
                    }
                }, {
                    "../math/vec2": 30,
                    "./Equation": 22
                }
            ],
            26: [
                function(a, b, c) {
                    var d = function() {};
                    b.exports = d, d.prototype = {
                        constructor: d,
                        on: function(a, b, c) {
                            b.context = c || this, void 0 === this._listeners && (this._listeners = {});
                            var d = this._listeners;
                            return void 0 === d[a] && (d[a] = []), d[a].indexOf(b) === -1 && d[a].push(b), this
                        },
                        has: function(a, b) {
                            if (void 0 === this._listeners) return !1;
                            var c = this._listeners;
                            if (b) {
                                if (void 0 !== c[a] && c[a].indexOf(b) !== -1) return !0
                            } else if (void 0 !== c[a]) return !0;
                            return !1
                        },
                        off: function(a, b) {
                            if (void 0 === this._listeners) return this;
                            var c = this._listeners,
                                d = c[a].indexOf(b);
                            return d !== -1 && c[a].splice(d, 1), this
                        },
                        emit: function(a) {
                            if (void 0 === this._listeners) return this;
                            var b = this._listeners,
                                c = b[a.type];
                            if (void 0 !== c) {
                                a.target = this;
                                for (var d = 0, e = c.length; d < e; d++) {
                                    var f = c[d];
                                    f.call(f.context, a)
                                }
                            }
                            return this
                        }
                    }
                }, {}
            ],
            27: [
                function(a, b, c) {
                    function d(a, b, c) {
                        if (c = c || {}, !(a instanceof e && b instanceof e)) throw new Error("First two arguments must be Material instances.");
                        this.id = d.idCounter++, this.materialA = a, this.materialB = b, this.friction = "undefined" != typeof c.friction ? Number(c.friction) : .3, this.restitution = "undefined" != typeof c.restitution ? Number(c.restitution) : 0, this.stiffness = "undefined" != typeof c.stiffness ? Number(c.stiffness) : f.DEFAULT_STIFFNESS, this.relaxation = "undefined" != typeof c.relaxation ? Number(c.relaxation) : f.DEFAULT_RELAXATION, this.frictionStiffness = "undefined" != typeof c.frictionStiffness ? Number(c.frictionStiffness) : f.DEFAULT_STIFFNESS, this.frictionRelaxation = "undefined" != typeof c.frictionRelaxation ? Number(c.frictionRelaxation) : f.DEFAULT_RELAXATION, this.surfaceVelocity = "undefined" != typeof c.surfaceVelocity ? Number(c.surfaceVelocity) : 0, this.contactSkinSize = .005
                    }
                    var e = a("./Material"),
                        f = a("../equations/Equation");
                    b.exports = d, d.idCounter = 0
                }, {
                    "../equations/Equation": 22,
                    "./Material": 28
                }
            ],
            28: [
                function(a, b, c) {
                    function d(a) {
                        this.id = a || d.idCounter++
                    }
                    b.exports = d, d.idCounter = 0
                }, {}
            ],
            29: [
                function(a, b, c) {
                    var d = {};
                    d.GetArea = function(a) {
                        if (a.length < 6) return 0;
                        for (var b = a.length - 2, c = 0, d = 0; d < b; d += 2) c += (a[d + 2] - a[d]) * (a[d + 1] + a[d + 3]);
                        return c += (a[0] - a[b]) * (a[b + 1] + a[1]), .5 * -c
                    }, d.Triangulate = function(a) {
                        var b = a.length >> 1;
                        if (b < 3) return [];
                        for (var c = [], e = [], f = 0; f < b; f++) e.push(f);
                        for (var f = 0, g = b; g > 3;) {
                            var h = e[(f + 0) % g],
                                i = e[(f + 1) % g],
                                j = e[(f + 2) % g],
                                k = a[2 * h],
                                l = a[2 * h + 1],
                                m = a[2 * i],
                                n = a[2 * i + 1],
                                o = a[2 * j],
                                p = a[2 * j + 1],
                                q = !1;
                            if (d._convex(k, l, m, n, o, p)) {
                                q = !0;
                                for (var r = 0; r < g; r++) {
                                    var s = e[r];
                                    if (s != h && s != i && s != j && d._PointInTriangle(a[2 * s], a[2 * s + 1], k, l, m, n, o, p)) {
                                        q = !1;
                                        break
                                    }
                                }
                            }
                            if (q) c.push(h, i, j), e.splice((f + 1) % g, 1), g--, f = 0;
                            else if (f++ > 3 * g) break
                        }
                        return c.push(e[0], e[1], e[2]), c
                    }, d._PointInTriangle = function(a, b, c, d, e, f, g, h) {
                        var i = g - c,
                            j = h - d,
                            k = e - c,
                            l = f - d,
                            m = a - c,
                            n = b - d,
                            o = i * i + j * j,
                            p = i * k + j * l,
                            q = i * m + j * n,
                            r = k * k + l * l,
                            s = k * m + l * n,
                            t = 1 / (o * r - p * p),
                            u = (r * q - p * s) * t,
                            v = (o * s - p * q) * t;
                        return u >= 0 && v >= 0 && u + v < 1
                    }, d._convex = function(a, b, c, d, e, f) {
                        return (b - d) * (e - c) + (c - a) * (f - d) >= 0
                    }, b.exports = d
                }, {}
            ],
            30: [
                function(a, b, c) {
                    var d = b.exports = {},
                        e = a("../utils/Utils");
                    d.crossLength = function(a, b) {
                        return a[0] * b[1] - a[1] * b[0]
                    }, d.crossVZ = function(a, b, c) {
                        return d.rotate(a, b, -Math.PI / 2), d.scale(a, a, c), a
                    }, d.crossZV = function(a, b, c) {
                        return d.rotate(a, c, Math.PI / 2), d.scale(a, a, b), a
                    }, d.rotate = function(a, b, c) {
                        if (0 !== c) {
                            var d = Math.cos(c),
                                e = Math.sin(c),
                                f = b[0],
                                g = b[1];
                            a[0] = d * f - e * g, a[1] = e * f + d * g
                        } else a[0] = b[0], a[1] = b[1]
                    }, d.rotate90cw = function(a, b) {
                        var c = b[0],
                            d = b[1];
                        a[0] = d, a[1] = -c
                    }, d.toLocalFrame = function(a, b, c, e) {
                        d.copy(a, b), d.sub(a, a, c), d.rotate(a, a, -e)
                    }, d.toGlobalFrame = function(a, b, c, e) {
                        d.copy(a, b), d.rotate(a, a, e), d.add(a, a, c)
                    }, d.vectorToLocalFrame = function(a, b, c) {
                        d.rotate(a, b, -c)
                    }, d.vectorToGlobalFrame = function(a, b, c) {
                        d.rotate(a, b, c)
                    }, d.centroid = function(a, b, c, e) {
                        return d.add(a, b, c), d.add(a, a, e), d.scale(a, a, 1 / 3), a
                    }, d.create = function() {
                        var a = new e.ARRAY_TYPE(2);
                        return a[0] = 0, a[1] = 0, a
                    }, d.clone = function(a) {
                        var b = new e.ARRAY_TYPE(2);
                        return b[0] = a[0], b[1] = a[1], b
                    }, d.fromValues = function(a, b) {
                        var c = new e.ARRAY_TYPE(2);
                        return c[0] = a, c[1] = b, c
                    }, d.copy = function(a, b) {
                        return a[0] = b[0], a[1] = b[1], a
                    }, d.set = function(a, b, c) {
                        return a[0] = b, a[1] = c, a
                    }, d.add = function(a, b, c) {
                        return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a
                    }, d.subtract = function(a, b, c) {
                        return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a
                    }, d.sub = d.subtract, d.multiply = function(a, b, c) {
                        return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a
                    }, d.mul = d.multiply, d.divide = function(a, b, c) {
                        return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a
                    }, d.div = d.divide, d.scale = function(a, b, c) {
                        return a[0] = b[0] * c, a[1] = b[1] * c, a
                    }, d.distance = function(a, b) {
                        var c = b[0] - a[0],
                            d = b[1] - a[1];
                        return Math.sqrt(c * c + d * d)
                    }, d.dist = d.distance, d.squaredDistance = function(a, b) {
                        var c = b[0] - a[0],
                            d = b[1] - a[1];
                        return c * c + d * d
                    }, d.sqrDist = d.squaredDistance, d.length = function(a) {
                        var b = a[0],
                            c = a[1];
                        return Math.sqrt(b * b + c * c)
                    }, d.len = d.length, d.squaredLength = function(a) {
                        var b = a[0],
                            c = a[1];
                        return b * b + c * c
                    }, d.sqrLen = d.squaredLength, d.negate = function(a, b) {
                        return a[0] = -b[0], a[1] = -b[1], a
                    }, d.normalize = function(a, b) {
                        var c = b[0],
                            d = b[1],
                            e = c * c + d * d;
                        return e > 0 && (e = 1 / Math.sqrt(e), a[0] = b[0] * e, a[1] = b[1] * e), a
                    }, d.dot = function(a, b) {
                        return a[0] * b[0] + a[1] * b[1]
                    }, d.str = function(a) {
                        return "vec2(" + a[0] + ", " + a[1] + ")"
                    }, d.lerp = function(a, b, c, d) {
                        var e = b[0],
                            f = b[1];
                        return a[0] = e + d * (c[0] - e), a[1] = f + d * (c[1] - f), a
                    }, d.reflect = function(a, b, c) {
                        var d = b[0] * c[0] + b[1] * c[1];
                        a[0] = b[0] - 2 * c[0] * d, a[1] = b[1] - 2 * c[1] * d
                    }, d.getLineSegmentsIntersection = function(a, b, c, e, f) {
                        var g = d.getLineSegmentsIntersectionFraction(b, c, e, f);
                        return !(g < 0 || (a[0] = b[0] + g * (c[0] - b[0]), a[1] = b[1] + g * (c[1] - b[1]), 0))
                    }, d.getLineSegmentsIntersectionFraction = function(a, b, c, d) {
                        var e, f, g = b[0] - a[0],
                            h = b[1] - a[1],
                            i = d[0] - c[0],
                            j = d[1] - c[1];
                        return e = (-h * (a[0] - c[0]) + g * (a[1] - c[1])) / (-i * h + g * j), f = (i * (a[1] - c[1]) - j * (a[0] - c[0])) / (-i * h + g * j), e >= 0 && e <= 1 && f >= 0 && f <= 1 ? f : -1
                    }
                }, {
                    "../utils/Utils": 57
                }
            ],
            31: [
                function(a, b, c) {
                    function d(a) {
                        a = a || {}, k.call(this), this.id = a.id || ++d._idCounter, this.world = null, this.shapes = [], this.mass = a.mass || 0, this.invMass = 0, this.inertia = 0, this.invInertia = 0, this.invMassSolve = 0, this.invInertiaSolve = 0, this.fixedRotation = !!a.fixedRotation, this.fixedX = !!a.fixedX, this.fixedY = !!a.fixedY, this.massMultiplier = e.create(), this.position = e.fromValues(0, 0), a.position && e.copy(this.position, a.position), this.interpolatedPosition = e.fromValues(0, 0), this.interpolatedAngle = 0, this.previousPosition = e.fromValues(0, 0), this.previousAngle = 0, this.velocity = e.fromValues(0, 0), a.velocity && e.copy(this.velocity, a.velocity), this.vlambda = e.fromValues(0, 0), this.wlambda = 0, this.angle = a.angle || 0, this.angularVelocity = a.angularVelocity || 0, this.force = e.create(), a.force && e.copy(this.force, a.force),
                            this.angularForce = a.angularForce || 0, this.damping = "number" == typeof a.damping ? a.damping : .1, this.angularDamping = "number" == typeof a.angularDamping ? a.angularDamping : .1, this.type = d.STATIC, "undefined" != typeof a.type ? this.type = a.type : a.mass ? this.type = d.DYNAMIC : this.type = d.STATIC, this.boundingRadius = 0, this.aabb = new j, this.aabbNeedsUpdate = !0, this.allowSleep = void 0 === a.allowSleep || a.allowSleep, this.wantsToSleep = !1, this.sleepState = d.AWAKE, this.sleepSpeedLimit = void 0 !== a.sleepSpeedLimit ? a.sleepSpeedLimit : .2, this.sleepTimeLimit = void 0 !== a.sleepTimeLimit ? a.sleepTimeLimit : 1, this.gravityScale = void 0 !== a.gravityScale ? a.gravityScale : 1, this.collisionResponse = void 0 === a.collisionResponse || a.collisionResponse, this.idleTime = 0, this.timeLastSleepy = 0, this.ccdSpeedThreshold = void 0 !== a.ccdSpeedThreshold ? a.ccdSpeedThreshold : -1, this.ccdIterations = void 0 !== a.ccdIterations ? a.ccdIterations : 10, this.concavePath = null, this._wakeUpAfterNarrowphase = !1, this.updateMassProperties()
                    }
                    var e = a("../math/vec2"),
                        f = a("poly-decomp"),
                        g = a("../shapes/Convex"),
                        h = a("../collision/RaycastResult"),
                        i = a("../collision/Ray"),
                        j = a("../collision/AABB"),
                        k = a("../events/EventEmitter");
                    b.exports = d, d.prototype = new k, d.prototype.constructor = d, d._idCounter = 0, d.prototype.updateSolveMassProperties = function() {
                        this.sleepState === d.SLEEPING || this.type === d.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve = 0) : (this.invMassSolve = this.invMass, this.invInertiaSolve = this.invInertia)
                    }, d.prototype.setDensity = function(a) {
                        var b = this.getArea();
                        this.mass = b * a, this.updateMassProperties()
                    }, d.prototype.getArea = function() {
                        for (var a = 0, b = 0; b < this.shapes.length; b++) a += this.shapes[b].area;
                        return a
                    }, d.prototype.getAABB = function() {
                        return this.aabbNeedsUpdate && this.updateAABB(), this.aabb
                    };
                    var l = new j,
                        m = e.create();
                    d.prototype.updateAABB = function() {
                        for (var a = this.shapes, b = a.length, c = m, d = this.angle, f = 0; f !== b; f++) {
                            var g = a[f],
                                h = g.angle + d;
                            e.rotate(c, g.position, d), e.add(c, c, this.position), g.computeAABB(l, c, h), 0 === f ? this.aabb.copy(l) : this.aabb.extend(l)
                        }
                        this.aabbNeedsUpdate = !1
                    }, d.prototype.updateBoundingRadius = function() {
                        for (var a = this.shapes, b = a.length, c = 0, d = 0; d !== b; d++) {
                            var f = a[d],
                                g = e.length(f.position),
                                h = f.boundingRadius;
                            g + h > c && (c = g + h)
                        }
                        this.boundingRadius = c
                    }, d.prototype.addShape = function(a, b, c) {
                        if (a.body) throw new Error("A shape can only be added to one body.");
                        a.body = this, b ? e.copy(a.position, b) : e.set(a.position, 0, 0), a.angle = c || 0, this.shapes.push(a), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0
                    }, d.prototype.removeShape = function(a) {
                        var b = this.shapes.indexOf(a);
                        return b !== -1 && (this.shapes.splice(b, 1), this.aabbNeedsUpdate = !0, a.body = null, !0)
                    }, d.prototype.updateMassProperties = function() {
                        if (this.type === d.STATIC || this.type === d.KINEMATIC) this.mass = Number.MAX_VALUE, this.invMass = 0, this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                        else {
                            var a = this.shapes,
                                b = a.length,
                                c = this.mass / b,
                                f = 0;
                            if (this.fixedRotation) this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                            else {
                                for (var g = 0; g < b; g++) {
                                    var h = a[g],
                                        i = e.squaredLength(h.position),
                                        j = h.computeMomentOfInertia(c);
                                    f += j + c * i
                                }
                                this.inertia = f, this.invInertia = f > 0 ? 1 / f : 0
                            }
                            this.invMass = 1 / this.mass, e.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1)
                        }
                    }, e.create(), d.prototype.applyForce = function(a, b) {
                        if (e.add(this.force, this.force, a), b) {
                            var c = e.crossLength(b, a);
                            this.angularForce += c
                        }
                    };
                    var n = e.create(),
                        o = e.create(),
                        p = e.create();
                    d.prototype.applyForceLocal = function(a, b) {
                        b = b || p;
                        var c = n,
                            d = o;
                        this.vectorToWorldFrame(c, a), this.vectorToWorldFrame(d, b), this.applyForce(c, d)
                    };
                    var q = e.create();
                    d.prototype.applyImpulse = function(a, b) {
                        if (this.type === d.DYNAMIC) {
                            var c = q;
                            if (e.scale(c, a, this.invMass), e.multiply(c, this.massMultiplier, c), e.add(this.velocity, c, this.velocity), b) {
                                var f = e.crossLength(b, a);
                                f *= this.invInertia, this.angularVelocity += f
                            }
                        }
                    };
                    var r = e.create(),
                        s = e.create(),
                        t = e.create();
                    d.prototype.applyImpulseLocal = function(a, b) {
                        b = b || t;
                        var c = r,
                            d = s;
                        this.vectorToWorldFrame(c, a), this.vectorToWorldFrame(d, b), this.applyImpulse(c, d)
                    }, d.prototype.toLocalFrame = function(a, b) {
                        e.toLocalFrame(a, b, this.position, this.angle)
                    }, d.prototype.toWorldFrame = function(a, b) {
                        e.toGlobalFrame(a, b, this.position, this.angle)
                    }, d.prototype.vectorToLocalFrame = function(a, b) {
                        e.vectorToLocalFrame(a, b, this.angle)
                    }, d.prototype.vectorToWorldFrame = function(a, b) {
                        e.vectorToGlobalFrame(a, b, this.angle)
                    }, d.prototype.fromPolygon = function(a, b) {
                        b = b || {};
                        for (var c = this.shapes.length; c >= 0; --c) this.removeShape(this.shapes[c]);
                        var d = new f.Polygon;
                        if (d.vertices = a, d.makeCCW(), "number" == typeof b.removeCollinearPoints && d.removeCollinearPoints(b.removeCollinearPoints), "undefined" == typeof b.skipSimpleCheck && !d.isSimple()) return !1;
                        this.concavePath = d.vertices.slice(0);
                        for (var c = 0; c < this.concavePath.length; c++) {
                            var h = [0, 0];
                            e.copy(h, this.concavePath[c]), this.concavePath[c] = h
                        }
                        var i;
                        i = b.optimalDecomp ? d.decomp() : d.quickDecomp();
                        for (var j = e.create(), c = 0; c !== i.length; c++) {
                            for (var k = new g({
                                vertices: i[c].vertices
                            }), l = 0; l !== k.vertices.length; l++) {
                                var h = k.vertices[l];
                                e.sub(h, h, k.centerOfMass)
                            }
                            e.scale(j, k.centerOfMass, 1), k.updateTriangles(), k.updateCenterOfMass(), k.updateBoundingRadius(), this.addShape(k, j)
                        }
                        return this.adjustCenterOfMass(), this.aabbNeedsUpdate = !0, !0
                    };
                    var u = (e.fromValues(0, 0), e.fromValues(0, 0)),
                        v = e.fromValues(0, 0),
                        w = e.fromValues(0, 0);
                    d.prototype.adjustCenterOfMass = function() {
                        var a = u,
                            b = v,
                            c = w,
                            d = 0;
                        e.set(b, 0, 0);
                        for (var f = 0; f !== this.shapes.length; f++) {
                            var g = this.shapes[f];
                            e.scale(a, g.position, g.area), e.add(b, b, a), d += g.area
                        }
                        e.scale(c, b, 1 / d);
                        for (var f = 0; f !== this.shapes.length; f++) {
                            var g = this.shapes[f];
                            e.sub(g.position, g.position, c)
                        }
                        e.add(this.position, this.position, c);
                        for (var f = 0; this.concavePath && f < this.concavePath.length; f++) e.sub(this.concavePath[f], this.concavePath[f], c);
                        this.updateMassProperties(), this.updateBoundingRadius()
                    }, d.prototype.setZeroForce = function() {
                        e.set(this.force, 0, 0), this.angularForce = 0
                    }, d.prototype.resetConstraintVelocity = function() {
                        var a = this,
                            b = a.vlambda;
                        e.set(b, 0, 0), a.wlambda = 0
                    }, d.prototype.addConstraintVelocity = function() {
                        var a = this,
                            b = a.velocity;
                        e.add(b, b, a.vlambda), a.angularVelocity += a.wlambda
                    }, d.prototype.applyDamping = function(a) {
                        if (this.type === d.DYNAMIC) {
                            var b = this.velocity;
                            e.scale(b, b, Math.pow(1 - this.damping, a)), this.angularVelocity *= Math.pow(1 - this.angularDamping, a)
                        }
                    }, d.prototype.wakeUp = function() {
                        var a = this.sleepState;
                        this.sleepState = d.AWAKE, this.idleTime = 0, a !== d.AWAKE && this.emit(d.wakeUpEvent)
                    }, d.prototype.sleep = function() {
                        this.sleepState = d.SLEEPING, this.angularVelocity = 0, this.angularForce = 0, e.set(this.velocity, 0, 0), e.set(this.force, 0, 0), this.emit(d.sleepEvent)
                    }, d.prototype.sleepTick = function(a, b, c) {
                        if (this.allowSleep && this.type !== d.SLEEPING) {
                            this.wantsToSleep = !1;
                            var f = (this.sleepState, e.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2)),
                                g = Math.pow(this.sleepSpeedLimit, 2);
                            f >= g ? (this.idleTime = 0, this.sleepState = d.AWAKE) : (this.idleTime += c, this.sleepState = d.SLEEPY), this.idleTime > this.sleepTimeLimit && (b ? this.wantsToSleep = !0 : this.sleep())
                        }
                    }, d.prototype.overlaps = function(a) {
                        return this.world.overlapKeeper.bodiesAreOverlapping(this, a)
                    };
                    var x = e.create(),
                        y = e.create();
                    d.prototype.integrate = function(a) {
                        var b = this.invMass,
                            c = this.force,
                            d = this.position,
                            f = this.velocity;
                        e.copy(this.previousPosition, this.position), this.previousAngle = this.angle, this.fixedRotation || (this.angularVelocity += this.angularForce * this.invInertia * a), e.scale(x, c, a * b), e.multiply(x, this.massMultiplier, x), e.add(f, x, f), this.integrateToTimeOfImpact(a) || (e.scale(y, f, a), e.add(d, d, y), this.fixedRotation || (this.angle += this.angularVelocity * a)), this.aabbNeedsUpdate = !0
                    };
                    var z = new h,
                        A = new i({
                            mode: i.ALL
                        }),
                        B = e.create(),
                        C = e.create(),
                        D = e.create(),
                        E = e.create();
                    d.prototype.integrateToTimeOfImpact = function(a) {
                        if (this.ccdSpeedThreshold < 0 || e.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) return !1;
                        e.normalize(B, this.velocity), e.scale(C, this.velocity, a), e.add(C, C, this.position), e.sub(D, C, this.position);
                        var b, c = this.angularVelocity * a,
                            d = e.length(D),
                            f = 1,
                            g = this;
                        if (z.reset(), A.callback = function(a) {
                            a.body !== g && (b = a.body, a.getHitPoint(C, A), e.sub(D, C, g.position), f = e.length(D) / d, a.stop())
                        }, e.copy(A.from, this.position), e.copy(A.to, C), A.update(), this.world.raycast(z, A), !b) return !1;
                        var h = this.angle;
                        e.copy(E, this.position);
                        for (var i = 0, j = 0, k = 0, l = f; l >= j && i < this.ccdIterations;) {
                            i++, k = (l - j) / 2, e.scale(y, D, f), e.add(this.position, E, y), this.angle = h + c * f, this.updateAABB();
                            var m = this.aabb.overlaps(b.aabb) && this.world.narrowphase.bodiesOverlap(this, b);
                            m ? j = k : l = k
                        }
                        return f = k, e.copy(this.position, E), this.angle = h, e.scale(y, D, f), e.add(this.position, this.position, y), this.fixedRotation || (this.angle += c * f), !0
                    }, d.prototype.getVelocityAtPoint = function(a, b) {
                        return e.crossVZ(a, b, this.angularVelocity), e.subtract(a, this.velocity, a), a
                    }, d.sleepyEvent = {
                        type: "sleepy"
                    }, d.sleepEvent = {
                        type: "sleep"
                    }, d.wakeUpEvent = {
                        type: "wakeup"
                    }, d.DYNAMIC = 1, d.STATIC = 2, d.KINEMATIC = 4, d.AWAKE = 0, d.SLEEPY = 1, d.SLEEPING = 2
                }, {
                    "../collision/AABB": 7,
                    "../collision/Ray": 11,
                    "../collision/RaycastResult": 12,
                    "../events/EventEmitter": 26,
                    "../math/vec2": 30,
                    "../shapes/Convex": 40,
                    "poly-decomp": 5
                }
            ],
            32: [
                function(a, b, c) {
                    function d(a, b, c) {
                        c = c || {}, f.call(this, a, b, c), this.localAnchorA = e.fromValues(0, 0), this.localAnchorB = e.fromValues(0, 0), c.localAnchorA && e.copy(this.localAnchorA, c.localAnchorA), c.localAnchorB && e.copy(this.localAnchorB, c.localAnchorB), c.worldAnchorA && this.setWorldAnchorA(c.worldAnchorA), c.worldAnchorB && this.setWorldAnchorB(c.worldAnchorB);
                        var d = e.create(),
                            g = e.create();
                        this.getWorldAnchorA(d), this.getWorldAnchorB(g);
                        var h = e.distance(d, g);
                        this.restLength = "number" == typeof c.restLength ? c.restLength : h
                    }
                    var e = a("../math/vec2"),
                        f = a("./Spring");
                    a("../utils/Utils"), b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.setWorldAnchorA = function(a) {
                        this.bodyA.toLocalFrame(this.localAnchorA, a)
                    }, d.prototype.setWorldAnchorB = function(a) {
                        this.bodyB.toLocalFrame(this.localAnchorB, a)
                    }, d.prototype.getWorldAnchorA = function(a) {
                        this.bodyA.toWorldFrame(a, this.localAnchorA)
                    }, d.prototype.getWorldAnchorB = function(a) {
                        this.bodyB.toWorldFrame(a, this.localAnchorB)
                    };
                    var g = e.create(),
                        h = e.create(),
                        i = e.create(),
                        j = e.create(),
                        k = e.create(),
                        l = e.create(),
                        m = e.create(),
                        n = e.create(),
                        o = e.create();
                    d.prototype.applyForce = function() {
                        var a = this.stiffness,
                            b = this.damping,
                            c = this.restLength,
                            d = this.bodyA,
                            f = this.bodyB,
                            p = g,
                            q = h,
                            r = i,
                            s = j,
                            t = o,
                            u = k,
                            v = l,
                            w = m,
                            x = n;
                        this.getWorldAnchorA(u), this.getWorldAnchorB(v), e.sub(w, u, d.position), e.sub(x, v, f.position), e.sub(p, v, u);
                        var y = e.len(p);
                        e.normalize(q, p), e.sub(r, f.velocity, d.velocity), e.crossZV(t, f.angularVelocity, x), e.add(r, r, t), e.crossZV(t, d.angularVelocity, w), e.sub(r, r, t), e.scale(s, q, -a * (y - c) - b * e.dot(r, q)), e.sub(d.force, d.force, s), e.add(f.force, f.force, s);
                        var z = e.crossLength(w, s),
                            A = e.crossLength(x, s);
                        d.angularForce -= z, f.angularForce += A
                    }
                }, {
                    "../math/vec2": 30,
                    "../utils/Utils": 57,
                    "./Spring": 34
                }
            ],
            33: [
                function(a, b, c) {
                    function d(a, b, c) {
                        c = c || {}, e.call(this, a, b, c), this.restAngle = "number" == typeof c.restAngle ? c.restAngle : b.angle - a.angle
                    }
                    var e = (a("../math/vec2"), a("./Spring"));
                    b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.applyForce = function() {
                        var a = this.stiffness,
                            b = this.damping,
                            c = this.restAngle,
                            d = this.bodyA,
                            e = this.bodyB,
                            f = e.angle - d.angle,
                            g = e.angularVelocity - d.angularVelocity,
                            h = -a * (f - c) - b * g * 0;
                        d.angularForce -= h, e.angularForce += h
                    }
                }, {
                    "../math/vec2": 30,
                    "./Spring": 34
                }
            ],
            34: [
                function(a, b, c) {
                    function d(a, b, c) {
                        c = e.defaults(c, {
                            stiffness: 100,
                            damping: 1
                        }), this.stiffness = c.stiffness, this.damping = c.damping, this.bodyA = a, this.bodyB = b
                    }
                    var e = (a("../math/vec2"), a("../utils/Utils"));
                    b.exports = d, d.prototype.applyForce = function() {}
                }, {
                    "../math/vec2": 30,
                    "../utils/Utils": 57
                }
            ],
            35: [
                function(a, b, c) {
                    function d(a, b) {
                        b = b || {}, this.chassisBody = a, this.wheels = [], this.groundBody = new i({
                            mass: 0
                        }), this.world = null;
                        var c = this;
                        this.preStepCallback = function() {
                            c.update()
                        }
                    }

                    function e(a, b) {
                        b = b || {}, this.vehicle = a, this.forwardEquation = new h(a.chassisBody, a.groundBody), this.sideEquation = new h(a.chassisBody, a.groundBody), this.steerValue = 0, this.engineForce = 0, this.setSideFriction(void 0 !== b.sideFriction ? b.sideFriction : 5), this.localForwardVector = f.fromValues(0, 1), b.localForwardVector && f.copy(this.localForwardVector, b.localForwardVector), this.localPosition = f.fromValues(0, 0), b.localPosition && f.copy(this.localPosition, b.localPosition), g.apply(this, a.chassisBody, a.groundBody), this.equations.push(this.forwardEquation, this.sideEquation), this.setBrakeForce(0)
                    }
                    var f = a("../math/vec2"),
                        g = (a("../utils/Utils"), a("../constraints/Constraint")),
                        h = a("../equations/FrictionEquation"),
                        i = a("../objects/Body");
                    b.exports = d, d.prototype.addToWorld = function(a) {
                        this.world = a, a.addBody(this.groundBody), a.on("preStep", this.preStepCallback);
                        for (var b = 0; b < this.wheels.length; b++) {
                            var c = this.wheels[b];
                            a.addConstraint(c)
                        }
                    }, d.prototype.removeFromWorld = function() {
                        var a = this.world;
                        a.removeBody(this.groundBody), a.off("preStep", this.preStepCallback);
                        for (var b = 0; b < this.wheels.length; b++) {
                            var c = this.wheels[b];
                            a.removeConstraint(c)
                        }
                        this.world = null
                    }, d.prototype.addWheel = function(a) {
                        var b = new e(this, a);
                        return this.wheels.push(b), b
                    }, d.prototype.update = function() {
                        for (var a = 0; a < this.wheels.length; a++) this.wheels[a].update()
                    }, e.prototype = new g, e.prototype.setBrakeForce = function(a) {
                        this.forwardEquation.setSlipForce(a)
                    }, e.prototype.setSideFriction = function(a) {
                        this.sideEquation.setSlipForce(a)
                    };
                    var j = f.create(),
                        k = f.create();
                    e.prototype.getSpeed = function() {
                        return this.vehicle.chassisBody.vectorToWorldFrame(k, this.localForwardVector), this.vehicle.chassisBody.getVelocityAtPoint(j, k), f.dot(j, k)
                    };
                    var l = f.create();
                    e.prototype.update = function() {
                        this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector), f.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2), this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t), f.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue), f.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue), this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition), f.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB), this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition), f.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA), f.normalize(l, this.forwardEquation.t), f.scale(l, l, this.engineForce), this.vehicle.chassisBody.applyForce(l, this.forwardEquation.contactPointA)
                    }
                }, {
                    "../constraints/Constraint": 14,
                    "../equations/FrictionEquation": 23,
                    "../math/vec2": 30,
                    "../objects/Body": 31,
                    "../utils/Utils": 57
                }
            ],
            36: [
                function(a, b, c) {
                    var d = b.exports = {
                        AABB: a("./collision/AABB"),
                        AngleLockEquation: a("./equations/AngleLockEquation"),
                        Body: a("./objects/Body"),
                        Broadphase: a("./collision/Broadphase"),
                        Capsule: a("./shapes/Capsule"),
                        Circle: a("./shapes/Circle"),
                        Constraint: a("./constraints/Constraint"),
                        ContactEquation: a("./equations/ContactEquation"),
                        ContactEquationPool: a("./utils/ContactEquationPool"),
                        ContactMaterial: a("./material/ContactMaterial"),
                        Convex: a("./shapes/Convex"),
                        DistanceConstraint: a("./constraints/DistanceConstraint"),
                        Equation: a("./equations/Equation"),
                        EventEmitter: a("./events/EventEmitter"),
                        FrictionEquation: a("./equations/FrictionEquation"),
                        FrictionEquationPool: a("./utils/FrictionEquationPool"),
                        GearConstraint: a("./constraints/GearConstraint"),
                        GSSolver: a("./solver/GSSolver"),
                        Heightfield: a("./shapes/Heightfield"),
                        Line: a("./shapes/Line"),
                        LockConstraint: a("./constraints/LockConstraint"),
                        Material: a("./material/Material"),
                        Narrowphase: a("./collision/Narrowphase"),
                        NaiveBroadphase: a("./collision/NaiveBroadphase"),
                        Particle: a("./shapes/Particle"),
                        Plane: a("./shapes/Plane"),
                        Pool: a("./utils/Pool"),
                        RevoluteConstraint: a("./constraints/RevoluteConstraint"),
                        PrismaticConstraint: a("./constraints/PrismaticConstraint"),
                        Ray: a("./collision/Ray"),
                        RaycastResult: a("./collision/RaycastResult"),
                        Box: a("./shapes/Box"),
                        RotationalVelocityEquation: a("./equations/RotationalVelocityEquation"),
                        SAPBroadphase: a("./collision/SAPBroadphase"),
                        Shape: a("./shapes/Shape"),
                        Solver: a("./solver/Solver"),
                        Spring: a("./objects/Spring"),
                        TopDownVehicle: a("./objects/TopDownVehicle"),
                        LinearSpring: a("./objects/LinearSpring"),
                        RotationalSpring: a("./objects/RotationalSpring"),
                        Utils: a("./utils/Utils"),
                        World: a("./world/World"),
                        vec2: a("./math/vec2"),
                        version: a("../package.json").version
                    };
                    Object.defineProperty(d, "Rectangle", {
                        get: function() {
                            return this.Box
                        }
                    })
                }, {
                    "../package.json": 6,
                    "./collision/AABB": 7,
                    "./collision/Broadphase": 8,
                    "./collision/NaiveBroadphase": 9,
                    "./collision/Narrowphase": 10,
                    "./collision/Ray": 11,
                    "./collision/RaycastResult": 12,
                    "./collision/SAPBroadphase": 13,
                    "./constraints/Constraint": 14,
                    "./constraints/DistanceConstraint": 15,
                    "./constraints/GearConstraint": 16,
                    "./constraints/LockConstraint": 17,
                    "./constraints/PrismaticConstraint": 18,
                    "./constraints/RevoluteConstraint": 19,
                    "./equations/AngleLockEquation": 20,
                    "./equations/ContactEquation": 21,
                    "./equations/Equation": 22,
                    "./equations/FrictionEquation": 23,
                    "./equations/RotationalVelocityEquation": 25,
                    "./events/EventEmitter": 26,
                    "./material/ContactMaterial": 27,
                    "./material/Material": 28,
                    "./math/vec2": 30,
                    "./objects/Body": 31,
                    "./objects/LinearSpring": 32,
                    "./objects/RotationalSpring": 33,
                    "./objects/Spring": 34,
                    "./objects/TopDownVehicle": 35,
                    "./shapes/Box": 37,
                    "./shapes/Capsule": 38,
                    "./shapes/Circle": 39,
                    "./shapes/Convex": 40,
                    "./shapes/Heightfield": 41,
                    "./shapes/Line": 42,
                    "./shapes/Particle": 43,
                    "./shapes/Plane": 44,
                    "./shapes/Shape": 45,
                    "./solver/GSSolver": 46,
                    "./solver/Solver": 47,
                    "./utils/ContactEquationPool": 48,
                    "./utils/FrictionEquationPool": 49,
                    "./utils/Pool": 55,
                    "./utils/Utils": 57,
                    "./world/World": 61
                }
            ],
            37: [
                function(a, b, c) {
                    function d(a) {
                        "number" == typeof arguments[0] && "number" == typeof arguments[1] && void(a = {
                            width: arguments[0],
                            height: arguments[1]
                        }), a = a || {};
                        var b = this.width = a.width || 1,
                            c = this.height = a.height || 1,
                            d = [e.fromValues(-b / 2, -c / 2), e.fromValues(b / 2, -c / 2), e.fromValues(b / 2, c / 2), e.fromValues(-b / 2, c / 2)],
                            h = [e.fromValues(1, 0), e.fromValues(0, 1)];
                        a.vertices = d, a.axes = h, a.type = f.BOX, g.call(this, a)
                    }
                    var e = a("../math/vec2"),
                        f = a("./Shape"),
                        g = a("./Convex");
                    b.exports = d, d.prototype = new g, d.prototype.constructor = d, d.prototype.computeMomentOfInertia = function(a) {
                        var b = this.width,
                            c = this.height;
                        return a * (c * c + b * b) / 12
                    }, d.prototype.updateBoundingRadius = function() {
                        var a = this.width,
                            b = this.height;
                        this.boundingRadius = Math.sqrt(a * a + b * b) / 2
                    }, e.create(), e.create(), e.create(), e.create(), d.prototype.computeAABB = function(a, b, c) {
                        a.setFromPoints(this.vertices, b, c, 0)
                    }, d.prototype.updateArea = function() {
                        this.area = this.width * this.height
                    }
                }, {
                    "../math/vec2": 30,
                    "./Convex": 40,
                    "./Shape": 45
                }
            ],
            38: [
                function(a, b, c) {
                    function d(a) {
                        "number" == typeof arguments[0] && "number" == typeof arguments[1] && void(a = {
                            length: arguments[0],
                            radius: arguments[1]
                        }), a = a || {}, this.length = a.length || 1, this.radius = a.radius || 1, a.type = e.CAPSULE, e.call(this, a)
                    }
                    var e = a("./Shape"),
                        f = a("../math/vec2");
                    b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeMomentOfInertia = function(a) {
                        var b = this.radius,
                            c = this.length + b,
                            d = 2 * b;
                        return a * (d * d + c * c) / 12
                    }, d.prototype.updateBoundingRadius = function() {
                        this.boundingRadius = this.radius + this.length / 2
                    }, d.prototype.updateArea = function() {
                        this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length
                    };
                    var g = f.create();
                    d.prototype.computeAABB = function(a, b, c) {
                        var d = this.radius;
                        f.set(g, this.length / 2, 0), 0 !== c && f.rotate(g, g, c), f.set(a.upperBound, Math.max(g[0] + d, -g[0] + d), Math.max(g[1] + d, -g[1] + d)), f.set(a.lowerBound, Math.min(g[0] - d, -g[0] - d), Math.min(g[1] - d, -g[1] - d)), f.add(a.lowerBound, a.lowerBound, b), f.add(a.upperBound, a.upperBound, b)
                    };
                    var h = f.create(),
                        i = f.create(),
                        j = f.create(),
                        k = f.create(),
                        l = f.fromValues(0, 1);
                    d.prototype.raycast = function(a, b, c, d) {
                        for (var e = b.from, g = b.to, m = (b.direction, h), n = i, o = j, p = k, q = this.length / 2, r = 0; r < 2; r++) {
                            var s = this.radius * (2 * r - 1);
                            f.set(o, -q, s), f.set(p, q, s), f.toGlobalFrame(o, o, c, d), f.toGlobalFrame(p, p, c, d);
                            var t = f.getLineSegmentsIntersectionFraction(e, g, o, p);
                            if (t >= 0 && (f.rotate(n, l, d), f.scale(n, n, 2 * r - 1), b.reportIntersection(a, t, n, -1), a.shouldStop(b))) return
                        }
                        for (var u = Math.pow(this.radius, 2) + Math.pow(q, 2), r = 0; r < 2; r++) {
                            f.set(o, q * (2 * r - 1), 0), f.toGlobalFrame(o, o, c, d);
                            var v = Math.pow(g[0] - e[0], 2) + Math.pow(g[1] - e[1], 2),
                                w = 2 * ((g[0] - e[0]) * (e[0] - o[0]) + (g[1] - e[1]) * (e[1] - o[1])),
                                x = Math.pow(e[0] - o[0], 2) + Math.pow(e[1] - o[1], 2) - Math.pow(this.radius, 2),
                                t = Math.pow(w, 2) - 4 * v * x;
                            if (!(t < 0))
                                if (0 === t) {
                                    if (f.lerp(m, e, g, t), f.squaredDistance(m, c) > u && (f.sub(n, m, o), f.normalize(n, n), b.reportIntersection(a, t, n, -1), a.shouldStop(b))) return
                                } else {
                                    var y = Math.sqrt(t),
                                        z = 1 / (2 * v),
                                        A = (-w - y) * z,
                                        B = (-w + y) * z;
                                    if (A >= 0 && A <= 1 && (f.lerp(m, e, g, A), f.squaredDistance(m, c) > u && (f.sub(n, m, o), f.normalize(n, n), b.reportIntersection(a, A, n, -1), a.shouldStop(b)))) return;
                                    if (B >= 0 && B <= 1 && (f.lerp(m, e, g, B), f.squaredDistance(m, c) > u && (f.sub(n, m, o), f.normalize(n, n), b.reportIntersection(a, B, n, -1), a.shouldStop(b)))) return
                                }
                        }
                    }
                }, {
                    "../math/vec2": 30,
                    "./Shape": 45
                }
            ],
            39: [
                function(a, b, c) {
                    function d(a) {
                        "number" == typeof arguments[0] && void(a = {
                            radius: arguments[0]
                        }), a = a || {}, this.radius = a.radius || 1, a.type = e.CIRCLE, e.call(this, a)
                    }
                    var e = a("./Shape"),
                        f = a("../math/vec2");
                    b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeMomentOfInertia = function(a) {
                        var b = this.radius;
                        return a * b * b / 2
                    }, d.prototype.updateBoundingRadius = function() {
                        this.boundingRadius = this.radius
                    }, d.prototype.updateArea = function() {
                        this.area = Math.PI * this.radius * this.radius
                    }, d.prototype.computeAABB = function(a, b, c) {
                        var d = this.radius;
                        f.set(a.upperBound, d, d), f.set(a.lowerBound, -d, -d), b && (f.add(a.lowerBound, a.lowerBound, b), f.add(a.upperBound, a.upperBound, b))
                    };
                    var g = f.create(),
                        h = f.create();
                    d.prototype.raycast = function(a, b, c, d) {
                        var e = b.from,
                            i = b.to,
                            j = this.radius,
                            k = Math.pow(i[0] - e[0], 2) + Math.pow(i[1] - e[1], 2),
                            l = 2 * ((i[0] - e[0]) * (e[0] - c[0]) + (i[1] - e[1]) * (e[1] - c[1])),
                            m = Math.pow(e[0] - c[0], 2) + Math.pow(e[1] - c[1], 2) - Math.pow(j, 2),
                            n = Math.pow(l, 2) - 4 * k * m,
                            o = g,
                            p = h;
                        if (!(n < 0))
                            if (0 === n) f.lerp(o, e, i, n), f.sub(p, o, c), f.normalize(p, p), b.reportIntersection(a, n, p, -1);
                            else {
                                var q = Math.sqrt(n),
                                    r = 1 / (2 * k),
                                    s = (-l - q) * r,
                                    t = (-l + q) * r;
                                if (s >= 0 && s <= 1 && (f.lerp(o, e, i, s), f.sub(p, o, c), f.normalize(p, p), b.reportIntersection(a, s, p, -1), a.shouldStop(b))) return;
                                t >= 0 && t <= 1 && (f.lerp(o, e, i, t), f.sub(p, o, c), f.normalize(p, p), b.reportIntersection(a, t, p, -1))
                            }
                    }
                }, {
                    "../math/vec2": 30,
                    "./Shape": 45
                }
            ],
            40: [
                function(a, b, c) {
                    function d(a) {
                        Array.isArray(arguments[0]) && void(a = {
                            vertices: arguments[0],
                            axes: arguments[1]
                        }), a = a || {}, this.vertices = [];
                        for (var b = void 0 !== a.vertices ? a.vertices : [], c = 0; c < b.length; c++) {
                            var d = f.create();
                            f.copy(d, b[c]), this.vertices.push(d)
                        }
                        if (this.axes = [], a.axes)
                            for (var c = 0; c < a.axes.length; c++) {
                                var g = f.create();
                                f.copy(g, a.axes[c]), this.axes.push(g)
                            } else
                                for (var c = 0; c < this.vertices.length; c++) {
                                    var h = this.vertices[c],
                                        i = this.vertices[(c + 1) % this.vertices.length],
                                        j = f.create();
                                    f.sub(j, i, h), f.rotate90cw(j, j), f.normalize(j, j), this.axes.push(j)
                                }
                        if (this.centerOfMass = f.fromValues(0, 0), this.triangles = [], this.vertices.length && (this.updateTriangles(), this.updateCenterOfMass()), this.boundingRadius = 0, a.type = e.CONVEX, e.call(this, a), this.updateBoundingRadius(), this.updateArea(), this.area < 0) throw new Error("Convex vertices must be given in conter-clockwise winding.")
                    }
                    var e = a("./Shape"),
                        f = a("../math/vec2"),
                        g = a("../math/polyk");
                    a("poly-decomp"), b.exports = d, d.prototype = new e, d.prototype.constructor = d;
                    var h = f.create(),
                        i = f.create();
                    d.prototype.projectOntoLocalAxis = function(a, b) {
                        for (var c, d, e = null, g = null, a = h, i = 0; i < this.vertices.length; i++) c = this.vertices[i], d = f.dot(c, a), (null === e || d > e) && (e = d), (null === g || d < g) && (g = d);
                        if (g > e) {
                            var j = g;
                            g = e, e = j
                        }
                        f.set(b, g, e)
                    }, d.prototype.projectOntoWorldAxis = function(a, b, c, d) {
                        var e = i;
                        this.projectOntoLocalAxis(a, d), 0 !== c ? f.rotate(e, a, c) : e = a;
                        var g = f.dot(b, e);
                        f.set(d, d[0] + g, d[1] + g)
                    }, d.prototype.updateTriangles = function() {
                        this.triangles.length = 0;
                        for (var a = [], b = 0; b < this.vertices.length; b++) {
                            var c = this.vertices[b];
                            a.push(c[0], c[1])
                        }
                        for (var d = g.Triangulate(a), b = 0; b < d.length; b += 3) {
                            var e = d[b],
                                f = d[b + 1],
                                h = d[b + 2];
                            this.triangles.push([e, f, h])
                        }
                    };
                    var j = f.create(),
                        k = f.create(),
                        l = f.create(),
                        m = f.create(),
                        n = f.create();
                    f.create(), f.create(), f.create(), f.create(), d.prototype.updateCenterOfMass = function() {
                        var a = this.triangles,
                            b = this.vertices,
                            c = this.centerOfMass,
                            e = j,
                            g = l,
                            h = m,
                            i = n,
                            o = k;
                        f.set(c, 0, 0);
                        for (var p = 0, q = 0; q !== a.length; q++) {
                            var r = a[q],
                                g = b[r[0]],
                                h = b[r[1]],
                                i = b[r[2]];
                            f.centroid(e, g, h, i);
                            var s = d.triangleArea(g, h, i);
                            p += s, f.scale(o, e, s), f.add(c, c, o)
                        }
                        f.scale(c, c, 1 / p)
                    }, d.prototype.computeMomentOfInertia = function(a) {
                        for (var b = 0, c = 0, d = this.vertices.length, e = d - 1, g = 0; g < d; e = g, g++) {
                            var h = this.vertices[e],
                                i = this.vertices[g],
                                j = Math.abs(f.crossLength(h, i)),
                                k = f.dot(i, i) + f.dot(i, h) + f.dot(h, h);
                            b += j * k, c += j
                        }
                        return a / 6 * (b / c)
                    }, d.prototype.updateBoundingRadius = function() {
                        for (var a = this.vertices, b = 0, c = 0; c !== a.length; c++) {
                            var d = f.squaredLength(a[c]);
                            d > b && (b = d)
                        }
                        this.boundingRadius = Math.sqrt(b)
                    }, d.triangleArea = function(a, b, c) {
                        return .5 * ((b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]))
                    }, d.prototype.updateArea = function() {
                        this.updateTriangles(), this.area = 0;
                        for (var a = this.triangles, b = this.vertices, c = 0; c !== a.length; c++) {
                            var e = a[c],
                                f = b[e[0]],
                                g = b[e[1]],
                                h = b[e[2]],
                                i = d.triangleArea(f, g, h);
                            this.area += i
                        }
                    }, d.prototype.computeAABB = function(a, b, c) {
                        a.setFromPoints(this.vertices, b, c, 0)
                    };
                    var o = f.create(),
                        p = f.create(),
                        q = f.create();
                    d.prototype.raycast = function(a, b, c, d) {
                        var e = o,
                            g = p,
                            h = q,
                            i = this.vertices;
                        f.toLocalFrame(e, b.from, c, d), f.toLocalFrame(g, b.to, c, d);
                        for (var j = i.length, k = 0; k < j && !a.shouldStop(b); k++) {
                            var l = i[k],
                                m = i[(k + 1) % j],
                                n = f.getLineSegmentsIntersectionFraction(e, g, l, m);
                            n >= 0 && (f.sub(h, m, l), f.rotate(h, h, -Math.PI / 2 + d), f.normalize(h, h), b.reportIntersection(a, n, h, k))
                        }
                    }
                }, {
                    "../math/polyk": 29,
                    "../math/vec2": 30,
                    "./Shape": 45,
                    "poly-decomp": 5
                }
            ],
            41: [
                function(a, b, c) {
                    function d(a) {
                        if (Array.isArray(arguments[0]) && (a = {
                            heights: arguments[0]
                        }, "object" == typeof arguments[1]))
                            for (var b in arguments[1]) a[b] = arguments[1][b];
                        a = a || {}, this.heights = a.heights ? a.heights.slice(0) : [], this.maxValue = a.maxValue || null, this.minValue = a.minValue || null, this.elementWidth = a.elementWidth || .1, void 0 !== a.maxValue && void 0 !== a.minValue || this.updateMaxMinValues(), a.type = e.HEIGHTFIELD, e.call(this, a)
                    }
                    var e = a("./Shape"),
                        f = a("../math/vec2");
                    a("../utils/Utils"), b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.updateMaxMinValues = function() {
                        for (var a = this.heights, b = a[0], c = a[0], d = 0; d !== a.length; d++) {
                            var e = a[d];
                            e > b && (b = e), e < c && (c = e)
                        }
                        this.maxValue = b, this.minValue = c
                    }, d.prototype.computeMomentOfInertia = function(a) {
                        return Number.MAX_VALUE
                    }, d.prototype.updateBoundingRadius = function() {
                        this.boundingRadius = Number.MAX_VALUE
                    }, d.prototype.updateArea = function() {
                        for (var a = this.heights, b = 0, c = 0; c < a.length - 1; c++) b += (a[c] + a[c + 1]) / 2 * this.elementWidth;
                        this.area = b
                    };
                    var g = [f.create(), f.create(), f.create(), f.create()];
                    d.prototype.computeAABB = function(a, b, c) {
                        f.set(g[0], 0, this.maxValue), f.set(g[1], this.elementWidth * this.heights.length, this.maxValue), f.set(g[2], this.elementWidth * this.heights.length, this.minValue), f.set(g[3], 0, this.minValue), a.setFromPoints(g, b, c)
                    }, d.prototype.getLineSegment = function(a, b, c) {
                        var d = this.heights,
                            e = this.elementWidth;
                        f.set(a, c * e, d[c]), f.set(b, (c + 1) * e, d[c + 1])
                    }, d.prototype.getSegmentIndex = function(a) {
                        return Math.floor(a[0] / this.elementWidth)
                    }, d.prototype.getClampedSegmentIndex = function(a) {
                        var b = this.getSegmentIndex(a);
                        return b = Math.min(this.heights.length, Math.max(b, 0))
                    };
                    var h = (f.create(), f.create()),
                        i = f.create(),
                        j = f.create(),
                        k = f.create(),
                        l = f.create();
                    f.fromValues(0, 1), d.prototype.raycast = function(a, b, c, d) {
                        var e = b.from,
                            g = b.to,
                            m = (b.direction, h),
                            n = i,
                            o = j,
                            p = k,
                            q = l;
                        f.toLocalFrame(p, e, c, d), f.toLocalFrame(q, g, c, d);
                        var r = this.getClampedSegmentIndex(p),
                            s = this.getClampedSegmentIndex(q);
                        if (r > s) {
                            var t = r;
                            r = s, s = t
                        }
                        for (var u = 0; u < this.heights.length - 1; u++) {
                            this.getLineSegment(n, o, u);
                            var v = f.getLineSegmentsIntersectionFraction(p, q, n, o);
                            if (v >= 0 && (f.sub(m, o, n), f.rotate(m, m, d + Math.PI / 2), f.normalize(m, m), b.reportIntersection(a, v, m, -1), a.shouldStop(b))) return
                        }
                    }
                }, {
                    "../math/vec2": 30,
                    "../utils/Utils": 57,
                    "./Shape": 45
                }
            ],
            42: [
                function(a, b, c) {
                    function d(a) {
                        "number" == typeof arguments[0] && void(a = {
                            length: arguments[0]
                        }), a = a || {}, this.length = a.length || 1, a.type = e.LINE, e.call(this, a)
                    }
                    var e = a("./Shape"),
                        f = a("../math/vec2");
                    b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeMomentOfInertia = function(a) {
                        return a * Math.pow(this.length, 2) / 12
                    }, d.prototype.updateBoundingRadius = function() {
                        this.boundingRadius = this.length / 2
                    };
                    var g = [f.create(), f.create()];
                    d.prototype.computeAABB = function(a, b, c) {
                        var d = this.length / 2;
                        f.set(g[0], -d, 0), f.set(g[1], d, 0), a.setFromPoints(g, b, c, 0)
                    };
                    var h = (f.create(), f.create()),
                        i = f.create(),
                        j = f.create(),
                        k = f.fromValues(0, 1);
                    d.prototype.raycast = function(a, b, c, d) {
                        var e = b.from,
                            g = b.to,
                            l = i,
                            m = j,
                            n = this.length / 2;
                        f.set(l, -n, 0), f.set(m, n, 0), f.toGlobalFrame(l, l, c, d), f.toGlobalFrame(m, m, c, d);
                        var o = f.getLineSegmentsIntersectionFraction(l, m, e, g);
                        if (o >= 0) {
                            var p = h;
                            f.rotate(p, k, d), b.reportIntersection(a, o, p, -1)
                        }
                    }
                }, {
                    "../math/vec2": 30,
                    "./Shape": 45
                }
            ],
            43: [
                function(a, b, c) {
                    function d(a) {
                        a = a || {}, a.type = e.PARTICLE, e.call(this, a)
                    }
                    var e = a("./Shape"),
                        f = a("../math/vec2");
                    b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeMomentOfInertia = function(a) {
                        return 0
                    }, d.prototype.updateBoundingRadius = function() {
                        this.boundingRadius = 0
                    }, d.prototype.computeAABB = function(a, b, c) {
                        f.copy(a.lowerBound, b), f.copy(a.upperBound, b)
                    }
                }, {
                    "../math/vec2": 30,
                    "./Shape": 45
                }
            ],
            44: [
                function(a, b, c) {
                    function d(a) {
                        a = a || {}, a.type = e.PLANE, e.call(this, a)
                    }
                    var e = a("./Shape"),
                        f = a("../math/vec2");
                    a("../utils/Utils"), b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeMomentOfInertia = function(a) {
                        return 0
                    }, d.prototype.updateBoundingRadius = function() {
                        this.boundingRadius = Number.MAX_VALUE
                    }, d.prototype.computeAABB = function(a, b, c) {
                        var d = c % (2 * Math.PI),
                            e = f.set,
                            g = Number.MAX_VALUE,
                            h = a.lowerBound,
                            i = a.upperBound;
                        0 === d ? (e(h, -g, -g), e(i, g, 0)) : d === Math.PI / 2 ? (e(h, 0, -g), e(i, g, g)) : d === Math.PI ? (e(h, -g, 0), e(i, g, g)) : d === 3 * Math.PI / 2 ? (e(h, -g, -g), e(i, 0, g)) : (e(h, -g, -g), e(i, g, g)), f.add(h, h, b), f.add(i, i, b)
                    }, d.prototype.updateArea = function() {
                        this.area = Number.MAX_VALUE
                    };
                    var g = f.create(),
                        h = (f.create(), f.create(), f.create()),
                        i = f.create();
                    d.prototype.raycast = function(a, b, c, d) {
                        var e = b.from,
                            j = b.to,
                            k = b.direction,
                            l = g,
                            m = h,
                            n = i;
                        f.set(m, 0, 1), f.rotate(m, m, d), f.sub(n, e, c);
                        var o = f.dot(n, m);
                        f.sub(n, j, c);
                        var p = f.dot(n, m);
                        if (!(o * p > 0 || f.squaredDistance(e, j) < o * o)) {
                            var q = f.dot(m, k);
                            f.sub(l, e, c);
                            var r = -f.dot(m, l) / q / b.length;
                            b.reportIntersection(a, r, m, -1)
                        }
                    }
                }, {
                    "../math/vec2": 30,
                    "../utils/Utils": 57,
                    "./Shape": 45
                }
            ],
            45: [
                function(a, b, c) {
                    function d(a) {
                        a = a || {}, this.body = null, this.position = e.fromValues(0, 0), a.position && e.copy(this.position, a.position), this.angle = a.angle || 0, this.type = a.type || 0, this.id = d.idCounter++, this.boundingRadius = 0, this.collisionGroup = void 0 !== a.collisionGroup ? a.collisionGroup : 1, this.collisionResponse = void 0 === a.collisionResponse || a.collisionResponse, this.collisionMask = void 0 !== a.collisionMask ? a.collisionMask : 1, this.material = a.material || null, this.area = 0, this.sensor = void 0 !== a.sensor && a.sensor, this.type && this.updateBoundingRadius(), this.updateArea()
                    }
                    b.exports = d;
                    var e = a("../math/vec2");
                    d.idCounter = 0, d.CIRCLE = 1, d.PARTICLE = 2, d.PLANE = 4, d.CONVEX = 8, d.LINE = 16, d.BOX = 32, Object.defineProperty(d, "RECTANGLE", {
                        get: function() {
                            return d.BOX
                        }
                    }), d.CAPSULE = 64, d.HEIGHTFIELD = 128, d.prototype.computeMomentOfInertia = function(a) {}, d.prototype.updateBoundingRadius = function() {}, d.prototype.updateArea = function() {}, d.prototype.computeAABB = function(a, b, c) {}, d.prototype.raycast = function(a, b, c, d) {}
                }, {
                    "../math/vec2": 30
                }
            ],
            46: [
                function(a, b, c) {
                    function d(a) {
                        g.call(this, a, g.GS), a = a || {}, this.iterations = a.iterations || 10, this.tolerance = a.tolerance || 1e-7, this.arrayStep = 30, this.lambda = new h.ARRAY_TYPE(this.arrayStep), this.Bs = new h.ARRAY_TYPE(this.arrayStep), this.invCs = new h.ARRAY_TYPE(this.arrayStep), this.useZeroRHS = !1, this.frictionIterations = 0, this.usedIterations = 0
                    }

                    function e(a) {
                        for (var b = a.length; b--;) a[b] = 0
                    }
                    var f = a("../math/vec2"),
                        g = a("./Solver"),
                        h = a("../utils/Utils"),
                        i = a("../equations/FrictionEquation");
                    b.exports = d, d.prototype = new g, d.prototype.constructor = d, d.prototype.solve = function(a, b) {
                        this.sortEquations();
                        var c = 0,
                            g = this.iterations,
                            j = this.frictionIterations,
                            k = this.equations,
                            l = k.length,
                            m = Math.pow(this.tolerance * l, 2),
                            n = b.bodies,
                            o = b.bodies.length,
                            p = (f.add, f.set, this.useZeroRHS),
                            q = this.lambda;
                        if (this.usedIterations = 0, l)
                            for (var r = 0; r !== o; r++) {
                                var s = n[r];
                                s.updateSolveMassProperties()
                            }
                        q.length < l && (q = this.lambda = new h.ARRAY_TYPE(l + this.arrayStep), this.Bs = new h.ARRAY_TYPE(l + this.arrayStep),
                            this.invCs = new h.ARRAY_TYPE(l + this.arrayStep)), e(q);
                        for (var t = this.invCs, u = this.Bs, q = this.lambda, r = 0; r !== k.length; r++) {
                            var v = k[r];
                            (v.timeStep !== a || v.needsUpdate) && (v.timeStep = a, v.update()), u[r] = v.computeB(v.a, v.b, a), t[r] = v.computeInvC(v.epsilon)
                        }
                        var v, w, r, x;
                        if (0 !== l) {
                            for (r = 0; r !== o; r++) {
                                var s = n[r];
                                s.resetConstraintVelocity()
                            }
                            if (j) {
                                for (c = 0; c !== j; c++) {
                                    for (w = 0, x = 0; x !== l; x++) {
                                        v = k[x];
                                        var y = d.iterateEquation(x, v, v.epsilon, u, t, q, p, a, c);
                                        w += Math.abs(y)
                                    }
                                    if (this.usedIterations++, w * w <= m) break
                                }
                                for (d.updateMultipliers(k, q, 1 / a), x = 0; x !== l; x++) {
                                    var z = k[x];
                                    if (z instanceof i) {
                                        for (var A = 0, B = 0; B !== z.contactEquations.length; B++) A += z.contactEquations[B].multiplier;
                                        A *= z.frictionCoefficient / z.contactEquations.length, z.maxForce = A, z.minForce = -A
                                    }
                                }
                            }
                            for (c = 0; c !== g; c++) {
                                for (w = 0, x = 0; x !== l; x++) {
                                    v = k[x];
                                    var y = d.iterateEquation(x, v, v.epsilon, u, t, q, p, a, c);
                                    w += Math.abs(y)
                                }
                                if (this.usedIterations++, w * w <= m) break
                            }
                            for (r = 0; r !== o; r++) n[r].addConstraintVelocity();
                            d.updateMultipliers(k, q, 1 / a)
                        }
                    }, d.updateMultipliers = function(a, b, c) {
                        for (var d = a.length; d--;) a[d].multiplier = b[d] * c
                    }, d.iterateEquation = function(a, b, c, d, e, f, g, h, i) {
                        var j = d[a],
                            k = e[a],
                            l = f[a],
                            m = b.computeGWlambda(),
                            n = b.maxForce,
                            o = b.minForce;
                        g && (j = 0);
                        var p = k * (j - m - c * l),
                            q = l + p;
                        return q < o * h ? p = o * h - l : q > n * h && (p = n * h - l), f[a] += p, b.addToWlambda(p), p
                    }
                }, {
                    "../equations/FrictionEquation": 23,
                    "../math/vec2": 30,
                    "../utils/Utils": 57,
                    "./Solver": 47
                }
            ],
            47: [
                function(a, b, c) {
                    function d(a, b) {
                        a = a || {}, e.call(this), this.type = b, this.equations = [], this.equationSortFunction = a.equationSortFunction || !1
                    }
                    var e = (a("../utils/Utils"), a("../events/EventEmitter"));
                    b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.solve = function(a, b) {
                        throw new Error("Solver.solve should be implemented by subclasses!")
                    };
                    var f = {
                        bodies: []
                    };
                    d.prototype.solveIsland = function(a, b) {
                        this.removeAllEquations(), b.equations.length && (this.addEquations(b.equations), f.bodies.length = 0, b.getBodies(f.bodies), f.bodies.length && this.solve(a, f))
                    }, d.prototype.sortEquations = function() {
                        this.equationSortFunction && this.equations.sort(this.equationSortFunction)
                    }, d.prototype.addEquation = function(a) {
                        a.enabled && this.equations.push(a)
                    }, d.prototype.addEquations = function(a) {
                        for (var b = 0, c = a.length; b !== c; b++) {
                            var d = a[b];
                            d.enabled && this.equations.push(d)
                        }
                    }, d.prototype.removeEquation = function(a) {
                        var b = this.equations.indexOf(a);
                        b !== -1 && this.equations.splice(b, 1)
                    }, d.prototype.removeAllEquations = function() {
                        this.equations.length = 0
                    }, d.GS = 1, d.ISLAND = 2
                }, {
                    "../events/EventEmitter": 26,
                    "../utils/Utils": 57
                }
            ],
            48: [
                function(a, b, c) {
                    function d() {
                        f.apply(this, arguments)
                    }
                    var e = a("../equations/ContactEquation"),
                        f = a("./Pool");
                    b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.create = function() {
                        return new e
                    }, d.prototype.destroy = function(a) {
                        return a.bodyA = a.bodyB = null, this
                    }
                }, {
                    "../equations/ContactEquation": 21,
                    "./Pool": 55
                }
            ],
            49: [
                function(a, b, c) {
                    function d() {
                        f.apply(this, arguments)
                    }
                    var e = a("../equations/FrictionEquation"),
                        f = a("./Pool");
                    b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.create = function() {
                        return new e
                    }, d.prototype.destroy = function(a) {
                        return a.bodyA = a.bodyB = null, this
                    }
                }, {
                    "../equations/FrictionEquation": 23,
                    "./Pool": 55
                }
            ],
            50: [
                function(a, b, c) {
                    function d() {
                        f.apply(this, arguments)
                    }
                    var e = a("../world/IslandNode"),
                        f = a("./Pool");
                    b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.create = function() {
                        return new e
                    }, d.prototype.destroy = function(a) {
                        return a.reset(), this
                    }
                }, {
                    "../world/IslandNode": 60,
                    "./Pool": 55
                }
            ],
            51: [
                function(a, b, c) {
                    function d() {
                        f.apply(this, arguments)
                    }
                    var e = a("../world/Island"),
                        f = a("./Pool");
                    b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.create = function() {
                        return new e
                    }, d.prototype.destroy = function(a) {
                        return a.reset(), this
                    }
                }, {
                    "../world/Island": 58,
                    "./Pool": 55
                }
            ],
            52: [
                function(a, b, c) {
                    function d() {
                        this.overlappingShapesLastState = new e, this.overlappingShapesCurrentState = new e, this.recordPool = new f({
                            size: 16
                        }), this.tmpDict = new e, this.tmpArray1 = []
                    }
                    var e = a("./TupleDictionary"),
                        f = (a("./OverlapKeeperRecord"), a("./OverlapKeeperRecordPool"));
                    a("./Utils"), b.exports = d, d.prototype.tick = function() {
                        for (var a = this.overlappingShapesLastState, b = this.overlappingShapesCurrentState, c = a.keys.length; c--;) {
                            var d = a.keys[c],
                                e = a.getByKey(d);
                            b.getByKey(d), e && this.recordPool.release(e)
                        }
                        a.reset(), a.copy(b), b.reset()
                    }, d.prototype.setOverlapping = function(a, b, c, d) {
                        var e = (this.overlappingShapesLastState, this.overlappingShapesCurrentState);
                        if (!e.get(b.id, d.id)) {
                            var f = this.recordPool.get();
                            f.set(a, b, c, d), e.set(b.id, d.id, f)
                        }
                    }, d.prototype.getNewOverlaps = function(a) {
                        return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, a)
                    }, d.prototype.getEndOverlaps = function(a) {
                        return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, a)
                    }, d.prototype.bodiesAreOverlapping = function(a, b) {
                        for (var c = this.overlappingShapesCurrentState, d = c.keys.length; d--;) {
                            var e = c.keys[d],
                                f = c.data[e];
                            if (f.bodyA === a && f.bodyB === b || f.bodyA === b && f.bodyB === a) return !0
                        }
                        return !1
                    }, d.prototype.getDiff = function(a, b, c) {
                        var c = c || [],
                            d = a,
                            e = b;
                        c.length = 0;
                        for (var f = e.keys.length; f--;) {
                            var g = e.keys[f],
                                h = e.data[g];
                            if (!h) throw new Error("Key " + g + " had no data!");
                            var i = d.data[g];
                            i || c.push(h)
                        }
                        return c
                    }, d.prototype.isNewOverlap = function(a, b) {
                        var c = 0 | a.id,
                            d = 0 | b.id,
                            e = this.overlappingShapesLastState,
                            f = this.overlappingShapesCurrentState;
                        return !e.get(c, d) && !!f.get(c, d)
                    }, d.prototype.getNewBodyOverlaps = function(a) {
                        this.tmpArray1.length = 0;
                        var b = this.getNewOverlaps(this.tmpArray1);
                        return this.getBodyDiff(b, a)
                    }, d.prototype.getEndBodyOverlaps = function(a) {
                        this.tmpArray1.length = 0;
                        var b = this.getEndOverlaps(this.tmpArray1);
                        return this.getBodyDiff(b, a)
                    }, d.prototype.getBodyDiff = function(a, b) {
                        b = b || [];
                        for (var c = this.tmpDict, d = a.length; d--;) {
                            var e = a[d];
                            c.set(0 | e.bodyA.id, 0 | e.bodyB.id, e)
                        }
                        for (d = c.keys.length; d--;) {
                            var e = c.getByKey(c.keys[d]);
                            e && b.push(e.bodyA, e.bodyB)
                        }
                        return c.reset(), b
                    }
                }, {
                    "./OverlapKeeperRecord": 53,
                    "./OverlapKeeperRecordPool": 54,
                    "./TupleDictionary": 56,
                    "./Utils": 57
                }
            ],
            53: [
                function(a, b, c) {
                    function d(a, b, c, d) {
                        this.shapeA = b, this.shapeB = d, this.bodyA = a, this.bodyB = c
                    }
                    b.exports = d, d.prototype.set = function(a, b, c, e) {
                        d.call(this, a, b, c, e)
                    }
                }, {}
            ],
            54: [
                function(a, b, c) {
                    function d() {
                        f.apply(this, arguments)
                    }
                    var e = a("./OverlapKeeperRecord"),
                        f = a("./Pool");
                    b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.create = function() {
                        return new e
                    }, d.prototype.destroy = function(a) {
                        return a.bodyA = a.bodyB = a.shapeA = a.shapeB = null, this
                    }
                }, {
                    "./OverlapKeeperRecord": 53,
                    "./Pool": 55
                }
            ],
            55: [
                function(a, b, c) {
                    function d(a) {
                        a = a || {}, this.objects = [], void 0 !== a.size && this.resize(a.size)
                    }
                    b.exports = d, d.prototype.resize = function(a) {
                        for (var b = this.objects; b.length > a;) b.pop();
                        for (; b.length < a;) b.push(this.create());
                        return this
                    }, d.prototype.get = function() {
                        var a = this.objects;
                        return a.length ? a.pop() : this.create()
                    }, d.prototype.release = function(a) {
                        return this.destroy(a), this.objects.push(a), this
                    }
                }, {}
            ],
            56: [
                function(a, b, c) {
                    function d() {
                        this.data = {}, this.keys = []
                    }
                    var e = a("./Utils");
                    b.exports = d, d.prototype.getKey = function(a, b) {
                        return a = 0 | a, b = 0 | b, (0 | a) === (0 | b) ? -1 : 0 | ((0 | a) > (0 | b) ? a << 16 | 65535 & b : b << 16 | 65535 & a)
                    }, d.prototype.getByKey = function(a) {
                        return a = 0 | a, this.data[a]
                    }, d.prototype.get = function(a, b) {
                        return this.data[this.getKey(a, b)]
                    }, d.prototype.set = function(a, b, c) {
                        if (!c) throw new Error("No data!");
                        var d = this.getKey(a, b);
                        return this.data[d] || this.keys.push(d), this.data[d] = c, d
                    }, d.prototype.reset = function() {
                        for (var a = this.data, b = this.keys, c = b.length; c--;) delete a[b[c]];
                        b.length = 0
                    }, d.prototype.copy = function(a) {
                        this.reset(), e.appendArray(this.keys, a.keys);
                        for (var b = a.keys.length; b--;) {
                            var c = a.keys[b];
                            this.data[c] = a.data[c]
                        }
                    }
                }, {
                    "./Utils": 57
                }
            ],
            57: [
                function(a, b, c) {
                    function d() {}
                    b.exports = d, d.appendArray = function(a, b) {
                        if (b.length < 15e4) a.push.apply(a, b);
                        else
                            for (var c = 0, d = b.length; c !== d; ++c) a.push(b[c])
                    }, d.splice = function(a, b, c) {
                        c = c || 1;
                        for (var d = b, e = a.length - c; d < e; d++) a[d] = a[d + c];
                        a.length = e
                    }, "undefined" != typeof P2_ARRAY_TYPE ? d.ARRAY_TYPE = P2_ARRAY_TYPE : "undefined" != typeof Float32Array ? d.ARRAY_TYPE = Float32Array : d.ARRAY_TYPE = Array, d.extend = function(a, b) {
                        for (var c in b) a[c] = b[c]
                    }, d.defaults = function(a, b) {
                        a = a || {};
                        for (var c in b) c in a || (a[c] = b[c]);
                        return a
                    }
                }, {}
            ],
            58: [
                function(a, b, c) {
                    function d() {
                        this.equations = [], this.bodies = []
                    }
                    var e = a("../objects/Body");
                    b.exports = d, d.prototype.reset = function() {
                        this.equations.length = this.bodies.length = 0
                    };
                    var f = [];
                    d.prototype.getBodies = function(a) {
                        var b = a || [],
                            c = this.equations;
                        f.length = 0;
                        for (var d = 0; d !== c.length; d++) {
                            var e = c[d];
                            f.indexOf(e.bodyA.id) === -1 && (b.push(e.bodyA), f.push(e.bodyA.id)), f.indexOf(e.bodyB.id) === -1 && (b.push(e.bodyB), f.push(e.bodyB.id))
                        }
                        return b
                    }, d.prototype.wantsToSleep = function() {
                        for (var a = 0; a < this.bodies.length; a++) {
                            var b = this.bodies[a];
                            if (b.type === e.DYNAMIC && !b.wantsToSleep) return !1
                        }
                        return !0
                    }, d.prototype.sleep = function() {
                        for (var a = 0; a < this.bodies.length; a++) {
                            var b = this.bodies[a];
                            b.sleep()
                        }
                        return !0
                    }
                }, {
                    "../objects/Body": 31
                }
            ],
            59: [
                function(a, b, c) {
                    function d(a) {
                        this.nodePool = new e({
                            size: 16
                        }), this.islandPool = new f({
                            size: 8
                        }), this.equations = [], this.islands = [], this.nodes = [], this.queue = []
                    }
                    var e = (a("../math/vec2"), a("./Island"), a("./IslandNode"), a("./../utils/IslandNodePool")),
                        f = a("./../utils/IslandPool"),
                        g = a("../objects/Body");
                    b.exports = d, d.getUnvisitedNode = function(a) {
                        for (var b = a.length, c = 0; c !== b; c++) {
                            var d = a[c];
                            if (!d.visited && d.body.type === g.DYNAMIC) return d
                        }
                        return !1
                    }, d.prototype.visit = function(a, b, c) {
                        b.push(a.body);
                        for (var d = a.equations.length, e = 0; e !== d; e++) {
                            var f = a.equations[e];
                            c.indexOf(f) === -1 && c.push(f)
                        }
                    }, d.prototype.bfs = function(a, b, c) {
                        var e = this.queue;
                        for (e.length = 0, e.push(a), a.visited = !0, this.visit(a, b, c); e.length;)
                            for (var f, h = e.pop(); f = d.getUnvisitedNode(h.neighbors);) f.visited = !0, this.visit(f, b, c), f.body.type === g.DYNAMIC && e.push(f)
                    }, d.prototype.split = function(a) {
                        for (var b = a.bodies, c = this.nodes, e = this.equations; c.length;) this.nodePool.release(c.pop());
                        for (var f = 0; f !== b.length; f++) {
                            var g = this.nodePool.get();
                            g.body = b[f], c.push(g)
                        }
                        for (var h = 0; h !== e.length; h++) {
                            var i = e[h],
                                f = b.indexOf(i.bodyA),
                                j = b.indexOf(i.bodyB),
                                k = c[f],
                                l = c[j];
                            k.neighbors.push(l), l.neighbors.push(k), k.equations.push(i), l.equations.push(i)
                        }
                        for (var m = this.islands, f = 0; f < m.length; f++) this.islandPool.release(m[f]);
                        m.length = 0;
                        for (var n; n = d.getUnvisitedNode(c);) {
                            var o = this.islandPool.get();
                            this.bfs(n, o.bodies, o.equations), m.push(o)
                        }
                        return m
                    }
                }, {
                    "../math/vec2": 30,
                    "../objects/Body": 31,
                    "./../utils/IslandNodePool": 50,
                    "./../utils/IslandPool": 51,
                    "./Island": 58,
                    "./IslandNode": 60
                }
            ],
            60: [
                function(a, b, c) {
                    function d(a) {
                        this.body = a, this.neighbors = [], this.equations = [], this.visited = !1
                    }
                    b.exports = d, d.prototype.reset = function() {
                        this.equations.length = 0, this.neighbors.length = 0, this.visited = !1, this.body = null
                    }
                }, {}
            ],
            61: [
                function(a, b, c) {
                    function d(a) {
                        l.apply(this), a = a || {}, this.springs = [], this.bodies = [], this.disabledBodyCollisionPairs = [], this.solver = a.solver || new e, this.narrowphase = new r(this), this.islandManager = new u, this.gravity = f.fromValues(0, -9.78), a.gravity && f.copy(this.gravity, a.gravity), this.frictionGravity = f.length(this.gravity) || 10, this.useWorldGravityAsFrictionGravity = !0, this.useFrictionGravityOnZeroGravity = !0, this.broadphase = a.broadphase || new q, this.broadphase.setWorld(this), this.constraints = [], this.defaultMaterial = new n, this.defaultContactMaterial = new o(this.defaultMaterial, this.defaultMaterial), this.lastTimeStep = 1 / 60, this.applySpringForces = !0, this.applyDamping = !0, this.applyGravity = !0, this.solveConstraints = !0, this.contactMaterials = [], this.time = 0, this.accumulator = 0, this.stepping = !1, this.bodiesToBeRemoved = [], this.islandSplit = "undefined" == typeof a.islandSplit || !!a.islandSplit, this.emitImpactEvent = !0, this._constraintIdCounter = 0, this._bodyIdCounter = 0, this.postStepEvent = {
                            type: "postStep"
                        }, this.addBodyEvent = {
                            type: "addBody",
                            body: null
                        }, this.removeBodyEvent = {
                            type: "removeBody",
                            body: null
                        }, this.addSpringEvent = {
                            type: "addSpring",
                            spring: null
                        }, this.impactEvent = {
                            type: "impact",
                            bodyA: null,
                            bodyB: null,
                            shapeA: null,
                            shapeB: null,
                            contactEquation: null
                        }, this.postBroadphaseEvent = {
                            type: "postBroadphase",
                            pairs: null
                        }, this.sleepMode = d.NO_SLEEPING, this.beginContactEvent = {
                            type: "beginContact",
                            shapeA: null,
                            shapeB: null,
                            bodyA: null,
                            bodyB: null,
                            contactEquations: []
                        }, this.endContactEvent = {
                            type: "endContact",
                            shapeA: null,
                            shapeB: null,
                            bodyA: null,
                            bodyB: null
                        }, this.preSolveEvent = {
                            type: "preSolve",
                            contactEquations: null,
                            frictionEquations: null
                        }, this.overlappingShapesLastState = {
                            keys: []
                        }, this.overlappingShapesCurrentState = {
                            keys: []
                        }, this.overlapKeeper = new t
                    }
                    var e = a("../solver/GSSolver"),
                        f = (a("../solver/Solver"), a("../collision/Ray"), a("../math/vec2")),
                        g = a("../shapes/Circle"),
                        h = a("../shapes/Convex"),
                        i = (a("../shapes/Line"), a("../shapes/Plane")),
                        j = a("../shapes/Capsule"),
                        k = a("../shapes/Particle"),
                        l = a("../events/EventEmitter"),
                        m = a("../objects/Body"),
                        n = (a("../shapes/Shape"), a("../objects/LinearSpring"), a("../material/Material")),
                        o = a("../material/ContactMaterial"),
                        p = (a("../constraints/DistanceConstraint"), a("../constraints/Constraint"), a("../constraints/LockConstraint"), a("../constraints/RevoluteConstraint"), a("../constraints/PrismaticConstraint"), a("../constraints/GearConstraint"), a("../../package.json"), a("../collision/Broadphase"), a("../collision/AABB")),
                        q = a("../collision/SAPBroadphase"),
                        r = a("../collision/Narrowphase"),
                        s = a("../utils/Utils"),
                        t = a("../utils/OverlapKeeper"),
                        u = a("./IslandManager");
                    a("../objects/RotationalSpring"), b.exports = d, d.prototype = new Object(l.prototype), d.prototype.constructor = d, d.NO_SLEEPING = 1, d.BODY_SLEEPING = 2, d.ISLAND_SLEEPING = 4, d.prototype.addConstraint = function(a) {
                        this.constraints.push(a)
                    }, d.prototype.addContactMaterial = function(a) {
                        this.contactMaterials.push(a)
                    }, d.prototype.removeContactMaterial = function(a) {
                        var b = this.contactMaterials.indexOf(a);
                        b !== -1 && s.splice(this.contactMaterials, b, 1)
                    }, d.prototype.getContactMaterial = function(a, b) {
                        for (var c = this.contactMaterials, d = 0, e = c.length; d !== e; d++) {
                            var f = c[d];
                            if (f.materialA.id === a.id && f.materialB.id === b.id || f.materialA.id === b.id && f.materialB.id === a.id) return f
                        }
                        return !1
                    }, d.prototype.removeConstraint = function(a) {
                        var b = this.constraints.indexOf(a);
                        b !== -1 && s.splice(this.constraints, b, 1)
                    };
                    var v = (f.create(), f.create(), f.create(), f.create(), f.create(), f.create(), f.create()),
                        w = f.fromValues(0, 0),
                        x = f.fromValues(0, 0);
                    f.fromValues(0, 0), f.fromValues(0, 0), d.prototype.step = function(a, b, c) {
                        if (c = c || 10, b = b || 0, 0 === b) this.internalStep(a), this.time += a;
                        else {
                            this.accumulator += b;
                            for (var d = 0; this.accumulator >= a && d < c;) this.internalStep(a), this.time += a, this.accumulator -= a, d++;
                            for (var e = this.accumulator % a / a, g = 0; g !== this.bodies.length; g++) {
                                var h = this.bodies[g];
                                f.lerp(h.interpolatedPosition, h.previousPosition, h.position, e), h.interpolatedAngle = h.previousAngle + e * (h.angle - h.previousAngle)
                            }
                        }
                    };
                    var y = [];
                    d.prototype.internalStep = function(a) {
                        this.stepping = !0;
                        var b = this.springs.length,
                            c = this.springs,
                            e = this.bodies,
                            g = this.gravity,
                            h = this.solver,
                            i = this.bodies.length,
                            j = this.broadphase,
                            k = this.narrowphase,
                            l = this.constraints,
                            n = v,
                            o = (f.scale, f.add),
                            p = (f.rotate, this.islandManager);
                        if (this.overlapKeeper.tick(), this.lastTimeStep = a, this.useWorldGravityAsFrictionGravity) {
                            var q = f.length(this.gravity);
                            0 === q && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = q)
                        }
                        if (this.applyGravity)
                            for (var r = 0; r !== i; r++) {
                                var t = e[r],
                                    u = t.force;
                                t.type === m.DYNAMIC && t.sleepState !== m.SLEEPING && (f.scale(n, g, t.mass * t.gravityScale), o(u, u, n))
                            }
                        if (this.applySpringForces)
                            for (var r = 0; r !== b; r++) {
                                var w = c[r];
                                w.applyForce()
                            }
                        if (this.applyDamping)
                            for (var r = 0; r !== i; r++) {
                                var t = e[r];
                                t.type === m.DYNAMIC && t.applyDamping(a)
                            }
                        for (var x = j.getCollisionPairs(this), z = this.disabledBodyCollisionPairs, r = z.length - 2; r >= 0; r -= 2)
                            for (var A = x.length - 2; A >= 0; A -= 2)(z[r] === x[A] && z[r + 1] === x[A + 1] || z[r + 1] === x[A] && z[r] === x[A + 1]) && x.splice(A, 2);
                        var B = l.length;
                        for (r = 0; r !== B; r++) {
                            var C = l[r];
                            if (!C.collideConnected)
                                for (var A = x.length - 2; A >= 0; A -= 2)(C.bodyA === x[A] && C.bodyB === x[A + 1] || C.bodyB === x[A] && C.bodyA === x[A + 1]) && x.splice(A, 2)
                        }
                        this.postBroadphaseEvent.pairs = x, this.emit(this.postBroadphaseEvent), this.postBroadphaseEvent.pairs = null, k.reset(this);
                        for (var r = 0, D = x.length; r !== D; r += 2)
                            for (var E = x[r], F = x[r + 1], G = 0, H = E.shapes.length; G !== H; G++)
                                for (var I = E.shapes[G], J = I.position, K = I.angle, L = 0, M = F.shapes.length; L !== M; L++) {
                                    var N = F.shapes[L],
                                        O = N.position,
                                        P = N.angle,
                                        Q = this.defaultContactMaterial;
                                    if (I.material && N.material) {
                                        var R = this.getContactMaterial(I.material, N.material);
                                        R && (Q = R)
                                    }
                                    this.runNarrowphase(k, E, I, J, K, F, N, O, P, Q, this.frictionGravity)
                                }
                        for (var r = 0; r !== i; r++) {
                            var S = e[r];
                            S._wakeUpAfterNarrowphase && (S.wakeUp(), S._wakeUpAfterNarrowphase = !1)
                        }
                        if (this.has("endContact")) {
                            this.overlapKeeper.getEndOverlaps(y);
                            for (var T = this.endContactEvent, L = y.length; L--;) {
                                var U = y[L];
                                T.shapeA = U.shapeA, T.shapeB = U.shapeB, T.bodyA = U.bodyA, T.bodyB = U.bodyB, this.emit(T)
                            }
                            y.length = 0
                        }
                        var V = this.preSolveEvent;
                        V.contactEquations = k.contactEquations, V.frictionEquations = k.frictionEquations, this.emit(V), V.contactEquations = V.frictionEquations = null;
                        var B = l.length;
                        for (r = 0; r !== B; r++) l[r].update();
                        if (k.contactEquations.length || k.frictionEquations.length || B)
                            if (this.islandSplit) {
                                for (p.equations.length = 0, s.appendArray(p.equations, k.contactEquations), s.appendArray(p.equations, k.frictionEquations), r = 0; r !== B; r++) s.appendArray(p.equations, l[r].equations);
                                p.split(this);
                                for (var r = 0; r !== p.islands.length; r++) {
                                    var W = p.islands[r];
                                    W.equations.length && h.solveIsland(a, W)
                                }
                            } else {
                                for (h.addEquations(k.contactEquations), h.addEquations(k.frictionEquations), r = 0; r !== B; r++) h.addEquations(l[r].equations);
                                this.solveConstraints && h.solve(a, this), h.removeAllEquations()
                            }
                        for (var r = 0; r !== i; r++) {
                            var S = e[r];
                            S.integrate(a)
                        }
                        for (var r = 0; r !== i; r++) e[r].setZeroForce();
                        if (this.emitImpactEvent && this.has("impact"))
                            for (var X = this.impactEvent, r = 0; r !== k.contactEquations.length; r++) {
                                var Y = k.contactEquations[r];
                                Y.firstImpact && (X.bodyA = Y.bodyA, X.bodyB = Y.bodyB, X.shapeA = Y.shapeA, X.shapeB = Y.shapeB, X.contactEquation = Y, this.emit(X))
                            }
                        if (this.sleepMode === d.BODY_SLEEPING)
                            for (r = 0; r !== i; r++) e[r].sleepTick(this.time, !1, a);
                        else if (this.sleepMode === d.ISLAND_SLEEPING && this.islandSplit) {
                            for (r = 0; r !== i; r++) e[r].sleepTick(this.time, !0, a);
                            for (var r = 0; r < this.islandManager.islands.length; r++) {
                                var W = this.islandManager.islands[r];
                                W.wantsToSleep() && W.sleep()
                            }
                        }
                        this.stepping = !1;
                        for (var Z = this.bodiesToBeRemoved, r = 0; r !== Z.length; r++) this.removeBody(Z[r]);
                        Z.length = 0, this.emit(this.postStepEvent)
                    }, d.prototype.runNarrowphase = function(a, b, c, d, e, g, h, i, j, k, l) {
                        if (0 !== (c.collisionGroup & h.collisionMask) && 0 !== (h.collisionGroup & c.collisionMask)) {
                            f.rotate(w, d, b.angle), f.rotate(x, i, g.angle), f.add(w, w, b.position), f.add(x, x, g.position);
                            var n = e + b.angle,
                                o = j + g.angle;
                            a.enableFriction = k.friction > 0, a.frictionCoefficient = k.friction;
                            var p;
                            p = b.type === m.STATIC || b.type === m.KINEMATIC ? g.mass : g.type === m.STATIC || g.type === m.KINEMATIC ? b.mass : b.mass * g.mass / (b.mass + g.mass), a.slipForce = k.friction * l * p, a.restitution = k.restitution, a.surfaceVelocity = k.surfaceVelocity, a.frictionStiffness = k.frictionStiffness, a.frictionRelaxation = k.frictionRelaxation, a.stiffness = k.stiffness, a.relaxation = k.relaxation, a.contactSkinSize = k.contactSkinSize, a.enabledEquations = b.collisionResponse && g.collisionResponse && c.collisionResponse && h.collisionResponse;
                            var q = a[c.type | h.type],
                                r = 0;
                            if (q) {
                                var s = c.sensor || h.sensor,
                                    t = a.frictionEquations.length;
                                r = c.type < h.type ? q.call(a, b, c, w, n, g, h, x, o, s) : q.call(a, g, h, x, o, b, c, w, n, s);
                                var u = a.frictionEquations.length - t;
                                if (r) {
                                    if (b.allowSleep && b.type === m.DYNAMIC && b.sleepState === m.SLEEPING && g.sleepState === m.AWAKE && g.type !== m.STATIC) {
                                        var v = f.squaredLength(g.velocity) + Math.pow(g.angularVelocity, 2),
                                            y = Math.pow(g.sleepSpeedLimit, 2);
                                        v >= 2 * y && (b._wakeUpAfterNarrowphase = !0)
                                    }
                                    if (g.allowSleep && g.type === m.DYNAMIC && g.sleepState === m.SLEEPING && b.sleepState === m.AWAKE && b.type !== m.STATIC) {
                                        var z = f.squaredLength(b.velocity) + Math.pow(b.angularVelocity, 2),
                                            A = Math.pow(b.sleepSpeedLimit, 2);
                                        z >= 2 * A && (g._wakeUpAfterNarrowphase = !0)
                                    }
                                    if (this.overlapKeeper.setOverlapping(b, c, g, h), this.has("beginContact") && this.overlapKeeper.isNewOverlap(c, h)) {
                                        var B = this.beginContactEvent;
                                        if (B.shapeA = c, B.shapeB = h, B.bodyA = b, B.bodyB = g, B.contactEquations.length = 0, "number" == typeof r)
                                            for (var C = a.contactEquations.length - r; C < a.contactEquations.length; C++) B.contactEquations.push(a.contactEquations[C]);
                                        this.emit(B)
                                    }
                                    if ("number" == typeof r && u > 1)
                                        for (var C = a.frictionEquations.length - u; C < a.frictionEquations.length; C++) {
                                            var D = a.frictionEquations[C];
                                            D.setSlipForce(D.getSlipForce() / u)
                                        }
                                }
                            }
                        }
                    }, d.prototype.addSpring = function(a) {
                        this.springs.push(a);
                        var b = this.addSpringEvent;
                        b.spring = a, this.emit(b), b.spring = null
                    }, d.prototype.removeSpring = function(a) {
                        var b = this.springs.indexOf(a);
                        b !== -1 && s.splice(this.springs, b, 1)
                    }, d.prototype.addBody = function(a) {
                        if (this.bodies.indexOf(a) === -1) {
                            this.bodies.push(a), a.world = this;
                            var b = this.addBodyEvent;
                            b.body = a, this.emit(b), b.body = null
                        }
                    }, d.prototype.removeBody = function(a) {
                        if (this.stepping) this.bodiesToBeRemoved.push(a);
                        else {
                            a.world = null;
                            var b = this.bodies.indexOf(a);
                            b !== -1 && (s.splice(this.bodies, b, 1), this.removeBodyEvent.body = a, a.resetConstraintVelocity(), this.emit(this.removeBodyEvent), this.removeBodyEvent.body = null)
                        }
                    }, d.prototype.getBodyById = function(a) {
                        for (var b = this.bodies, c = 0; c < b.length; c++) {
                            var d = b[c];
                            if (d.id === a) return d
                        }
                        return !1
                    }, d.prototype.disableBodyCollision = function(a, b) {
                        this.disabledBodyCollisionPairs.push(a, b)
                    }, d.prototype.enableBodyCollision = function(a, b) {
                        for (var c = this.disabledBodyCollisionPairs, d = 0; d < c.length; d += 2)
                            if (c[d] === a && c[d + 1] === b || c[d + 1] === a && c[d] === b) return void c.splice(d, 2)
                    }, d.prototype.clear = function() {
                        this.time = 0, this.solver && this.solver.equations.length && this.solver.removeAllEquations();
                        for (var a = this.constraints, b = a.length - 1; b >= 0; b--) this.removeConstraint(a[b]);
                        for (var c = this.bodies, b = c.length - 1; b >= 0; b--) this.removeBody(c[b]);
                        for (var e = this.springs, b = e.length - 1; b >= 0; b--) this.removeSpring(e[b]);
                        for (var f = this.contactMaterials, b = f.length - 1; b >= 0; b--) this.removeContactMaterial(f[b]);
                        d.apply(this)
                    };
                    var z = f.create(),
                        A = (f.fromValues(0, 0), f.fromValues(0, 0));
                    d.prototype.hitTest = function(a, b, c) {
                        c = c || 0;
                        var d = new m({
                                position: a
                            }),
                            e = new k,
                            l = a,
                            n = 0,
                            o = z,
                            p = A;
                        d.addShape(e);
                        for (var q = this.narrowphase, r = [], s = 0, t = b.length; s !== t; s++)
                            for (var u = b[s], v = 0, w = u.shapes.length; v !== w; v++) {
                                var x = u.shapes[v];
                                f.rotate(o, x.position, u.angle), f.add(o, o, u.position);
                                var y = x.angle + u.angle;
                                (x instanceof g && q.circleParticle(u, x, o, y, d, e, l, n, !0) || x instanceof h && q.particleConvex(d, e, l, n, u, x, o, y, !0) || x instanceof i && q.particlePlane(d, e, l, n, u, x, o, y, !0) || x instanceof j && q.particleCapsule(d, e, l, n, u, x, o, y, !0) || x instanceof k && f.squaredLength(f.sub(p, o, a)) < c * c) && r.push(u)
                            }
                        return r
                    }, d.prototype.setGlobalStiffness = function(a) {
                        for (var b = this.constraints, c = 0; c !== b.length; c++)
                            for (var d = b[c], e = 0; e !== d.equations.length; e++) {
                                var f = d.equations[e];
                                f.stiffness = a, f.needsUpdate = !0
                            }
                        for (var g = this.contactMaterials, c = 0; c !== g.length; c++) {
                            var d = g[c];
                            d.stiffness = d.frictionStiffness = a
                        }
                        var d = this.defaultContactMaterial;
                        d.stiffness = d.frictionStiffness = a
                    }, d.prototype.setGlobalRelaxation = function(a) {
                        for (var b = 0; b !== this.constraints.length; b++)
                            for (var c = this.constraints[b], d = 0; d !== c.equations.length; d++) {
                                var e = c.equations[d];
                                e.relaxation = a, e.needsUpdate = !0
                            }
                        for (var b = 0; b !== this.contactMaterials.length; b++) {
                            var c = this.contactMaterials[b];
                            c.relaxation = c.frictionRelaxation = a
                        }
                        var c = this.defaultContactMaterial;
                        c.relaxation = c.frictionRelaxation = a
                    };
                    var B = new p,
                        C = [];
                    d.prototype.raycast = function(a, b) {
                        return b.getAABB(B), this.broadphase.aabbQuery(this, B, C), b.intersectBodies(a, C), C.length = 0, a.hasHit()
                    }
                }, {
                    "../../package.json": 6,
                    "../collision/AABB": 7,
                    "../collision/Broadphase": 8,
                    "../collision/Narrowphase": 10,
                    "../collision/Ray": 11,
                    "../collision/SAPBroadphase": 13,
                    "../constraints/Constraint": 14,
                    "../constraints/DistanceConstraint": 15,
                    "../constraints/GearConstraint": 16,
                    "../constraints/LockConstraint": 17,
                    "../constraints/PrismaticConstraint": 18,
                    "../constraints/RevoluteConstraint": 19,
                    "../events/EventEmitter": 26,
                    "../material/ContactMaterial": 27,
                    "../material/Material": 28,
                    "../math/vec2": 30,
                    "../objects/Body": 31,
                    "../objects/LinearSpring": 32,
                    "../objects/RotationalSpring": 33,
                    "../shapes/Capsule": 38,
                    "../shapes/Circle": 39,
                    "../shapes/Convex": 40,
                    "../shapes/Line": 42,
                    "../shapes/Particle": 43,
                    "../shapes/Plane": 44,
                    "../shapes/Shape": 45,
                    "../solver/GSSolver": 46,
                    "../solver/Solver": 47,
                    "../utils/OverlapKeeper": 52,
                    "../utils/Utils": 57,
                    "./IslandManager": 59
                }
            ]
        }, {}, [36])(36)
    }),
    function() {
        var a = this,
            b = b || {};
        return b.game = null, b.WEBGL_RENDERER = 0, b.CANVAS_RENDERER = 1, b.VERSION = "v2.2.9", b._UID = 0, "undefined" != typeof Float32Array ? (b.Float32Array = Float32Array, b.Uint16Array = Uint16Array, b.Uint32Array = Uint32Array, b.ArrayBuffer = ArrayBuffer) : (b.Float32Array = Array, b.Uint16Array = Array), b.PI_2 = 2 * Math.PI, b.RAD_TO_DEG = 180 / Math.PI, b.DEG_TO_RAD = Math.PI / 180, b.RETINA_PREFIX = "@2x", b.DisplayObject = function() {
            this.position = new b.Point(0, 0), this.scale = new b.Point(1, 1), this.pivot = new b.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new b.Matrix, this.worldPosition = new b.Point(0, 0), this.worldScale = new b.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new b.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1
        }, b.DisplayObject.prototype.constructor = b.DisplayObject, b.DisplayObject.prototype = {
            destroy: function() {
                if (this.children) {
                    for (var a = this.children.length; a--;) this.children[a].destroy();
                    this.children = []
                }
                this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite()
            },
            updateTransform: function(a) {
                if (!a && !this.parent && !this.game) return this;
                var c = this.parent;
                a ? c = a : this.parent || (c = this.game.world);
                var d, e, f, g, h, i, j = c.worldTransform,
                    k = this.worldTransform;
                return this.rotation % b.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), d = this._cr * this.scale.x, e = this._sr * this.scale.x, f = -this._sr * this.scale.y, g = this._cr * this.scale.y, h = this.position.x, i = this.position.y, (this.pivot.x || this.pivot.y) && (h -= this.pivot.x * d + this.pivot.y * f, i -= this.pivot.x * e + this.pivot.y * g), k.a = d * j.a + e * j.c, k.b = d * j.b + e * j.d, k.c = f * j.a + g * j.c, k.d = f * j.b + g * j.d, k.tx = h * j.a + i * j.c + j.tx, k.ty = h * j.b + i * j.d + j.ty) : (d = this.scale.x, g = this.scale.y, h = this.position.x - this.pivot.x * d, i = this.position.y - this.pivot.y * g, k.a = d * j.a, k.b = d * j.b, k.c = g * j.c, k.d = g * j.d, k.tx = h * j.a + i * j.c + j.tx, k.ty = h * j.b + i * j.d + j.ty), this.worldAlpha = this.alpha * c.worldAlpha, this.worldPosition.set(k.tx, k.ty), this.worldScale.set(this.scale.x * Math.sqrt(k.a * k.a + k.c * k.c), this.scale.y * Math.sqrt(k.b * k.b + k.d * k.d)), this.worldRotation = Math.atan2(-k.c, k.d), this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, k, j), this
            },
            preUpdate: function() {},
            generateTexture: function(a, c, d) {
                var e = this.getLocalBounds(),
                    f = new b.RenderTexture(0 | e.width, 0 | e.height, d, c, a);
                return b.DisplayObject._tempMatrix.tx = -e.x, b.DisplayObject._tempMatrix.ty = -e.y, f.render(this, b.DisplayObject._tempMatrix), f
            },
            updateCache: function() {
                return this._generateCachedSprite(), this
            },
            toGlobal: function(a) {
                return this.updateTransform(), this.worldTransform.apply(a)
            },
            toLocal: function(a, b) {
                return b && (a = b.toGlobal(a)), this.updateTransform(), this.worldTransform.applyInverse(a)
            },
            _renderCachedSprite: function(a) {
                this._cachedSprite.worldAlpha = this.worldAlpha, a.gl ? b.Sprite.prototype._renderWebGL.call(this._cachedSprite, a) : b.Sprite.prototype._renderCanvas.call(this._cachedSprite, a)
            },
            _generateCachedSprite: function() {
                this._cacheAsBitmap = !1;
                var a = this.getLocalBounds();
                if (a.width = Math.max(1, Math.ceil(a.width)), a.height = Math.max(1, Math.ceil(a.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(a.width, a.height);
                else {
                    var c = new b.RenderTexture(a.width, a.height);
                    this._cachedSprite = new b.Sprite(c), this._cachedSprite.worldTransform = this.worldTransform
                }
                var d = this._filters;
                this._filters = null, this._cachedSprite.filters = d, b.DisplayObject._tempMatrix.tx = -a.x, b.DisplayObject._tempMatrix.ty = -a.y, this._cachedSprite.texture.render(this, b.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -(a.x / a.width), this._cachedSprite.anchor.y = -(a.y / a.height), this._filters = d, this._cacheAsBitmap = !0
            },
            _destroyCachedSprite: function() {
                this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null)
            }
        }, b.DisplayObject.prototype.displayObjectUpdateTransform = b.DisplayObject.prototype.updateTransform, Object.defineProperties(b.DisplayObject.prototype, {
            x: {
                get: function() {
                    return this.position.x
                },
                set: function(a) {
                    this.position.x = a
                }
            },
            y: {
                get: function() {
                    return this.position.y
                },
                set: function(a) {
                    this.position.y = a
                }
            },
            worldVisible: {
                get: function() {
                    if (this.visible) {
                        var a = this.parent;
                        if (!a) return this.visible;
                        do {
                            if (!a.visible) return !1;
                            a = a.parent
                        } while (a);
                        return !0
                    }
                    return !1
                }
            },
            mask: {
                get: function() {
                    return this._mask
                },
                set: function(a) {
                    this._mask && (this._mask.isMask = !1), this._mask = a, a && (this._mask.isMask = !0)
                }
            },
            filters: {
                get: function() {
                    return this._filters
                },
                set: function(a) {
                    if (Array.isArray(a)) {
                        for (var c = [], d = 0; d < a.length; d++)
                            for (var e = a[d].passes, f = 0; f < e.length; f++) c.push(e[f]);
                        this._filterBlock = {
                            target: this,
                            filterPasses: c
                        }
                    }
                    this._filters = a, this.blendMode && this.blendMode === b.blendModes.MULTIPLY && (this.blendMode = b.blendModes.NORMAL)
                }
            },
            cacheAsBitmap: {
                get: function() {
                    return this._cacheAsBitmap
                },
                set: function(a) {
                    this._cacheAsBitmap !== a && (a ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = a)
                }
            }
        }), b.DisplayObjectContainer = function() {
            b.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1
        }, b.DisplayObjectContainer.prototype = Object.create(b.DisplayObject.prototype), b.DisplayObjectContainer.prototype.constructor = b.DisplayObjectContainer, b.DisplayObjectContainer.prototype.addChild = function(a) {
            return this.addChildAt(a, this.children.length)
        }, b.DisplayObjectContainer.prototype.addChildAt = function(a, b) {
            if (b >= 0 && b <= this.children.length) return a.parent && a.parent.removeChild(a), a.parent = this, this.children.splice(b, 0, a), a;
            throw new Error(a + "addChildAt: The index " + b + " supplied is out of bounds " + this.children.length)
        }, b.DisplayObjectContainer.prototype.swapChildren = function(a, b) {
            if (a !== b) {
                var c = this.getChildIndex(a),
                    d = this.getChildIndex(b);
                if (c < 0 || d < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
                this.children[c] = b, this.children[d] = a
            }
        }, b.DisplayObjectContainer.prototype.getChildIndex = function(a) {
            var b = this.children.indexOf(a);
            if (b === -1) throw new Error("The supplied DisplayObject must be a child of the caller");
            return b
        }, b.DisplayObjectContainer.prototype.setChildIndex = function(a, b) {
            if (b < 0 || b >= this.children.length) throw new Error("The supplied index is out of bounds");
            var c = this.getChildIndex(a);
            this.children.splice(c, 1), this.children.splice(b, 0, a)
        }, b.DisplayObjectContainer.prototype.getChildAt = function(a) {
            if (a < 0 || a >= this.children.length) throw new Error("getChildAt: Supplied index " + a + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
            return this.children[a]
        }, b.DisplayObjectContainer.prototype.removeChild = function(a) {
            var b = this.children.indexOf(a);
            if (b !== -1) return this.removeChildAt(b)
        }, b.DisplayObjectContainer.prototype.removeChildAt = function(a) {
            var b = this.getChildAt(a);
            return b && (b.parent = void 0, this.children.splice(a, 1)), b
        }, b.DisplayObjectContainer.prototype.removeChildren = function(a, b) {
            void 0 === a && (a = 0), void 0 === b && (b = this.children.length);
            var c = b - a;
            if (c > 0 && c <= b) {
                for (var d = this.children.splice(begin, c), e = 0; e < d.length; e++) {
                    var f = d[e];
                    f.parent = void 0
                }
                return d
            }
            if (0 === c && 0 === this.children.length) return [];
            throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
        }, b.DisplayObjectContainer.prototype.updateTransform = function() {
            if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap))
                for (var a = 0; a < this.children.length; a++) this.children[a].updateTransform()
        }, b.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = b.DisplayObjectContainer.prototype.updateTransform, b.DisplayObjectContainer.prototype.getBounds = function(a) {
            var c = a && a instanceof b.DisplayObject,
                d = !0;
            c ? d = a instanceof b.DisplayObjectContainer && a.contains(this) : a = this;
            var e;
            if (c) {
                var f = a.worldTransform;
                for (a.worldTransform = b.identityMatrix, e = 0; e < a.children.length; e++) a.children[e].updateTransform();
            }
            var g, h, i, j = 1 / 0,
                k = 1 / 0,
                l = -(1 / 0),
                m = -(1 / 0),
                n = !1;
            for (e = 0; e < this.children.length; e++) {
                var o = this.children[e];
                o.visible && (n = !0, g = this.children[e].getBounds(), j = j < g.x ? j : g.x, k = k < g.y ? k : g.y, h = g.width + g.x, i = g.height + g.y, l = l > h ? l : h, m = m > i ? m : i)
            }
            var p = this._bounds;
            if (!n) {
                p = new b.Rectangle;
                var q = p.x,
                    r = p.width + p.x,
                    s = p.y,
                    t = p.height + p.y,
                    u = this.worldTransform,
                    v = u.a,
                    w = u.b,
                    x = u.c,
                    y = u.d,
                    z = u.tx,
                    A = u.ty,
                    B = v * r + x * t + z,
                    C = y * t + w * r + A,
                    D = v * q + x * t + z,
                    E = y * t + w * q + A,
                    F = v * q + x * s + z,
                    G = y * s + w * q + A,
                    H = v * r + x * s + z,
                    I = y * s + w * r + A;
                l = B, m = C, j = B, k = C, j = D < j ? D : j, j = F < j ? F : j, j = H < j ? H : j, k = E < k ? E : k, k = G < k ? G : k, k = I < k ? I : k, l = D > l ? D : l, l = F > l ? F : l, l = H > l ? H : l, m = E > m ? E : m, m = G > m ? G : m, m = I > m ? I : m
            }
            if (p.x = j, p.y = k, p.width = l - j, p.height = m - k, c)
                for (a.worldTransform = f, e = 0; e < a.children.length; e++) a.children[e].updateTransform();
            if (!d) {
                var J = a.getBounds();
                p.x -= J.x, p.y -= J.y
            }
            return p
        }, b.DisplayObjectContainer.prototype.getLocalBounds = function() {
            return this.getBounds(this)
        }, b.DisplayObjectContainer.prototype.contains = function(a) {
            return !!a && (a === this || this.contains(a.parent))
        }, b.DisplayObjectContainer.prototype._renderWebGL = function(a) {
            if (this.visible && !(this.alpha <= 0)) {
                if (this._cacheAsBitmap) return void this._renderCachedSprite(a);
                var b;
                if (this._mask || this._filters) {
                    for (this._filters && (a.spriteBatch.flush(), a.filterManager.pushFilter(this._filterBlock)), this._mask && (a.spriteBatch.stop(), a.maskManager.pushMask(this.mask, a), a.spriteBatch.start()), b = 0; b < this.children.length; b++) this.children[b]._renderWebGL(a);
                    a.spriteBatch.stop(), this._mask && a.maskManager.popMask(this._mask, a), this._filters && a.filterManager.popFilter(), a.spriteBatch.start()
                } else
                    for (b = 0; b < this.children.length; b++) this.children[b]._renderWebGL(a)
            }
        }, b.DisplayObjectContainer.prototype._renderCanvas = function(a) {
            if (this.visible !== !1 && 0 !== this.alpha) {
                if (this._cacheAsBitmap) return void this._renderCachedSprite(a);
                this._mask && a.maskManager.pushMask(this._mask, a);
                for (var b = 0; b < this.children.length; b++) this.children[b]._renderCanvas(a);
                this._mask && a.maskManager.popMask(a)
            }
        }, Object.defineProperty(b.DisplayObjectContainer.prototype, "width", {
            get: function() {
                return this.getLocalBounds().width * this.scale.x
            },
            set: function(a) {
                var b = this.getLocalBounds().width;
                0 !== b ? this.scale.x = a / b : this.scale.x = 1, this._width = a
            }
        }), Object.defineProperty(b.DisplayObjectContainer.prototype, "height", {
            get: function() {
                return this.getLocalBounds().height * this.scale.y
            },
            set: function(a) {
                var b = this.getLocalBounds().height;
                0 !== b ? this.scale.y = a / b : this.scale.y = 1, this._height = a
            }
        }), b.Sprite = function(a) {
            b.DisplayObjectContainer.call(this), this.anchor = new b.Point, this.texture = a || b.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = b.blendModes.NORMAL, this.shader = null, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0
        }, b.Sprite.prototype = Object.create(b.DisplayObjectContainer.prototype), b.Sprite.prototype.constructor = b.Sprite, Object.defineProperty(b.Sprite.prototype, "width", {
            get: function() {
                return this.scale.x * this.texture.frame.width
            },
            set: function(a) {
                this.scale.x = a / this.texture.frame.width, this._width = a
            }
        }), Object.defineProperty(b.Sprite.prototype, "height", {
            get: function() {
                return this.scale.y * this.texture.frame.height
            },
            set: function(a) {
                this.scale.y = a / this.texture.frame.height, this._height = a
            }
        }), b.Sprite.prototype.setTexture = function(a, b) {
            void 0 !== b && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = a, this.texture.valid = !0, this.cachedTint = -1
        }, b.Sprite.prototype.onTextureUpdate = function() {
            this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height)
        }, b.Sprite.prototype.getBounds = function(a) {
            var b = this.texture.frame.width,
                c = this.texture.frame.height,
                d = b * (1 - this.anchor.x),
                e = b * -this.anchor.x,
                f = c * (1 - this.anchor.y),
                g = c * -this.anchor.y,
                h = a || this.worldTransform,
                i = h.a,
                j = h.b,
                k = h.c,
                l = h.d,
                m = h.tx,
                n = h.ty,
                o = -(1 / 0),
                p = -(1 / 0),
                q = 1 / 0,
                r = 1 / 0;
            if (0 === j && 0 === k) {
                if (i < 0) {
                    i *= -1;
                    var s = d;
                    d = -e, e = -s
                }
                if (l < 0) {
                    l *= -1;
                    var s = f;
                    f = -g, g = -s
                }
                q = i * e + m, o = i * d + m, r = l * g + n, p = l * f + n
            } else {
                var t = i * e + k * g + m,
                    u = l * g + j * e + n,
                    v = i * d + k * g + m,
                    w = l * g + j * d + n,
                    x = i * d + k * f + m,
                    y = l * f + j * d + n,
                    z = i * e + k * f + m,
                    A = l * f + j * e + n;
                q = t < q ? t : q, q = v < q ? v : q, q = x < q ? x : q, q = z < q ? z : q, r = u < r ? u : r, r = w < r ? w : r, r = y < r ? y : r, r = A < r ? A : r, o = t > o ? t : o, o = v > o ? v : o, o = x > o ? x : o, o = z > o ? z : o, p = u > p ? u : p, p = w > p ? w : p, p = y > p ? y : p, p = A > p ? A : p
            }
            var B = this._bounds;
            return B.x = q, B.width = o - q, B.y = r, B.height = p - r, this._currentBounds = B, B
        }, b.Sprite.prototype.getLocalBounds = function() {
            var a = this.worldTransform;
            this.worldTransform = b.identityMatrix;
            for (var c = 0; c < this.children.length; c++) this.children[c].updateTransform();
            var d = this.getBounds();
            for (this.worldTransform = a, c = 0; c < this.children.length; c++) this.children[c].updateTransform();
            return d
        }, b.Sprite.prototype._renderWebGL = function(a, b) {
            if (this.visible && !(this.alpha <= 0) && this.renderable) {
                var c = this.worldTransform;
                if (b && (c = b), this._mask || this._filters) {
                    var d = a.spriteBatch;
                    this._filters && (d.flush(), a.filterManager.pushFilter(this._filterBlock)), this._mask && (d.stop(), a.maskManager.pushMask(this.mask, a), d.start()), d.render(this);
                    for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(a);
                    d.stop(), this._mask && a.maskManager.popMask(this._mask, a), this._filters && a.filterManager.popFilter(), d.start()
                } else {
                    a.spriteBatch.render(this);
                    for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(a, c)
                }
            }
        }, b.Sprite.prototype._renderCanvas = function(a, c) {
            if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
                var d = this.worldTransform;
                if (c && (d = c), this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, a.context.globalCompositeOperation = b.blendModesCanvas[a.currentBlendMode]), this._mask && a.maskManager.pushMask(this._mask, a), this.texture.valid) {
                    var e = this.texture.baseTexture.resolution / a.resolution;
                    a.context.globalAlpha = this.worldAlpha, a.smoothProperty && a.scaleMode !== this.texture.baseTexture.scaleMode && (a.scaleMode = this.texture.baseTexture.scaleMode, a.context[a.smoothProperty] = a.scaleMode === b.scaleModes.LINEAR);
                    var f = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
                        g = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height,
                        h = d.tx * a.resolution + a.shakeX,
                        i = d.ty * a.resolution + a.shakeY;
                    a.roundPixels ? (a.context.setTransform(d.a, d.b, d.c, d.d, 0 | h, 0 | i), f |= 0, g |= 0) : a.context.setTransform(d.a, d.b, d.c, d.d, h, i);
                    var j = this.texture.crop.width,
                        k = this.texture.crop.height;
                    if (f /= e, g /= e, 16777215 !== this.tint)(this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = b.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), a.context.drawImage(this.tintedTexture, 0, 0, j, k, f, g, j / e, k / e);
                    else {
                        var l = this.texture.crop.x,
                            m = this.texture.crop.y;
                        a.context.drawImage(this.texture.baseTexture.source, l, m, j, k, f, g, j / e, k / e)
                    }
                }
                for (var n = 0; n < this.children.length; n++) this.children[n]._renderCanvas(a);
                this._mask && a.maskManager.popMask(a)
            }
        }, b.SpriteBatch = function(a) {
            b.DisplayObjectContainer.call(this), this.textureThing = a, this.ready = !1
        }, b.SpriteBatch.prototype = Object.create(b.DisplayObjectContainer.prototype), b.SpriteBatch.prototype.constructor = b.SpriteBatch, b.SpriteBatch.prototype.initWebGL = function(a) {
            this.fastSpriteBatch = new b.WebGLFastSpriteBatch(a), this.ready = !0
        }, b.SpriteBatch.prototype.updateTransform = function() {
            this.displayObjectUpdateTransform()
        }, b.SpriteBatch.prototype._renderWebGL = function(a) {
            !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || this.initWebGL(a.gl), this.fastSpriteBatch.gl !== a.gl && this.fastSpriteBatch.setContext(a.gl), a.spriteBatch.stop(), a.shaderManager.setShader(a.shaderManager.fastShader), this.fastSpriteBatch.begin(this, a), this.fastSpriteBatch.render(this), a.spriteBatch.start())
        }, b.SpriteBatch.prototype._renderCanvas = function(a) {
            if (this.visible && !(this.alpha <= 0) && this.children.length) {
                var b = a.context;
                b.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
                for (var c = this.worldTransform, d = !0, e = 0; e < this.children.length; e++) {
                    var f = this.children[e];
                    if (f.visible) {
                        var g = f.texture,
                            h = g.frame;
                        if (b.globalAlpha = this.worldAlpha * f.alpha, f.rotation % (2 * Math.PI) === 0) d && (b.setTransform(c.a, c.b, c.c, c.d, c.tx, c.ty), d = !1), b.drawImage(g.baseTexture.source, h.x, h.y, h.width, h.height, f.anchor.x * (-h.width * f.scale.x) + f.position.x + .5 + a.shakeX | 0, f.anchor.y * (-h.height * f.scale.y) + f.position.y + .5 + a.shakeY | 0, h.width * f.scale.x, h.height * f.scale.y);
                        else {
                            d || (d = !0), f.displayObjectUpdateTransform();
                            var i = f.worldTransform,
                                j = i.tx * a.resolution + a.shakeX,
                                k = i.ty * a.resolution + a.shakeY;
                            a.roundPixels ? b.setTransform(i.a, i.b, i.c, i.d, 0 | j, 0 | k) : b.setTransform(i.a, i.b, i.c, i.d, j, k), b.drawImage(g.baseTexture.source, h.x, h.y, h.width, h.height, f.anchor.x * -h.width + .5 | 0, f.anchor.y * -h.height + .5 | 0, h.width, h.height)
                        }
                    }
                }
            }
        }, b.hex2rgb = function(a) {
            return [(a >> 16 & 255) / 255, (a >> 8 & 255) / 255, (255 & a) / 255]
        }, b.rgb2hex = function(a) {
            return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2]
        }, b.canUseNewCanvasBlendModes = function() {
            if (void 0 === document) return !1;
            var a = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/",
                c = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==",
                d = new Image;
            d.src = a + "AP804Oa6" + c;
            var e = new Image;
            e.src = a + "/wCKxvRF" + c;
            var f = b.CanvasPool.create(this, 6, 1),
                g = f.getContext("2d");
            if (g.globalCompositeOperation = "multiply", g.drawImage(d, 0, 0), g.drawImage(e, 2, 0), !g.getImageData(2, 0, 1, 1)) return !1;
            var h = g.getImageData(2, 0, 1, 1).data;
            return b.CanvasPool.remove(this), 255 === h[0] && 0 === h[1] && 0 === h[2]
        }, b.getNextPowerOfTwo = function(a) {
            if (a > 0 && 0 === (a & a - 1)) return a;
            for (var b = 1; b < a;) b <<= 1;
            return b
        }, b.isPowerOfTwo = function(a, b) {
            return a > 0 && 0 === (a & a - 1) && b > 0 && 0 === (b & b - 1)
        }, b.CanvasPool = {
            create: function(a, c, d) {
                var e, f = b.CanvasPool.getFirst();
                if (f === -1) {
                    var g = {
                        parent: a,
                        canvas: document.createElement("canvas")
                    };
                    b.CanvasPool.pool.push(g), e = g.canvas
                } else b.CanvasPool.pool[f].parent = a, e = b.CanvasPool.pool[f].canvas;
                return void 0 !== c && (e.width = c, e.height = d), e
            },
            getFirst: function() {
                for (var a = b.CanvasPool.pool, c = 0; c < a.length; c++)
                    if (!a[c].parent) return c;
                return -1
            },
            remove: function(a) {
                for (var c = b.CanvasPool.pool, d = 0; d < c.length; d++) c[d].parent === a && (c[d].parent = null, c[d].canvas.width = 1, c[d].canvas.height = 1)
            },
            removeByCanvas: function(a) {
                for (var c = b.CanvasPool.pool, d = 0; d < c.length; d++) c[d].canvas === a && (c[d].parent = null, c[d].canvas.width = 1, c[d].canvas.height = 1)
            },
            getTotal: function() {
                for (var a = b.CanvasPool.pool, c = 0, d = 0; d < a.length; d++) a[d].parent && c++;
                return c
            },
            getFree: function() {
                for (var a = b.CanvasPool.pool, c = 0, d = 0; d < a.length; d++) a[d].parent || c++;
                return c
            }
        }, b.CanvasPool.pool = [], b.initDefaultShaders = function() {}, b.CompileVertexShader = function(a, c) {
            return b._CompileShader(a, c, a.VERTEX_SHADER)
        }, b.CompileFragmentShader = function(a, c) {
            return b._CompileShader(a, c, a.FRAGMENT_SHADER)
        }, b._CompileShader = function(a, b, c) {
            var d = b;
            Array.isArray(b) && (d = b.join("\n"));
            var e = a.createShader(c);
            return a.shaderSource(e, d), a.compileShader(e), a.getShaderParameter(e, a.COMPILE_STATUS) ? e : (window.console.log(a.getShaderInfoLog(e)), null)
        }, b.compileProgram = function(a, c, d) {
            var e = b.CompileFragmentShader(a, d),
                f = b.CompileVertexShader(a, c),
                g = a.createProgram();
            return a.attachShader(g, f), a.attachShader(g, e), a.linkProgram(g), a.getProgramParameter(g, a.LINK_STATUS) || (window.console.log(a.getProgramInfoLog(g)), window.console.log("Could not initialise shaders")), g
        }, b.PixiShader = function(a) {
            this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], this.init()
        }, b.PixiShader.prototype.constructor = b.PixiShader, b.PixiShader.prototype.init = function() {
            var a = this.gl,
                c = b.compileProgram(a, this.vertexSrc || b.PixiShader.defaultVertexSrc, this.fragmentSrc);
            a.useProgram(c), this.uSampler = a.getUniformLocation(c, "uSampler"), this.projectionVector = a.getUniformLocation(c, "projectionVector"), this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.dimensions = a.getUniformLocation(c, "dimensions"), this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord"), this.colorAttribute = a.getAttribLocation(c, "aColor"), this.colorAttribute === -1 && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute];
            for (var d in this.uniforms) this.uniforms[d].uniformLocation = a.getUniformLocation(c, d);
            this.initUniforms(), this.program = c
        }, b.PixiShader.prototype.initUniforms = function() {
            this.textureCount = 1;
            var a, b = this.gl;
            for (var c in this.uniforms) {
                a = this.uniforms[c];
                var d = a.type;
                "sampler2D" === d ? (a._init = !1, null !== a.value && this.initSampler2D(a)) : "mat2" === d || "mat3" === d || "mat4" === d ? (a.glMatrix = !0, a.glValueLength = 1, "mat2" === d ? a.glFunc = b.uniformMatrix2fv : "mat3" === d ? a.glFunc = b.uniformMatrix3fv : "mat4" === d && (a.glFunc = b.uniformMatrix4fv)) : (a.glFunc = b["uniform" + d], "2f" === d || "2i" === d ? a.glValueLength = 2 : "3f" === d || "3i" === d ? a.glValueLength = 3 : "4f" === d || "4i" === d ? a.glValueLength = 4 : a.glValueLength = 1)
            }
        }, b.PixiShader.prototype.initSampler2D = function(a) {
            if (a.value && a.value.baseTexture && a.value.baseTexture.hasLoaded) {
                var b = this.gl;
                if (b.activeTexture(b["TEXTURE" + this.textureCount]), b.bindTexture(b.TEXTURE_2D, a.value.baseTexture._glTextures[b.id]), a.textureData) {
                    var c = a.textureData,
                        d = c.magFilter ? c.magFilter : b.LINEAR,
                        e = c.minFilter ? c.minFilter : b.LINEAR,
                        f = c.wrapS ? c.wrapS : b.CLAMP_TO_EDGE,
                        g = c.wrapT ? c.wrapT : b.CLAMP_TO_EDGE,
                        h = c.luminance ? b.LUMINANCE : b.RGBA;
                    if (c.repeat && (f = b.REPEAT, g = b.REPEAT), b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !!c.flipY), c.width) {
                        var i = c.width ? c.width : 512,
                            j = c.height ? c.height : 2,
                            k = c.border ? c.border : 0;
                        b.texImage2D(b.TEXTURE_2D, 0, h, i, j, k, h, b.UNSIGNED_BYTE, null)
                    } else b.texImage2D(b.TEXTURE_2D, 0, h, b.RGBA, b.UNSIGNED_BYTE, a.value.baseTexture.source);
                    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, d), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, e), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, f), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, g)
                }
                b.uniform1i(a.uniformLocation, this.textureCount), a._init = !0, this.textureCount++
            }
        }, b.PixiShader.prototype.syncUniforms = function() {
            this.textureCount = 1;
            var a, c = this.gl;
            for (var d in this.uniforms) a = this.uniforms[d], 1 === a.glValueLength ? a.glMatrix === !0 ? a.glFunc.call(c, a.uniformLocation, a.transpose, a.value) : a.glFunc.call(c, a.uniformLocation, a.value) : 2 === a.glValueLength ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y) : 3 === a.glValueLength ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y, a.value.z) : 4 === a.glValueLength ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y, a.value.z, a.value.w) : "sampler2D" === a.type && (a._init ? (c.activeTexture(c["TEXTURE" + this.textureCount]), a.value.baseTexture._dirty[c.id] ? b.instances[c.id].updateTexture(a.value.baseTexture) : c.bindTexture(c.TEXTURE_2D, a.value.baseTexture._glTextures[c.id]), c.uniform1i(a.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(a))
        }, b.PixiShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, b.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}"], b.PixiFastShader = function(a) {
            this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"], this.textureCount = 0, this.init()
        }, b.PixiFastShader.prototype.constructor = b.PixiFastShader, b.PixiFastShader.prototype.init = function() {
            var a = this.gl,
                c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
            a.useProgram(c), this.uSampler = a.getUniformLocation(c, "uSampler"), this.projectionVector = a.getUniformLocation(c, "projectionVector"), this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.dimensions = a.getUniformLocation(c, "dimensions"), this.uMatrix = a.getUniformLocation(c, "uMatrix"), this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), this.aPositionCoord = a.getAttribLocation(c, "aPositionCoord"), this.aScale = a.getAttribLocation(c, "aScale"), this.aRotation = a.getAttribLocation(c, "aRotation"), this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord"), this.colorAttribute = a.getAttribLocation(c, "aColor"), this.colorAttribute === -1 && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute], this.program = c
        }, b.PixiFastShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, b.StripShader = function(a) {
            this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"], this.init()
        }, b.StripShader.prototype.constructor = b.StripShader, b.StripShader.prototype.init = function() {
            var a = this.gl,
                c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
            a.useProgram(c), this.uSampler = a.getUniformLocation(c, "uSampler"), this.projectionVector = a.getUniformLocation(c, "projectionVector"), this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.colorAttribute = a.getAttribLocation(c, "aColor"), this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord], this.translationMatrix = a.getUniformLocation(c, "translationMatrix"), this.alpha = a.getUniformLocation(c, "alpha"), this.program = c
        }, b.StripShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
        }, b.PrimitiveShader = function(a) {
            this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], this.init()
        }, b.PrimitiveShader.prototype.constructor = b.PrimitiveShader, b.PrimitiveShader.prototype.init = function() {
            var a = this.gl,
                c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
            a.useProgram(c), this.projectionVector = a.getUniformLocation(c, "projectionVector"), this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.tintColor = a.getUniformLocation(c, "tint"), this.flipY = a.getUniformLocation(c, "flipY"), this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), this.colorAttribute = a.getAttribLocation(c, "aColor"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = a.getUniformLocation(c, "translationMatrix"), this.alpha = a.getUniformLocation(c, "alpha"), this.program = c
        }, b.PrimitiveShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, b.ComplexPrimitiveShader = function(a) {
            this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"], this.init()
        }, b.ComplexPrimitiveShader.prototype.constructor = b.ComplexPrimitiveShader, b.ComplexPrimitiveShader.prototype.init = function() {
            var a = this.gl,
                c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
            a.useProgram(c), this.projectionVector = a.getUniformLocation(c, "projectionVector"), this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.tintColor = a.getUniformLocation(c, "tint"), this.color = a.getUniformLocation(c, "color"), this.flipY = a.getUniformLocation(c, "flipY"), this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = a.getUniformLocation(c, "translationMatrix"), this.alpha = a.getUniformLocation(c, "alpha"), this.program = c
        }, b.ComplexPrimitiveShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
        }, b.glContexts = [], b.instances = [], b.WebGLRenderer = function(a) {
            this.game = a, b.defaultRenderer || (b.defaultRenderer = this), this.type = b.WEBGL_RENDERER, this.resolution = a.resolution, this.transparent = a.transparent, this.autoResize = !1, this.preserveDrawingBuffer = a.preserveDrawingBuffer, this.clearBeforeRender = a.clearBeforeRender, this.width = a.width, this.height = a.height, this.view = a.canvas, this._contextOptions = {
                alpha: this.transparent,
                antialias: a.antialias,
                premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
                stencil: !0,
                preserveDrawingBuffer: this.preserveDrawingBuffer
            }, this.projection = new b.Point, this.offset = new b.Point, this.shaderManager = new b.WebGLShaderManager, this.spriteBatch = new b.WebGLSpriteBatch, this.maskManager = new b.WebGLMaskManager, this.filterManager = new b.WebGLFilterManager, this.stencilManager = new b.WebGLStencilManager, this.blendModeManager = new b.WebGLBlendModeManager, this.renderSession = {}, this.renderSession.game = this.game, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, this.renderSession.renderer = this, this.renderSession.resolution = this.resolution, this.initContext(), this.mapBlendModes()
        }, b.WebGLRenderer.prototype.constructor = b.WebGLRenderer, b.WebGLRenderer.prototype.initContext = function() {
            var a = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
            if (this.gl = a, !a) throw new Error("This browser does not support webGL. Try using the canvas renderer");
            this.glContextId = a.id = b.WebGLRenderer.glContextId++, b.glContexts[this.glContextId] = a, b.instances[this.glContextId] = this, a.disable(a.DEPTH_TEST), a.disable(a.CULL_FACE), a.enable(a.BLEND), this.shaderManager.setContext(a), this.spriteBatch.setContext(a), this.maskManager.setContext(a), this.filterManager.setContext(a), this.blendModeManager.setContext(a), this.stencilManager.setContext(a), this.renderSession.gl = this.gl, this.resize(this.width, this.height)
        }, b.WebGLRenderer.prototype.render = function(a) {
            if (!this.contextLost) {
                var b = this.gl;
                b.viewport(0, 0, this.width, this.height), b.bindFramebuffer(b.FRAMEBUFFER, null), this.game.clearBeforeRender && (b.clearColor(a._bgColor.r, a._bgColor.g, a._bgColor.b, a._bgColor.a), b.clear(b.COLOR_BUFFER_BIT)), this.offset.x = this.game.camera._shake.x, this.offset.y = this.game.camera._shake.y, this.renderDisplayObject(a, this.projection)
            }
        }, b.WebGLRenderer.prototype.renderDisplayObject = function(a, c, d, e) {
            this.renderSession.blendModeManager.setBlendMode(b.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.flipY = d ? -1 : 1, this.renderSession.projection = c, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, d), a._renderWebGL(this.renderSession, e), this.spriteBatch.end()
        }, b.WebGLRenderer.prototype.resize = function(a, b) {
            this.width = a * this.resolution, this.height = b * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution
        }, b.WebGLRenderer.prototype.updateTexture = function(a) {
            if (!a.hasLoaded) return !1;
            var c = this.gl;
            return a._glTextures[c.id] || (a._glTextures[c.id] = c.createTexture()), c.bindTexture(c.TEXTURE_2D, a._glTextures[c.id]), c.pixelStorei(c.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultipliedAlpha), c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, c.RGBA, c.UNSIGNED_BYTE, a.source), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR : c.NEAREST), a.mipmap && b.isPowerOfTwo(a.width, a.height) ? (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR_MIPMAP_LINEAR : c.NEAREST_MIPMAP_NEAREST), c.generateMipmap(c.TEXTURE_2D)) : c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR : c.NEAREST), a._powerOf2 ? (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.REPEAT), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.REPEAT)) : (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE)), a._dirty[c.id] = !1, !0
        }, b.WebGLRenderer.prototype.destroy = function() {
            b.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, b.CanvasPool.remove(this), b.instances[this.glContextId] = null, b.WebGLRenderer.glContextId--
        }, b.WebGLRenderer.prototype.mapBlendModes = function() {
            var a = this.gl;
            if (!b.blendModesWebGL) {
                var c = [],
                    d = b.blendModes;
                c[d.NORMAL] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.ADD] = [a.SRC_ALPHA, a.DST_ALPHA], c[d.MULTIPLY] = [a.DST_COLOR, a.ONE_MINUS_SRC_ALPHA], c[d.SCREEN] = [a.SRC_ALPHA, a.ONE], c[d.OVERLAY] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.DARKEN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.LIGHTEN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.COLOR_DODGE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.COLOR_BURN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.HARD_LIGHT] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.SOFT_LIGHT] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.DIFFERENCE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.EXCLUSION] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.HUE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.SATURATION] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.COLOR] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.LUMINOSITY] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], b.blendModesWebGL = c
            }
        }, b.WebGLRenderer.glContextId = 0, b.WebGLBlendModeManager = function() {
            this.currentBlendMode = 99999
        }, b.WebGLBlendModeManager.prototype.constructor = b.WebGLBlendModeManager, b.WebGLBlendModeManager.prototype.setContext = function(a) {
            this.gl = a
        }, b.WebGLBlendModeManager.prototype.setBlendMode = function(a) {
            if (this.currentBlendMode === a) return !1;
            this.currentBlendMode = a;
            var c = b.blendModesWebGL[this.currentBlendMode];
            return c && this.gl.blendFunc(c[0], c[1]), !0
        }, b.WebGLBlendModeManager.prototype.destroy = function() {
            this.gl = null
        }, b.WebGLMaskManager = function() {}, b.WebGLMaskManager.prototype.constructor = b.WebGLMaskManager, b.WebGLMaskManager.prototype.setContext = function(a) {
            this.gl = a
        }, b.WebGLMaskManager.prototype.pushMask = function(a, c) {
            var d = c.gl;
            a.dirty && b.WebGLGraphics.updateGraphics(a, d), void 0 !== a._webGL[d.id] && void 0 !== a._webGL[d.id].data && 0 !== a._webGL[d.id].data.length && c.stencilManager.pushStencil(a, a._webGL[d.id].data[0], c)
        }, b.WebGLMaskManager.prototype.popMask = function(a, b) {
            var c = this.gl;
            void 0 !== a._webGL[c.id] && void 0 !== a._webGL[c.id].data && 0 !== a._webGL[c.id].data.length && b.stencilManager.popStencil(a, a._webGL[c.id].data[0], b)
        }, b.WebGLMaskManager.prototype.destroy = function() {
            this.gl = null
        }, b.WebGLStencilManager = function() {
            this.stencilStack = [], this.reverse = !0, this.count = 0
        }, b.WebGLStencilManager.prototype.setContext = function(a) {
            this.gl = a
        }, b.WebGLStencilManager.prototype.pushStencil = function(a, b, c) {
            var d = this.gl;
            this.bindGraphics(a, b, c), 0 === this.stencilStack.length && (d.enable(d.STENCIL_TEST), d.clear(d.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(b);
            var e = this.count;
            d.colorMask(!1, !1, !1, !1), d.stencilFunc(d.ALWAYS, 0, 255), d.stencilOp(d.KEEP, d.KEEP, d.INVERT), 1 === b.mode ? (d.drawElements(d.TRIANGLE_FAN, b.indices.length - 4, d.UNSIGNED_SHORT, 0), this.reverse ? (d.stencilFunc(d.EQUAL, 255 - e, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)) : (d.stencilFunc(d.EQUAL, e, 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)), d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (b.indices.length - 4)), this.reverse ? d.stencilFunc(d.EQUAL, 255 - (e + 1), 255) : d.stencilFunc(d.EQUAL, e + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (d.stencilFunc(d.EQUAL, e, 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)) : (d.stencilFunc(d.EQUAL, 255 - e, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)), d.drawElements(d.TRIANGLE_STRIP, b.indices.length, d.UNSIGNED_SHORT, 0), this.reverse ? d.stencilFunc(d.EQUAL, e + 1, 255) : d.stencilFunc(d.EQUAL, 255 - (e + 1), 255)), d.colorMask(!0, !0, !0, !0), d.stencilOp(d.KEEP, d.KEEP, d.KEEP), this.count++
        }, b.WebGLStencilManager.prototype.bindGraphics = function(a, c, d) {
            this._currentGraphics = a;
            var e, f = this.gl,
                g = d.projection,
                h = d.offset;
            1 === c.mode ? (e = d.shaderManager.complexPrimitiveShader, d.shaderManager.setShader(e), f.uniform1f(e.flipY, d.flipY), f.uniformMatrix3fv(e.translationMatrix, !1, a.worldTransform.toArray(!0)), f.uniform2f(e.projectionVector, g.x, -g.y), f.uniform2f(e.offsetVector, -h.x, -h.y), f.uniform3fv(e.tintColor, b.hex2rgb(a.tint)), f.uniform3fv(e.color, c.color), f.uniform1f(e.alpha, a.worldAlpha * c.alpha), f.bindBuffer(f.ARRAY_BUFFER, c.buffer), f.vertexAttribPointer(e.aVertexPosition, 2, f.FLOAT, !1, 8, 0), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, c.indexBuffer)) : (e = d.shaderManager.primitiveShader, d.shaderManager.setShader(e), f.uniformMatrix3fv(e.translationMatrix, !1, a.worldTransform.toArray(!0)), f.uniform1f(e.flipY, d.flipY), f.uniform2f(e.projectionVector, g.x, -g.y), f.uniform2f(e.offsetVector, -h.x, -h.y), f.uniform3fv(e.tintColor, b.hex2rgb(a.tint)), f.uniform1f(e.alpha, a.worldAlpha), f.bindBuffer(f.ARRAY_BUFFER, c.buffer), f.vertexAttribPointer(e.aVertexPosition, 2, f.FLOAT, !1, 24, 0), f.vertexAttribPointer(e.colorAttribute, 4, f.FLOAT, !1, 24, 8),
                f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, c.indexBuffer))
        }, b.WebGLStencilManager.prototype.popStencil = function(a, b, c) {
            var d = this.gl;
            if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) d.disable(d.STENCIL_TEST);
            else {
                var e = this.count;
                this.bindGraphics(a, b, c), d.colorMask(!1, !1, !1, !1), 1 === b.mode ? (this.reverse = !this.reverse, this.reverse ? (d.stencilFunc(d.EQUAL, 255 - (e + 1), 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)) : (d.stencilFunc(d.EQUAL, e + 1, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)), d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (b.indices.length - 4)), d.stencilFunc(d.ALWAYS, 0, 255), d.stencilOp(d.KEEP, d.KEEP, d.INVERT), d.drawElements(d.TRIANGLE_FAN, b.indices.length - 4, d.UNSIGNED_SHORT, 0), this.reverse ? d.stencilFunc(d.EQUAL, e, 255) : d.stencilFunc(d.EQUAL, 255 - e, 255)) : (this.reverse ? (d.stencilFunc(d.EQUAL, e + 1, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)) : (d.stencilFunc(d.EQUAL, 255 - (e + 1), 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)), d.drawElements(d.TRIANGLE_STRIP, b.indices.length, d.UNSIGNED_SHORT, 0), this.reverse ? d.stencilFunc(d.EQUAL, e, 255) : d.stencilFunc(d.EQUAL, 255 - e, 255)), d.colorMask(!0, !0, !0, !0), d.stencilOp(d.KEEP, d.KEEP, d.KEEP)
            }
        }, b.WebGLStencilManager.prototype.destroy = function() {
            this.stencilStack = null, this.gl = null
        }, b.WebGLShaderManager = function() {
            this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
            for (var a = 0; a < this.maxAttibs; a++) this.attribState[a] = !1;
            this.stack = []
        }, b.WebGLShaderManager.prototype.constructor = b.WebGLShaderManager, b.WebGLShaderManager.prototype.setContext = function(a) {
            this.gl = a, this.primitiveShader = new b.PrimitiveShader(a), this.complexPrimitiveShader = new b.ComplexPrimitiveShader(a), this.defaultShader = new b.PixiShader(a), this.fastShader = new b.PixiFastShader(a), this.stripShader = new b.StripShader(a), this.setShader(this.defaultShader)
        }, b.WebGLShaderManager.prototype.setAttribs = function(a) {
            var b;
            for (b = 0; b < this.tempAttribState.length; b++) this.tempAttribState[b] = !1;
            for (b = 0; b < a.length; b++) {
                var c = a[b];
                this.tempAttribState[c] = !0
            }
            var d = this.gl;
            for (b = 0; b < this.attribState.length; b++) this.attribState[b] !== this.tempAttribState[b] && (this.attribState[b] = this.tempAttribState[b], this.tempAttribState[b] ? d.enableVertexAttribArray(b) : d.disableVertexAttribArray(b))
        }, b.WebGLShaderManager.prototype.setShader = function(a) {
            return this._currentId !== a._UID && (this._currentId = a._UID, this.currentShader = a, this.gl.useProgram(a.program), this.setAttribs(a.attributes), !0)
        }, b.WebGLShaderManager.prototype.destroy = function() {
            this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.gl = null
        }, b.WebGLSpriteBatch = function() {
            this.vertSize = 5, this.size = 2e3;
            var a = 4 * this.size * 4 * this.vertSize,
                c = 6 * this.size;
            this.vertices = new b.ArrayBuffer(a), this.positions = new b.Float32Array(this.vertices), this.colors = new b.Uint32Array(this.vertices), this.indices = new b.Uint16Array(c), this.lastIndexCount = 0;
            for (var d = 0, e = 0; d < c; d += 6, e += 4) this.indices[d + 0] = e + 0, this.indices[d + 1] = e + 1, this.indices[d + 2] = e + 2, this.indices[d + 3] = e + 0, this.indices[d + 4] = e + 2, this.indices[d + 5] = e + 3;
            this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.defaultShader = new b.AbstractFilter(["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"])
        }, b.WebGLSpriteBatch.prototype.setContext = function(a) {
            this.gl = a, this.vertexBuffer = a.createBuffer(), this.indexBuffer = a.createBuffer(), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW), this.currentBlendMode = 99999;
            var c = new b.PixiShader(a);
            c.fragmentSrc = this.defaultShader.fragmentSrc, c.uniforms = {}, c.init(), this.defaultShader.shaders[a.id] = c
        }, b.WebGLSpriteBatch.prototype.begin = function(a) {
            this.renderSession = a, this.shader = this.renderSession.shaderManager.defaultShader, this.start()
        }, b.WebGLSpriteBatch.prototype.end = function() {
            this.flush()
        }, b.WebGLSpriteBatch.prototype.render = function(a, b) {
            var c = a.texture,
                d = a.worldTransform;
            b && (d = b), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = c.baseTexture);
            var e = c._uvs;
            if (e) {
                var f, g, h, i, j = a.anchor.x,
                    k = a.anchor.y;
                if (c.trim) {
                    var l = c.trim;
                    g = l.x - j * l.width, f = g + c.crop.width, i = l.y - k * l.height, h = i + c.crop.height
                } else f = c.frame.width * (1 - j), g = c.frame.width * -j, h = c.frame.height * (1 - k), i = c.frame.height * -k;
                var m = 4 * this.currentBatchSize * this.vertSize,
                    n = c.baseTexture.resolution,
                    o = d.a / n,
                    p = d.b / n,
                    q = d.c / n,
                    r = d.d / n,
                    s = d.tx,
                    t = d.ty,
                    u = this.colors,
                    v = this.positions;
                this.renderSession.roundPixels ? (v[m] = o * g + q * i + s | 0, v[m + 1] = r * i + p * g + t | 0, v[m + 5] = o * f + q * i + s | 0, v[m + 6] = r * i + p * f + t | 0, v[m + 10] = o * f + q * h + s | 0, v[m + 11] = r * h + p * f + t | 0, v[m + 15] = o * g + q * h + s | 0, v[m + 16] = r * h + p * g + t | 0) : (v[m] = o * g + q * i + s, v[m + 1] = r * i + p * g + t, v[m + 5] = o * f + q * i + s, v[m + 6] = r * i + p * f + t, v[m + 10] = o * f + q * h + s, v[m + 11] = r * h + p * f + t, v[m + 15] = o * g + q * h + s, v[m + 16] = r * h + p * g + t), v[m + 2] = e.x0, v[m + 3] = e.y0, v[m + 7] = e.x1, v[m + 8] = e.y1, v[m + 12] = e.x2, v[m + 13] = e.y2, v[m + 17] = e.x3, v[m + 18] = e.y3;
                var w = a.tint;
                u[m + 4] = u[m + 9] = u[m + 14] = u[m + 19] = (w >> 16) + (65280 & w) + ((255 & w) << 16) + (255 * a.worldAlpha << 24), this.sprites[this.currentBatchSize++] = a
            }
        }, b.WebGLSpriteBatch.prototype.renderTilingSprite = function(a) {
            var c = a.tilingTexture;
            this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = c.baseTexture), a._uvs || (a._uvs = new b.TextureUvs);
            var d = a._uvs,
                e = c.baseTexture.width,
                f = c.baseTexture.height;
            a.tilePosition.x %= e * a.tileScaleOffset.x, a.tilePosition.y %= f * a.tileScaleOffset.y;
            var g = a.tilePosition.x / (e * a.tileScaleOffset.x),
                h = a.tilePosition.y / (f * a.tileScaleOffset.y),
                i = a.width / e / (a.tileScale.x * a.tileScaleOffset.x),
                j = a.height / f / (a.tileScale.y * a.tileScaleOffset.y);
            d.x0 = 0 - g, d.y0 = 0 - h, d.x1 = 1 * i - g, d.y1 = 0 - h, d.x2 = 1 * i - g, d.y2 = 1 * j - h, d.x3 = 0 - g, d.y3 = 1 * j - h;
            var k = a.tint,
                l = (k >> 16) + (65280 & k) + ((255 & k) << 16) + (255 * a.worldAlpha << 24),
                m = this.positions,
                n = this.colors,
                o = a.width,
                p = a.height,
                q = a.anchor.x,
                r = a.anchor.y,
                s = o * (1 - q),
                t = o * -q,
                u = p * (1 - r),
                v = p * -r,
                w = 4 * this.currentBatchSize * this.vertSize,
                x = c.baseTexture.resolution,
                y = a.worldTransform,
                z = y.a / x,
                A = y.b / x,
                B = y.c / x,
                C = y.d / x,
                D = y.tx,
                E = y.ty;
            m[w++] = z * t + B * v + D, m[w++] = C * v + A * t + E, m[w++] = d.x0, m[w++] = d.y0, n[w++] = l, m[w++] = z * s + B * v + D, m[w++] = C * v + A * s + E, m[w++] = d.x1, m[w++] = d.y1, n[w++] = l, m[w++] = z * s + B * u + D, m[w++] = C * u + A * s + E, m[w++] = d.x2, m[w++] = d.y2, n[w++] = l, m[w++] = z * t + B * u + D, m[w++] = C * u + A * t + E, m[w++] = d.x3, m[w++] = d.y3, n[w++] = l, this.sprites[this.currentBatchSize++] = a
        }, b.WebGLSpriteBatch.prototype.flush = function() {
            if (0 !== this.currentBatchSize) {
                var a, c = this.gl;
                if (this.dirty) {
                    this.dirty = !1, c.activeTexture(c.TEXTURE0), c.bindBuffer(c.ARRAY_BUFFER, this.vertexBuffer), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a = this.defaultShader.shaders[c.id];
                    var d = 4 * this.vertSize;
                    c.vertexAttribPointer(a.aVertexPosition, 2, c.FLOAT, !1, d, 0), c.vertexAttribPointer(a.aTextureCoord, 2, c.FLOAT, !1, d, 8), c.vertexAttribPointer(a.colorAttribute, 4, c.UNSIGNED_BYTE, !0, d, 16)
                }
                if (this.currentBatchSize > .5 * this.size) c.bufferSubData(c.ARRAY_BUFFER, 0, this.vertices);
                else {
                    var e = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                    c.bufferSubData(c.ARRAY_BUFFER, 0, e)
                }
                for (var f, g, h, i, j = 0, k = 0, l = null, m = this.renderSession.blendModeManager.currentBlendMode, n = null, o = !1, p = !1, q = 0, r = this.currentBatchSize; q < r; q++) {
                    i = this.sprites[q], f = i.tilingTexture ? i.tilingTexture.baseTexture : i.texture.baseTexture, g = i.blendMode, h = i.shader || this.defaultShader, o = m !== g, p = n !== h;
                    var s = f.skipRender;
                    if (s && i.children.length > 0 && (s = !1), (l !== f && !s || o || p) && (this.renderBatch(l, j, k), k = q, j = 0, l = f, o && (m = g, this.renderSession.blendModeManager.setBlendMode(m)), p)) {
                        n = h, a = n.shaders[c.id], a || (a = new b.PixiShader(c), a.fragmentSrc = n.fragmentSrc, a.uniforms = n.uniforms, a.init(), n.shaders[c.id] = a), this.renderSession.shaderManager.setShader(a), a.dirty && a.syncUniforms();
                        var t = this.renderSession.projection;
                        c.uniform2f(a.projectionVector, t.x, t.y);
                        var u = this.renderSession.offset;
                        c.uniform2f(a.offsetVector, u.x, u.y)
                    }
                    j++
                }
                this.renderBatch(l, j, k), this.currentBatchSize = 0
            }
        }, b.WebGLSpriteBatch.prototype.renderBatch = function(a, b, c) {
            if (0 !== b) {
                var d = this.gl;
                if (a._dirty[d.id]) {
                    if (!this.renderSession.renderer.updateTexture(a)) return
                } else d.bindTexture(d.TEXTURE_2D, a._glTextures[d.id]);
                d.drawElements(d.TRIANGLES, 6 * b, d.UNSIGNED_SHORT, 6 * c * 2), this.renderSession.drawCount++
            }
        }, b.WebGLSpriteBatch.prototype.stop = function() {
            this.flush(), this.dirty = !0
        }, b.WebGLSpriteBatch.prototype.start = function() {
            this.dirty = !0
        }, b.WebGLSpriteBatch.prototype.destroy = function() {
            this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null
        }, b.WebGLFastSpriteBatch = function(a) {
            this.vertSize = 10, this.maxSize = 6e3, this.size = this.maxSize;
            var c = 4 * this.size * this.vertSize,
                d = 6 * this.maxSize;
            this.vertices = new b.Float32Array(c), this.indices = new b.Uint16Array(d), this.vertexBuffer = null, this.indexBuffer = null, this.lastIndexCount = 0;
            for (var e = 0, f = 0; e < d; e += 6, f += 4) this.indices[e + 0] = f + 0, this.indices[e + 1] = f + 1, this.indices[e + 2] = f + 2, this.indices[e + 3] = f + 0, this.indices[e + 4] = f + 2, this.indices[e + 5] = f + 3;
            this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(a)
        }, b.WebGLFastSpriteBatch.prototype.constructor = b.WebGLFastSpriteBatch, b.WebGLFastSpriteBatch.prototype.setContext = function(a) {
            this.gl = a, this.vertexBuffer = a.createBuffer(), this.indexBuffer = a.createBuffer(), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW)
        }, b.WebGLFastSpriteBatch.prototype.begin = function(a, b) {
            this.renderSession = b, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = a.worldTransform.toArray(!0), this.start()
        }, b.WebGLFastSpriteBatch.prototype.end = function() {
            this.flush()
        }, b.WebGLFastSpriteBatch.prototype.render = function(a) {
            var b = a.children,
                c = b[0];
            if (c.texture._uvs) {
                this.currentBaseTexture = c.texture.baseTexture, c.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(c.blendMode));
                for (var d = 0, e = b.length; d < e; d++) this.renderSprite(b[d]);
                this.flush()
            }
        }, b.WebGLFastSpriteBatch.prototype.renderSprite = function(a) {
            if (a.visible && (a.texture.baseTexture === this.currentBaseTexture || a.texture.baseTexture.skipRender || (this.flush(), this.currentBaseTexture = a.texture.baseTexture, a.texture._uvs))) {
                var b, c, d, e, f, g, h, i, j = this.vertices;
                if (b = a.texture._uvs, c = a.texture.frame.width, d = a.texture.frame.height, a.texture.trim) {
                    var k = a.texture.trim;
                    f = k.x - a.anchor.x * k.width, e = f + a.texture.crop.width, h = k.y - a.anchor.y * k.height, g = h + a.texture.crop.height
                } else e = a.texture.frame.width * (1 - a.anchor.x), f = a.texture.frame.width * -a.anchor.x, g = a.texture.frame.height * (1 - a.anchor.y), h = a.texture.frame.height * -a.anchor.y;
                i = 4 * this.currentBatchSize * this.vertSize, j[i++] = f, j[i++] = h, j[i++] = a.position.x, j[i++] = a.position.y, j[i++] = a.scale.x, j[i++] = a.scale.y, j[i++] = a.rotation, j[i++] = b.x0, j[i++] = b.y1, j[i++] = a.alpha, j[i++] = e, j[i++] = h, j[i++] = a.position.x, j[i++] = a.position.y, j[i++] = a.scale.x, j[i++] = a.scale.y, j[i++] = a.rotation, j[i++] = b.x1, j[i++] = b.y1, j[i++] = a.alpha, j[i++] = e, j[i++] = g, j[i++] = a.position.x, j[i++] = a.position.y, j[i++] = a.scale.x, j[i++] = a.scale.y, j[i++] = a.rotation, j[i++] = b.x2, j[i++] = b.y2, j[i++] = a.alpha, j[i++] = f, j[i++] = g, j[i++] = a.position.x, j[i++] = a.position.y, j[i++] = a.scale.x, j[i++] = a.scale.y, j[i++] = a.rotation, j[i++] = b.x3, j[i++] = b.y3, j[i++] = a.alpha, this.currentBatchSize++, this.currentBatchSize >= this.size && this.flush()
            }
        }, b.WebGLFastSpriteBatch.prototype.flush = function() {
            if (0 !== this.currentBatchSize) {
                var a = this.gl;
                if (this.currentBaseTexture._glTextures[a.id] || this.renderSession.renderer.updateTexture(this.currentBaseTexture, a), a.bindTexture(a.TEXTURE_2D, this.currentBaseTexture._glTextures[a.id]), this.currentBatchSize > .5 * this.size) a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertices);
                else {
                    var b = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                    a.bufferSubData(a.ARRAY_BUFFER, 0, b)
                }
                a.drawElements(a.TRIANGLES, 6 * this.currentBatchSize, a.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++
            }
        }, b.WebGLFastSpriteBatch.prototype.stop = function() {
            this.flush()
        }, b.WebGLFastSpriteBatch.prototype.start = function() {
            var a = this.gl;
            a.activeTexture(a.TEXTURE0), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            var b = this.renderSession.projection;
            a.uniform2f(this.shader.projectionVector, b.x, b.y), a.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
            var c = 4 * this.vertSize;
            a.vertexAttribPointer(this.shader.aVertexPosition, 2, a.FLOAT, !1, c, 0), a.vertexAttribPointer(this.shader.aPositionCoord, 2, a.FLOAT, !1, c, 8), a.vertexAttribPointer(this.shader.aScale, 2, a.FLOAT, !1, c, 16), a.vertexAttribPointer(this.shader.aRotation, 1, a.FLOAT, !1, c, 24), a.vertexAttribPointer(this.shader.aTextureCoord, 2, a.FLOAT, !1, c, 28), a.vertexAttribPointer(this.shader.colorAttribute, 1, a.FLOAT, !1, c, 36)
        }, b.WebGLFilterManager = function() {
            this.filterStack = [], this.offsetX = 0, this.offsetY = 0
        }, b.WebGLFilterManager.prototype.constructor = b.WebGLFilterManager, b.WebGLFilterManager.prototype.setContext = function(a) {
            this.gl = a, this.texturePool = [], this.initShaderBuffers()
        }, b.WebGLFilterManager.prototype.begin = function(a, b) {
            this.renderSession = a, this.defaultShader = a.shaderManager.defaultShader;
            var c = this.renderSession.projection;
            this.width = 2 * c.x, this.height = 2 * -c.y, this.buffer = b
        }, b.WebGLFilterManager.prototype.pushFilter = function(a) {
            var c = this.gl,
                d = this.renderSession.projection,
                e = this.renderSession.offset;
            a._filterArea = a.target.filterArea || a.target.getBounds(), a._previous_stencil_mgr = this.renderSession.stencilManager, this.renderSession.stencilManager = new b.WebGLStencilManager, this.renderSession.stencilManager.setContext(c), c.disable(c.STENCIL_TEST), this.filterStack.push(a);
            var f = a.filterPasses[0];
            this.offsetX += a._filterArea.x, this.offsetY += a._filterArea.y;
            var g = this.texturePool.pop();
            g ? g.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : g = new b.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), c.bindTexture(c.TEXTURE_2D, g.texture);
            var h = a._filterArea,
                i = f.padding;
            h.x -= i, h.y -= i, h.width += 2 * i, h.height += 2 * i, h.x < 0 && (h.x = 0), h.width > this.width && (h.width = this.width), h.y < 0 && (h.y = 0), h.height > this.height && (h.height = this.height), c.bindFramebuffer(c.FRAMEBUFFER, g.frameBuffer), c.viewport(0, 0, h.width * this.renderSession.resolution, h.height * this.renderSession.resolution), d.x = h.width / 2, d.y = -h.height / 2, e.x = -h.x, e.y = -h.y, c.colorMask(!0, !0, !0, !0), c.clearColor(0, 0, 0, 0), c.clear(c.COLOR_BUFFER_BIT), a._glFilterTexture = g
        }, b.WebGLFilterManager.prototype.popFilter = function() {
            var a = this.gl,
                c = this.filterStack.pop(),
                d = c._filterArea,
                e = c._glFilterTexture,
                f = this.renderSession.projection,
                g = this.renderSession.offset;
            if (c.filterPasses.length > 1) {
                a.viewport(0, 0, d.width * this.renderSession.resolution, d.height * this.renderSession.resolution), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = d.height, this.vertexArray[2] = d.width, this.vertexArray[3] = d.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = d.width, this.vertexArray[7] = 0, a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray), a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = d.width / this.width, this.uvArray[5] = d.height / this.height, this.uvArray[6] = d.width / this.width, this.uvArray[7] = d.height / this.height, a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray);
                var h = e,
                    i = this.texturePool.pop();
                i || (i = new b.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)), i.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), a.bindFramebuffer(a.FRAMEBUFFER, i.frameBuffer), a.clear(a.COLOR_BUFFER_BIT), a.disable(a.BLEND);
                for (var j = 0; j < c.filterPasses.length - 1; j++) {
                    var k = c.filterPasses[j];
                    a.bindFramebuffer(a.FRAMEBUFFER, i.frameBuffer), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, h.texture), this.applyFilterPass(k, d, d.width, d.height);
                    var l = h;
                    h = i, i = l
                }
                a.enable(a.BLEND), e = h, this.texturePool.push(i)
            }
            var m = c.filterPasses[c.filterPasses.length - 1];
            this.offsetX -= d.x, this.offsetY -= d.y;
            var n = this.width,
                o = this.height,
                p = 0,
                q = 0,
                r = this.buffer;
            if (0 === this.filterStack.length) a.colorMask(!0, !0, !0, !0);
            else {
                var s = this.filterStack[this.filterStack.length - 1];
                d = s._filterArea, n = d.width, o = d.height, p = d.x, q = d.y, r = s._glFilterTexture.frameBuffer
            }
            f.x = n / 2, f.y = -o / 2, g.x = p, g.y = q, d = c._filterArea;
            var t = d.x - p,
                u = d.y - q;
            a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = t, this.vertexArray[1] = u + d.height, this.vertexArray[2] = t + d.width, this.vertexArray[3] = u + d.height, this.vertexArray[4] = t, this.vertexArray[5] = u, this.vertexArray[6] = t + d.width, this.vertexArray[7] = u, a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray), a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = d.width / this.width, this.uvArray[5] = d.height / this.height, this.uvArray[6] = d.width / this.width, this.uvArray[7] = d.height / this.height, a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray), a.viewport(0, 0, n * this.renderSession.resolution, o * this.renderSession.resolution), a.bindFramebuffer(a.FRAMEBUFFER, r), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, e.texture), this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(), this.renderSession.stencilManager = c._previous_stencil_mgr, c._previous_stencil_mgr = null, this.renderSession.stencilManager.count > 0 ? a.enable(a.STENCIL_TEST) : a.disable(a.STENCIL_TEST), this.applyFilterPass(m, d, n, o), this.texturePool.push(e), c._glFilterTexture = null
        }, b.WebGLFilterManager.prototype.applyFilterPass = function(a, c, d, e) {
            var f = this.gl,
                g = a.shaders[f.id];
            g || (g = new b.PixiShader(f), g.fragmentSrc = a.fragmentSrc, g.uniforms = a.uniforms, g.init(), a.shaders[f.id] = g), this.renderSession.shaderManager.setShader(g), f.uniform2f(g.projectionVector, d / 2, -e / 2), f.uniform2f(g.offsetVector, 0, 0), a.uniforms.dimensions && (a.uniforms.dimensions.value[0] = this.width, a.uniforms.dimensions.value[1] = this.height, a.uniforms.dimensions.value[2] = this.vertexArray[0], a.uniforms.dimensions.value[3] = this.vertexArray[5]), g.syncUniforms(), f.bindBuffer(f.ARRAY_BUFFER, this.vertexBuffer), f.vertexAttribPointer(g.aVertexPosition, 2, f.FLOAT, !1, 0, 0), f.bindBuffer(f.ARRAY_BUFFER, this.uvBuffer), f.vertexAttribPointer(g.aTextureCoord, 2, f.FLOAT, !1, 0, 0), f.bindBuffer(f.ARRAY_BUFFER, this.colorBuffer), f.vertexAttribPointer(g.colorAttribute, 2, f.FLOAT, !1, 0, 0), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, this.indexBuffer), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0), this.renderSession.drawCount++
        }, b.WebGLFilterManager.prototype.initShaderBuffers = function() {
            var a = this.gl;
            this.vertexBuffer = a.createBuffer(), this.uvBuffer = a.createBuffer(), this.colorBuffer = a.createBuffer(), this.indexBuffer = a.createBuffer(), this.vertexArray = new b.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bufferData(a.ARRAY_BUFFER, this.vertexArray, a.STATIC_DRAW), this.uvArray = new b.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer), a.bufferData(a.ARRAY_BUFFER, this.uvArray, a.STATIC_DRAW), this.colorArray = new b.Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]), a.bindBuffer(a.ARRAY_BUFFER, this.colorBuffer), a.bufferData(a.ARRAY_BUFFER, this.colorArray, a.STATIC_DRAW), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), a.STATIC_DRAW)
        }, b.WebGLFilterManager.prototype.destroy = function() {
            var a = this.gl;
            this.filterStack = null, this.offsetX = 0, this.offsetY = 0;
            for (var b = 0; b < this.texturePool.length; b++) this.texturePool[b].destroy();
            this.texturePool = null, a.deleteBuffer(this.vertexBuffer), a.deleteBuffer(this.uvBuffer), a.deleteBuffer(this.colorBuffer), a.deleteBuffer(this.indexBuffer)
        }, b.FilterTexture = function(a, c, d, e) {
            this.gl = a, this.frameBuffer = a.createFramebuffer(), this.texture = a.createTexture(), e = e || b.scaleModes.DEFAULT, a.bindTexture(a.TEXTURE_2D, this.texture), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, e === b.scaleModes.LINEAR ? a.LINEAR : a.NEAREST), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, e === b.scaleModes.LINEAR ? a.LINEAR : a.NEAREST), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), a.bindFramebuffer(a.FRAMEBUFFER, this.frameBuffer), a.bindFramebuffer(a.FRAMEBUFFER, this.frameBuffer), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, this.texture, 0), this.renderBuffer = a.createRenderbuffer(), a.bindRenderbuffer(a.RENDERBUFFER, this.renderBuffer), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, this.renderBuffer), this.resize(c, d)
        }, b.FilterTexture.prototype.constructor = b.FilterTexture, b.FilterTexture.prototype.clear = function() {
            var a = this.gl;
            a.clearColor(0, 0, 0, 0), a.clear(a.COLOR_BUFFER_BIT)
        }, b.FilterTexture.prototype.resize = function(a, b) {
            if (this.width !== a || this.height !== b) {
                this.width = a, this.height = b;
                var c = this.gl;
                c.bindTexture(c.TEXTURE_2D, this.texture), c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, a, b, 0, c.RGBA, c.UNSIGNED_BYTE, null), c.bindRenderbuffer(c.RENDERBUFFER, this.renderBuffer), c.renderbufferStorage(c.RENDERBUFFER, c.DEPTH_STENCIL, a, b)
            }
        }, b.FilterTexture.prototype.destroy = function() {
            var a = this.gl;
            a.deleteFramebuffer(this.frameBuffer), a.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null
        }, b.CanvasBuffer = function(a, c) {
            this.width = a, this.height = c, this.canvas = b.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = a, this.canvas.height = c
        }, b.CanvasBuffer.prototype.constructor = b.CanvasBuffer, b.CanvasBuffer.prototype.clear = function() {
            this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height)
        }, b.CanvasBuffer.prototype.resize = function(a, b) {
            this.width = this.canvas.width = a, this.height = this.canvas.height = b
        }, b.CanvasBuffer.prototype.destroy = function() {
            b.CanvasPool.remove(this)
        }, b.CanvasMaskManager = function() {}, b.CanvasMaskManager.prototype.constructor = b.CanvasMaskManager, b.CanvasMaskManager.prototype.pushMask = function(a, c) {
            var d = c.context;
            d.save();
            var e = a.alpha,
                f = a.worldTransform,
                g = c.resolution;
            d.setTransform(f.a * g, f.b * g, f.c * g, f.d * g, f.tx * g, f.ty * g), b.CanvasGraphics.renderGraphicsMask(a, d), d.clip(), a.worldAlpha = e
        }, b.CanvasMaskManager.prototype.popMask = function(a) {
            a.context.restore()
        }, b.CanvasTinter = function() {}, b.CanvasTinter.getTintedTexture = function(a, c) {
            var d = a.tintedTexture || b.CanvasPool.create(this);
            return b.CanvasTinter.tintMethod(a.texture, c, d), d
        }, b.CanvasTinter.tintWithMultiply = function(a, b, c) {
            var d = c.getContext("2d"),
                e = a.crop;
            c.width === e.width && c.height === e.height || (c.width = e.width, c.height = e.height), d.clearRect(0, 0, e.width, e.height), d.fillStyle = "#" + ("00000" + (0 | b).toString(16)).substr(-6), d.fillRect(0, 0, e.width, e.height), d.globalCompositeOperation = "multiply", d.drawImage(a.baseTexture.source, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height), d.globalCompositeOperation = "destination-atop", d.drawImage(a.baseTexture.source, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height)
        }, b.CanvasTinter.tintWithPerPixel = function(a, c, d) {
            var e = d.getContext("2d"),
                f = a.crop;
            d.width = f.width, d.height = f.height, e.globalCompositeOperation = "copy", e.drawImage(a.baseTexture.source, f.x, f.y, f.width, f.height, 0, 0, f.width, f.height);
            for (var g = b.hex2rgb(c), h = g[0], i = g[1], j = g[2], k = e.getImageData(0, 0, f.width, f.height), l = k.data, m = 0; m < l.length; m += 4)
                if (l[m + 0] *= h, l[m + 1] *= i, l[m + 2] *= j, !b.CanvasTinter.canHandleAlpha) {
                    var n = l[m + 3];
                    l[m + 0] /= 255 / n, l[m + 1] /= 255 / n, l[m + 2] /= 255 / n
                }
            e.putImageData(k, 0, 0)
        }, b.CanvasTinter.checkInverseAlpha = function() {
            var a = new b.CanvasBuffer(2, 1);
            a.context.fillStyle = "rgba(10, 20, 30, 0.5)", a.context.fillRect(0, 0, 1, 1);
            var c = a.context.getImageData(0, 0, 1, 1);
            if (null === c) return !1;
            a.context.putImageData(c, 1, 0);
            var d = a.context.getImageData(1, 0, 1, 1);
            return d.data[0] === c.data[0] && d.data[1] === c.data[1] && d.data[2] === c.data[2] && d.data[3] === c.data[3]
        }, b.CanvasTinter.canHandleAlpha = b.CanvasTinter.checkInverseAlpha(), b.CanvasTinter.canUseMultiply = b.canUseNewCanvasBlendModes(), b.CanvasTinter.tintMethod = b.CanvasTinter.canUseMultiply ? b.CanvasTinter.tintWithMultiply : b.CanvasTinter.tintWithPerPixel, b.CanvasRenderer = function(a) {
            this.game = a, b.defaultRenderer || (b.defaultRenderer = this), this.type = b.CANVAS_RENDERER, this.resolution = a.resolution, this.clearBeforeRender = a.clearBeforeRender, this.transparent = a.transparent, this.autoResize = !1, this.width = a.width * this.resolution, this.height = a.height * this.resolution, this.view = a.canvas, this.context = this.view.getContext("2d", {
                alpha: this.transparent
            }), this.refresh = !0, this.count = 0, this.maskManager = new b.CanvasMaskManager, this.renderSession = {
                context: this.context,
                maskManager: this.maskManager,
                scaleMode: null,
                smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
                roundPixels: !1
            }, this.mapBlendModes(), this.resize(this.width, this.height)
        }, b.CanvasRenderer.prototype.constructor = b.CanvasRenderer, b.CanvasRenderer.prototype.render = function(a) {
            this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : a._bgColor && (this.context.fillStyle = a._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(a)
        }, b.CanvasRenderer.prototype.destroy = function(a) {
            void 0 === a && (a = !0), a && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null
        }, b.CanvasRenderer.prototype.resize = function(a, c) {
            this.width = a * this.resolution, this.height = c * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === b.scaleModes.LINEAR)
        }, b.CanvasRenderer.prototype.renderDisplayObject = function(a, b, c) {
            this.renderSession.context = b || this.context, this.renderSession.resolution = this.resolution, a._renderCanvas(this.renderSession, c)
        }, b.CanvasRenderer.prototype.mapBlendModes = function() {
            if (!b.blendModesCanvas) {
                var a = [],
                    c = b.blendModes,
                    d = b.canUseNewCanvasBlendModes();
                a[c.NORMAL] = "source-over", a[c.ADD] = "lighter", a[c.MULTIPLY] = d ? "multiply" : "source-over", a[c.SCREEN] = d ? "screen" : "source-over", a[c.OVERLAY] = d ? "overlay" : "source-over", a[c.DARKEN] = d ? "darken" : "source-over", a[c.LIGHTEN] = d ? "lighten" : "source-over", a[c.COLOR_DODGE] = d ? "color-dodge" : "source-over", a[c.COLOR_BURN] = d ? "color-burn" : "source-over", a[c.HARD_LIGHT] = d ? "hard-light" : "source-over", a[c.SOFT_LIGHT] = d ? "soft-light" : "source-over", a[c.DIFFERENCE] = d ? "difference" : "source-over", a[c.EXCLUSION] = d ? "exclusion" : "source-over", a[c.HUE] = d ? "hue" : "source-over", a[c.SATURATION] = d ? "saturation" : "source-over", a[c.COLOR] = d ? "color" : "source-over", a[c.LUMINOSITY] = d ? "luminosity" : "source-over", b.blendModesCanvas = a
            }
        }, b.BaseTexture = function(a, c) {
            this.resolution = 1, this.width = 100, this.height = 100, this.scaleMode = c || b.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = a, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this._dirty = [!0, !0, !0, !0], a && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1)
        }, b.BaseTexture.prototype.constructor = b.BaseTexture, b.BaseTexture.prototype.forceLoaded = function(a, b) {
            this.hasLoaded = !0, this.width = a, this.height = b, this.dirty()
        }, b.BaseTexture.prototype.destroy = function() {
            this.source && b.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU()
        }, b.BaseTexture.prototype.updateSourceImage = function(a) {}, b.BaseTexture.prototype.dirty = function() {
            for (var a = 0; a < this._glTextures.length; a++) this._dirty[a] = !0
        }, b.BaseTexture.prototype.unloadFromGPU = function() {
            this.dirty();
            for (var a = this._glTextures.length - 1; a >= 0; a--) {
                var c = this._glTextures[a],
                    d = b.glContexts[a];
                d && c && d.deleteTexture(c)
            }
            this._glTextures.length = 0, this.dirty()
        }, b.BaseTexture.fromCanvas = function(a, c) {
            return 0 === a.width && (a.width = 1), 0 === a.height && (a.height = 1), new b.BaseTexture(a, c)
        }, b.TextureSilentFail = !1, b.Texture = function(a, c, d, e) {
            this.noFrame = !1, c || (this.noFrame = !0, c = new b.Rectangle(0, 0, 1, 1)), a instanceof b.Texture && (a = a.baseTexture), this.baseTexture = a, this.frame = c, this.trim = e, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = d || new b.Rectangle(0, 0, 1, 1), a.hasLoaded && (this.noFrame && (c = new b.Rectangle(0, 0, a.width, a.height)), this.setFrame(c))
        }, b.Texture.prototype.constructor = b.Texture, b.Texture.prototype.onBaseTextureLoaded = function() {
            var a = this.baseTexture;
            this.noFrame && (this.frame = new b.Rectangle(0, 0, a.width, a.height)), this.setFrame(this.frame)
        }, b.Texture.prototype.destroy = function(a) {
            a && this.baseTexture.destroy(), this.valid = !1
        }, b.Texture.prototype.setFrame = function(a) {
            if (this.noFrame = !1, this.frame = a, this.width = a.width, this.height = a.height, this.crop.x = a.x, this.crop.y = a.y, this.crop.width = a.width, this.crop.height = a.height, !this.trim && (a.x + a.width > this.baseTexture.width || a.y + a.height > this.baseTexture.height)) {
                if (!b.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
                return void(this.valid = !1)
            }
            this.valid = a && a.width && a.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs()
        }, b.Texture.prototype._updateUvs = function() {
            this._uvs || (this._uvs = new b.TextureUvs);
            var a = this.crop,
                c = this.baseTexture.width,
                d = this.baseTexture.height;
            this._uvs.x0 = a.x / c, this._uvs.y0 = a.y / d, this._uvs.x1 = (a.x + a.width) / c, this._uvs.y1 = a.y / d, this._uvs.x2 = (a.x + a.width) / c, this._uvs.y2 = (a.y + a.height) / d, this._uvs.x3 = a.x / c, this._uvs.y3 = (a.y + a.height) / d
        }, b.Texture.fromCanvas = function(a, c) {
            var d = b.BaseTexture.fromCanvas(a, c);
            return new b.Texture(d)
        }, b.TextureUvs = function() {
            this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0
        }, b.RenderTexture = function(a, c, d, e, f) {
            if (this.width = a || 100, this.height = c || 100, this.resolution = f || 1, this.frame = new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.baseTexture = new b.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = e || b.scaleModes.DEFAULT, this.baseTexture.hasLoaded = !0, b.Texture.call(this, this.baseTexture, new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)), this.renderer = d || b.defaultRenderer, this.renderer.type === b.WEBGL_RENDERER) {
                var g = this.renderer.gl;
                this.baseTexture._dirty[g.id] = !1, this.textureBuffer = new b.FilterTexture(g, this.width, this.height, this.baseTexture.scaleMode), this.baseTexture._glTextures[g.id] = this.textureBuffer.texture, this.render = this.renderWebGL, this.projection = new b.Point(.5 * this.width, .5 * -this.height)
            } else this.render = this.renderCanvas, this.textureBuffer = new b.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas;
            this.valid = !0, this.tempMatrix = new Phaser.Matrix, this._updateUvs()
        }, b.RenderTexture.prototype = Object.create(b.Texture.prototype), b.RenderTexture.prototype.constructor = b.RenderTexture, b.RenderTexture.prototype.resize = function(a, c, d) {
            a === this.width && c === this.height || (this.valid = a > 0 && c > 0, this.width = a, this.height = c, this.frame.width = this.crop.width = a * this.resolution, this.frame.height = this.crop.height = c * this.resolution, d && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.renderer.type === b.WEBGL_RENDERER && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height))
        }, b.RenderTexture.prototype.clear = function() {
            this.valid && (this.renderer.type === b.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear())
        }, b.RenderTexture.prototype.renderWebGL = function(a, b, c) {
            if (this.valid && 0 !== a.alpha) {
                var d = a.worldTransform;
                d.identity(), d.translate(0, 2 * this.projection.y), b && d.append(b), d.scale(1, -1);
                for (var e = 0; e < a.children.length; e++) a.children[e].updateTransform();
                var f = this.renderer.gl;
                f.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), f.bindFramebuffer(f.FRAMEBUFFER, this.textureBuffer.frameBuffer), c && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(a, this.projection, this.textureBuffer.frameBuffer, b), this.renderer.spriteBatch.dirty = !0
            }
        }, b.RenderTexture.prototype.renderCanvas = function(a, b, c) {
            if (this.valid && 0 !== a.alpha) {
                var d = a.worldTransform;
                d.identity(), b && d.append(b);
                for (var e = 0; e < a.children.length; e++) a.children[e].updateTransform();
                c && this.textureBuffer.clear();
                var f = this.renderer.resolution;
                this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(a, this.textureBuffer.context, b), this.renderer.resolution = f
            }
        }, b.RenderTexture.prototype.getImage = function() {
            var a = new Image;
            return a.src = this.getBase64(), a
        }, b.RenderTexture.prototype.getBase64 = function() {
            return this.getCanvas().toDataURL()
        }, b.RenderTexture.prototype.getCanvas = function() {
            if (this.renderer.type === b.WEBGL_RENDERER) {
                var a = this.renderer.gl,
                    c = this.textureBuffer.width,
                    d = this.textureBuffer.height,
                    e = new Uint8Array(4 * c * d);
                a.bindFramebuffer(a.FRAMEBUFFER, this.textureBuffer.frameBuffer), a.readPixels(0, 0, c, d, a.RGBA, a.UNSIGNED_BYTE, e), a.bindFramebuffer(a.FRAMEBUFFER, null);
                var f = new b.CanvasBuffer(c, d),
                    g = f.context.getImageData(0, 0, c, d);
                return g.data.set(e), f.context.putImageData(g, 0, 0), f.canvas
            }
            return this.textureBuffer.canvas
        }, b.AbstractFilter = function(a, b) {
            this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.uniforms = b || {}, this.fragmentSrc = a || []
        }, b.AbstractFilter.prototype.constructor = b.AbstractFilter, b.AbstractFilter.prototype.syncUniforms = function() {
            for (var a = 0, b = this.shaders.length; a < b; a++) this.shaders[a].dirty = !0
        }, b.Strip = function(a) {
            b.DisplayObjectContainer.call(this), this.texture = a, this.uvs = new b.Float32Array([0, 1, 1, 1, 1, 0, 0, 1]), this.vertices = new b.Float32Array([0, 0, 100, 0, 100, 100, 0, 100]), this.colors = new b.Float32Array([1, 1, 1, 1]), this.indices = new b.Uint16Array([0, 1, 2, 3]), this.dirty = !0, this.blendMode = b.blendModes.NORMAL, this.canvasPadding = 0, this.drawMode = b.Strip.DrawModes.TRIANGLE_STRIP
        }, b.Strip.prototype = Object.create(b.DisplayObjectContainer.prototype), b.Strip.prototype.constructor = b.Strip, b.Strip.prototype._renderWebGL = function(a) {
            !this.visible || this.alpha <= 0 || (a.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(a), a.shaderManager.setShader(a.shaderManager.stripShader), this._renderStrip(a), a.spriteBatch.start())
        }, b.Strip.prototype._initWebGL = function(a) {
            var b = a.gl;
            this._vertexBuffer = b.createBuffer(), this._indexBuffer = b.createBuffer(), this._uvBuffer = b.createBuffer(), this._colorBuffer = b.createBuffer(), b.bindBuffer(b.ARRAY_BUFFER, this._vertexBuffer), b.bufferData(b.ARRAY_BUFFER, this.vertices, b.DYNAMIC_DRAW), b.bindBuffer(b.ARRAY_BUFFER, this._uvBuffer), b.bufferData(b.ARRAY_BUFFER, this.uvs, b.STATIC_DRAW), b.bindBuffer(b.ARRAY_BUFFER, this._colorBuffer), b.bufferData(b.ARRAY_BUFFER, this.colors, b.STATIC_DRAW), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indexBuffer), b.bufferData(b.ELEMENT_ARRAY_BUFFER, this.indices, b.STATIC_DRAW)
        }, b.Strip.prototype._renderStrip = function(a) {
            var c = a.gl,
                d = a.projection,
                e = a.offset,
                f = a.shaderManager.stripShader,
                g = this.drawMode === b.Strip.DrawModes.TRIANGLE_STRIP ? c.TRIANGLE_STRIP : c.TRIANGLES;
            a.blendModeManager.setBlendMode(this.blendMode), c.uniformMatrix3fv(f.translationMatrix, !1, this.worldTransform.toArray(!0)), c.uniform2f(f.projectionVector, d.x, -d.y), c.uniform2f(f.offsetVector, -e.x, -e.y), c.uniform1f(f.alpha, this.worldAlpha), this.dirty ? (this.dirty = !1, c.bindBuffer(c.ARRAY_BUFFER, this._vertexBuffer), c.bufferData(c.ARRAY_BUFFER, this.vertices, c.STATIC_DRAW), c.vertexAttribPointer(f.aVertexPosition, 2, c.FLOAT, !1, 0, 0), c.bindBuffer(c.ARRAY_BUFFER, this._uvBuffer), c.bufferData(c.ARRAY_BUFFER, this.uvs, c.STATIC_DRAW), c.vertexAttribPointer(f.aTextureCoord, 2, c.FLOAT, !1, 0, 0), c.activeTexture(c.TEXTURE0), this.texture.baseTexture._dirty[c.id] ? a.renderer.updateTexture(this.texture.baseTexture) : c.bindTexture(c.TEXTURE_2D, this.texture.baseTexture._glTextures[c.id]), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indexBuffer), c.bufferData(c.ELEMENT_ARRAY_BUFFER, this.indices, c.STATIC_DRAW)) : (c.bindBuffer(c.ARRAY_BUFFER, this._vertexBuffer), c.bufferSubData(c.ARRAY_BUFFER, 0, this.vertices), c.vertexAttribPointer(f.aVertexPosition, 2, c.FLOAT, !1, 0, 0), c.bindBuffer(c.ARRAY_BUFFER, this._uvBuffer), c.vertexAttribPointer(f.aTextureCoord, 2, c.FLOAT, !1, 0, 0), c.activeTexture(c.TEXTURE0), this.texture.baseTexture._dirty[c.id] ? a.renderer.updateTexture(this.texture.baseTexture) : c.bindTexture(c.TEXTURE_2D, this.texture.baseTexture._glTextures[c.id]), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), c.drawElements(g, this.indices.length, c.UNSIGNED_SHORT, 0)
        }, b.Strip.prototype._renderCanvas = function(a) {
            var c = a.context,
                d = this.worldTransform,
                e = d.tx * a.resolution + a.shakeX,
                f = d.ty * a.resolution + a.shakeY;
            a.roundPixels ? c.setTransform(d.a, d.b, d.c, d.d, 0 | e, 0 | f) : c.setTransform(d.a, d.b, d.c, d.d, e, f), this.drawMode === b.Strip.DrawModes.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(c) : this._renderCanvasTriangles(c)
        }, b.Strip.prototype._renderCanvasTriangleStrip = function(a) {
            var b = this.vertices,
                c = this.uvs,
                d = b.length / 2;
            this.count++;
            for (var e = 0; e < d - 2; e++) {
                var f = 2 * e;
                this._renderCanvasDrawTriangle(a, b, c, f, f + 2, f + 4)
            }
        }, b.Strip.prototype._renderCanvasTriangles = function(a) {
            var b = this.vertices,
                c = this.uvs,
                d = this.indices,
                e = d.length;
            this.count++;
            for (var f = 0; f < e; f += 3) {
                var g = 2 * d[f],
                    h = 2 * d[f + 1],
                    i = 2 * d[f + 2];
                this._renderCanvasDrawTriangle(a, b, c, g, h, i)
            }
        }, b.Strip.prototype._renderCanvasDrawTriangle = function(a, b, c, d, e, f) {
            var g = this.texture.baseTexture.source,
                h = this.texture.width,
                i = this.texture.height,
                j = b[d],
                k = b[e],
                l = b[f],
                m = b[d + 1],
                n = b[e + 1],
                o = b[f + 1],
                p = c[d] * h,
                q = c[e] * h,
                r = c[f] * h,
                s = c[d + 1] * i,
                t = c[e + 1] * i,
                u = c[f + 1] * i;
            if (this.canvasPadding > 0) {
                var v = this.canvasPadding / this.worldTransform.a,
                    w = this.canvasPadding / this.worldTransform.d,
                    x = (j + k + l) / 3,
                    y = (m + n + o) / 3,
                    z = j - x,
                    A = m - y,
                    B = Math.sqrt(z * z + A * A);
                j = x + z / B * (B + v), m = y + A / B * (B + w), z = k - x, A = n - y, B = Math.sqrt(z * z + A * A), k = x + z / B * (B + v), n = y + A / B * (B + w), z = l - x, A = o - y, B = Math.sqrt(z * z + A * A), l = x + z / B * (B + v), o = y + A / B * (B + w)
            }
            a.save(), a.beginPath(), a.moveTo(j, m), a.lineTo(k, n), a.lineTo(l, o), a.closePath(), a.clip();
            var C = p * t + s * r + q * u - t * r - s * q - p * u,
                D = j * t + s * l + k * u - t * l - s * k - j * u,
                E = p * k + j * r + q * l - k * r - j * q - p * l,
                F = p * t * l + s * k * r + j * q * u - j * t * r - s * q * l - p * k * u,
                G = m * t + s * o + n * u - t * o - s * n - m * u,
                H = p * n + m * r + q * o - n * r - m * q - p * o,
                I = p * t * o + s * n * r + m * q * u - m * t * r - s * q * o - p * n * u;
            a.transform(D / C, G / C, E / C, H / C, F / C, I / C), a.drawImage(g, 0, 0), a.restore()
        }, b.Strip.prototype.renderStripFlat = function(a) {
            var b = this.context,
                c = a.vertices,
                d = c.length / 2;
            this.count++, b.beginPath();
            for (var e = 1; e < d - 2; e++) {
                var f = 2 * e,
                    g = c[f],
                    h = c[f + 2],
                    i = c[f + 4],
                    j = c[f + 1],
                    k = c[f + 3],
                    l = c[f + 5];
                b.moveTo(g, j), b.lineTo(h, k), b.lineTo(i, l)
            }
            b.fillStyle = "#FF0000", b.fill(), b.closePath()
        }, b.Strip.prototype.onTextureUpdate = function() {
            this.updateFrame = !0
        }, b.Strip.prototype.getBounds = function(a) {
            for (var c = a || this.worldTransform, d = c.a, e = c.b, f = c.c, g = c.d, h = c.tx, i = c.ty, j = -(1 / 0), k = -(1 / 0), l = 1 / 0, m = 1 / 0, n = this.vertices, o = 0, p = n.length; o < p; o += 2) {
                var q = n[o],
                    r = n[o + 1],
                    s = d * q + f * r + h,
                    t = g * r + e * q + i;
                l = s < l ? s : l, m = t < m ? t : m, j = s > j ? s : j, k = t > k ? t : k
            }
            if (l === -(1 / 0) || k === 1 / 0) return b.EmptyRectangle;
            var u = this._bounds;
            return u.x = l, u.width = j - l, u.y = m, u.height = k - m, this._currentBounds = u, u
        }, b.Strip.DrawModes = {
            TRIANGLE_STRIP: 0,
            TRIANGLES: 1
        }, b.Rope = function(a, c) {
            b.Strip.call(this, a), this.points = c, this.vertices = new b.Float32Array(4 * c.length), this.uvs = new b.Float32Array(4 * c.length), this.colors = new b.Float32Array(2 * c.length), this.indices = new b.Uint16Array(2 * c.length), this.refresh()
        }, b.Rope.prototype = Object.create(b.Strip.prototype), b.Rope.prototype.constructor = b.Rope, b.Rope.prototype.refresh = function() {
            var a = this.points;
            if (!(a.length < 1)) {
                var b = this.uvs,
                    c = a[0],
                    d = this.indices,
                    e = this.colors;
                this.count -= .2, b[0] = 0, b[1] = 0, b[2] = 0, b[3] = 1, e[0] = 1, e[1] = 1, d[0] = 0, d[1] = 1;
                for (var f, g, h, i = a.length, j = 1; j < i; j++) f = a[j], g = 4 * j, h = j / (i - 1), j % 2 ? (b[g] = h, b[g + 1] = 0, b[g + 2] = h, b[g + 3] = 1) : (b[g] = h, b[g + 1] = 0, b[g + 2] = h, b[g + 3] = 1), g = 2 * j, e[g] = 1, e[g + 1] = 1, g = 2 * j, d[g] = g, d[g + 1] = g + 1, c = f
            }
        }, b.Rope.prototype.updateTransform = function() {
            var a = this.points;
            if (!(a.length < 1)) {
                var c, d = a[0],
                    e = {
                        x: 0,
                        y: 0
                    };
                this.count -= .2;
                for (var f, g, h, i, j, k = this.vertices, l = a.length, m = 0; m < l; m++) f = a[m], g = 4 * m, c = m < a.length - 1 ? a[m + 1] : f, e.y = -(c.x - d.x), e.x = c.y - d.y, h = 10 * (1 - m / (l - 1)), h > 1 && (h = 1), i = Math.sqrt(e.x * e.x + e.y * e.y), j = this.texture.height / 2, e.x /= i, e.y /= i, e.x *= j, e.y *= j, k[g] = f.x + e.x, k[g + 1] = f.y + e.y, k[g + 2] = f.x - e.x, k[g + 3] = f.y - e.y, d = f;
                b.DisplayObjectContainer.prototype.updateTransform.call(this)
            }
        }, b.Rope.prototype.setTexture = function(a) {
            this.texture = a
        }, b.TilingSprite = function(a, c, d) {
            b.Sprite.call(this, a), this._width = c || 128, this._height = d || 128, this.tileScale = new b.Point(1, 1), this.tileScaleOffset = new b.Point(1, 1), this.tilePosition = new b.Point, this.renderable = !0, this.tint = 16777215, this.textureDebug = !1, this.blendMode = b.blendModes.NORMAL, this.canvasBuffer = null, this.tilingTexture = null, this.tilePattern = null, this.refreshTexture = !0, this.frameWidth = 0, this.frameHeight = 0
        }, b.TilingSprite.prototype = Object.create(b.Sprite.prototype), b.TilingSprite.prototype.constructor = b.TilingSprite, b.TilingSprite.prototype.setTexture = function(a) {
            this.texture !== a && (this.texture = a, this.refreshTexture = !0, this.cachedTint = 16777215)
        }, b.TilingSprite.prototype._renderWebGL = function(a) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                if (this._mask && (a.spriteBatch.stop(), a.maskManager.pushMask(this.mask, a), a.spriteBatch.start()), this._filters && (a.spriteBatch.flush(), a.filterManager.pushFilter(this._filterBlock)), this.refreshTexture) {
                    if (this.generateTilingTexture(!0, a), !this.tilingTexture) return;
                    this.tilingTexture.needsUpdate && (a.renderer.updateTexture(this.tilingTexture.baseTexture), this.tilingTexture.needsUpdate = !1)
                }
                a.spriteBatch.renderTilingSprite(this);
                for (var b = 0; b < this.children.length; b++) this.children[b]._renderWebGL(a);
                a.spriteBatch.stop(), this._filters && a.filterManager.popFilter(), this._mask && a.maskManager.popMask(this._mask, a), a.spriteBatch.start()
            }
        }, b.TilingSprite.prototype._renderCanvas = function(a) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                var c = a.context;
                this._mask && a.maskManager.pushMask(this._mask, a), c.globalAlpha = this.worldAlpha;
                var d = this.worldTransform,
                    e = a.resolution,
                    f = d.tx * e + a.shakeX,
                    g = d.ty * e + a.shakeY;
                if (c.setTransform(d.a * e, d.b * e, d.c * e, d.d * e, f, g), this.refreshTexture) {
                    if (this.generateTilingTexture(!1, a), !this.tilingTexture) return;
                    this.tilePattern = c.createPattern(this.tilingTexture.baseTexture.source, "repeat")
                }
                var h = a.currentBlendMode;
                this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, c.globalCompositeOperation = b.blendModesCanvas[a.currentBlendMode]);
                var i = this.tilePosition,
                    j = this.tileScale;
                i.x %= this.tilingTexture.baseTexture.width, i.y %= this.tilingTexture.baseTexture.height, c.scale(j.x, j.y), c.translate(i.x + this.anchor.x * -this._width, i.y + this.anchor.y * -this._height), c.fillStyle = this.tilePattern;
                var f = -i.x,
                    g = -i.y,
                    k = this._width / j.x,
                    l = this._height / j.y;
                a.roundPixels && (f |= 0, g |= 0, k |= 0, l |= 0), c.fillRect(f, g, k, l), c.scale(1 / j.x, 1 / j.y), c.translate(-i.x + this.anchor.x * this._width, -i.y + this.anchor.y * this._height), this._mask && a.maskManager.popMask(a);
                for (var m = 0; m < this.children.length; m++) this.children[m]._renderCanvas(a);
                h !== this.blendMode && (a.currentBlendMode = h, c.globalCompositeOperation = b.blendModesCanvas[h])
            }
        }, b.TilingSprite.prototype.onTextureUpdate = function() {}, b.TilingSprite.prototype.generateTilingTexture = function(a, c) {
            if (this.texture.baseTexture.hasLoaded) {
                var d = this.texture,
                    e = d.frame,
                    f = this._frame.sourceSizeW || this._frame.width,
                    g = this._frame.sourceSizeH || this._frame.height,
                    h = 0,
                    i = 0;
                this._frame.trimmed && (h = this._frame.spriteSourceSizeX, i = this._frame.spriteSourceSizeY), a && (f = b.getNextPowerOfTwo(f), g = b.getNextPowerOfTwo(g)), this.canvasBuffer ? (this.canvasBuffer.resize(f, g), this.tilingTexture.baseTexture.width = f, this.tilingTexture.baseTexture.height = g, this.tilingTexture.needsUpdate = !0) : (this.canvasBuffer = new b.CanvasBuffer(f, g), this.tilingTexture = b.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture.isTiling = !0, this.tilingTexture.needsUpdate = !0), this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", this.canvasBuffer.context.strokeRect(0, 0, f, g));
                var j = d.crop.width,
                    k = d.crop.height;
                j === f && k === g || (j = f, k = g), this.canvasBuffer.context.drawImage(d.baseTexture.source, d.crop.x, d.crop.y, d.crop.width, d.crop.height, h, i, j, k), this.tileScaleOffset.x = e.width / f, this.tileScaleOffset.y = e.height / g, this.refreshTexture = !1, this.tilingTexture.baseTexture._powerOf2 = !0
            }
        }, b.TilingSprite.prototype.getBounds = function() {
            var a = this._width,
                b = this._height,
                c = a * (1 - this.anchor.x),
                d = a * -this.anchor.x,
                e = b * (1 - this.anchor.y),
                f = b * -this.anchor.y,
                g = this.worldTransform,
                h = g.a,
                i = g.b,
                j = g.c,
                k = g.d,
                l = g.tx,
                m = g.ty,
                n = h * d + j * f + l,
                o = k * f + i * d + m,
                p = h * c + j * f + l,
                q = k * f + i * c + m,
                r = h * c + j * e + l,
                s = k * e + i * c + m,
                t = h * d + j * e + l,
                u = k * e + i * d + m,
                v = -(1 / 0),
                w = -(1 / 0),
                x = 1 / 0,
                y = 1 / 0;
            x = n < x ? n : x, x = p < x ? p : x, x = r < x ? r : x, x = t < x ? t : x, y = o < y ? o : y, y = q < y ? q : y, y = s < y ? s : y, y = u < y ? u : y, v = n > v ? n : v, v = p > v ? p : v, v = r > v ? r : v, v = t > v ? t : v, w = o > w ? o : w, w = q > w ? q : w, w = s > w ? s : w, w = u > w ? u : w;
            var z = this._bounds;
            return z.x = x, z.width = v - x, z.y = y, z.height = w - y, this._currentBounds = z, z
        }, b.TilingSprite.prototype.destroy = function() {
            b.Sprite.prototype.destroy.call(this), this.canvasBuffer && (this.canvasBuffer.destroy(), this.canvasBuffer = null), this.tileScale = null, this.tileScaleOffset = null, this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), this.tilingTexture = null)
        }, Object.defineProperty(b.TilingSprite.prototype, "width", {
            get: function() {
                return this._width
            },
            set: function(a) {
                this._width = a
            }
        }), Object.defineProperty(b.TilingSprite.prototype, "height", {
            get: function() {
                return this._height
            },
            set: function(a) {
                this._height = a
            }
        }), "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = b), exports.PIXI = b) : "undefined" != typeof define && define.amd ? define("PIXI", function() {
            return a.PIXI = b
        }()) : a.PIXI = b, b
    }.call(this),
    function() {
        function a(a, b) {
            this._scaleFactor = a, this._deltaMode = b, this.originalEvent = null
        }
        var b = this,
            c = c || {
                VERSION: "2.6.2",
                GAMES: [],
                AUTO: 0,
                CANVAS: 1,
                WEBGL: 2,
                HEADLESS: 3,
                NONE: 0,
                LEFT: 1,
                RIGHT: 2,
                UP: 3,
                DOWN: 4,
                SPRITE: 0,
                BUTTON: 1,
                IMAGE: 2,
                GRAPHICS: 3,
                TEXT: 4,
                TILESPRITE: 5,
                BITMAPTEXT: 6,
                GROUP: 7,
                RENDERTEXTURE: 8,
                TILEMAP: 9,
                TILEMAPLAYER: 10,
                EMITTER: 11,
                POLYGON: 12,
                BITMAPDATA: 13,
                CANVAS_FILTER: 14,
                WEBGL_FILTER: 15,
                ELLIPSE: 16,
                SPRITEBATCH: 17,
                RETROFONT: 18,
                POINTER: 19,
                ROPE: 20,
                CIRCLE: 21,
                RECTANGLE: 22,
                LINE: 23,
                MATRIX: 24,
                POINT: 25,
                ROUNDEDRECTANGLE: 26,
                CREATURE: 27,
                VIDEO: 28,
                PENDING_ATLAS: -1,
                HORIZONTAL: 0,
                VERTICAL: 1,
                LANDSCAPE: 0,
                PORTRAIT: 1,
                ANGLE_UP: 270,
                ANGLE_DOWN: 90,
                ANGLE_LEFT: 180,
                ANGLE_RIGHT: 0,
                ANGLE_NORTH_EAST: 315,
                ANGLE_NORTH_WEST: 225,
                ANGLE_SOUTH_EAST: 45,
                ANGLE_SOUTH_WEST: 135,
                TOP_LEFT: 0,
                TOP_CENTER: 1,
                TOP_RIGHT: 2,
                LEFT_TOP: 3,
                LEFT_CENTER: 4,
                LEFT_BOTTOM: 5,
                CENTER: 6,
                RIGHT_TOP: 7,
                RIGHT_CENTER: 8,
                RIGHT_BOTTOM: 9,
                BOTTOM_LEFT: 10,
                BOTTOM_CENTER: 11,
                BOTTOM_RIGHT: 12,
                blendModes: {
                    NORMAL: 0,
                    ADD: 1,
                    MULTIPLY: 2,
                    SCREEN: 3,
                    OVERLAY: 4,
                    DARKEN: 5,
                    LIGHTEN: 6,
                    COLOR_DODGE: 7,
                    COLOR_BURN: 8,
                    HARD_LIGHT: 9,
                    SOFT_LIGHT: 10,
                    DIFFERENCE: 11,
                    EXCLUSION: 12,
                    HUE: 13,
                    SATURATION: 14,
                    COLOR: 15,
                    LUMINOSITY: 16
                },
                scaleModes: {
                    DEFAULT: 0,
                    LINEAR: 0,
                    NEAREST: 1
                },
                PIXI: PIXI || {}
            };
        if (Math.trunc || (Math.trunc = function(a) {
            return a < 0 ? Math.ceil(a) : Math.floor(a)
        }), Function.prototype.bind || (Function.prototype.bind = function() {
            var a = Array.prototype.slice;
            return function(b) {
                function c() {
                    var f = e.concat(a.call(arguments));
                    d.apply(this instanceof c ? this : b, f)
                }
                var d = this,
                    e = a.call(arguments, 1);
                if ("function" != typeof d) throw new TypeError;
                return c.prototype = function f(a) {
                    if (a && (f.prototype = a), !(this instanceof f)) return new f
                }(d.prototype), c
            }
        }()), Array.isArray || (Array.isArray = function(a) {
            return "[object Array]" === Object.prototype.toString.call(a)
        }), Array.prototype.forEach || (Array.prototype.forEach = function(a) {
            "use strict";
            if (void 0 === this || null === this) throw new TypeError;
            var b = Object(this),
                c = b.length >>> 0;
            if ("function" != typeof a) throw new TypeError;
            for (var d = arguments.length >= 2 ? arguments[1] : void 0, e = 0; e < c; e++) e in b && a.call(d, b[e], e, b)
        }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
            var d = function(a) {
                var b = new Array;
                window[a] = function(a) {
                    if ("number" == typeof a) {
                        Array.call(this, a), this.length = a;
                        for (var b = 0; b < this.length; b++) this[b] = 0
                    } else {
                        Array.call(this, a.length), this.length = a.length;
                        for (var b = 0; b < this.length; b++) this[b] = a[b]
                    }
                }, window[a].prototype = b, window[a].constructor = window[a]
            };
            d("Uint32Array"), d("Int16Array")
        }
        window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {}), c.Utils = {
                reverseString: function(a) {
                    return a.split("").reverse().join("")
                },
                getProperty: function(a, b) {
                    for (var c = b.split("."), d = c.pop(), e = c.length, f = 1, g = c[0]; f < e && (a = a[g]);) g = c[f], f++;
                    return a ? a[d] : null
                },
                setProperty: function(a, b, c) {
                    for (var d = b.split("."), e = d.pop(), f = d.length, g = 1, h = d[0]; g < f && (a = a[h]);) h = d[g], g++;
                    return a && (a[e] = c), a
                },
                chanceRoll: function(a) {
                    return void 0 === a && (a = 50), a > 0 && 100 * Math.random() <= a
                },
                randomChoice: function(a, b) {
                    return Math.random() < .5 ? a : b
                },
                parseDimension: function(a, b) {
                    var c = 0,
                        d = 0;
                    return "string" == typeof a ? "%" === a.substr(-1) ? (c = parseInt(a, 10) / 100, d = 0 === b ? window.innerWidth * c : window.innerHeight * c) : d = parseInt(a, 10) : d = a, d
                },
                pad: function(a, b, c, d) {
                    if (void 0 === b) var b = 0;
                    if (void 0 === c) var c = " ";
                    if (void 0 === d) var d = 3;
                    a = a.toString();
                    var e = 0;
                    if (b + 1 >= a.length) switch (d) {
                        case 1:
                            a = new Array(b + 1 - a.length).join(c) + a;
                            break;
                        case 3:
                            var f = Math.ceil((e = b - a.length) / 2),
                                g = e - f;
                            a = new Array(g + 1).join(c) + a + new Array(f + 1).join(c);
                            break;
                        default:
                            a += new Array(b + 1 - a.length).join(c)
                    }
                    return a
                },
                isPlainObject: function(a) {
                    if ("object" != typeof a || a.nodeType || a === a.window) return !1;
                    try {
                        if (a.constructor && !{}.hasOwnProperty.call(a.constructor.prototype, "isPrototypeOf")) return !1
                    } catch (a) {
                        return !1
                    }
                    return !0
                },
                extend: function() {
                    var a, b, d, e, f, g, h = arguments[0] || {},
                        i = 1,
                        j = arguments.length,
                        k = !1;
                    for ("boolean" == typeof h && (k = h, h = arguments[1] || {}, i = 2), j === i && (h = this, --i); i < j; i++)
                        if (null != (a = arguments[i]))
                            for (b in a) d = h[b], e = a[b], h !== e && (k && e && (c.Utils.isPlainObject(e) || (f = Array.isArray(e))) ? (f ? (f = !1, g = d && Array.isArray(d) ? d : []) : g = d && c.Utils.isPlainObject(d) ? d : {}, h[b] = c.Utils.extend(k, g, e)) : void 0 !== e && (h[b] = e));
                    return h
                },
                mixinPrototype: function(a, b, c) {
                    void 0 === c && (c = !1);
                    for (var d = Object.keys(b), e = 0; e < d.length; e++) {
                        var f = d[e],
                            g = b[f];
                        !c && f in a || (!g || "function" != typeof g.get && "function" != typeof g.set ? a[f] = g : "function" == typeof g.clone ? a[f] = g.clone() : Object.defineProperty(a, f, g))
                    }
                },
                mixin: function(a, b) {
                    if (!a || "object" != typeof a) return b;
                    for (var d in a) {
                        var e = a[d];
                        if (!e.childNodes && !e.cloneNode) {
                            var f = typeof a[d];
                            a[d] && "object" === f ? typeof b[d] === f ? b[d] = c.Utils.mixin(a[d], b[d]) : b[d] = c.Utils.mixin(a[d], new e.constructor) : b[d] = a[d]
                        }
                    }
                    return b
                }
            }, c.Circle = function(a, b, d) {
                a = a || 0, b = b || 0, d = d || 0, this.x = a, this.y = b, this._diameter = d, this._radius = 0, d > 0 && (this._radius = .5 * d), this.type = c.CIRCLE
            }, c.Circle.prototype = {
                circumference: function() {
                    return 2 * (Math.PI * this._radius)
                },
                random: function(a) {
                    void 0 === a && (a = new c.Point);
                    var b = 2 * Math.PI * Math.random(),
                        d = Math.random() + Math.random(),
                        e = d > 1 ? 2 - d : d,
                        f = e * Math.cos(b),
                        g = e * Math.sin(b);
                    return a.x = this.x + f * this.radius, a.y = this.y + g * this.radius, a
                },
                getBounds: function() {
                    return new c.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter)
                },
                setTo: function(a, b, c) {
                    return this.x = a, this.y = b, this._diameter = c, this._radius = .5 * c, this
                },
                copyFrom: function(a) {
                    return this.setTo(a.x, a.y, a.diameter)
                },
                copyTo: function(a) {
                    return a.x = this.x, a.y = this.y, a.diameter = this._diameter, a
                },
                distance: function(a, b) {
                    var d = c.Math.distance(this.x, this.y, a.x, a.y);
                    return b ? Math.round(d) : d
                },
                clone: function(a) {
                    return void 0 === a || null === a ? a = new c.Circle(this.x, this.y, this.diameter) : a.setTo(this.x, this.y, this.diameter), a
                },
                contains: function(a, b) {
                    return c.Circle.contains(this, a, b)
                },
                circumferencePoint: function(a, b, d) {
                    return c.Circle.circumferencePoint(this, a, b, d)
                },
                offset: function(a, b) {
                    return this.x += a, this.y += b, this
                },
                offsetPoint: function(a) {
                    return this.offset(a.x, a.y)
                },
                toString: function() {
                    return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
                }
            }, c.Circle.prototype.constructor = c.Circle, Object.defineProperty(c.Circle.prototype, "diameter", {
                get: function() {
                    return this._diameter
                },
                set: function(a) {
                    a > 0 && (this._diameter = a, this._radius = .5 * a)
                }
            }), Object.defineProperty(c.Circle.prototype, "radius", {
                get: function() {
                    return this._radius
                },
                set: function(a) {
                    a > 0 && (this._radius = a, this._diameter = 2 * a)
                }
            }), Object.defineProperty(c.Circle.prototype, "left", {
                get: function() {
                    return this.x - this._radius
                },
                set: function(a) {
                    a > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - a
                }
            }), Object.defineProperty(c.Circle.prototype, "right", {
                get: function() {
                    return this.x + this._radius
                },
                set: function(a) {
                    a < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = a - this.x
                }
            }), Object.defineProperty(c.Circle.prototype, "top", {
                get: function() {
                    return this.y - this._radius
                },
                set: function(a) {
                    a > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - a
                }
            }), Object.defineProperty(c.Circle.prototype, "bottom", {
                get: function() {
                    return this.y + this._radius
                },
                set: function(a) {
                    a < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = a - this.y
                }
            }), Object.defineProperty(c.Circle.prototype, "area", {
                get: function() {
                    return this._radius > 0 ? Math.PI * this._radius * this._radius : 0
                }
            }), Object.defineProperty(c.Circle.prototype, "empty", {
                get: function() {
                    return 0 === this._diameter
                },
                set: function(a) {
                    a === !0 && this.setTo(0, 0, 0)
                }
            }), c.Circle.contains = function(a, b, c) {
                if (a.radius > 0 && b >= a.left && b <= a.right && c >= a.top && c <= a.bottom) {
                    var d = (a.x - b) * (a.x - b),
                        e = (a.y - c) * (a.y - c);
                    return d + e <= a.radius * a.radius
                }
                return !1
            }, c.Circle.equals = function(a, b) {
                return a.x === b.x && a.y === b.y && a.diameter === b.diameter
            }, c.Circle.intersects = function(a, b) {
                return c.Math.distance(a.x, a.y, b.x, b.y) <= a.radius + b.radius
            }, c.Circle.circumferencePoint = function(a, b, d, e) {
                return void 0 === d && (d = !1), void 0 === e && (e = new c.Point), d === !0 && (b = c.Math.degToRad(b)), e.x = a.x + a.radius * Math.cos(b), e.y = a.y + a.radius * Math.sin(b), e
            }, c.Circle.intersectsRectangle = function(a, b) {
                var c = Math.abs(a.x - b.x - b.halfWidth),
                    d = b.halfWidth + a.radius;
                if (c > d) return !1;
                var e = Math.abs(a.y - b.y - b.halfHeight),
                    f = b.halfHeight + a.radius;
                if (e > f) return !1;
                if (c <= b.halfWidth || e <= b.halfHeight) return !0;
                var g = c - b.halfWidth,
                    h = e - b.halfHeight,
                    i = g * g,
                    j = h * h,
                    k = a.radius * a.radius;
                return i + j <= k
            }, PIXI.Circle = c.Circle, c.Ellipse = function(a, b, d, e) {
                a = a || 0, b = b || 0, d = d || 0, e = e || 0, this.x = a, this.y = b, this.width = d, this.height = e, this.type = c.ELLIPSE
            }, c.Ellipse.prototype = {
                setTo: function(a, b, c, d) {
                    return this.x = a, this.y = b, this.width = c, this.height = d, this
                },
                getBounds: function() {
                    return new c.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height)
                },
                copyFrom: function(a) {
                    return this.setTo(a.x, a.y, a.width, a.height)
                },
                copyTo: function(a) {
                    return a.x = this.x, a.y = this.y, a.width = this.width, a.height = this.height, a
                },
                clone: function(a) {
                    return void 0 === a || null === a ? a = new c.Ellipse(this.x, this.y, this.width, this.height) : a.setTo(this.x, this.y, this.width, this.height), a
                },
                contains: function(a, b) {
                    return c.Ellipse.contains(this, a, b)
                },
                random: function(a) {
                    void 0 === a && (a = new c.Point);
                    var b = Math.random() * Math.PI * 2,
                        d = Math.random();
                    return a.x = Math.sqrt(d) * Math.cos(b), a.y = Math.sqrt(d) * Math.sin(b), a.x = this.x + a.x * this.width / 2, a.y = this.y + a.y * this.height / 2, a
                },
                toString: function() {
                    return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
                }
            }, c.Ellipse.prototype.constructor = c.Ellipse, Object.defineProperty(c.Ellipse.prototype, "left", {
                get: function() {
                    return this.x
                },
                set: function(a) {
                    this.x = a
                }
            }), Object.defineProperty(c.Ellipse.prototype, "right", {
                get: function() {
                    return this.x + this.width
                },
                set: function(a) {
                    a < this.x ? this.width = 0 : this.width = a - this.x
                }
            }), Object.defineProperty(c.Ellipse.prototype, "top", {
                get: function() {
                    return this.y
                },
                set: function(a) {
                    this.y = a
                }
            }), Object.defineProperty(c.Ellipse.prototype, "bottom", {
                get: function() {
                    return this.y + this.height
                },
                set: function(a) {
                    a < this.y ? this.height = 0 : this.height = a - this.y
                }
            }), Object.defineProperty(c.Ellipse.prototype, "empty", {
                get: function() {
                    return 0 === this.width || 0 === this.height
                },
                set: function(a) {
                    a === !0 && this.setTo(0, 0, 0, 0)
                }
            }), c.Ellipse.contains = function(a, b, c) {
                if (a.width <= 0 || a.height <= 0) return !1;
                var d = (b - a.x) / a.width - .5,
                    e = (c - a.y) / a.height - .5;
                return d *= d, e *= e, d + e < .25
            }, PIXI.Ellipse = c.Ellipse, c.Line = function(a, b, d, e) {
                a = a || 0, b = b || 0, d = d || 0, e = e || 0, this.start = new c.Point(a, b), this.end = new c.Point(d, e), this.type = c.LINE
            }, c.Line.prototype = {
                setTo: function(a, b, c, d) {
                    return this.start.setTo(a, b), this.end.setTo(c, d), this
                },
                fromSprite: function(a, b, c) {
                    return void 0 === c && (c = !1), c ? this.setTo(a.center.x, a.center.y, b.center.x, b.center.y) : this.setTo(a.x, a.y, b.x, b.y)
                },
                fromAngle: function(a, b, c, d) {
                    return this.start.setTo(a, b), this.end.setTo(a + Math.cos(c) * d, b + Math.sin(c) * d), this
                },
                rotate: function(a, b) {
                    var c = (this.start.x + this.end.x) / 2,
                        d = (this.start.y + this.end.y) / 2;
                    return this.start.rotate(c, d, a, b), this.end.rotate(c, d, a, b), this
                },
                rotateAround: function(a, b, c, d) {
                    return this.start.rotate(a, b, c, d), this.end.rotate(a, b, c, d), this
                },
                intersects: function(a, b, d) {
                    return c.Line.intersectsPoints(this.start, this.end, a.start, a.end, b, d)
                },
                reflect: function(a) {
                    return c.Line.reflect(this, a)
                },
                midPoint: function(a) {
                    return void 0 === a && (a = new c.Point), a.x = (this.start.x + this.end.x) / 2, a.y = (this.start.y + this.end.y) / 2, a
                },
                centerOn: function(a, b) {
                    var c = (this.start.x + this.end.x) / 2,
                        d = (this.start.y + this.end.y) / 2,
                        e = a - c,
                        f = b - d;
                    this.start.add(e, f), this.end.add(e, f)
                },
                pointOnLine: function(a, b) {
                    return (a - this.start.x) * (this.end.y - this.start.y) === (this.end.x - this.start.x) * (b - this.start.y)
                },
                pointOnSegment: function(a, b) {
                    var c = Math.min(this.start.x, this.end.x),
                        d = Math.max(this.start.x, this.end.x),
                        e = Math.min(this.start.y, this.end.y),
                        f = Math.max(this.start.y, this.end.y);
                    return this.pointOnLine(a, b) && a >= c && a <= d && b >= e && b <= f
                },
                random: function(a) {
                    void 0 === a && (a = new c.Point);
                    var b = Math.random();
                    return a.x = this.start.x + b * (this.end.x - this.start.x), a.y = this.start.y + b * (this.end.y - this.start.y), a
                },
                coordinatesOnLine: function(a, b) {
                    void 0 === a && (a = 1), void 0 === b && (b = []);
                    var c = Math.round(this.start.x),
                        d = Math.round(this.start.y),
                        e = Math.round(this.end.x),
                        f = Math.round(this.end.y),
                        g = Math.abs(e - c),
                        h = Math.abs(f - d),
                        i = c < e ? 1 : -1,
                        j = d < f ? 1 : -1,
                        k = g - h;
                    b.push([c, d]);
                    for (var l = 1; c !== e || d !== f;) {
                        var m = k << 1;
                        m > -h && (k -= h, c += i), m < g && (k += g, d += j), l % a === 0 && b.push([c, d]), l++
                    }
                    return b
                },
                clone: function(a) {
                    return void 0 === a || null === a ? a = new c.Line(this.start.x, this.start.y, this.end.x, this.end.y) : a.setTo(this.start.x, this.start.y, this.end.x, this.end.y), a
                }
            }, Object.defineProperty(c.Line.prototype, "length", {
                get: function() {
                    return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
                }
            }), Object.defineProperty(c.Line.prototype, "angle", {
                get: function() {
                    return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x)
                }
            }), Object.defineProperty(c.Line.prototype, "slope", {
                get: function() {
                    return (this.end.y - this.start.y) / (this.end.x - this.start.x)
                }
            }), Object.defineProperty(c.Line.prototype, "perpSlope", {
                get: function() {
                    return -((this.end.x - this.start.x) / (this.end.y - this.start.y))
                }
            }), Object.defineProperty(c.Line.prototype, "x", {
                get: function() {
                    return Math.min(this.start.x, this.end.x)
                }
            }), Object.defineProperty(c.Line.prototype, "y", {
                get: function() {
                    return Math.min(this.start.y, this.end.y)
                }
            }), Object.defineProperty(c.Line.prototype, "left", {
                get: function() {
                    return Math.min(this.start.x, this.end.x)
                }
            }), Object.defineProperty(c.Line.prototype, "right", {
                get: function() {
                    return Math.max(this.start.x, this.end.x)
                }
            }), Object.defineProperty(c.Line.prototype, "top", {
                get: function() {
                    return Math.min(this.start.y, this.end.y)
                }
            }), Object.defineProperty(c.Line.prototype, "bottom", {
                get: function() {
                    return Math.max(this.start.y, this.end.y)
                }
            }), Object.defineProperty(c.Line.prototype, "width", {
                get: function() {
                    return Math.abs(this.start.x - this.end.x)
                }
            }), Object.defineProperty(c.Line.prototype, "height", {
                get: function() {
                    return Math.abs(this.start.y - this.end.y)
                }
            }), Object.defineProperty(c.Line.prototype, "normalX", {
                get: function() {
                    return Math.cos(this.angle - 1.5707963267948966)
                }
            }), Object.defineProperty(c.Line.prototype, "normalY", {
                get: function() {
                    return Math.sin(this.angle - 1.5707963267948966)
                }
            }), Object.defineProperty(c.Line.prototype, "normalAngle", {
                get: function() {
                    return c.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI)
                }
            }), c.Line.intersectsPoints = function(a, b, d, e, f, g) {
                void 0 === f && (f = !0), void 0 === g && (g = new c.Point);
                var h = b.y - a.y,
                    i = e.y - d.y,
                    j = a.x - b.x,
                    k = d.x - e.x,
                    l = b.x * a.y - a.x * b.y,
                    m = e.x * d.y - d.x * e.y,
                    n = h * k - i * j;
                if (0 === n) return null;
                if (g.x = (j * m - k * l) / n, g.y = (i * l - h * m) / n, f) {
                    var o = (e.y - d.y) * (b.x - a.x) - (e.x - d.x) * (b.y - a.y),
                        p = ((e.x - d.x) * (a.y - d.y) - (e.y - d.y) * (a.x - d.x)) / o,
                        q = ((b.x - a.x) * (a.y - d.y) - (b.y - a.y) * (a.x - d.x)) / o;
                    return p >= 0 && p <= 1 && q >= 0 && q <= 1 ? g : null
                }
                return g
            }, c.Line.intersects = function(a, b, d, e) {
                return c.Line.intersectsPoints(a.start, a.end, b.start, b.end, d, e)
            }, c.Line.intersectsRectangle = function(a, b) {
                if (!c.Rectangle.intersects(a, b)) return !1;
                var d = a.start.x,
                    e = a.start.y,
                    f = a.end.x,
                    g = a.end.y,
                    h = b.x,
                    i = b.y,
                    j = b.right,
                    k = b.bottom,
                    l = 0;
                if (d >= h && d <= j && e >= i && e <= k || f >= h && f <= j && g >= i && g <= k) return !0;
                if (d < h && f >= h) {
                    if (l = e + (g - e) * (h - d) / (f - d), l > i && l <= k) return !0
                } else if (d > j && f <= j && (l = e + (g - e) * (j - d) / (f - d), l >= i && l <= k)) return !0;
                if (e < i && g >= i) {
                    if (l = d + (f - d) * (i - e) / (g - e), l >= h && l <= j) return !0
                } else if (e > k && g <= k && (l = d + (f - d) * (k - e) / (g - e), l >= h && l <= j)) return !0;
                return !1
            }, c.Line.reflect = function(a, b) {
                return 2 * b.normalAngle - 3.141592653589793 - a.angle
            }, c.Matrix = function(a, b, d, e, f, g) {
                void 0 !== a && null !== a || (a = 1), void 0 !== b && null !== b || (b = 0), void 0 !== d && null !== d || (d = 0), void 0 !== e && null !== e || (e = 1), void 0 !== f && null !== f || (f = 0), void 0 !== g && null !== g || (g = 0), this.a = a, this.b = b, this.c = d, this.d = e, this.tx = f, this.ty = g, this.type = c.MATRIX
            }, c.Matrix.prototype = {
                fromArray: function(a) {
                    return this.setTo(a[0], a[1], a[3], a[4], a[2], a[5])
                },
                setTo: function(a, b, c, d, e, f) {
                    return this.a = a, this.b = b, this.c = c, this.d = d, this.tx = e, this.ty = f, this
                },
                clone: function(a) {
                    return void 0 === a || null === a ? a = new c.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (a.a = this.a, a.b = this.b, a.c = this.c, a.d = this.d, a.tx = this.tx, a.ty = this.ty), a
                },
                copyTo: function(a) {
                    return a.copyFrom(this), a
                },
                copyFrom: function(a) {
                    return this.a = a.a, this.b = a.b, this.c = a.c, this.d = a.d, this.tx = a.tx, this.ty = a.ty, this
                },
                toArray: function(a, b) {
                    return void 0 === b && (b = new PIXI.Float32Array(9)), a ? (b[0] = this.a, b[1] = this.b, b[2] = 0, b[3] = this.c, b[4] = this.d, b[5] = 0, b[6] = this.tx, b[7] = this.ty, b[8] = 1) : (b[0] = this.a, b[1] = this.c, b[2] = this.tx, b[3] = this.b, b[4] = this.d, b[5] = this.ty, b[6] = 0, b[7] = 0, b[8] = 1), b
                },
                apply: function(a, b) {
                    return void 0 === b && (b = new c.Point), b.x = this.a * a.x + this.c * a.y + this.tx, b.y = this.b * a.x + this.d * a.y + this.ty, b
                },
                applyInverse: function(a, b) {
                    void 0 === b && (b = new c.Point);
                    var d = 1 / (this.a * this.d + this.c * -this.b),
                        e = a.x,
                        f = a.y;
                    return b.x = this.d * d * e + -this.c * d * f + (this.ty * this.c - this.tx * this.d) * d, b.y = this.a * d * f + -this.b * d * e + (-this.ty * this.a + this.tx * this.b) * d, b
                },
                translate: function(a, b) {
                    return this.tx += a, this.ty += b, this
                },
                scale: function(a, b) {
                    return this.a *= a, this.d *= b, this.c *= a, this.b *= b, this.tx *= a, this.ty *= b, this
                },
                rotate: function(a) {
                    var b = Math.cos(a),
                        c = Math.sin(a),
                        d = this.a,
                        e = this.c,
                        f = this.tx;
                    return this.a = d * b - this.b * c, this.b = d * c + this.b * b, this.c = e * b - this.d * c, this.d = e * c + this.d * b, this.tx = f * b - this.ty * c, this.ty = f * c + this.ty * b, this
                },
                append: function(a) {
                    var b = this.a,
                        c = this.b,
                        d = this.c,
                        e = this.d;
                    return this.a = a.a * b + a.b * d, this.b = a.a * c + a.b * e, this.c = a.c * b + a.d * d, this.d = a.c * c + a.d * e, this.tx = a.tx * b + a.ty * d + this.tx, this.ty = a.tx * c + a.ty * e + this.ty, this
                },
                identity: function() {
                    return this.setTo(1, 0, 0, 1, 0, 0)
                }
            }, c.identityMatrix = new c.Matrix, PIXI.Matrix = c.Matrix,
            PIXI.identityMatrix = c.identityMatrix, c.Point = function(a, b) {
                a = a || 0, b = b || 0, this.x = a, this.y = b, this.type = c.POINT
            }, c.Point.prototype = {
                copyFrom: function(a) {
                    return this.setTo(a.x, a.y)
                },
                invert: function() {
                    return this.setTo(this.y, this.x)
                },
                setTo: function(a, b) {
                    return this.x = a || 0, this.y = b || (0 !== b ? this.x : 0), this
                },
                set: function(a, b) {
                    return this.x = a || 0, this.y = b || (0 !== b ? this.x : 0), this
                },
                add: function(a, b) {
                    return this.x += a, this.y += b, this
                },
                subtract: function(a, b) {
                    return this.x -= a, this.y -= b, this
                },
                multiply: function(a, b) {
                    return this.x *= a, this.y *= b, this
                },
                divide: function(a, b) {
                    return this.x /= a, this.y /= b, this
                },
                clampX: function(a, b) {
                    return this.x = c.Math.clamp(this.x, a, b), this
                },
                clampY: function(a, b) {
                    return this.y = c.Math.clamp(this.y, a, b), this
                },
                clamp: function(a, b) {
                    return this.x = c.Math.clamp(this.x, a, b), this.y = c.Math.clamp(this.y, a, b), this
                },
                clone: function(a) {
                    return void 0 === a || null === a ? a = new c.Point(this.x, this.y) : a.setTo(this.x, this.y), a
                },
                copyTo: function(a) {
                    return a.x = this.x, a.y = this.y, a
                },
                distance: function(a, b) {
                    return c.Point.distance(this, a, b)
                },
                equals: function(a) {
                    return a.x === this.x && a.y === this.y
                },
                angle: function(a, b) {
                    return void 0 === b && (b = !1), b ? c.Math.radToDeg(Math.atan2(a.y - this.y, a.x - this.x)) : Math.atan2(a.y - this.y, a.x - this.x)
                },
                rotate: function(a, b, d, e, f) {
                    return c.Point.rotate(this, a, b, d, e, f)
                },
                getMagnitude: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                getMagnitudeSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                setMagnitude: function(a) {
                    return this.normalize().multiply(a, a)
                },
                normalize: function() {
                    if (!this.isZero()) {
                        var a = this.getMagnitude();
                        this.x /= a, this.y /= a
                    }
                    return this
                },
                isZero: function() {
                    return 0 === this.x && 0 === this.y
                },
                dot: function(a) {
                    return this.x * a.x + this.y * a.y
                },
                cross: function(a) {
                    return this.x * a.y - this.y * a.x
                },
                perp: function() {
                    return this.setTo(-this.y, this.x)
                },
                rperp: function() {
                    return this.setTo(this.y, -this.x)
                },
                normalRightHand: function() {
                    return this.setTo(this.y * -1, this.x)
                },
                floor: function() {
                    return this.setTo(Math.floor(this.x), Math.floor(this.y))
                },
                ceil: function() {
                    return this.setTo(Math.ceil(this.x), Math.ceil(this.y))
                },
                toString: function() {
                    return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
                }
            }, c.Point.prototype.constructor = c.Point, c.Point.add = function(a, b, d) {
                return void 0 === d && (d = new c.Point), d.x = a.x + b.x, d.y = a.y + b.y, d
            }, c.Point.subtract = function(a, b, d) {
                return void 0 === d && (d = new c.Point), d.x = a.x - b.x, d.y = a.y - b.y, d
            }, c.Point.multiply = function(a, b, d) {
                return void 0 === d && (d = new c.Point), d.x = a.x * b.x, d.y = a.y * b.y, d
            }, c.Point.divide = function(a, b, d) {
                return void 0 === d && (d = new c.Point), d.x = a.x / b.x, d.y = a.y / b.y, d
            }, c.Point.equals = function(a, b) {
                return a.x === b.x && a.y === b.y
            }, c.Point.angle = function(a, b) {
                return Math.atan2(a.y - b.y, a.x - b.x)
            }, c.Point.negative = function(a, b) {
                return void 0 === b && (b = new c.Point), b.setTo(-a.x, -a.y)
            }, c.Point.multiplyAdd = function(a, b, d, e) {
                return void 0 === e && (e = new c.Point), e.setTo(a.x + b.x * d, a.y + b.y * d)
            }, c.Point.interpolate = function(a, b, d, e) {
                return void 0 === e && (e = new c.Point), e.setTo(a.x + (b.x - a.x) * d, a.y + (b.y - a.y) * d)
            }, c.Point.perp = function(a, b) {
                return void 0 === b && (b = new c.Point), b.setTo(-a.y, a.x)
            }, c.Point.rperp = function(a, b) {
                return void 0 === b && (b = new c.Point), b.setTo(a.y, -a.x)
            }, c.Point.distance = function(a, b, d) {
                var e = c.Math.distance(a.x, a.y, b.x, b.y);
                return d ? Math.round(e) : e
            }, c.Point.project = function(a, b, d) {
                void 0 === d && (d = new c.Point);
                var e = a.dot(b) / b.getMagnitudeSq();
                return 0 !== e && d.setTo(e * b.x, e * b.y), d
            }, c.Point.projectUnit = function(a, b, d) {
                void 0 === d && (d = new c.Point);
                var e = a.dot(b);
                return 0 !== e && d.setTo(e * b.x, e * b.y), d
            }, c.Point.normalRightHand = function(a, b) {
                return void 0 === b && (b = new c.Point), b.setTo(a.y * -1, a.x)
            }, c.Point.normalize = function(a, b) {
                void 0 === b && (b = new c.Point);
                var d = a.getMagnitude();
                return 0 !== d && b.setTo(a.x / d, a.y / d), b
            }, c.Point.rotate = function(a, b, d, e, f, g) {
                if (f && (e = c.Math.degToRad(e)), void 0 === g) {
                    a.subtract(b, d);
                    var h = Math.sin(e),
                        i = Math.cos(e),
                        j = i * a.x - h * a.y,
                        k = h * a.x + i * a.y;
                    a.x = j + b, a.y = k + d
                } else {
                    var l = e + Math.atan2(a.y - d, a.x - b);
                    a.x = b + g * Math.cos(l), a.y = d + g * Math.sin(l)
                }
                return a
            }, c.Point.centroid = function(a, b) {
                if (void 0 === b && (b = new c.Point), "[object Array]" !== Object.prototype.toString.call(a)) throw new Error("Phaser.Point. Parameter 'points' must be an array");
                var d = a.length;
                if (d < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
                if (1 === d) return b.copyFrom(a[0]), b;
                for (var e = 0; e < d; e++) c.Point.add(b, a[e], b);
                return b.divide(d, d), b
            }, c.Point.parse = function(a, b, d) {
                b = b || "x", d = d || "y";
                var e = new c.Point;
                return a[b] && (e.x = parseInt(a[b], 10)), a[d] && (e.y = parseInt(a[d], 10)), e
            }, PIXI.Point = c.Point, c.Polygon = function() {
                this.area = 0, this._points = [], arguments.length > 0 && this.setTo.apply(this, arguments), this.closed = !0, this.flattened = !1, this.type = c.POLYGON
            }, c.Polygon.prototype = {
                toNumberArray: function(a) {
                    void 0 === a && (a = []);
                    for (var b = 0; b < this._points.length; b++) "number" == typeof this._points[b] ? (a.push(this._points[b]), a.push(this._points[b + 1]), b++) : (a.push(this._points[b].x), a.push(this._points[b].y));
                    return a
                },
                flatten: function() {
                    return this._points = this.toNumberArray(), this.flattened = !0, this
                },
                clone: function(a) {
                    var b = this._points.slice();
                    return void 0 === a || null === a ? a = new c.Polygon(b) : a.setTo(b), a
                },
                contains: function(a, b) {
                    var c = !1;
                    if (this.flattened)
                        for (var d = -2, e = this._points.length - 2;
                            (d += 2) < this._points.length; e = d) {
                            var f = this._points[d],
                                g = this._points[d + 1],
                                h = this._points[e],
                                i = this._points[e + 1];
                            (g <= b && b < i || i <= b && b < g) && a < (h - f) * (b - g) / (i - g) + f && (c = !c)
                        } else
                            for (var d = -1, e = this._points.length - 1; ++d < this._points.length; e = d) {
                                var f = this._points[d].x,
                                    g = this._points[d].y,
                                    h = this._points[e].x,
                                    i = this._points[e].y;
                                (g <= b && b < i || i <= b && b < g) && a < (h - f) * (b - g) / (i - g) + f && (c = !c)
                            }
                    return c
                },
                setTo: function(a) {
                    if (this.area = 0, this._points = [], arguments.length > 0) {
                        Array.isArray(a) || (a = Array.prototype.slice.call(arguments));
                        for (var b = Number.MAX_VALUE, c = 0, d = a.length; c < d; c++) {
                            if ("number" == typeof a[c]) {
                                var e = new PIXI.Point(a[c], a[c + 1]);
                                c++
                            } else if (Array.isArray(a[c])) var e = new PIXI.Point(a[c][0], a[c][1]);
                            else var e = new PIXI.Point(a[c].x, a[c].y);
                            this._points.push(e), e.y < b && (b = e.y)
                        }
                        this.calculateArea(b)
                    }
                    return this
                },
                calculateArea: function(a) {
                    for (var b, c, d, e, f = 0, g = this._points.length; f < g; f++) b = this._points[f], c = f === g - 1 ? this._points[0] : this._points[f + 1], d = (b.y - a + (c.y - a)) / 2, e = b.x - c.x, this.area += d * e;
                    return this.area
                }
            }, c.Polygon.prototype.constructor = c.Polygon, Object.defineProperty(c.Polygon.prototype, "points", {
                get: function() {
                    return this._points
                },
                set: function(a) {
                    null != a ? this.setTo(a) : this.setTo()
                }
            }), PIXI.Polygon = c.Polygon, c.Rectangle = function(a, b, d, e) {
                a = a || 0, b = b || 0, d = d || 0, e = e || 0, this.x = a, this.y = b, this.width = d, this.height = e, this.type = c.RECTANGLE
            }, c.Rectangle.prototype = {
                offset: function(a, b) {
                    return this.x += a, this.y += b, this
                },
                offsetPoint: function(a) {
                    return this.offset(a.x, a.y)
                },
                setTo: function(a, b, c, d) {
                    return this.x = a, this.y = b, this.width = c, this.height = d, this
                },
                scale: function(a, b) {
                    return void 0 === b && (b = a), this.width *= a, this.height *= b, this
                },
                centerOn: function(a, b) {
                    return this.centerX = a, this.centerY = b, this
                },
                floor: function() {
                    this.x = Math.floor(this.x), this.y = Math.floor(this.y)
                },
                floorAll: function() {
                    this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height)
                },
                ceil: function() {
                    this.x = Math.ceil(this.x), this.y = Math.ceil(this.y)
                },
                ceilAll: function() {
                    this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height)
                },
                copyFrom: function(a) {
                    return this.setTo(a.x, a.y, a.width, a.height)
                },
                copyTo: function(a) {
                    return a.x = this.x, a.y = this.y, a.width = this.width, a.height = this.height, a
                },
                inflate: function(a, b) {
                    return c.Rectangle.inflate(this, a, b)
                },
                size: function(a) {
                    return c.Rectangle.size(this, a)
                },
                resize: function(a, b) {
                    return this.width = a, this.height = b, this
                },
                clone: function(a) {
                    return c.Rectangle.clone(this, a)
                },
                contains: function(a, b) {
                    return c.Rectangle.contains(this, a, b)
                },
                containsRect: function(a) {
                    return c.Rectangle.containsRect(a, this)
                },
                equals: function(a) {
                    return c.Rectangle.equals(this, a)
                },
                intersection: function(a, b) {
                    return c.Rectangle.intersection(this, a, b)
                },
                intersects: function(a) {
                    return c.Rectangle.intersects(this, a)
                },
                intersectsRaw: function(a, b, d, e, f) {
                    return c.Rectangle.intersectsRaw(this, a, b, d, e, f)
                },
                union: function(a, b) {
                    return c.Rectangle.union(this, a, b)
                },
                random: function(a) {
                    return void 0 === a && (a = new c.Point), a.x = this.randomX, a.y = this.randomY, a
                },
                getPoint: function(a, b) {
                    switch (void 0 === b && (b = new c.Point), a) {
                        default:
                            case c.TOP_LEFT:
                            return b.set(this.x, this.y);
                        case c.TOP_CENTER:
                            return b.set(this.centerX, this.y);
                        case c.TOP_RIGHT:
                            return b.set(this.right, this.y);
                        case c.LEFT_CENTER:
                            return b.set(this.x, this.centerY);
                        case c.CENTER:
                            return b.set(this.centerX, this.centerY);
                        case c.RIGHT_CENTER:
                            return b.set(this.right, this.centerY);
                        case c.BOTTOM_LEFT:
                            return b.set(this.x, this.bottom);
                        case c.BOTTOM_CENTER:
                            return b.set(this.centerX, this.bottom);
                        case c.BOTTOM_RIGHT:
                            return b.set(this.right, this.bottom)
                    }
                },
                toString: function() {
                    return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
                }
            }, Object.defineProperty(c.Rectangle.prototype, "halfWidth", {
                get: function() {
                    return Math.round(this.width / 2)
                }
            }), Object.defineProperty(c.Rectangle.prototype, "halfHeight", {
                get: function() {
                    return Math.round(this.height / 2)
                }
            }), Object.defineProperty(c.Rectangle.prototype, "bottom", {
                get: function() {
                    return this.y + this.height
                },
                set: function(a) {
                    a <= this.y ? this.height = 0 : this.height = a - this.y
                }
            }), Object.defineProperty(c.Rectangle.prototype, "bottomLeft", {
                get: function() {
                    return new c.Point(this.x, this.bottom)
                },
                set: function(a) {
                    this.x = a.x, this.bottom = a.y
                }
            }), Object.defineProperty(c.Rectangle.prototype, "bottomRight", {
                get: function() {
                    return new c.Point(this.right, this.bottom)
                },
                set: function(a) {
                    this.right = a.x, this.bottom = a.y
                }
            }), Object.defineProperty(c.Rectangle.prototype, "left", {
                get: function() {
                    return this.x
                },
                set: function(a) {
                    a >= this.right ? this.width = 0 : this.width = this.right - a, this.x = a
                }
            }), Object.defineProperty(c.Rectangle.prototype, "right", {
                get: function() {
                    return this.x + this.width
                },
                set: function(a) {
                    a <= this.x ? this.width = 0 : this.width = a - this.x
                }
            }), Object.defineProperty(c.Rectangle.prototype, "volume", {
                get: function() {
                    return this.width * this.height
                }
            }), Object.defineProperty(c.Rectangle.prototype, "perimeter", {
                get: function() {
                    return 2 * this.width + 2 * this.height
                }
            }), Object.defineProperty(c.Rectangle.prototype, "centerX", {
                get: function() {
                    return this.x + this.halfWidth
                },
                set: function(a) {
                    this.x = a - this.halfWidth
                }
            }), Object.defineProperty(c.Rectangle.prototype, "centerY", {
                get: function() {
                    return this.y + this.halfHeight
                },
                set: function(a) {
                    this.y = a - this.halfHeight
                }
            }), Object.defineProperty(c.Rectangle.prototype, "randomX", {
                get: function() {
                    return this.x + Math.random() * this.width
                }
            }), Object.defineProperty(c.Rectangle.prototype, "randomY", {
                get: function() {
                    return this.y + Math.random() * this.height
                }
            }), Object.defineProperty(c.Rectangle.prototype, "top", {
                get: function() {
                    return this.y
                },
                set: function(a) {
                    a >= this.bottom ? (this.height = 0, this.y = a) : this.height = this.bottom - a
                }
            }), Object.defineProperty(c.Rectangle.prototype, "topLeft", {
                get: function() {
                    return new c.Point(this.x, this.y)
                },
                set: function(a) {
                    this.x = a.x, this.y = a.y
                }
            }), Object.defineProperty(c.Rectangle.prototype, "topRight", {
                get: function() {
                    return new c.Point(this.x + this.width, this.y)
                },
                set: function(a) {
                    this.right = a.x, this.y = a.y
                }
            }), Object.defineProperty(c.Rectangle.prototype, "empty", {
                get: function() {
                    return !this.width || !this.height
                },
                set: function(a) {
                    a === !0 && this.setTo(0, 0, 0, 0)
                }
            }), c.Rectangle.prototype.constructor = c.Rectangle, c.Rectangle.inflate = function(a, b, c) {
                return a.x -= b, a.width += 2 * b, a.y -= c, a.height += 2 * c, a
            }, c.Rectangle.inflatePoint = function(a, b) {
                return c.Rectangle.inflate(a, b.x, b.y)
            }, c.Rectangle.size = function(a, b) {
                return void 0 === b || null === b ? b = new c.Point(a.width, a.height) : b.setTo(a.width, a.height), b
            }, c.Rectangle.clone = function(a, b) {
                return void 0 === b || null === b ? b = new c.Rectangle(a.x, a.y, a.width, a.height) : b.setTo(a.x, a.y, a.width, a.height), b
            }, c.Rectangle.contains = function(a, b, c) {
                return !(a.width <= 0 || a.height <= 0) && b >= a.x && b < a.right && c >= a.y && c < a.bottom
            }, c.Rectangle.containsRaw = function(a, b, c, d, e, f) {
                return e >= a && e < a + c && f >= b && f < b + d
            }, c.Rectangle.containsPoint = function(a, b) {
                return c.Rectangle.contains(a, b.x, b.y)
            }, c.Rectangle.containsRect = function(a, b) {
                return !(a.volume > b.volume) && a.x >= b.x && a.y >= b.y && a.right < b.right && a.bottom < b.bottom
            }, c.Rectangle.equals = function(a, b) {
                return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height
            }, c.Rectangle.sameDimensions = function(a, b) {
                return a.width === b.width && a.height === b.height
            }, c.Rectangle.intersection = function(a, b, d) {
                return void 0 === d && (d = new c.Rectangle), c.Rectangle.intersects(a, b) && (d.x = Math.max(a.x, b.x), d.y = Math.max(a.y, b.y), d.width = Math.min(a.right, b.right) - d.x, d.height = Math.min(a.bottom, b.bottom) - d.y), d
            }, c.Rectangle.intersects = function(a, b) {
                return !(a.width <= 0 || a.height <= 0 || b.width <= 0 || b.height <= 0 || a.right < b.x || a.bottom < b.y || a.x > b.right || a.y > b.bottom)
            }, c.Rectangle.intersectsRaw = function(a, b, c, d, e, f) {
                return void 0 === f && (f = 0), !(b > a.right + f || c < a.left - f || d > a.bottom + f || e < a.top - f)
            }, c.Rectangle.union = function(a, b, d) {
                return void 0 === d && (d = new c.Rectangle), d.setTo(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.max(a.right, b.right) - Math.min(a.left, b.left), Math.max(a.bottom, b.bottom) - Math.min(a.top, b.top))
            }, c.Rectangle.aabb = function(a, b) {
                void 0 === b && (b = new c.Rectangle);
                var d = Number.NEGATIVE_INFINITY,
                    e = Number.POSITIVE_INFINITY,
                    f = Number.NEGATIVE_INFINITY,
                    g = Number.POSITIVE_INFINITY;
                return a.forEach(function(a) {
                    a.x > d && (d = a.x), a.x < e && (e = a.x), a.y > f && (f = a.y), a.y < g && (g = a.y)
                }), b.setTo(e, g, d - e, f - g), b
            }, PIXI.Rectangle = c.Rectangle, PIXI.EmptyRectangle = new c.Rectangle(0, 0, 0, 0), c.RoundedRectangle = function(a, b, d, e, f) {
                void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === d && (d = 0), void 0 === e && (e = 0), void 0 === f && (f = 20), this.x = a, this.y = b, this.width = d, this.height = e, this.radius = f || 20, this.type = c.ROUNDEDRECTANGLE
            }, c.RoundedRectangle.prototype = {
                clone: function() {
                    return new c.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius)
                },
                contains: function(a, b) {
                    if (this.width <= 0 || this.height <= 0) return !1;
                    var c = this.x;
                    if (a >= c && a <= c + this.width) {
                        var d = this.y;
                        if (b >= d && b <= d + this.height) return !0
                    }
                    return !1
                }
            }, c.RoundedRectangle.prototype.constructor = c.RoundedRectangle, PIXI.RoundedRectangle = c.RoundedRectangle, c.Camera = function(a, b, d, e, f, g) {
                this.game = a, this.world = a.world, this.id = 0, this.view = new c.Rectangle(d, e, f, g), this.bounds = new c.Rectangle(d, e, f, g), this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = {
                    x: !1,
                    y: !1
                }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, this.lerp = new c.Point(1, 1), this.onShakeComplete = new c.Signal, this.onFlashComplete = new c.Signal, this.onFadeComplete = new c.Signal, this.fx = null, this._targetPosition = new c.Point, this._edge = 0, this._position = new c.Point, this._shake = {
                    intensity: 0,
                    duration: 0,
                    horizontal: !1,
                    vertical: !1,
                    shakeBounds: !0,
                    x: 0,
                    y: 0
                }, this._fxDuration = 0, this._fxType = 0
            }, c.Camera.FOLLOW_LOCKON = 0, c.Camera.FOLLOW_PLATFORMER = 1, c.Camera.FOLLOW_TOPDOWN = 2, c.Camera.FOLLOW_TOPDOWN_TIGHT = 3, c.Camera.SHAKE_BOTH = 4, c.Camera.SHAKE_HORIZONTAL = 5, c.Camera.SHAKE_VERTICAL = 6, c.Camera.ENABLE_FX = !0, c.Camera.prototype = {
                boot: function() {
                    this.displayObject = this.game.world, this.scale = this.game.world.scale, this.game.camera = this, c.Graphics && c.Camera.ENABLE_FX && (this.fx = new c.Graphics(this.game), this.game.stage.addChild(this.fx))
                },
                preUpdate: function() {
                    this.totalInView = 0
                },
                follow: function(a, b, d, e) {
                    void 0 === b && (b = c.Camera.FOLLOW_LOCKON), void 0 === d && (d = 1), void 0 === e && (e = 1), this.target = a, this.lerp.set(d, e);
                    var f;
                    switch (b) {
                        case c.Camera.FOLLOW_PLATFORMER:
                            var g = this.width / 8,
                                h = this.height / 3;
                            this.deadzone = new c.Rectangle((this.width - g) / 2, (this.height - h) / 2 - .25 * h, g, h);
                            break;
                        case c.Camera.FOLLOW_TOPDOWN:
                            f = Math.max(this.width, this.height) / 4, this.deadzone = new c.Rectangle((this.width - f) / 2, (this.height - f) / 2, f, f);
                            break;
                        case c.Camera.FOLLOW_TOPDOWN_TIGHT:
                            f = Math.max(this.width, this.height) / 8, this.deadzone = new c.Rectangle((this.width - f) / 2, (this.height - f) / 2, f, f);
                            break;
                        case c.Camera.FOLLOW_LOCKON:
                            this.deadzone = null;
                            break;
                        default:
                            this.deadzone = null
                    }
                },
                unfollow: function() {
                    this.target = null
                },
                focusOn: function(a) {
                    this.setPosition(Math.round(a.x - this.view.halfWidth), Math.round(a.y - this.view.halfHeight))
                },
                focusOnXY: function(a, b) {
                    this.setPosition(Math.round(a - this.view.halfWidth), Math.round(b - this.view.halfHeight))
                },
                shake: function(a, b, d, e, f) {
                    return void 0 === a && (a = .05), void 0 === b && (b = 500), void 0 === d && (d = !0), void 0 === e && (e = c.Camera.SHAKE_BOTH), void 0 === f && (f = !0), !(!d && this._shake.duration > 0 || (this._shake.intensity = a, this._shake.duration = b, this._shake.shakeBounds = f, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = e === c.Camera.SHAKE_BOTH || e === c.Camera.SHAKE_HORIZONTAL, this._shake.vertical = e === c.Camera.SHAKE_BOTH || e === c.Camera.SHAKE_VERTICAL, 0))
                },
                flash: function(a, b, c) {
                    return void 0 === a && (a = 16777215), void 0 === b && (b = 500), void 0 === c && (c = !1), !(!this.fx || !c && this._fxDuration > 0 || (this.fx.clear(), this.fx.beginFill(a), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = b, this._fxType = 0, 0))
                },
                fade: function(a, b, c) {
                    return void 0 === a && (a = 0), void 0 === b && (b = 500), void 0 === c && (c = !1), !(!this.fx || !c && this._fxDuration > 0 || (this.fx.clear(), this.fx.beginFill(a), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = b, this._fxType = 1, 0))
                },
                update: function() {
                    this._fxDuration > 0 && this.updateFX(), this._shake.duration > 0 && this.updateShake(), this.bounds && this.checkBounds(), this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
                },
                updateFX: function() {
                    0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration, this.fx.alpha >= 1 && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch()))
                },
                updateShake: function() {
                    this._shake.duration -= this.game.time.elapsedMS, this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height))
                },
                updateTarget: function() {
                    this._targetPosition.x = this.view.x + this.target.worldPosition.x, this._targetPosition.y = this.view.y + this.target.worldPosition.y, this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
                },
                setBoundsToWorld: function() {
                    this.bounds && this.bounds.copyFrom(this.game.world.bounds)
                },
                checkBounds: function() {
                    this.atLimit.x = !1, this.atLimit.y = !1;
                    var a = this.view.x + this._shake.x,
                        b = this.view.right + this._shake.x,
                        c = this.view.y + this._shake.y,
                        d = this.view.bottom + this._shake.y;
                    a <= this.bounds.x * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)), b >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)), c <= this.bounds.top * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)), d >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0))
                },
                setPosition: function(a, b) {
                    this.view.x = a, this.view.y = b, this.bounds && this.checkBounds()
                },
                setSize: function(a, b) {
                    this.view.width = a, this.view.height = b
                },
                reset: function() {
                    this.target = null, this.view.x = 0, this.view.y = 0, this._shake.duration = 0, this.resetFX()
                },
                resetFX: function() {
                    this.fx.clear(), this.fx.alpha = 0, this._fxDuration = 0
                }
            }, c.Camera.prototype.constructor = c.Camera, Object.defineProperty(c.Camera.prototype, "x", {
                get: function() {
                    return this.view.x
                },
                set: function(a) {
                    this.view.x = a, this.bounds && this.checkBounds()
                }
            }), Object.defineProperty(c.Camera.prototype, "y", {
                get: function() {
                    return this.view.y
                },
                set: function(a) {
                    this.view.y = a, this.bounds && this.checkBounds()
                }
            }), Object.defineProperty(c.Camera.prototype, "position", {
                get: function() {
                    return this._position.set(this.view.x, this.view.y), this._position
                },
                set: function(a) {
                    "undefined" != typeof a.x && (this.view.x = a.x), "undefined" != typeof a.y && (this.view.y = a.y), this.bounds && this.checkBounds()
                }
            }), Object.defineProperty(c.Camera.prototype, "width", {
                get: function() {
                    return this.view.width
                },
                set: function(a) {
                    this.view.width = a
                }
            }), Object.defineProperty(c.Camera.prototype, "height", {
                get: function() {
                    return this.view.height
                },
                set: function(a) {
                    this.view.height = a
                }
            }), Object.defineProperty(c.Camera.prototype, "shakeIntensity", {
                get: function() {
                    return this._shake.intensity
                },
                set: function(a) {
                    this._shake.intensity = a
                }
            }), c.State = function() {
                this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, this.stage = null, this.state = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null
            }, c.State.prototype = {
                init: function() {},
                preload: function() {},
                loadUpdate: function() {},
                loadRender: function() {},
                create: function() {},
                update: function() {},
                preRender: function() {},
                render: function() {},
                resize: function() {},
                paused: function() {},
                resumed: function() {},
                pauseUpdate: function() {},
                shutdown: function() {}
            }, c.State.prototype.constructor = c.State, c.StateManager = function(a, b) {
                this.game = a, this.states = {}, this._pendingState = null, "undefined" != typeof b && null !== b && (this._pendingState = b), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onStateChange = new c.Signal, this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null
            }, c.StateManager.prototype = {
                boot: function() {
                    this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0)
                },
                add: function(a, b, d) {
                    void 0 === d && (d = !1);
                    var e;
                    return b instanceof c.State ? e = b : "object" == typeof b ? (e = b, e.game = this.game) : "function" == typeof b && (e = new b(this.game)), this.states[a] = e, d && (this.game.isBooted ? this.start(a) : this._pendingState = a), e
                },
                remove: function(a) {
                    this.current === a && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[a]
                },
                start: function(a, b, c) {
                    void 0 === b && (b = !0), void 0 === c && (c = !1), this.checkState(a) && (this._pendingState = a, this._clearWorld = b, this._clearCache = c, arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3)))
                },
                restart: function(a, b) {
                    void 0 === a && (a = !0), void 0 === b && (b = !1), this._pendingState = this.current, this._clearWorld = a, this._clearCache = b, arguments.length > 2 && (this._args = Array.prototype.slice.call(arguments, 2))
                },
                dummy: function() {},
                preUpdate: function() {
                    if (this._pendingState && this.game.isBooted) {
                        var a = this.current;
                        if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, a), this.current !== this._pendingState) return;
                        this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()
                    }
                },
                clearCurrentState: function() {
                    this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy()))
                },
                checkState: function(a) {
                    return !!this.states[a] && (!!(this.states[a].preload || this.states[a].create || this.states[a].update || this.states[a].render) || !1)
                },
                link: function(a) {
                    this.states[a].game = this.game, this.states[a].add = this.game.add, this.states[a].make = this.game.make, this.states[a].camera = this.game.camera, this.states[a].cache = this.game.cache, this.states[a].input = this.game.input, this.states[a].load = this.game.load, this.states[a].math = this.game.math, this.states[a].sound = this.game.sound, this.states[a].scale = this.game.scale, this.states[a].state = this, this.states[a].stage = this.game.stage, this.states[a].time = this.game.time, this.states[a].tweens = this.game.tweens, this.states[a].world = this.game.world, this.states[a].particles = this.game.particles, this.states[a].rnd = this.game.rnd, this.states[a].physics = this.game.physics, this.states[a].key = a
                },
                unlink: function(a) {
                    this.states[a] && (this.states[a].game = null, this.states[a].add = null, this.states[a].make = null, this.states[a].camera = null, this.states[a].cache = null, this.states[a].input = null, this.states[a].load = null, this.states[a].math = null, this.states[a].sound = null, this.states[a].scale = null, this.states[a].state = null, this.states[a].stage = null, this.states[a].time = null, this.states[a].tweens = null, this.states[a].world = null, this.states[a].particles = null, this.states[a].rnd = null, this.states[a].physics = null)
                },
                setCurrentState: function(a) {
                    this.callbackContext = this.states[a], this.link(a), this.onInitCallback = this.states[a].init || this.dummy, this.onPreloadCallback = this.states[a].preload || null, this.onLoadRenderCallback = this.states[a].loadRender || null, this.onLoadUpdateCallback = this.states[a].loadUpdate || null, this.onCreateCallback = this.states[a].create || null, this.onUpdateCallback = this.states[a].update || null, this.onPreRenderCallback = this.states[a].preRender || null, this.onRenderCallback = this.states[a].render || null, this.onResizeCallback = this.states[a].resize || null, this.onPausedCallback = this.states[a].paused || null, this.onResumedCallback = this.states[a].resumed || null, this.onPauseUpdateCallback = this.states[a].pauseUpdate || null, this.onShutDownCallback = this.states[a].shutdown || this.dummy, "" !== this.current && this.game.physics.reset(), this.current = a, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), a === this._pendingState && (this._args = []), this.game._kickstart = !0
                },
                getCurrentState: function() {
                    return this.states[this.current]
                },
                loadComplete: function() {
                    this._created === !1 && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game), this._created === !1 && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
                },
                pause: function() {
                    this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
                },
                resume: function() {
                    this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
                },
                update: function() {
                    this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                },
                pauseUpdate: function() {
                    this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                },
                preRender: function(a) {
                    this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, a)
                },
                resize: function(a, b) {
                    this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, a, b)
                },
                render: function() {
                    this._created ? this.onRenderCallback && (this.game.renderType === c.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
                },
                destroy: function() {
                    this._clearWorld = !0, this._clearCache = !0, this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, this.current = ""
                }
            }, c.StateManager.prototype.constructor = c.StateManager, Object.defineProperty(c.StateManager.prototype, "created", {
                get: function() {
                    return this._created
                }
            }), c.Signal = function() {}, c.Signal.prototype = {
                _bindings: null,
                _prevParams: null,
                memorize: !1,
                _shouldPropagate: !0,
                active: !0,
                _boundDispatch: !1,
                validateListener: function(a, b) {
                    if ("function" != typeof a) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", b))
                },
                _registerListener: function(a, b, d, e, f) {
                    var g, h = this._indexOfListener(a, d);
                    if (h !== -1) {
                        if (g = this._bindings[h], g.isOnce() !== b) throw new Error("You cannot add" + (b ? "" : "Once") + "() then add" + (b ? "Once" : "") + "() the same listener without removing the relationship first.")
                    } else g = new c.SignalBinding(this, a, b, d, e, f), this._addBinding(g);
                    return this.memorize && this._prevParams && g.execute(this._prevParams), g
                },
                _addBinding: function(a) {
                    this._bindings || (this._bindings = []);
                    var b = this._bindings.length;
                    do b--; while (this._bindings[b] && a._priority <= this._bindings[b]._priority);
                    this._bindings.splice(b + 1, 0, a)
                },
                _indexOfListener: function(a, b) {
                    if (!this._bindings) return -1;
                    void 0 === b && (b = null);
                    for (var c, d = this._bindings.length; d--;)
                        if (c = this._bindings[d], c._listener === a && c.context === b) return d;
                    return -1
                },
                has: function(a, b) {
                    return this._indexOfListener(a, b) !== -1
                },
                add: function(a, b, c) {
                    this.validateListener(a, "add");
                    var d = [];
                    if (arguments.length > 3)
                        for (var e = 3; e < arguments.length; e++) d.push(arguments[e]);
                    return this._registerListener(a, !1, b, c, d)
                },
                addOnce: function(a, b, c) {
                    this.validateListener(a, "addOnce");
                    var d = [];
                    if (arguments.length > 3)
                        for (var e = 3; e < arguments.length; e++) d.push(arguments[e]);
                    return this._registerListener(a, !0, b, c, d)
                },
                remove: function(a, b) {
                    this.validateListener(a, "remove");
                    var c = this._indexOfListener(a, b);
                    return c !== -1 && (this._bindings[c]._destroy(), this._bindings.splice(c, 1)), a
                },
                removeAll: function(a) {
                    if (void 0 === a && (a = null), this._bindings) {
                        for (var b = this._bindings.length; b--;) a ? this._bindings[b].context === a && (this._bindings[b]._destroy(), this._bindings.splice(b, 1)) : this._bindings[b]._destroy();
                        a || (this._bindings.length = 0)
                    }
                },
                getNumListeners: function() {
                    return this._bindings ? this._bindings.length : 0
                },
                halt: function() {
                    this._shouldPropagate = !1
                },
                dispatch: function() {
                    if (this.active && this._bindings) {
                        var a, b = Array.prototype.slice.call(arguments),
                            c = this._bindings.length;
                        if (this.memorize && (this._prevParams = b), c) {
                            a = this._bindings.slice(), this._shouldPropagate = !0;
                            do c--; while (a[c] && this._shouldPropagate && a[c].execute(b) !== !1)
                        }
                    }
                },
                forget: function() {
                    this._prevParams && (this._prevParams = null);
                },
                dispose: function() {
                    this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null)
                },
                toString: function() {
                    return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
                }
            }, Object.defineProperty(c.Signal.prototype, "boundDispatch", {
                get: function() {
                    var a = this;
                    return this._boundDispatch || (this._boundDispatch = function() {
                        return a.dispatch.apply(a, arguments)
                    })
                }
            }), c.Signal.prototype.constructor = c.Signal, c.SignalBinding = function(a, b, c, d, e, f) {
                this._listener = b, c && (this._isOnce = !0), null != d && (this.context = d), this._signal = a, e && (this._priority = e), f && f.length && (this._args = f)
            }, c.SignalBinding.prototype = {
                context: null,
                _isOnce: !1,
                _priority: 0,
                _args: null,
                callCount: 0,
                active: !0,
                params: null,
                execute: function(a) {
                    var b, c;
                    return this.active && this._listener && (c = this.params ? this.params.concat(a) : a, this._args && (c = c.concat(this._args)), b = this._listener.apply(this.context, c), this.callCount++, this._isOnce && this.detach()), b
                },
                detach: function() {
                    return this.isBound() ? this._signal.remove(this._listener, this.context) : null
                },
                isBound: function() {
                    return !!this._signal && !!this._listener
                },
                isOnce: function() {
                    return this._isOnce
                },
                getListener: function() {
                    return this._listener
                },
                getSignal: function() {
                    return this._signal
                },
                _destroy: function() {
                    delete this._signal, delete this._listener, delete this.context
                },
                toString: function() {
                    return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
                }
            }, c.SignalBinding.prototype.constructor = c.SignalBinding, c.Filter = function(a, b, d) {
                this.game = a, this.type = c.WEBGL_FILTER, this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.prevPoint = new c.Point;
                var e = new Date;
                if (this.uniforms = {
                    resolution: {
                        type: "2f",
                        value: {
                            x: 256,
                            y: 256
                        }
                    },
                    time: {
                        type: "1f",
                        value: 0
                    },
                    mouse: {
                        type: "2f",
                        value: {
                            x: 0,
                            y: 0
                        }
                    },
                    date: {
                        type: "4fv",
                        value: [e.getFullYear(), e.getMonth(), e.getDate(), 60 * e.getHours() * 60 + 60 * e.getMinutes() + e.getSeconds()]
                    },
                    sampleRate: {
                        type: "1f",
                        value: 44100
                    },
                    iChannel0: {
                        type: "sampler2D",
                        value: null,
                        textureData: {
                            repeat: !0
                        }
                    },
                    iChannel1: {
                        type: "sampler2D",
                        value: null,
                        textureData: {
                            repeat: !0
                        }
                    },
                    iChannel2: {
                        type: "sampler2D",
                        value: null,
                        textureData: {
                            repeat: !0
                        }
                    },
                    iChannel3: {
                        type: "sampler2D",
                        value: null,
                        textureData: {
                            repeat: !0
                        }
                    }
                }, b)
                    for (var f in b) this.uniforms[f] = b[f];
                this.fragmentSrc = d || ""
            }, c.Filter.prototype = {
                init: function() {},
                setResolution: function(a, b) {
                    this.uniforms.resolution.value.x = a, this.uniforms.resolution.value.y = b
                },
                update: function(a) {
                    if ("undefined" != typeof a) {
                        var b = a.x / this.game.width,
                            c = 1 - a.y / this.game.height;
                        b === this.prevPoint.x && c === this.prevPoint.y || (this.uniforms.mouse.value.x = b.toFixed(2), this.uniforms.mouse.value.y = c.toFixed(2), this.prevPoint.set(b, c))
                    }
                    this.uniforms.time.value = this.game.time.totalElapsedSeconds()
                },
                addToWorld: function(a, b, c, d, e, f) {
                    void 0 === e && (e = 0), void 0 === f && (f = 0), void 0 !== c && null !== c ? this.width = c : c = this.width, void 0 !== d && null !== d ? this.height = d : d = this.height;
                    var g = this.game.add.image(a, b, "__default");
                    return g.width = c, g.height = d, g.anchor.set(e, f), g.filters = [this], g
                },
                destroy: function() {
                    this.game = null
                }
            }, c.Filter.prototype.constructor = c.Filter, Object.defineProperty(c.Filter.prototype, "width", {
                get: function() {
                    return this.uniforms.resolution.value.x
                },
                set: function(a) {
                    this.uniforms.resolution.value.x = a
                }
            }), Object.defineProperty(c.Filter.prototype, "height", {
                get: function() {
                    return this.uniforms.resolution.value.y
                },
                set: function(a) {
                    this.uniforms.resolution.value.y = a
                }
            }), c.Plugin = function(a, b) {
                void 0 === b && (b = null), this.game = a, this.parent = b, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1
            }, c.Plugin.prototype = {
                preUpdate: function() {},
                update: function() {},
                render: function() {},
                postRender: function() {},
                destroy: function() {
                    this.game = null, this.parent = null, this.active = !1, this.visible = !1
                }
            }, c.Plugin.prototype.constructor = c.Plugin, c.PluginManager = function(a) {
                this.game = a, this.plugins = [], this._len = 0, this._i = 0
            }, c.PluginManager.prototype = {
                add: function(a) {
                    var b = Array.prototype.slice.call(arguments, 1),
                        c = !1;
                    return "function" == typeof a ? a = new a(this.game, this) : (a.game = this.game, a.parent = this), "function" == typeof a.preUpdate && (a.hasPreUpdate = !0, c = !0), "function" == typeof a.update && (a.hasUpdate = !0, c = !0), "function" == typeof a.postUpdate && (a.hasPostUpdate = !0, c = !0), "function" == typeof a.render && (a.hasRender = !0, c = !0), "function" == typeof a.postRender && (a.hasPostRender = !0, c = !0), c ? ((a.hasPreUpdate || a.hasUpdate || a.hasPostUpdate) && (a.active = !0), (a.hasRender || a.hasPostRender) && (a.visible = !0), this._len = this.plugins.push(a), "function" == typeof a.init && a.init.apply(a, b), a) : null
                },
                remove: function(a, b) {
                    for (void 0 === b && (b = !0), this._i = this._len; this._i--;)
                        if (this.plugins[this._i] === a) return b && a.destroy(), this.plugins.splice(this._i, 1), void this._len--
                },
                removeAll: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
                    this.plugins.length = 0, this._len = 0
                },
                preUpdate: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
                },
                update: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
                },
                postUpdate: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
                },
                render: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
                },
                postRender: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
                },
                destroy: function() {
                    this.removeAll(), this.game = null
                }
            }, c.PluginManager.prototype.constructor = c.PluginManager, c.Stage = function(a) {
                this.game = a, PIXI.DisplayObjectContainer.call(this), this.name = "_stage_root", this.disableVisibilityChange = !1, this.exists = !0, this.worldTransform = new PIXI.Matrix, this.stage = this, this.currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, this._bgColor = {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 0,
                    color: 0,
                    rgba: "#000000"
                }, this.game.transparent || (this._bgColor.a = 1), a.config && this.parseConfig(a.config)
            }, c.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), c.Stage.prototype.constructor = c.Stage, c.Stage.prototype.parseConfig = function(a) {
                a.disableVisibilityChange && (this.disableVisibilityChange = a.disableVisibilityChange), a.backgroundColor && this.setBackgroundColor(a.backgroundColor)
            }, c.Stage.prototype.boot = function() {
                c.DOM.getOffset(this.game.canvas, this.offset), c.Canvas.setUserSelect(this.game.canvas, "none"), c.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility()
            }, c.Stage.prototype.preUpdate = function() {
                this.currentRenderOrderID = 0;
                for (var a = 0; a < this.children.length; a++) this.children[a].preUpdate()
            }, c.Stage.prototype.update = function() {
                for (var a = this.children.length; a--;) this.children[a].update()
            }, c.Stage.prototype.postUpdate = function() {
                this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
                for (var a = 0; a < this.children.length; a++) this.children[a].postUpdate();
                this.updateTransform()
            }, c.Stage.prototype.updateTransform = function() {
                this.worldAlpha = 1;
                for (var a = 0; a < this.children.length; a++) this.children[a].updateTransform()
            }, c.Stage.prototype.checkVisibility = function() {
                void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
                var a = this;
                this._onChange = function(b) {
                    return a.visibilityChange(b)
                }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, window.onpageshow = this._onChange, this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function() {
                    c.Stage.prototype.visibilityChange.call(a, {
                        type: "pause"
                    })
                }), CocoonJS.App.onActivated.addEventListener(function() {
                    c.Stage.prototype.visibilityChange.call(a, {
                        type: "resume"
                    })
                }))
            }, c.Stage.prototype.visibilityChange = function(a) {
                return "pagehide" === a.type || "blur" === a.type || "pageshow" === a.type || "focus" === a.type ? void("pagehide" === a.type || "blur" === a.type ? this.game.focusLoss(a) : "pageshow" !== a.type && "focus" !== a.type || this.game.focusGain(a)) : void(this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === a.type ? this.game.gamePaused(a) : this.game.gameResumed(a)))
            }, c.Stage.prototype.setBackgroundColor = function(a) {
                this.game.transparent || (c.Color.valueToColor(a, this._bgColor), c.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1)
            }, c.Stage.prototype.destroy = function() {
                this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null
            }, Object.defineProperty(c.Stage.prototype, "backgroundColor", {
                get: function() {
                    return this._bgColor.color
                },
                set: function(a) {
                    this.setBackgroundColor(a)
                }
            }), Object.defineProperty(c.Stage.prototype, "smoothed", {
                get: function() {
                    return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR
                },
                set: function(a) {
                    a ? PIXI.scaleModes.DEFAULT = PIXI.scaleModes.LINEAR : PIXI.scaleModes.DEFAULT = PIXI.scaleModes.NEAREST
                }
            }), c.Group = function(a, b, d, e, f, g) {
                void 0 === e && (e = !1), void 0 === f && (f = !1), void 0 === g && (g = c.Physics.ARCADE), this.game = a, void 0 === b && (b = a.world), this.name = d || "group", this.z = 0, PIXI.DisplayObjectContainer.call(this), e ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : b && (b.addChild(this), this.z = b.children.length), this.type = c.GROUP, this.physicsType = c.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = c.Sprite, this.cursor = null, this.inputEnableChildren = !1, this.onChildInputDown = new c.Signal, this.onChildInputUp = new c.Signal, this.onChildInputOver = new c.Signal, this.onChildInputOut = new c.Signal, this.enableBody = f, this.enableBodyDebug = !1, this.physicsBodyType = g, this.physicsSortDirection = null, this.onDestroy = new c.Signal, this.cursorIndex = 0, this.fixedToCamera = !1, this.cameraOffset = new c.Point, this.hash = [], this._sortProperty = "z"
            }, c.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), c.Group.prototype.constructor = c.Group, c.Group.RETURN_NONE = 0, c.Group.RETURN_TOTAL = 1, c.Group.RETURN_CHILD = 2, c.Group.RETURN_ALL = 3, c.Group.SORT_ASCENDING = -1, c.Group.SORT_DESCENDING = 1, c.Group.prototype.add = function(a, b, c) {
                return void 0 === b && (b = !1), a.parent === this ? a : (a.body && a.parent && a.parent.hash && a.parent.removeFromHash(a), void 0 === c ? (a.z = this.children.length, this.addChild(a)) : (this.addChildAt(a, c), this.updateZ()), this.enableBody && a.hasOwnProperty("body") && null === a.body ? this.game.physics.enable(a, this.physicsBodyType) : a.body && this.addToHash(a), !this.inputEnableChildren || a.input && !a.inputEnabled || (a.inputEnabled = !0), !b && a.events && a.events.onAddedToGroup$dispatch(a, this), null === this.cursor && (this.cursor = a), a)
            }, c.Group.prototype.addAt = function(a, b, c) {
                this.add(a, c, b)
            }, c.Group.prototype.addToHash = function(a) {
                if (a.parent === this) {
                    var b = this.hash.indexOf(a);
                    if (b === -1) return this.hash.push(a), !0
                }
                return !1
            }, c.Group.prototype.removeFromHash = function(a) {
                if (a) {
                    var b = this.hash.indexOf(a);
                    if (b !== -1) return this.hash.splice(b, 1), !0
                }
                return !1
            }, c.Group.prototype.addMultiple = function(a, b) {
                if (a instanceof c.Group) a.moveAll(this, b);
                else if (Array.isArray(a))
                    for (var d = 0; d < a.length; d++) this.add(a[d], b);
                return a
            }, c.Group.prototype.getAt = function(a) {
                return a < 0 || a >= this.children.length ? -1 : this.getChildAt(a)
            }, c.Group.prototype.create = function(a, b, c, d, e, f) {
                void 0 === e && (e = !0);
                var g = new this.classType(this.game, a, b, c, d);
                return g.exists = e, g.visible = e, g.alive = e, this.add(g, !1, f)
            }, c.Group.prototype.createMultiple = function(a, b, c, d) {
                void 0 === c && (c = 0), void 0 === d && (d = !1), Array.isArray(b) || (b = [b]), Array.isArray(c) || (c = [c]);
                var e = this,
                    f = [];
                return b.forEach(function(b) {
                    c.forEach(function(c) {
                        for (var g = 0; g < a; g++) f.push(e.create(0, 0, b, c, d))
                    })
                }), f
            }, c.Group.prototype.updateZ = function() {
                for (var a = this.children.length; a--;) this.children[a].z = a
            }, c.Group.prototype.align = function(a, b, d, e, f, g) {
                if (void 0 === f && (f = c.TOP_LEFT), void 0 === g && (g = 0), 0 === this.children.length || g > this.children.length || a === -1 && b === -1) return !1;
                for (var h = new c.Rectangle(0, 0, d, e), i = a * d, j = b * e, k = g; k < this.children.length; k++) {
                    var l = this.children[k];
                    if (l.alignIn)
                        if (l.alignIn(h, f), a === -1) h.y += e, h.y === j && (h.x += d, h.y = 0);
                        else if (b === -1) h.x += d, h.x === i && (h.x = 0, h.y += e);
                    else if (h.x += d, h.x === i && (h.x = 0, h.y += e, h.y === j)) return !0
                }
                return !0
            }, c.Group.prototype.resetCursor = function(a) {
                if (void 0 === a && (a = 0), a > this.children.length - 1 && (a = 0), this.cursor) return this.cursorIndex = a, this.cursor = this.children[this.cursorIndex], this.cursor
            }, c.Group.prototype.next = function() {
                if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor
            }, c.Group.prototype.previous = function() {
                if (this.cursor) return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor
            }, c.Group.prototype.swap = function(a, b) {
                this.swapChildren(a, b), this.updateZ()
            }, c.Group.prototype.bringToTop = function(a) {
                return a.parent === this && this.getIndex(a) < this.children.length && (this.remove(a, !1, !0), this.add(a, !0)), a
            }, c.Group.prototype.sendToBack = function(a) {
                return a.parent === this && this.getIndex(a) > 0 && (this.remove(a, !1, !0), this.addAt(a, 0, !0)), a
            }, c.Group.prototype.moveUp = function(a) {
                if (a.parent === this && this.getIndex(a) < this.children.length - 1) {
                    var b = this.getIndex(a),
                        c = this.getAt(b + 1);
                    c && this.swap(a, c)
                }
                return a
            }, c.Group.prototype.moveDown = function(a) {
                if (a.parent === this && this.getIndex(a) > 0) {
                    var b = this.getIndex(a),
                        c = this.getAt(b - 1);
                    c && this.swap(a, c)
                }
                return a
            }, c.Group.prototype.xy = function(a, b, c) {
                return a < 0 || a > this.children.length ? -1 : (this.getChildAt(a).x = b, void(this.getChildAt(a).y = c))
            }, c.Group.prototype.reverse = function() {
                this.children.reverse(), this.updateZ()
            }, c.Group.prototype.getIndex = function(a) {
                return this.children.indexOf(a)
            }, c.Group.prototype.getByName = function(a) {
                for (var b = 0; b < this.children.length; b++)
                    if (this.children[b].name === a) return this.children[b];
                return null
            }, c.Group.prototype.replace = function(a, b) {
                var d = this.getIndex(a);
                if (d !== -1) return b.parent && (b.parent instanceof c.Group ? b.parent.remove(b) : b.parent.removeChild(b)), this.remove(a), this.addAt(b, d), a
            }, c.Group.prototype.hasProperty = function(a, b) {
                var c = b.length;
                return 1 === c && b[0] in a || 2 === c && b[0] in a && b[1] in a[b[0]] || 3 === c && b[0] in a && b[1] in a[b[0]] && b[2] in a[b[0]][b[1]] || 4 === c && b[0] in a && b[1] in a[b[0]] && b[2] in a[b[0]][b[1]] && b[3] in a[b[0]][b[1]][b[2]]
            }, c.Group.prototype.setProperty = function(a, b, c, d, e) {
                if (void 0 === e && (e = !1), d = d || 0, !this.hasProperty(a, b) && (!e || d > 0)) return !1;
                var f = b.length;
                return 1 === f ? 0 === d ? a[b[0]] = c : 1 === d ? a[b[0]] += c : 2 === d ? a[b[0]] -= c : 3 === d ? a[b[0]] *= c : 4 === d && (a[b[0]] /= c) : 2 === f ? 0 === d ? a[b[0]][b[1]] = c : 1 === d ? a[b[0]][b[1]] += c : 2 === d ? a[b[0]][b[1]] -= c : 3 === d ? a[b[0]][b[1]] *= c : 4 === d && (a[b[0]][b[1]] /= c) : 3 === f ? 0 === d ? a[b[0]][b[1]][b[2]] = c : 1 === d ? a[b[0]][b[1]][b[2]] += c : 2 === d ? a[b[0]][b[1]][b[2]] -= c : 3 === d ? a[b[0]][b[1]][b[2]] *= c : 4 === d && (a[b[0]][b[1]][b[2]] /= c) : 4 === f && (0 === d ? a[b[0]][b[1]][b[2]][b[3]] = c : 1 === d ? a[b[0]][b[1]][b[2]][b[3]] += c : 2 === d ? a[b[0]][b[1]][b[2]][b[3]] -= c : 3 === d ? a[b[0]][b[1]][b[2]][b[3]] *= c : 4 === d && (a[b[0]][b[1]][b[2]][b[3]] /= c)), !0
            }, c.Group.prototype.checkProperty = function(a, b, d, e) {
                return void 0 === e && (e = !1), !(!c.Utils.getProperty(a, b) && e) && c.Utils.getProperty(a, b) === d
            }, c.Group.prototype.set = function(a, b, c, d, e, f, g) {
                if (void 0 === g && (g = !1), b = b.split("."), void 0 === d && (d = !1), void 0 === e && (e = !1), (d === !1 || d && a.alive) && (e === !1 || e && a.visible)) return this.setProperty(a, b, c, f, g)
            }, c.Group.prototype.setAll = function(a, b, c, d, e, f) {
                void 0 === c && (c = !1), void 0 === d && (d = !1), void 0 === f && (f = !1), a = a.split("."), e = e || 0;
                for (var g = 0; g < this.children.length; g++)(!c || c && this.children[g].alive) && (!d || d && this.children[g].visible) && this.setProperty(this.children[g], a, b, e, f)
            }, c.Group.prototype.setAllChildren = function(a, b, d, e, f, g) {
                void 0 === d && (d = !1), void 0 === e && (e = !1), void 0 === g && (g = !1), f = f || 0;
                for (var h = 0; h < this.children.length; h++)(!d || d && this.children[h].alive) && (!e || e && this.children[h].visible) && (this.children[h] instanceof c.Group ? this.children[h].setAllChildren(a, b, d, e, f, g) : this.setProperty(this.children[h], a.split("."), b, f, g))
            }, c.Group.prototype.checkAll = function(a, b, c, d, e) {
                void 0 === c && (c = !1), void 0 === d && (d = !1), void 0 === e && (e = !1);
                for (var f = 0; f < this.children.length; f++)
                    if ((!c || c && this.children[f].alive) && (!d || d && this.children[f].visible) && !this.checkProperty(this.children[f], a, b, e)) return !1;
                return !0
            }, c.Group.prototype.addAll = function(a, b, c, d) {
                this.setAll(a, b, c, d, 1)
            }, c.Group.prototype.subAll = function(a, b, c, d) {
                this.setAll(a, b, c, d, 2)
            }, c.Group.prototype.multiplyAll = function(a, b, c, d) {
                this.setAll(a, b, c, d, 3)
            }, c.Group.prototype.divideAll = function(a, b, c, d) {
                this.setAll(a, b, c, d, 4)
            }, c.Group.prototype.callAllExists = function(a, b) {
                var c;
                if (arguments.length > 2) {
                    c = [];
                    for (var d = 2; d < arguments.length; d++) c.push(arguments[d])
                }
                for (var d = 0; d < this.children.length; d++) this.children[d].exists === b && this.children[d][a] && this.children[d][a].apply(this.children[d], c)
            }, c.Group.prototype.callbackFromArray = function(a, b, c) {
                if (1 === c) {
                    if (a[b[0]]) return a[b[0]]
                } else if (2 === c) {
                    if (a[b[0]][b[1]]) return a[b[0]][b[1]]
                } else if (3 === c) {
                    if (a[b[0]][b[1]][b[2]]) return a[b[0]][b[1]][b[2]]
                } else if (4 === c) {
                    if (a[b[0]][b[1]][b[2]][b[3]]) return a[b[0]][b[1]][b[2]][b[3]]
                } else if (a[b]) return a[b];
                return !1
            }, c.Group.prototype.callAll = function(a, b) {
                if (void 0 !== a) {
                    a = a.split(".");
                    var c = a.length;
                    if (void 0 === b || null === b || "" === b) b = null;
                    else if ("string" == typeof b) {
                        b = b.split(".");
                        var d = b.length
                    }
                    var e;
                    if (arguments.length > 2) {
                        e = [];
                        for (var f = 2; f < arguments.length; f++) e.push(arguments[f])
                    }
                    for (var g = null, h = null, f = 0; f < this.children.length; f++) g = this.callbackFromArray(this.children[f], a, c), b && g ? (h = this.callbackFromArray(this.children[f], b, d), g && g.apply(h, e)) : g && g.apply(this.children[f], e)
                }
            }, c.Group.prototype.preUpdate = function() {
                if (this.pendingDestroy) return this.destroy(), !1;
                if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
                for (var a = 0; a < this.children.length; a++) this.children[a].preUpdate();
                return !0
            }, c.Group.prototype.update = function() {
                for (var a = this.children.length; a--;) this.children[a].update()
            }, c.Group.prototype.postUpdate = function() {
                this.fixedToCamera && (this.x = this.game.camera.view.x + this.cameraOffset.x, this.y = this.game.camera.view.y + this.cameraOffset.y);
                for (var a = 0; a < this.children.length; a++) this.children[a].postUpdate()
            }, c.Group.prototype.filter = function(a, b) {
                for (var d = -1, e = this.children.length, f = []; ++d < e;) {
                    var g = this.children[d];
                    (!b || b && g.exists) && a(g, d, this.children) && f.push(g)
                }
                return new c.ArraySet(f)
            }, c.Group.prototype.forEach = function(a, b, c) {
                if (void 0 === c && (c = !1), arguments.length <= 3)
                    for (var d = 0; d < this.children.length; d++)(!c || c && this.children[d].exists) && a.call(b, this.children[d]);
                else {
                    for (var e = [null], d = 3; d < arguments.length; d++) e.push(arguments[d]);
                    for (var d = 0; d < this.children.length; d++)(!c || c && this.children[d].exists) && (e[0] = this.children[d], a.apply(b, e))
                }
            }, c.Group.prototype.forEachExists = function(a, b) {
                var d;
                if (arguments.length > 2) {
                    d = [null];
                    for (var e = 2; e < arguments.length; e++) d.push(arguments[e])
                }
                this.iterate("exists", !0, c.Group.RETURN_TOTAL, a, b, d)
            }, c.Group.prototype.forEachAlive = function(a, b) {
                var d;
                if (arguments.length > 2) {
                    d = [null];
                    for (var e = 2; e < arguments.length; e++) d.push(arguments[e])
                }
                this.iterate("alive", !0, c.Group.RETURN_TOTAL, a, b, d)
            }, c.Group.prototype.forEachDead = function(a, b) {
                var d;
                if (arguments.length > 2) {
                    d = [null];
                    for (var e = 2; e < arguments.length; e++) d.push(arguments[e])
                }
                this.iterate("alive", !1, c.Group.RETURN_TOTAL, a, b, d)
            }, c.Group.prototype.sort = function(a, b) {
                this.children.length < 2 || (void 0 === a && (a = "z"), void 0 === b && (b = c.Group.SORT_ASCENDING), this._sortProperty = a, b === c.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ())
            }, c.Group.prototype.customSort = function(a, b) {
                this.children.length < 2 || (this.children.sort(a.bind(b)), this.updateZ())
            }, c.Group.prototype.ascendingSortHandler = function(a, b) {
                return a[this._sortProperty] < b[this._sortProperty] ? -1 : a[this._sortProperty] > b[this._sortProperty] ? 1 : a.z < b.z ? -1 : 1
            }, c.Group.prototype.descendingSortHandler = function(a, b) {
                return a[this._sortProperty] < b[this._sortProperty] ? 1 : a[this._sortProperty] > b[this._sortProperty] ? -1 : 0
            }, c.Group.prototype.iterate = function(a, b, d, e, f, g) {
                if (0 === this.children.length) {
                    if (d === c.Group.RETURN_TOTAL) return 0;
                    if (d === c.Group.RETURN_ALL) return []
                }
                var h = 0;
                if (d === c.Group.RETURN_ALL) var i = [];
                for (var j = 0; j < this.children.length; j++)
                    if (this.children[j][a] === b) {
                        if (h++, e && (g ? (g[0] = this.children[j], e.apply(f, g)) : e.call(f, this.children[j])), d === c.Group.RETURN_CHILD) return this.children[j];
                        d === c.Group.RETURN_ALL && i.push(this.children[j])
                    }
                return d === c.Group.RETURN_TOTAL ? h : d === c.Group.RETURN_ALL ? i : null
            }, c.Group.prototype.getFirstExists = function(a, b, d, e, f, g) {
                void 0 === b && (b = !1), "boolean" != typeof a && (a = !0);
                var h = this.iterate("exists", a, c.Group.RETURN_CHILD);
                return null === h && b ? this.create(d, e, f, g) : this.resetChild(h, d, e, f, g)
            }, c.Group.prototype.getFirstAlive = function(a, b, d, e, f) {
                void 0 === a && (a = !1);
                var g = this.iterate("alive", !0, c.Group.RETURN_CHILD);
                return null === g && a ? this.create(b, d, e, f) : this.resetChild(g, b, d, e, f)
            }, c.Group.prototype.getFirstDead = function(a, b, d, e, f) {
                void 0 === a && (a = !1);
                var g = this.iterate("alive", !1, c.Group.RETURN_CHILD);
                return null === g && a ? this.create(b, d, e, f) : this.resetChild(g, b, d, e, f)
            }, c.Group.prototype.resetChild = function(a, b, c, d, e) {
                return null === a ? null : (void 0 === b && (b = null), void 0 === c && (c = null), null !== b && null !== c && a.reset(b, c), void 0 !== d && a.loadTexture(d, e), a)
            }, c.Group.prototype.getTop = function() {
                if (this.children.length > 0) return this.children[this.children.length - 1]
            }, c.Group.prototype.getBottom = function() {
                if (this.children.length > 0) return this.children[0]
            }, c.Group.prototype.getClosestTo = function(a, b, d) {
                for (var e = Number.MAX_VALUE, f = 0, g = null, h = 0; h < this.children.length; h++) {
                    var i = this.children[h];
                    i.exists && (f = Math.abs(c.Point.distance(a, i)), f < e && (!b || b.call(d, i, f)) && (e = f, g = i))
                }
                return g
            }, c.Group.prototype.getFurthestFrom = function(a, b, d) {
                for (var e = 0, f = 0, g = null, h = 0; h < this.children.length; h++) {
                    var i = this.children[h];
                    i.exists && (f = Math.abs(c.Point.distance(a, i)), f > e && (!b || b.call(d, i, f)) && (e = f, g = i))
                }
                return g
            }, c.Group.prototype.countLiving = function() {
                return this.iterate("alive", !0, c.Group.RETURN_TOTAL)
            }, c.Group.prototype.countDead = function() {
                return this.iterate("alive", !1, c.Group.RETURN_TOTAL)
            }, c.Group.prototype.getRandom = function(a, b) {
                return void 0 === a && (a = 0), void 0 === b && (b = this.children.length), 0 === b ? null : c.ArrayUtils.getRandomItem(this.children, a, b)
            }, c.Group.prototype.getRandomExists = function(a, b) {
                var c = this.getAll("exists", !0, a, b);
                return this.game.rnd.pick(c)
            }, c.Group.prototype.getAll = function(a, b, c, d) {
                void 0 === c && (c = 0), void 0 === d && (d = this.children.length);
                for (var e = [], f = c; f < d; f++) {
                    var g = this.children[f];
                    a && g[a] === b && e.push(g)
                }
                return e
            }, c.Group.prototype.remove = function(a, b, c) {
                if (void 0 === b && (b = !1), void 0 === c && (c = !1), 0 === this.children.length || this.children.indexOf(a) === -1) return !1;
                c || !a.events || a.destroyPhase || a.events.onRemovedFromGroup$dispatch(a, this);
                var d = this.removeChild(a);
                return this.removeFromHash(a), this.updateZ(), this.cursor === a && this.next(), b && d && d.destroy(!0), !0
            }, c.Group.prototype.moveAll = function(a, b) {
                if (void 0 === b && (b = !1), this.children.length > 0 && a instanceof c.Group) {
                    do a.add(this.children[0], b); while (this.children.length > 0);
                    this.hash = [], this.cursor = null
                }
                return a
            }, c.Group.prototype.removeAll = function(a, b, c) {
                if (void 0 === a && (a = !1), void 0 === b && (b = !1), void 0 === c && (c = !1), 0 !== this.children.length) {
                    do {
                        !b && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                        var d = this.removeChild(this.children[0]);
                        this.removeFromHash(d), a && d && d.destroy(!0, c)
                    } while (this.children.length > 0);
                    this.hash = [], this.cursor = null
                }
            }, c.Group.prototype.removeBetween = function(a, b, c, d) {
                if (void 0 === b && (b = this.children.length - 1), void 0 === c && (c = !1), void 0 === d && (d = !1), 0 !== this.children.length) {
                    if (a > b || a < 0 || b > this.children.length) return !1;
                    for (var e = b; e >= a;) {
                        !d && this.children[e].events && this.children[e].events.onRemovedFromGroup$dispatch(this.children[e], this);
                        var f = this.removeChild(this.children[e]);
                        this.removeFromHash(f), c && f && f.destroy(!0), this.cursor === this.children[e] && (this.cursor = null), e--
                    }
                    this.updateZ()
                }
            }, c.Group.prototype.destroy = function(a, b) {
                null === this.game || this.ignoreDestroy || (void 0 === a && (a = !0), void 0 === b && (b = !1), this.onDestroy.dispatch(this, a, b), this.removeAll(a), this.cursor = null, this.filters = null, this.pendingDestroy = !1, b || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1))
            }, Object.defineProperty(c.Group.prototype, "total", {
                get: function() {
                    return this.iterate("exists", !0, c.Group.RETURN_TOTAL)
                }
            }), Object.defineProperty(c.Group.prototype, "length", {
                get: function() {
                    return this.children.length
                }
            }), Object.defineProperty(c.Group.prototype, "angle", {
                get: function() {
                    return c.Math.radToDeg(this.rotation)
                },
                set: function(a) {
                    this.rotation = c.Math.degToRad(a)
                }
            }), Object.defineProperty(c.Group.prototype, "centerX", {
                get: function() {
                    return this.getBounds(this.parent).centerX
                },
                set: function(a) {
                    var b = this.getBounds(this.parent),
                        c = this.x - b.x;
                    this.x = a + c - b.halfWidth
                }
            }), Object.defineProperty(c.Group.prototype, "centerY", {
                get: function() {
                    return this.getBounds(this.parent).centerY
                },
                set: function(a) {
                    var b = this.getBounds(this.parent),
                        c = this.y - b.y;
                    this.y = a + c - b.halfHeight
                }
            }), Object.defineProperty(c.Group.prototype, "left", {
                get: function() {
                    return this.getBounds(this.parent).left
                },
                set: function(a) {
                    var b = this.getBounds(this.parent),
                        c = this.x - b.x;
                    this.x = a + c
                }
            }), Object.defineProperty(c.Group.prototype, "right", {
                get: function() {
                    return this.getBounds(this.parent).right
                },
                set: function(a) {
                    var b = this.getBounds(this.parent),
                        c = this.x - b.x;
                    this.x = a + c - b.width
                }
            }), Object.defineProperty(c.Group.prototype, "top", {
                get: function() {
                    return this.getBounds(this.parent).top
                },
                set: function(a) {
                    var b = this.getBounds(this.parent),
                        c = this.y - b.y;
                    this.y = a + c
                }
            }), Object.defineProperty(c.Group.prototype, "bottom", {
                get: function() {
                    return this.getBounds(this.parent).bottom
                },
                set: function(a) {
                    var b = this.getBounds(this.parent),
                        c = this.y - b.y;
                    this.y = a + c - b.height
                }
            }), c.World = function(a) {
                c.Group.call(this, a, null, "__world", !1), this.bounds = new c.Rectangle(0, 0, a.width, a.height), this.camera = null, this._definedSize = !1, this._width = a.width, this._height = a.height, this.game.state.onStateChange.add(this.stateChange, this)
            }, c.World.prototype = Object.create(c.Group.prototype), c.World.prototype.constructor = c.World, c.World.prototype.boot = function() {
                this.camera = new c.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.game.stage.addChild(this), this.camera.boot()
            }, c.World.prototype.stateChange = function() {
                this.x = 0, this.y = 0, this.camera.reset()
            }, c.World.prototype.setBounds = function(a, b, c, d) {
                this._definedSize = !0, this._width = c, this._height = d, this.bounds.setTo(a, b, c, d), this.x = a, this.y = b, this.camera.bounds && this.camera.bounds.setTo(a, b, Math.max(c, this.game.width), Math.max(d, this.game.height)), this.game.physics.setBoundsToWorld()
            }, c.World.prototype.resize = function(a, b) {
                this._definedSize && (a < this._width && (a = this._width), b < this._height && (b = this._height)), this.bounds.width = a, this.bounds.height = b, this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld()
            }, c.World.prototype.shutdown = function() {
                this.destroy(!0, !0)
            }, c.World.prototype.wrap = function(a, b, c, d, e) {
                void 0 === b && (b = 0), void 0 === c && (c = !1), void 0 === d && (d = !0), void 0 === e && (e = !0), c ? (a.getBounds(), d && (a.x + a._currentBounds.width < this.bounds.x ? a.x = this.bounds.right : a.x > this.bounds.right && (a.x = this.bounds.left)), e && (a.y + a._currentBounds.height < this.bounds.top ? a.y = this.bounds.bottom : a.y > this.bounds.bottom && (a.y = this.bounds.top))) : (d && a.x + b < this.bounds.x ? a.x = this.bounds.right + b : d && a.x - b > this.bounds.right && (a.x = this.bounds.left - b), e && a.y + b < this.bounds.top ? a.y = this.bounds.bottom + b : e && a.y - b > this.bounds.bottom && (a.y = this.bounds.top - b))
            }, Object.defineProperty(c.World.prototype, "width", {
                get: function() {
                    return this.bounds.width
                },
                set: function(a) {
                    a < this.game.width && (a = this.game.width), this.bounds.width = a, this._width = a, this._definedSize = !0
                }
            }), Object.defineProperty(c.World.prototype, "height", {
                get: function() {
                    return this.bounds.height
                },
                set: function(a) {
                    a < this.game.height && (a = this.game.height), this.bounds.height = a, this._height = a, this._definedSize = !0
                }
            }), Object.defineProperty(c.World.prototype, "centerX", {
                get: function() {
                    return this.bounds.halfWidth + this.bounds.x
                }
            }), Object.defineProperty(c.World.prototype, "centerY", {
                get: function() {
                    return this.bounds.halfHeight + this.bounds.y
                }
            }), Object.defineProperty(c.World.prototype, "randomX", {
                get: function() {
                    return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width)
                }
            }), Object.defineProperty(c.World.prototype, "randomY", {
                get: function() {
                    return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height)
                }
            }), c.Game = function(a, b, d, e, f, g, h, i) {
                return this.id = c.GAMES.push(this) - 1, this.config = null, this.physicsConfig = i, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = !1, this.antialias = !0, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !0, this.renderer = null, this.renderType = c.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.plugins = null, this.rnd = null, this.device = c.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = !1, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new c.Signal, this.forceSingleUpdate = !0, this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = {
                    enableDebug: !0
                }, "undefined" != typeof a && (this._width = a), "undefined" != typeof b && (this._height = b), "undefined" != typeof d && (this.renderType = d), "undefined" != typeof e && (this.parent = e), "undefined" != typeof g && (this.transparent = g), "undefined" != typeof h && (this.antialias = h), this.rnd = new c.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new c.StateManager(this, f)), this.device.whenReady(this.boot, this), this
            }, c.Game.prototype = {
                parseConfig: function(a) {
                    this.config = a, void 0 === a.enableDebug && (this.config.enableDebug = !0), a.width && (this._width = a.width), a.height && (this._height = a.height), a.renderer && (this.renderType = a.renderer), a.parent && (this.parent = a.parent), void 0 !== a.transparent && (this.transparent = a.transparent), void 0 !== a.antialias && (this.antialias = a.antialias), a.resolution && (this.resolution = a.resolution), void 0 !== a.preserveDrawingBuffer && (this.preserveDrawingBuffer = a.preserveDrawingBuffer), a.physicsConfig && (this.physicsConfig = a.physicsConfig);
                    var b = [(Date.now() * Math.random()).toString()];
                    a.seed && (b = a.seed), this.rnd = new c.RandomDataGenerator(b);
                    var d = null;
                    a.state && (d = a.state), this.state = new c.StateManager(this, d)
                },
                boot: function() {
                    this.isBooted || (this.onPause = new c.Signal, this.onResume = new c.Signal, this.onBlur = new c.Signal, this.onFocus = new c.Signal, this.isBooted = !0, PIXI.game = this, this.math = c.Math, this.scale = new c.ScaleManager(this, this._width, this._height), this.stage = new c.Stage(this), this.setUpRenderer(), this.world = new c.World(this), this.add = new c.GameObjectFactory(this), this.make = new c.GameObjectCreator(this), this.cache = new c.Cache(this), this.load = new c.Loader(this), this.time = new c.Time(this), this.tweens = new c.TweenManager(this),
                        this.input = new c.Input(this), this.sound = new c.SoundManager(this), this.physics = new c.Physics(this, this.physicsConfig), this.particles = new c.Particles(this), this.create = new c.Create(this), this.plugins = new c.PluginManager(this), this.net = new c.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(), this.sound.boot(), this.state.boot(), this.config.enableDebug ? (this.debug = new c.Utils.Debug(this), this.debug.boot()) : this.debug = {
                            preUpdate: function() {},
                            update: function() {},
                            reset: function() {}
                        }, this.showDebugHeader(), this.isRunning = !0, this.config && this.config.forceSetTimeOut ? this.raf = new c.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new c.RequestAnimationFrame(this, (!1)), this._kickstart = !0, window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus(), this.raf.start())
                },
                showDebugHeader: function() {
                    if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                        var a = c.VERSION,
                            b = "Canvas",
                            d = "HTML Audio",
                            e = 1;
                        if (this.renderType === c.WEBGL ? (b = "WebGL", e++) : this.renderType === c.HEADLESS && (b = "Headless"), this.device.webAudio && (d = "WebAudio", e++), this.device.chrome)
                            for (var f = ["%c %c %c Phaser v" + a + " | Pixi.js | " + b + " | " + d + "  %c %c %c http://phaser.io %c♥%c♥%c♥", "background: #fb8cb3", "background: #d44a52", "color: #ffffff; background: #871905;", "background: #d44a52", "background: #fb8cb3", "background: #ffffff"], g = 0; g < 3; g++) g < e ? f.push("color: #ff2424; background: #fff") : f.push("color: #959595; background: #fff");
                        else window.console && void 0
                    }
                },
                setUpRenderer: function() {
                    if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = c.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.renderType === c.HEADLESS || this.renderType === c.CANVAS || this.renderType === c.AUTO && !this.device.webGL) {
                        if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas or WebGL context, aborting.");
                        this.renderType = c.CANVAS, this.renderer = new PIXI.CanvasRenderer(this), this.context = this.renderer.context
                    } else this.renderType = c.WEBGL, this.renderer = new PIXI.WebGLRenderer(this), this.context = null, this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1), this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1);
                    this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === c.CANVAS), this.renderType !== c.HEADLESS && (this.stage.smoothed = this.antialias, c.Canvas.addToDOM(this.canvas, this.parent, !1), c.Canvas.setTouchAction(this.canvas))
                },
                contextLost: function(a) {
                    a.preventDefault(), this.renderer.contextLost = !0
                },
                contextRestored: function() {
                    this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1
                },
                update: function(a) {
                    if (this.time.update(a), this._kickstart) return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void(this._kickstart = !1);
                    if (this._spiraling > 1 && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0, this.updateRender(this.time.slowMotion * this.time.desiredFps);
                    else {
                        var b = 1e3 * this.time.slowMotion / this.time.desiredFps;
                        this._deltaTime += Math.max(Math.min(3 * b, this.time.elapsed), 0);
                        var c = 0;
                        for (this.updatesThisFrame = Math.floor(this._deltaTime / b), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= b && (this._deltaTime -= b, this.currentUpdateID = c, this.updateLogic(this.time.desiredFpsMult), c++, !this.forceSingleUpdate || 1 !== c);) this.time.refresh();
                        c > this._lastCount ? this._spiraling++ : c < this._lastCount && (this._spiraling = 0), this._lastCount = c, this.updateRender(this._deltaTime / b)
                    }
                },
                updateLogic: function(a) {
                    this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(), this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(a), this.plugins.preUpdate(a), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.particles.update(), this.plugins.update(), this.stage.postUpdate(), this.plugins.postUpdate()), this.stage.updateTransform()
                },
                updateRender: function(a) {
                    this.lockRender || (this.state.preRender(a), this.renderType !== c.HEADLESS && (this.renderer.render(this.stage), this.plugins.render(a), this.state.render(a)), this.plugins.postRender(a))
                },
                enableStep: function() {
                    this.stepping = !0, this.pendingStep = !1, this.stepCount = 0
                },
                disableStep: function() {
                    this.stepping = !1, this.pendingStep = !1
                },
                step: function() {
                    this.pendingStep = !1, this.stepCount++
                },
                destroy: function() {
                    this.raf.stop(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.plugins.destroy(), this.state = null, this.sound = null, this.scale = null, this.stage = null, this.input = null, this.physics = null, this.plugins = null, this.cache = null, this.load = null, this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), c.Canvas.removeFromDOM(this.canvas), PIXI.defaultRenderer = null, c.GAMES[this.id] = null
                },
                gamePaused: function(a) {
                    this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.muteOnPause && this.sound.setMute(), this.onPause.dispatch(a), this.device.cordova && this.device.iOS && (this.lockRender = !0))
                },
                gameResumed: function(a) {
                    this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.muteOnPause && this.sound.unsetMute(), this.onResume.dispatch(a), this.device.cordova && this.device.iOS && (this.lockRender = !1))
                },
                focusLoss: function(a) {
                    this.onBlur.dispatch(a), this.stage.disableVisibilityChange || this.gamePaused(a)
                },
                focusGain: function(a) {
                    this.onFocus.dispatch(a), this.stage.disableVisibilityChange || this.gameResumed(a)
                }
            }, c.Game.prototype.constructor = c.Game, Object.defineProperty(c.Game.prototype, "paused", {
                get: function() {
                    return this._paused
                },
                set: function(a) {
                    a === !0 ? (this._paused === !1 && (this._paused = !0, this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), this._codePaused = !1)
                }
            }), c.Input = function(a) {
                this.game = a, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.customCandidateHandler = null, this.customCandidateHandlerContext = null, this.pollRate = 0, this.enabled = !0, this.multiInputOverride = c.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new c.ArraySet, this._localPoint = new c.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0
            }, c.Input.MOUSE_OVERRIDES_TOUCH = 0, c.Input.TOUCH_OVERRIDES_MOUSE = 1, c.Input.MOUSE_TOUCH_COMBINE = 2, c.Input.MAX_POINTERS = 10, c.Input.prototype = {
                boot: function() {
                    this.mousePointer = new c.Pointer(this.game, 0, c.PointerMode.CURSOR), this.addPointer(), this.addPointer(), this.mouse = new c.Mouse(this.game), this.touch = new c.Touch(this.game), this.mspointer = new c.MSPointer(this.game), c.Keyboard && (this.keyboard = new c.Keyboard(this.game)), c.Gamepad && (this.gamepad = new c.Gamepad(this.game)), this.onDown = new c.Signal, this.onUp = new c.Signal, this.onTap = new c.Signal, this.onHold = new c.Signal, this.scale = new c.Point(1, 1), this.speed = new c.Point, this.position = new c.Point, this._oldPosition = new c.Point, this.circle = new c.Circle(0, 0, 44), this.activePointer = this.mousePointer, this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1), this.hitContext = this.hitCanvas.getContext("2d"), this.mouse.start(), this.touch.start(), this.mspointer.start(), this.mousePointer.active = !0, this.keyboard && this.keyboard.start();
                    var a = this;
                    this._onClickTrampoline = function(b) {
                        a.onClickTrampoline(b)
                    }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
                },
                destroy: function() {
                    this.mouse.stop(), this.touch.stop(), this.mspointer.stop(), this.keyboard && this.keyboard.stop(), this.gamepad && this.gamepad.stop(), this.moveCallbacks = [], PIXI.CanvasPool.remove(this), this.game.canvas.removeEventListener("click", this._onClickTrampoline)
                },
                setInteractiveCandidateHandler: function(a, b) {
                    this.customCandidateHandler = a, this.customCandidateHandlerContext = b
                },
                addMoveCallback: function(a, b) {
                    this.moveCallbacks.push({
                        callback: a,
                        context: b
                    })
                },
                deleteMoveCallback: function(a, b) {
                    for (var c = this.moveCallbacks.length; c--;)
                        if (this.moveCallbacks[c].callback === a && this.moveCallbacks[c].context === b) return void this.moveCallbacks.splice(c, 1)
                },
                addPointer: function() {
                    if (this.pointers.length >= c.Input.MAX_POINTERS) return null;
                    var a = this.pointers.length + 1,
                        b = new c.Pointer(this.game, a, c.PointerMode.TOUCH);
                    return this.pointers.push(b), this["pointer" + a] = b, b
                },
                update: function() {
                    if (this.keyboard && this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate) return void this._pollCounter++;
                    this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad && this.gamepad.active && this.gamepad.update();
                    for (var a = 0; a < this.pointers.length; a++) this.pointers[a].update();
                    this._pollCounter = 0
                },
                reset: function(a) {
                    if (this.game.isBooted && !this.resetLocked) {
                        void 0 === a && (a = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(a), this.gamepad && this.gamepad.reset();
                        for (var b = 0; b < this.pointers.length; b++) this.pointers[b].reset();
                        "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit"), a && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new c.Signal, this.onUp = new c.Signal, this.onTap = new c.Signal, this.onHold = new c.Signal, this.moveCallbacks = []), this._pollCounter = 0
                    }
                },
                resetSpeed: function(a, b) {
                    this._oldPosition.setTo(a, b), this.speed.setTo(0, 0)
                },
                startPointer: function(a) {
                    if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null;
                    if (!this.pointer1.active) return this.pointer1.start(a);
                    if (!this.pointer2.active) return this.pointer2.start(a);
                    for (var b = 2; b < this.pointers.length; b++) {
                        var c = this.pointers[b];
                        if (!c.active) return c.start(a)
                    }
                    return null
                },
                updatePointer: function(a) {
                    if (this.pointer1.active && this.pointer1.identifier === a.identifier) return this.pointer1.move(a);
                    if (this.pointer2.active && this.pointer2.identifier === a.identifier) return this.pointer2.move(a);
                    for (var b = 2; b < this.pointers.length; b++) {
                        var c = this.pointers[b];
                        if (c.active && c.identifier === a.identifier) return c.move(a)
                    }
                    return null
                },
                stopPointer: function(a) {
                    if (this.pointer1.active && this.pointer1.identifier === a.identifier) return this.pointer1.stop(a);
                    if (this.pointer2.active && this.pointer2.identifier === a.identifier) return this.pointer2.stop(a);
                    for (var b = 2; b < this.pointers.length; b++) {
                        var c = this.pointers[b];
                        if (c.active && c.identifier === a.identifier) return c.stop(a)
                    }
                    return null
                },
                countActivePointers: function(a) {
                    void 0 === a && (a = this.pointers.length);
                    for (var b = a, c = 0; c < this.pointers.length && b > 0; c++) {
                        var d = this.pointers[c];
                        d.active && b--
                    }
                    return a - b
                },
                getPointer: function(a) {
                    void 0 === a && (a = !1);
                    for (var b = 0; b < this.pointers.length; b++) {
                        var c = this.pointers[b];
                        if (c.active === a) return c
                    }
                    return null
                },
                getPointerFromIdentifier: function(a) {
                    for (var b = 0; b < this.pointers.length; b++) {
                        var c = this.pointers[b];
                        if (c.identifier === a) return c
                    }
                    return null
                },
                getPointerFromId: function(a) {
                    for (var b = 0; b < this.pointers.length; b++) {
                        var c = this.pointers[b];
                        if (c.pointerId === a) return c
                    }
                    return null
                },
                getLocalPosition: function(a, b, d) {
                    void 0 === d && (d = new c.Point);
                    var e = a.worldTransform,
                        f = 1 / (e.a * e.d + e.c * -e.b);
                    return d.setTo(e.d * f * b.x + -e.c * f * b.y + (e.ty * e.c - e.tx * e.d) * f, e.a * f * b.y + -e.b * f * b.x + (-e.ty * e.a + e.tx * e.b) * f)
                },
                hitTest: function(a, b, d) {
                    if (!a.worldVisible) return !1;
                    if (this.getLocalPosition(a, b, this._localPoint), d.copyFrom(this._localPoint), a.hitArea && a.hitArea.contains) return a.hitArea.contains(this._localPoint.x, this._localPoint.y);
                    if (a instanceof c.TileSprite) {
                        var e = a.width,
                            f = a.height,
                            g = -e * a.anchor.x;
                        if (this._localPoint.x >= g && this._localPoint.x < g + e) {
                            var h = -f * a.anchor.y;
                            if (this._localPoint.y >= h && this._localPoint.y < h + f) return !0
                        }
                    } else if (a instanceof PIXI.Sprite) {
                        var e = a.texture.frame.width,
                            f = a.texture.frame.height,
                            g = -e * a.anchor.x;
                        if (this._localPoint.x >= g && this._localPoint.x < g + e) {
                            var h = -f * a.anchor.y;
                            if (this._localPoint.y >= h && this._localPoint.y < h + f) return !0
                        }
                    } else if (a instanceof c.Graphics)
                        for (var i = 0; i < a.graphicsData.length; i++) {
                            var j = a.graphicsData[i];
                            if (j.fill && j.shape && j.shape.contains(this._localPoint.x, this._localPoint.y)) return !0
                        }
                    for (var i = 0; i < a.children.length; i++)
                        if (this.hitTest(a.children[i], b, d)) return !0;
                    return !1
                },
                onClickTrampoline: function() {
                    this.activePointer.processClickTrampolines()
                }
            }, c.Input.prototype.constructor = c.Input, Object.defineProperty(c.Input.prototype, "x", {
                get: function() {
                    return this._x
                },
                set: function(a) {
                    this._x = Math.floor(a)
                }
            }), Object.defineProperty(c.Input.prototype, "y", {
                get: function() {
                    return this._y
                },
                set: function(a) {
                    this._y = Math.floor(a)
                }
            }), Object.defineProperty(c.Input.prototype, "pollLocked", {
                get: function() {
                    return this.pollRate > 0 && this._pollCounter < this.pollRate
                }
            }), Object.defineProperty(c.Input.prototype, "totalInactivePointers", {
                get: function() {
                    return this.pointers.length - this.countActivePointers()
                }
            }), Object.defineProperty(c.Input.prototype, "totalActivePointers", {
                get: function() {
                    return this.countActivePointers()
                }
            }), Object.defineProperty(c.Input.prototype, "worldX", {
                get: function() {
                    return this.game.camera.view.x + this.x
                }
            }), Object.defineProperty(c.Input.prototype, "worldY", {
                get: function() {
                    return this.game.camera.view.y + this.y
                }
            }), c.Mouse = function(a) {
                this.game = a, this.input = a.input, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.mouseWheelCallback = null, this.capture = !1, this.button = -1, this.wheelDelta = 0, this.enabled = !0, this.locked = !1, this.stopOnGameOut = !1, this.pointerLock = new c.Signal, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null, this._onMouseWheel = null, this._wheelEvent = null
            }, c.Mouse.NO_BUTTON = -1, c.Mouse.LEFT_BUTTON = 0, c.Mouse.MIDDLE_BUTTON = 1, c.Mouse.RIGHT_BUTTON = 2, c.Mouse.BACK_BUTTON = 3, c.Mouse.FORWARD_BUTTON = 4, c.Mouse.WHEEL_UP = 1, c.Mouse.WHEEL_DOWN = -1, c.Mouse.prototype = {
                start: function() {
                    if ((!this.game.device.android || this.game.device.chrome !== !1) && null === this._onMouseDown) {
                        var b = this;
                        this._onMouseDown = function(a) {
                            return b.onMouseDown(a)
                        }, this._onMouseMove = function(a) {
                            return b.onMouseMove(a)
                        }, this._onMouseUp = function(a) {
                            return b.onMouseUp(a)
                        }, this._onMouseUpGlobal = function(a) {
                            return b.onMouseUpGlobal(a)
                        }, this._onMouseOutGlobal = function(a) {
                            return b.onMouseOutGlobal(a)
                        }, this._onMouseOut = function(a) {
                            return b.onMouseOut(a)
                        }, this._onMouseOver = function(a) {
                            return b.onMouseOver(a)
                        }, this._onMouseWheel = function(a) {
                            return b.onMouseWheel(a)
                        };
                        var c = this.game.canvas;
                        c.addEventListener("mousedown", this._onMouseDown, !0), c.addEventListener("mousemove", this._onMouseMove, !0), c.addEventListener("mouseup", this._onMouseUp, !0), this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), c.addEventListener("mouseover", this._onMouseOver, !0), c.addEventListener("mouseout", this._onMouseOut, !0));
                        var d = this.game.device.wheelEvent;
                        d && (c.addEventListener(d, this._onMouseWheel, !0), "mousewheel" === d ? this._wheelEvent = new a((-.025), 1) : "DOMMouseScroll" === d && (this._wheelEvent = new a(1, 1)))
                    }
                },
                onMouseDown: function(a) {
                    this.event = a, this.capture && a.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = 0, this.input.mousePointer.start(a))
                },
                onMouseMove: function(a) {
                    this.event = a, this.capture && a.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = 0, this.input.mousePointer.move(a))
                },
                onMouseUp: function(a) {
                    this.event = a, this.capture && a.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = 0, this.input.mousePointer.stop(a))
                },
                onMouseUpGlobal: function(a) {
                    this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, a), a.identifier = 0, this.input.mousePointer.stop(a))
                },
                onMouseOutGlobal: function(a) {
                    this.event = a, this.capture && a.preventDefault(), this.input.mousePointer.withinGame = !1, this.input.enabled && this.enabled && (this.input.mousePointer.stop(a), this.input.mousePointer.leftButton.stop(a), this.input.mousePointer.rightButton.stop(a))
                },
                onMouseOut: function(a) {
                    this.event = a, this.capture && a.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && this.stopOnGameOut && (a.identifier = 0, this.input.mousePointer.stop(a))
                },
                onMouseOver: function(a) {
                    this.event = a, this.capture && a.preventDefault(), this.input.mousePointer.withinGame = !0, this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, a)
                },
                onMouseWheel: function(a) {
                    this._wheelEvent && (a = this._wheelEvent.bindEvent(a)), this.event = a, this.capture && a.preventDefault(), this.wheelDelta = c.Math.clamp(-a.deltaY, -1, 1), this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, a)
                },
                requestPointerLock: function() {
                    if (this.game.device.pointerLock) {
                        var a = this.game.canvas;
                        a.requestPointerLock = a.requestPointerLock || a.mozRequestPointerLock || a.webkitRequestPointerLock, a.requestPointerLock();
                        var b = this;
                        this._pointerLockChange = function(a) {
                            return b.pointerLockChange(a)
                        }, document.addEventListener("pointerlockchange", this._pointerLockChange, !0), document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                    }
                },
                pointerLockChange: function(a) {
                    var b = this.game.canvas;
                    document.pointerLockElement === b || document.mozPointerLockElement === b || document.webkitPointerLockElement === b ? (this.locked = !0, this.pointerLock.dispatch(!0, a)) : (this.locked = !1, this.pointerLock.dispatch(!1, a))
                },
                releasePointerLock: function() {
                    document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock(), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                },
                stop: function() {
                    var a = this.game.canvas;
                    a.removeEventListener("mousedown", this._onMouseDown, !0), a.removeEventListener("mousemove", this._onMouseMove, !0), a.removeEventListener("mouseup", this._onMouseUp, !0), a.removeEventListener("mouseover", this._onMouseOver, !0), a.removeEventListener("mouseout", this._onMouseOut, !0);
                    var b = this.game.device.wheelEvent;
                    b && a.removeEventListener(b, this._onMouseWheel, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), window.removeEventListener("mouseout", this._onMouseOutGlobal, !0), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                }
            }, c.Mouse.prototype.constructor = c.Mouse, a.prototype = {}, a.prototype.constructor = a, a.prototype.bindEvent = function(b) {
                if (!a._stubsGenerated && b) {
                    var c = function(a) {
                        return function() {
                            var b = this.originalEvent[a];
                            return "function" != typeof b ? b : b.bind(this.originalEvent)
                        }
                    };
                    for (var d in b) d in a.prototype || Object.defineProperty(a.prototype, d, {
                        get: c(d)
                    });
                    a._stubsGenerated = !0
                }
                return this.originalEvent = b, this
            }, Object.defineProperties(a.prototype, {
                type: {
                    value: "wheel"
                },
                deltaMode: {
                    get: function() {
                        return this._deltaMode
                    }
                },
                deltaY: {
                    get: function() {
                        return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0
                    }
                },
                deltaX: {
                    get: function() {
                        return this._scaleFactor * this.originalEvent.wheelDeltaX || 0
                    }
                },
                deltaZ: {
                    value: 0
                }
            }), c.MSPointer = function(a) {
                this.game = a, this.input = a.input, this.callbackContext = this.game, this.pointerDownCallback = null, this.pointerMoveCallback = null, this.pointerUpCallback = null, this.capture = !0, this.button = -1, this.event = null, this.enabled = !0, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, this._onMSPointerOut = null, this._onMSPointerOver = null
            }, c.MSPointer.prototype = {
                start: function() {
                    if (null === this._onMSPointerDown) {
                        var a = this;
                        if (this.game.device.mspointer) {
                            this._onMSPointerDown = function(b) {
                                return a.onPointerDown(b)
                            }, this._onMSPointerMove = function(b) {
                                return a.onPointerMove(b)
                            }, this._onMSPointerUp = function(b) {
                                return a.onPointerUp(b)
                            }, this._onMSPointerUpGlobal = function(b) {
                                return a.onPointerUpGlobal(b)
                            }, this._onMSPointerOut = function(b) {
                                return a.onPointerOut(b)
                            }, this._onMSPointerOver = function(b) {
                                return a.onPointerOver(b)
                            };
                            var b = this.game.canvas;
                            b.addEventListener("MSPointerDown", this._onMSPointerDown, !1), b.addEventListener("MSPointerMove", this._onMSPointerMove, !1), b.addEventListener("MSPointerUp", this._onMSPointerUp, !1), b.addEventListener("pointerdown", this._onMSPointerDown, !1), b.addEventListener("pointermove", this._onMSPointerMove, !1), b.addEventListener("pointerup", this._onMSPointerUp, !1), b.style["-ms-content-zooming"] = "none", b.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), b.addEventListener("MSPointerOver", this._onMSPointerOver, !0), b.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), b.addEventListener("pointerover", this._onMSPointerOver, !0), b.addEventListener("pointerout", this._onMSPointerOut, !0))
                        }
                    }
                },
                onPointerDown: function(a) {
                    this.event = a, this.capture && a.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = a.pointerId, "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.start(a) : this.input.startPointer(a))
                },
                onPointerMove: function(a) {
                    this.event = a, this.capture && a.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = a.pointerId, "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.move(a) : this.input.updatePointer(a))
                },
                onPointerUp: function(a) {
                    this.event = a, this.capture && a.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = a.pointerId, "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.stop(a) : this.input.stopPointer(a))
                },
                onPointerUpGlobal: function(a) {
                    if ("mouse" !== a.pointerType && 4 !== a.pointerType || this.input.mousePointer.withinGame) {
                        var b = this.input.getPointerFromIdentifier(a.identifier);
                        b && b.withinGame && this.onPointerUp(a)
                    } else this.onPointerUp(a)
                },
                onPointerOut: function(a) {
                    if (this.event = a, this.capture && a.preventDefault(), "mouse" === a.pointerType || 4 === a.pointerType) this.input.mousePointer.withinGame = !1;
                    else {
                        var b = this.input.getPointerFromIdentifier(a.identifier);
                        b && (b.withinGame = !1)
                    }
                    this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, a), this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (a.identifier = 0, b ? b.stop(a) : this.input.mousePointer.stop(a))
                },
                onPointerOver: function(a) {
                    if (this.event = a, this.capture && a.preventDefault(), "mouse" === a.pointerType || 4 === a.pointerType) this.input.mousePointer.withinGame = !0;
                    else {
                        var b = this.input.getPointerFromIdentifier(a.identifier);
                        b && (b.withinGame = !0)
                    }
                    this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, a)
                },
                stop: function() {
                    var a = this.game.canvas;
                    a.removeEventListener("MSPointerDown", this._onMSPointerDown, !1), a.removeEventListener("MSPointerMove", this._onMSPointerMove, !1), a.removeEventListener("MSPointerUp", this._onMSPointerUp, !1), a.removeEventListener("pointerdown", this._onMSPointerDown, !1), a.removeEventListener("pointermove", this._onMSPointerMove, !1), a.removeEventListener("pointerup", this._onMSPointerUp, !1), window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), a.removeEventListener("MSPointerOver", this._onMSPointerOver, !0), a.removeEventListener("MSPointerOut", this._onMSPointerOut, !0), window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0), a.removeEventListener("pointerover", this._onMSPointerOver, !0), a.removeEventListener("pointerout", this._onMSPointerOut, !0)
                }
            }, c.MSPointer.prototype.constructor = c.MSPointer, c.DeviceButton = function(a, b) {
                this.parent = a, this.game = a.game, this.event = null, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = b, this.onDown = new c.Signal, this.onUp = new c.Signal, this.onFloat = new c.Signal
            }, c.DeviceButton.prototype = {
                start: function(a, b) {
                    this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = a, this.value = b, a && (this.altKey = a.altKey, this.shiftKey = a.shiftKey, this.ctrlKey = a.ctrlKey), this.onDown.dispatch(this, b))
                },
                stop: function(a, b) {
                    this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = a, this.value = b, a && (this.altKey = a.altKey, this.shiftKey = a.shiftKey, this.ctrlKey = a.ctrlKey), this.onUp.dispatch(this, b))
                },
                padFloat: function(a) {
                    this.value = a, this.onFloat.dispatch(this, a)
                },
                justPressed: function(a) {
                    return a = a || 250, this.isDown && this.timeDown + a > this.game.time.time
                },
                justReleased: function(a) {
                    return a = a || 250, this.isUp && this.timeUp + a > this.game.time.time
                },
                reset: function() {
                    this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1
                },
                destroy: function() {
                    this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, this.game = null
                }
            }, c.DeviceButton.prototype.constructor = c.DeviceButton, Object.defineProperty(c.DeviceButton.prototype, "duration", {
                get: function() {
                    return this.isUp ? -1 : this.game.time.time - this.timeDown
                }
            }), c.Pointer = function(a, b, d) {
                this.game = a, this.id = b, this.type = c.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.pointerMode = d || c.PointerMode.CURSOR | c.PointerMode.CONTACT, this.target = null, this.button = null, this.leftButton = new c.DeviceButton(this, c.Pointer.LEFT_BUTTON), this.middleButton = new c.DeviceButton(this, c.Pointer.MIDDLE_BUTTON), this.rightButton = new c.DeviceButton(this, c.Pointer.RIGHT_BUTTON), this.backButton = new c.DeviceButton(this, c.Pointer.BACK_BUTTON), this.forwardButton = new c.DeviceButton(this, c.Pointer.FORWARD_BUTTON), this.eraserButton = new c.DeviceButton(this, c.Pointer.ERASER_BUTTON), this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === b, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.interactiveCandidates = [], this.active = !1, this.dirty = !1, this.position = new c.Point, this.positionDown = new c.Point, this.positionUp = new c.Point, this.circle = new c.Circle(0, 0, 44), this._clickTrampolines = null, this._trampolineTargetObject = null
            }, c.Pointer.NO_BUTTON = 0, c.Pointer.LEFT_BUTTON = 1, c.Pointer.RIGHT_BUTTON = 2, c.Pointer.MIDDLE_BUTTON = 4, c.Pointer.BACK_BUTTON = 8, c.Pointer.FORWARD_BUTTON = 16, c.Pointer.ERASER_BUTTON = 32, c.Pointer.prototype = {
                resetButtons: function() {
                    this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset())
                },
                processButtonsDown: function(a, b) {
                    c.Pointer.LEFT_BUTTON & a && this.leftButton.start(b), c.Pointer.RIGHT_BUTTON & a && this.rightButton.start(b), c.Pointer.MIDDLE_BUTTON & a && this.middleButton.start(b), c.Pointer.BACK_BUTTON & a && this.backButton.start(b), c.Pointer.FORWARD_BUTTON & a && this.forwardButton.start(b), c.Pointer.ERASER_BUTTON & a && this.eraserButton.start(b)
                },
                processButtonsUp: function(a, b) {
                    a === c.Mouse.LEFT_BUTTON && this.leftButton.stop(b), a === c.Mouse.RIGHT_BUTTON && this.rightButton.stop(b), a === c.Mouse.MIDDLE_BUTTON && this.middleButton.stop(b), a === c.Mouse.BACK_BUTTON && this.backButton.stop(b), a === c.Mouse.FORWARD_BUTTON && this.forwardButton.stop(b), 5 === a && this.eraserButton.stop(b)
                },
                updateButtons: function(a) {
                    this.button = a.button;
                    var b = "down" === a.type.toLowerCase().substr(-4);
                    void 0 !== a.buttons ? b ? this.processButtonsDown(a.buttons, a) : this.processButtonsUp(a.button, a) : b ? this.leftButton.start(a) : (this.leftButton.stop(a), this.rightButton.stop(a)), 1 === a.buttons && a.ctrlKey && this.leftButton.isDown && (this.leftButton.stop(a), this.rightButton.start(a)), this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0)
                },
                start: function(a) {
                    var b = this.game.input;
                    return a.pointerId && (this.pointerId = a.pointerId), this.identifier = a.identifier, this.target = a.target, this.isMouse ? this.updateButtons(a) : (this.isDown = !0, this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = !1, this.move(a, !0), this.positionDown.setTo(this.x, this.y), (b.multiInputOverride === c.Input.MOUSE_OVERRIDES_TOUCH || b.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || b.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === b.totalActivePointers) && (b.x = this.x, b.y = this.y, b.position.setTo(this.x, this.y), b.onDown.dispatch(this, a), b.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this
                },
                update: function() {
                    var a = this.game.input;
                    this.active && (this.dirty && (a.interactiveItems.total > 0 && this.processInteractiveObjects(!1), this.dirty = !1), this._holdSent === !1 && this.duration >= a.holdRate && ((a.multiInputOverride === c.Input.MOUSE_OVERRIDES_TOUCH || a.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || a.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === a.totalActivePointers) && a.onHold.dispatch(this), this._holdSent = !0), a.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + a.recordRate, this._history.push({
                        x: this.position.x,
                        y: this.position.y
                    }), this._history.length > a.recordLimit && this._history.shift()))
                },
                move: function(a, b) {
                    var d = this.game.input;
                    if (!d.pollLocked) {
                        if (void 0 === b && (b = !1), void 0 !== a.button && (this.button = a.button), b && this.isMouse && this.updateButtons(a), this.clientX = a.clientX, this.clientY = a.clientY, this.pageX = a.pageX, this.pageY = a.pageY, this.screenX = a.screenX, this.screenY = a.screenY, this.isMouse && d.mouse.locked && !b && (this.rawMovementX = a.movementX || a.mozMovementX || a.webkitMovementX || 0, this.rawMovementY = a.movementY || a.mozMovementY || a.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * d.scale.x, this.y = (this.pageY - this.game.scale.offset.y) * d.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (d.multiInputOverride === c.Input.MOUSE_OVERRIDES_TOUCH || d.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || d.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === d.totalActivePointers) && (d.activePointer = this, d.x = this.x, d.y = this.y, d.position.setTo(d.x, d.y), d.circle.x = d.x, d.circle.y = d.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY), this.game.paused) return this;
                        for (var e = d.moveCallbacks.length; e--;) d.moveCallbacks[e].callback.call(d.moveCallbacks[e].context, this, this.x, this.y, b);
                        return null !== this.targetObject && this.targetObject.isDragged === !0 ? this.targetObject.update(this) === !1 && (this.targetObject = null) : d.interactiveItems.total > 0 && this.processInteractiveObjects(b), this
                    }
                },
                processInteractiveObjects: function(a) {
                    var b = 0,
                        c = -1,
                        d = null,
                        e = this.game.input.interactiveItems.first;
                    for (this.interactiveCandidates = []; e;) e.checked = !1, e.validForInput(c, b, !1) && (e.checked = !0, (a && e.checkPointerDown(this, !0) || !a && e.checkPointerOver(this, !0)) && (b = e.sprite.renderOrderID, c = e.priorityID, d = e, this.interactiveCandidates.push(e))), e = this.game.input.interactiveItems.next;
                    for (e = this.game.input.interactiveItems.first; e;)!e.checked && e.validForInput(c, b, !0) && (a && e.checkPointerDown(this, !1) || !a && e.checkPointerOver(this, !1)) && (b = e.sprite.renderOrderID, c = e.priorityID, d = e, this.interactiveCandidates.push(e)), e = this.game.input.interactiveItems.next;
                    return this.game.input.customCandidateHandler && (d = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, d)), this.swapTarget(d, !1), null !== this.targetObject
                },
                swapTarget: function(a, b) {
                    void 0 === b && (b = !1), null === a ? this.targetObject && (this.targetObject._pointerOutHandler(this, b), this.targetObject = null) : null === this.targetObject ? (this.targetObject = a, a._pointerOverHandler(this, b)) : this.targetObject === a ? a.update(this) === !1 && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, b), this.targetObject = a, this.targetObject._pointerOverHandler(this, b))
                },
                leave: function(a) {
                    this.withinGame = !1, this.move(a, !1)
                },
                stop: function(a) {
                    var b = this.game.input;
                    return this._stateReset && this.withinGame ? void a.preventDefault() : (this.timeUp = this.game.time.time, (b.multiInputOverride === c.Input.MOUSE_OVERRIDES_TOUCH || b.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || b.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === b.totalActivePointers) && (b.onUp.dispatch(this, a), this.duration >= 0 && this.duration <= b.tapRate && (this.timeUp - this.previousTapTime < b.doubleTapRate ? b.onTap.dispatch(this, !0) : b.onTap.dispatch(this, !1), this.previousTapTime = this.timeUp)), this.isMouse ? this.updateButtons(a) : (this.isDown = !1, this.isUp = !0), this.id > 0 && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(a.pageX, a.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), this.isMouse === !1 && b.currentPointers--, b.interactiveItems.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this)
                },
                justPressed: function(a) {
                    return a = a || this.game.input.justPressedRate, this.isDown === !0 && this.timeDown + a > this.game.time.time
                },
                justReleased: function(a) {
                    return a = a || this.game.input.justReleasedRate, this.isUp && this.timeUp + a > this.game.time.time
                },
                addClickTrampoline: function(a, b, c, d) {
                    if (this.isDown) {
                        for (var e = this._clickTrampolines = this._clickTrampolines || [], f = 0; f < e.length; f++)
                            if (e[f].name === a) {
                                e.splice(f, 1);
                                break
                            }
                        e.push({
                            name: a,
                            targetObject: this.targetObject,
                            callback: b,
                            callbackContext: c,
                            callbackArgs: d
                        })
                    }
                },
                processClickTrampolines: function() {
                    var a = this._clickTrampolines;
                    if (a) {
                        for (var b = 0; b < a.length; b++) {
                            var c = a[b];
                            c.targetObject === this._trampolineTargetObject && c.callback.apply(c.callbackContext, c.callbackArgs)
                        }
                        this._clickTrampolines = null, this._trampolineTargetObject = null
                    }
                },
                reset: function() {
                    this.isMouse === !1 && (this.active = !1), this.pointerId = null, this.identifier = null, this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null
                },
                resetMovement: function() {
                    this.movementX = 0, this.movementY = 0
                }
            }, c.Pointer.prototype.constructor = c.Pointer, Object.defineProperty(c.Pointer.prototype, "duration", {
                get: function() {
                    return this.isUp ? -1 : this.game.time.time - this.timeDown
                }
            }), Object.defineProperty(c.Pointer.prototype, "worldX", {
                get: function() {
                    return this.game.world.camera.x + this.x
                }
            }), Object.defineProperty(c.Pointer.prototype, "worldY", {
                get: function() {
                    return this.game.world.camera.y + this.y
                }
            }), c.PointerMode = {
                CURSOR: 1,
                CONTACT: 2
            }, c.Touch = function(a) {
                this.game = a, this.enabled = !0, this.touchLockCallbacks = [], this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null
            }, c.Touch.prototype = {
                start: function() {
                    if (null === this._onTouchStart) {
                        var a = this;
                        this.game.device.touch && (this._onTouchStart = function(b) {
                            return a.onTouchStart(b)
                        }, this._onTouchMove = function(b) {
                            return a.onTouchMove(b)
                        }, this._onTouchEnd = function(b) {
                            return a.onTouchEnd(b)
                        }, this._onTouchEnter = function(b) {
                            return a.onTouchEnter(b)
                        }, this._onTouchLeave = function(b) {
                            return a.onTouchLeave(b)
                        }, this._onTouchCancel = function(b) {
                            return a.onTouchCancel(b)
                        }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)))
                    }
                },
                consumeDocumentTouches: function() {
                    this._documentTouchMove = function(a) {
                        a.preventDefault()
                    }, document.addEventListener("touchmove", this._documentTouchMove, !1)
                },
                addTouchLockCallback: function(a, b, c) {
                    void 0 === c && (c = !1), this.touchLockCallbacks.push({
                        callback: a,
                        context: b,
                        onEnd: c
                    })
                },
                removeTouchLockCallback: function(a, b) {
                    for (var c = this.touchLockCallbacks.length; c--;)
                        if (this.touchLockCallbacks[c].callback === a && this.touchLockCallbacks[c].context === b) return this.touchLockCallbacks.splice(c, 1), !0;
                    return !1
                },
                onTouchStart: function(a) {
                    for (var b = this.touchLockCallbacks.length; b--;) {
                        var c = this.touchLockCallbacks[b];
                        !c.onEnd && c.callback.call(c.context, this, a) && this.touchLockCallbacks.splice(b, 1)
                    }
                    if (this.event = a, this.game.input.enabled && this.enabled) {
                        this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, a), this.preventDefault && a.preventDefault();
                        for (var b = 0; b < a.changedTouches.length; b++) this.game.input.startPointer(a.changedTouches[b])
                    }
                },
                onTouchCancel: function(a) {
                    if (this.event = a, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, a), this.game.input.enabled && this.enabled) {
                        this.preventDefault && a.preventDefault();
                        for (var b = 0; b < a.changedTouches.length; b++) this.game.input.stopPointer(a.changedTouches[b])
                    }
                },
                onTouchEnter: function(a) {
                    this.event = a, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, a), this.game.input.enabled && this.enabled && this.preventDefault && a.preventDefault()
                },
                onTouchLeave: function(a) {
                    this.event = a, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, a), this.preventDefault && a.preventDefault()
                },
                onTouchMove: function(a) {
                    this.event = a, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, a), this.preventDefault && a.preventDefault();
                    for (var b = 0; b < a.changedTouches.length; b++) this.game.input.updatePointer(a.changedTouches[b])
                },
                onTouchEnd: function(a) {
                    for (var b = this.touchLockCallbacks.length; b--;) {
                        var c = this.touchLockCallbacks[b];
                        c.onEnd && c.callback.call(c.context, this, a) && this.touchLockCallbacks.splice(b, 1)
                    }
                    this.event = a, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, a), this.preventDefault && a.preventDefault();
                    for (var b = 0; b < a.changedTouches.length; b++) this.game.input.stopPointer(a.changedTouches[b])
                },
                stop: function() {
                    this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel))
                }
            }, c.Touch.prototype.constructor = c.Touch, c.InputHandler = function(a) {
                this.sprite = a, this.game = a.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.scaleLayer = !1, this.dragOffset = new c.Point, this.dragFromCenter = !1, this.dragStopBlocksInputUp = !1, this.dragStartPoint = new c.Point, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.downPoint = new c.Point, this.snapPoint = new c.Point, this._dragPoint = new c.Point, this._dragPhase = !1, this._pendingDrag = !1, this._dragTimePass = !1, this._dragDistancePass = !1, this._wasEnabled = !1, this._tempPoint = new c.Point, this._pointerData = [], this._pointerData.push({
                    id: 0,
                    x: 0,
                    y: 0,
                    camX: 0,
                    camY: 0,
                    isDown: !1,
                    isUp: !1,
                    isOver: !1,
                    isOut: !1,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: !1
                })
            }, c.InputHandler.prototype = {
                start: function(a, b) {
                    if (a = a || 0, void 0 === b && (b = !1), this.enabled === !1) {
                        this.game.input.interactiveItems.add(this), this.useHandCursor = b, this.priorityID = a;
                        for (var d = 0; d < 10; d++) this._pointerData[d] = {
                            id: d,
                            x: 0,
                            y: 0,
                            isDown: !1,
                            isUp: !1,
                            isOver: !1,
                            isOut: !1,
                            timeOver: 0,
                            timeOut: 0,
                            timeDown: 0,
                            timeUp: 0,
                            downDuration: 0,
                            isDragged: !1
                        };
                        this.snapOffset = new c.Point, this.enabled = !0, this._wasEnabled = !0
                    }
                    return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite
                },
                addedToGroup: function() {
                    this._dragPhase || this._wasEnabled && !this.enabled && this.start()
                },
                removedFromGroup: function() {
                    this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1)
                },
                reset: function() {
                    this.enabled = !1;
                    for (var a = 0; a < 10; a++) this._pointerData[a] = {
                        id: a,
                        x: 0,
                        y: 0,
                        isDown: !1,
                        isUp: !1,
                        isOver: !1,
                        isOut: !1,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: !1
                    }
                },
                stop: function() {
                    this.enabled !== !1 && (this.enabled = !1, this.game.input.interactiveItems.remove(this))
                },
                destroy: function() {
                    this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null)
                },
                validForInput: function(a, b, c) {
                    return void 0 === c && (c = !0), !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput || !c && (this.pixelPerfectClick || this.pixelPerfectOver) || !(this.priorityID > a || this.priorityID === a && this.sprite.renderOrderID > b))
                },
                isPixelPerfect: function() {
                    return this.pixelPerfectClick || this.pixelPerfectOver
                },
                pointerX: function(a) {
                    return a = a || 0, this._pointerData[a].x
                },
                pointerY: function(a) {
                    return a = a || 0, this._pointerData[a].y
                },
                pointerDown: function(a) {
                    return a = a || 0, this._pointerData[a].isDown
                },
                pointerUp: function(a) {
                    return a = a || 0, this._pointerData[a].isUp
                },
                pointerTimeDown: function(a) {
                    return a = a || 0, this._pointerData[a].timeDown
                },
                pointerTimeUp: function(a) {
                    return a = a || 0, this._pointerData[a].timeUp
                },
                pointerOver: function(a) {
                    if (!this.enabled) return !1;
                    if (void 0 === a) {
                        for (var b = 0; b < 10; b++)
                            if (this._pointerData[b].isOver) return !0;
                        return !1
                    }
                    return this._pointerData[a].isOver
                },
                pointerOut: function(a) {
                    if (!this.enabled) return !1;
                    if (void 0 !== a) return this._pointerData[a].isOut;
                    for (var b = 0; b < 10; b++)
                        if (this._pointerData[b].isOut) return !0
                },
                pointerTimeOver: function(a) {
                    return a = a || 0, this._pointerData[a].timeOver
                },
                pointerTimeOut: function(a) {
                    return a = a || 0, this._pointerData[a].timeOut
                },
                pointerDragged: function(a) {
                    return a = a || 0, this._pointerData[a].isDragged
                },
                checkPointerDown: function(a, b) {
                    return !!(a.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && !!this.game.input.hitTest(this.sprite, a, this._tempPoint) && (void 0 === b && (b = !1), !(!b && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))
                },
                checkPointerOver: function(a, b) {
                    return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && !!this.game.input.hitTest(this.sprite, a, this._tempPoint) && (void 0 === b && (b = !1), !(!b && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))
                },
                checkPixel: function(a, b, c) {
                    if (this.sprite.texture.baseTexture.source) {
                        if (null === a && null === b) {
                            this.game.input.getLocalPosition(this.sprite, c, this._tempPoint);
                            var a = this._tempPoint.x,
                                b = this._tempPoint.y
                        }
                        if (0 !== this.sprite.anchor.x && (a -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (b -= -this.sprite.texture.frame.height * this.sprite.anchor.y), a += this.sprite.texture.frame.x, b += this.sprite.texture.frame.y, this.sprite.texture.trim && (a -= this.sprite.texture.trim.x, b -= this.sprite.texture.trim.y, a < this.sprite.texture.crop.x || a > this.sprite.texture.crop.right || b < this.sprite.texture.crop.y || b > this.sprite.texture.crop.bottom)) return this._dx = a, this._dy = b, !1;
                        this._dx = a, this._dy = b, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, a, b, 1, 1, 0, 0, 1, 1);
                        var d = this.game.input.hitContext.getImageData(0, 0, 1, 1);
                        if (d.data[3] >= this.pixelPerfectAlpha) return !0
                    }
                    return !1
                },
                update: function(a) {
                    if (null !== this.sprite && void 0 !== this.sprite.parent) return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = c.Math.distance(a.x, a.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(a), !0) : this.draggable && this._draggedPointerID === a.id ? this.updateDrag(a, !1) : this._pointerData[a.id].isOver ? this.checkPointerOver(a) ? (this._pointerData[a.id].x = a.x - this.sprite.x, this._pointerData[a.id].y = a.y - this.sprite.y, !0) : (this._pointerOutHandler(a), !1) : void 0 : (this._pointerOutHandler(a), !1)
                },
                _pointerOverHandler: function(a, b) {
                    if (null !== this.sprite) {
                        var d = this._pointerData[a.id];
                        if (d.isOver === !1 || a.dirty) {
                            var e = d.isOver === !1;
                            d.isOver = !0, d.isOut = !1, d.timeOver = this.game.time.time, d.x = a.x - this.sprite.x, d.y = a.y - this.sprite.y, this.useHandCursor && d.isDragged === !1 && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), !b && e && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, a), this.sprite.parent && this.sprite.parent.type === c.GROUP && this.sprite.parent.onChildInputOver.dispatch(this.sprite, a)
                        }
                    }
                },
                _pointerOutHandler: function(a, b) {
                    if (null !== this.sprite) {
                        var d = this._pointerData[a.id];
                        d.isOver = !1, d.isOut = !0, d.timeOut = this.game.time.time, this.useHandCursor && d.isDragged === !1 && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), !b && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, a), this.sprite && this.sprite.parent && this.sprite.parent.type === c.GROUP && this.sprite.parent.onChildInputOut.dispatch(this.sprite, a))
                    }
                },
                _touchedHandler: function(a) {
                    if (null !== this.sprite) {
                        var b = this._pointerData[a.id];
                        if (!b.isDown && b.isOver) {
                            if (this.pixelPerfectClick && !this.checkPixel(null, null, a)) return;
                            if (b.isDown = !0, b.isUp = !1, b.timeDown = this.game.time.time, this.downPoint.set(a.x, a.y), a.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, a), this.sprite && this.sprite.parent && this.sprite.parent.type === c.GROUP && this.sprite.parent.onChildInputDown.dispatch(this.sprite, a), null === this.sprite)) return;
                            this.draggable && this.isDragged === !1 && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(a) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, this.dragTimeThreshold > 0 ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, a)) : this._dragTimePass = !0)), this.bringToTop && this.sprite.bringToTop()
                        }
                    }
                },
                dragTimeElapsed: function(a) {
                    this._dragTimePass = !0, this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(a)
                },
                _releasedHandler: function(a) {
                    if (null !== this.sprite) {
                        var b = this._pointerData[a.id];
                        if (b.isDown && a.isUp) {
                            b.isDown = !1, b.isUp = !0, b.timeUp = this.game.time.time, b.downDuration = b.timeUp - b.timeDown;
                            var d = this.checkPointerOver(a);
                            this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === a.id) || this.sprite.events.onInputUp$dispatch(this.sprite, a, d), this.sprite && this.sprite.parent && this.sprite.parent.type === c.GROUP && this.sprite.parent.onChildInputUp.dispatch(this.sprite, a, d), d && (d = this.checkPointerOver(a))), b.isOver = d, !d && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), a.dirty = !0, this._pendingDrag = !1, this.draggable && this.isDragged && this._draggedPointerID === a.id && this.stopDrag(a)
                        }
                    }
                },
                updateDrag: function(a, b) {
                    if (void 0 === b && (b = !1), a.isUp) return this.stopDrag(a), !1;
                    var c = this.globalToLocalX(a.x) + this._dragPoint.x + this.dragOffset.x,
                        d = this.globalToLocalY(a.y) + this._dragPoint.y + this.dragOffset.y;
                    if (this.sprite.fixedToCamera) this.allowHorizontalDrag && (this.sprite.cameraOffset.x = c), this.allowVerticalDrag && (this.sprite.cameraOffset.y = d), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y));
                    else {
                        var e = this.game.camera.x - this._pointerData[a.id].camX,
                            f = this.game.camera.y - this._pointerData[a.id].camY;
                        this.allowHorizontalDrag && (this.sprite.x = c + e), this.allowVerticalDrag && (this.sprite.y = d + f), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.x, this.sprite.y))
                    }
                    return this.sprite.events.onDragUpdate.dispatch(this.sprite, a, c, d, this.snapPoint, b), !0
                },
                justOver: function(a, b) {
                    return a = a || 0, b = b || 500, this._pointerData[a].isOver && this.overDuration(a) < b
                },
                justOut: function(a, b) {
                    return a = a || 0, b = b || 500, this._pointerData[a].isOut && this.game.time.time - this._pointerData[a].timeOut < b
                },
                justPressed: function(a, b) {
                    return a = a || 0, b = b || 500, this._pointerData[a].isDown && this.downDuration(a) < b
                },
                justReleased: function(a, b) {
                    return a = a || 0, b = b || 500, this._pointerData[a].isUp && this.game.time.time - this._pointerData[a].timeUp < b
                },
                overDuration: function(a) {
                    return a = a || 0, this._pointerData[a].isOver ? this.game.time.time - this._pointerData[a].timeOver : -1
                },
                downDuration: function(a) {
                    return a = a || 0, this._pointerData[a].isDown ? this.game.time.time - this._pointerData[a].timeDown : -1
                },
                enableDrag: function(a, b, d, e, f, g) {
                    void 0 === a && (a = !1), void 0 === b && (b = !1), void 0 === d && (d = !1), void 0 === e && (e = 255), void 0 === f && (f = null), void 0 === g && (g = null), this._dragPoint = new c.Point, this.draggable = !0, this.bringToTop = b, this.dragOffset = new c.Point, this.dragFromCenter = a, this.pixelPerfectClick = d, this.pixelPerfectAlpha = e, f && (this.boundsRect = f), g && (this.boundsSprite = g)
                },
                disableDrag: function() {
                    if (this._pointerData)
                        for (var a = 0; a < 10; a++) this._pointerData[a].isDragged = !1;
                    this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1, this._pendingDrag = !1
                },
                startDrag: function(a) {
                    var b = this.sprite.x,
                        c = this.sprite.y;
                    if (this.isDragged = !0, this._draggedPointerID = a.id, this._pointerData[a.id].camX = this.game.camera.x, this._pointerData[a.id].camY = this.game.camera.y, this._pointerData[a.id].isDragged = !0, this.sprite.fixedToCamera) {
                        if (this.dragFromCenter) {
                            var d = this.sprite.getBounds();
                            this.sprite.cameraOffset.x = this.globalToLocalX(a.x) + (this.sprite.cameraOffset.x - d.centerX), this.sprite.cameraOffset.y = this.globalToLocalY(a.y) + (this.sprite.cameraOffset.y - d.centerY)
                        }
                        this._dragPoint.setTo(this.sprite.cameraOffset.x - a.x, this.sprite.cameraOffset.y - a.y)
                    } else {
                        if (this.dragFromCenter) {
                            var d = this.sprite.getBounds();
                            this.sprite.x = this.globalToLocalX(a.x) + (this.sprite.x - d.centerX), this.sprite.y = this.globalToLocalY(a.y) + (this.sprite.y - d.centerY)
                        }
                        this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(a.x), this.sprite.y - this.globalToLocalY(a.y))
                    }
                    this.updateDrag(a, !0), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.dragStartPoint.set(b, c), this.sprite.events.onDragStart$dispatch(this.sprite, a, b, c), this._pendingDrag = !1
                },
                globalToLocalX: function(a) {
                    return this.scaleLayer && (a -= this.game.scale.grid.boundsFluid.x, a *= this.game.scale.grid.scaleFluidInversed.x), a
                },
                globalToLocalY: function(a) {
                    return this.scaleLayer && (a -= this.game.scale.grid.boundsFluid.y, a *= this.game.scale.grid.scaleFluidInversed.y), a
                },
                stopDrag: function(a) {
                    this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[a.id].isDragged = !1, this._dragPhase = !1, this._pendingDrag = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), this.sprite.events.onDragStop$dispatch(this.sprite, a), this.checkPointerOver(a) === !1 && this._pointerOutHandler(a)
                },
                setDragLock: function(a, b) {
                    void 0 === a && (a = !0), void 0 === b && (b = !0), this.allowHorizontalDrag = a, this.allowVerticalDrag = b
                },
                enableSnap: function(a, b, c, d, e, f) {
                    void 0 === c && (c = !0), void 0 === d && (d = !1), void 0 === e && (e = 0), void 0 === f && (f = 0), this.snapX = a, this.snapY = b, this.snapOffsetX = e, this.snapOffsetY = f, this.snapOnDrag = c, this.snapOnRelease = d
                },
                disableSnap: function() {
                    this.snapOnDrag = !1, this.snapOnRelease = !1
                },
                checkBoundsRect: function() {
                    this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)))
                },
                checkBoundsSprite: function() {
                    this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)))
                }
            }, c.InputHandler.prototype.constructor = c.InputHandler, c.Gamepad = function(a) {
                this.game = a, this._gamepadIndexMap = {}, this._rawPads = [], this._active = !1, this.enabled = !0, this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || navigator.userAgent.indexOf("Firefox/") !== -1 || !!navigator.getGamepads, this._prevRawGamepadTypes = [], this._prevTimestamps = [], this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this._ongamepadconnected = null, this._gamepaddisconnected = null, this._gamepads = [new c.SinglePad(a, this), new c.SinglePad(a, this), new c.SinglePad(a, this), new c.SinglePad(a, this)]
            }, c.Gamepad.prototype = {
                addCallbacks: function(a, b) {
                    "undefined" != typeof b && (this.onConnectCallback = "function" == typeof b.onConnect ? b.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof b.onDisconnect ? b.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof b.onDown ? b.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof b.onUp ? b.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof b.onAxis ? b.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof b.onFloat ? b.onFloat : this.onFloatCallback, this.callbackContext = a)
                },
                start: function() {
                    if (!this._active) {
                        this._active = !0;
                        var a = this;
                        this._onGamepadConnected = function(b) {
                            return a.onGamepadConnected(b)
                        }, this._onGamepadDisconnected = function(b) {
                            return a.onGamepadDisconnected(b)
                        }, window.addEventListener("gamepadconnected", this._onGamepadConnected, !1), window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1)
                    }
                },
                onGamepadConnected: function(a) {
                    var b = a.gamepad;
                    this._rawPads.push(b), this._gamepads[b.index].connect(b)
                },
                onGamepadDisconnected: function(a) {
                    var b = a.gamepad;
                    for (var c in this._rawPads) this._rawPads[c].index === b.index && this._rawPads.splice(c, 1);
                    this._gamepads[b.index].disconnect()
                },
                update: function() {
                    this._pollGamepads(), this.pad1.pollStatus(), this.pad2.pollStatus(), this.pad3.pollStatus(), this.pad4.pollStatus()
                },
                _pollGamepads: function() {
                    if (this._active) {
                        if (navigator.getGamepads) var a = navigator.getGamepads();
                        else if (navigator.webkitGetGamepads) var a = navigator.webkitGetGamepads();
                        else if (navigator.webkitGamepads) var a = navigator.webkitGamepads();
                        if (a) {
                            this._rawPads = [];
                            for (var b = !1, c = 0; c < a.length && (typeof a[c] !== this._prevRawGamepadTypes[c] && (b = !0, this._prevRawGamepadTypes[c] = typeof a[c]), a[c] && this._rawPads.push(a[c]), 3 !== c); c++);
                            for (var d = 0; d < this._gamepads.length; d++) this._gamepads[d]._rawPad = this._rawPads[d];
                            if (b) {
                                for (var e, f = {
                                    rawIndices: {},
                                    padIndices: {}
                                }, g = 0; g < this._gamepads.length; g++)
                                    if (e = this._gamepads[g], e.connected)
                                        for (var h = 0; h < this._rawPads.length; h++) this._rawPads[h].index === e.index && (f.rawIndices[e.index] = !0, f.padIndices[g] = !0);
                                for (var i = 0; i < this._gamepads.length; i++)
                                    if (e = this._gamepads[i], !f.padIndices[i]) {
                                        this._rawPads.length < 1 && e.disconnect();
                                        for (var j = 0; j < this._rawPads.length && !f.padIndices[i]; j++) {
                                            var k = this._rawPads[j];
                                            if (k) {
                                                if (f.rawIndices[k.index]) {
                                                    e.disconnect();
                                                    continue
                                                }
                                                e.connect(k), f.rawIndices[k.index] = !0, f.padIndices[i] = !0
                                            } else e.disconnect()
                                        }
                                    }
                            }
                        }
                    }
                },
                setDeadZones: function(a) {
                    for (var b = 0; b < this._gamepads.length; b++) this._gamepads[b].deadZone = a
                },
                stop: function() {
                    this._active = !1, window.removeEventListener("gamepadconnected", this._onGamepadConnected), window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected)
                },
                reset: function() {
                    this.update();
                    for (var a = 0; a < this._gamepads.length; a++) this._gamepads[a].reset()
                },
                justPressed: function(a, b) {
                    for (var c = 0; c < this._gamepads.length; c++)
                        if (this._gamepads[c].justPressed(a, b) === !0) return !0;
                    return !1
                },
                justReleased: function(a, b) {
                    for (var c = 0; c < this._gamepads.length; c++)
                        if (this._gamepads[c].justReleased(a, b) === !0) return !0;
                    return !1
                },
                isDown: function(a) {
                    for (var b = 0; b < this._gamepads.length; b++)
                        if (this._gamepads[b].isDown(a) === !0) return !0;
                    return !1
                },
                destroy: function() {
                    this.stop();
                    for (var a = 0; a < this._gamepads.length; a++) this._gamepads[a].destroy()
                }
            }, c.Gamepad.prototype.constructor = c.Gamepad, Object.defineProperty(c.Gamepad.prototype, "active", {
                get: function() {
                    return this._active
                }
            }), Object.defineProperty(c.Gamepad.prototype, "supported", {
                get: function() {
                    return this._gamepadSupportAvailable
                }
            }), Object.defineProperty(c.Gamepad.prototype, "padsConnected", {
                get: function() {
                    return this._rawPads.length
                }
            }), Object.defineProperty(c.Gamepad.prototype, "pad1", {
                get: function() {
                    return this._gamepads[0]
                }
            }), Object.defineProperty(c.Gamepad.prototype, "pad2", {
                get: function() {
                    return this._gamepads[1]
                }
            }), Object.defineProperty(c.Gamepad.prototype, "pad3", {
                get: function() {
                    return this._gamepads[2]
                }
            }), Object.defineProperty(c.Gamepad.prototype, "pad4", {
                get: function() {
                    return this._gamepads[3]
                }
            }), c.Gamepad.BUTTON_0 = 0, c.Gamepad.BUTTON_1 = 1, c.Gamepad.BUTTON_2 = 2, c.Gamepad.BUTTON_3 = 3, c.Gamepad.BUTTON_4 = 4, c.Gamepad.BUTTON_5 = 5, c.Gamepad.BUTTON_6 = 6, c.Gamepad.BUTTON_7 = 7, c.Gamepad.BUTTON_8 = 8, c.Gamepad.BUTTON_9 = 9, c.Gamepad.BUTTON_10 = 10, c.Gamepad.BUTTON_11 = 11, c.Gamepad.BUTTON_12 = 12, c.Gamepad.BUTTON_13 = 13, c.Gamepad.BUTTON_14 = 14, c.Gamepad.BUTTON_15 = 15, c.Gamepad.AXIS_0 = 0, c.Gamepad.AXIS_1 = 1, c.Gamepad.AXIS_2 = 2, c.Gamepad.AXIS_3 = 3, c.Gamepad.AXIS_4 = 4, c.Gamepad.AXIS_5 = 5, c.Gamepad.AXIS_6 = 6, c.Gamepad.AXIS_7 = 7, c.Gamepad.AXIS_8 = 8, c.Gamepad.AXIS_9 = 9, c.Gamepad.XBOX360_A = 0, c.Gamepad.XBOX360_B = 1, c.Gamepad.XBOX360_X = 2, c.Gamepad.XBOX360_Y = 3, c.Gamepad.XBOX360_LEFT_BUMPER = 4, c.Gamepad.XBOX360_RIGHT_BUMPER = 5, c.Gamepad.XBOX360_LEFT_TRIGGER = 6, c.Gamepad.XBOX360_RIGHT_TRIGGER = 7, c.Gamepad.XBOX360_BACK = 8, c.Gamepad.XBOX360_START = 9, c.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10, c.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11, c.Gamepad.XBOX360_DPAD_LEFT = 14, c.Gamepad.XBOX360_DPAD_RIGHT = 15, c.Gamepad.XBOX360_DPAD_UP = 12, c.Gamepad.XBOX360_DPAD_DOWN = 13, c.Gamepad.XBOX360_STICK_LEFT_X = 0, c.Gamepad.XBOX360_STICK_LEFT_Y = 1, c.Gamepad.XBOX360_STICK_RIGHT_X = 2, c.Gamepad.XBOX360_STICK_RIGHT_Y = 3, c.Gamepad.PS3XC_X = 0, c.Gamepad.PS3XC_CIRCLE = 1, c.Gamepad.PS3XC_SQUARE = 2, c.Gamepad.PS3XC_TRIANGLE = 3, c.Gamepad.PS3XC_L1 = 4, c.Gamepad.PS3XC_R1 = 5, c.Gamepad.PS3XC_L2 = 6, c.Gamepad.PS3XC_R2 = 7, c.Gamepad.PS3XC_SELECT = 8, c.Gamepad.PS3XC_START = 9, c.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10, c.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11, c.Gamepad.PS3XC_DPAD_UP = 12, c.Gamepad.PS3XC_DPAD_DOWN = 13, c.Gamepad.PS3XC_DPAD_LEFT = 14, c.Gamepad.PS3XC_DPAD_RIGHT = 15, c.Gamepad.PS3XC_STICK_LEFT_X = 0, c.Gamepad.PS3XC_STICK_LEFT_Y = 1, c.Gamepad.PS3XC_STICK_RIGHT_X = 2, c.Gamepad.PS3XC_STICK_RIGHT_Y = 3, c.SinglePad = function(a, b) {
                this.game = a, this.index = null, this.connected = !1, this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this.deadZone = .26, this._padParent = b, this._rawPad = null, this._prevTimestamp = null, this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0
            }, c.SinglePad.prototype = {
                addCallbacks: function(a, b) {
                    "undefined" != typeof b && (this.onConnectCallback = "function" == typeof b.onConnect ? b.onConnect : this.onConnectCallback,
                        this.onDisconnectCallback = "function" == typeof b.onDisconnect ? b.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof b.onDown ? b.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof b.onUp ? b.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof b.onAxis ? b.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof b.onFloat ? b.onFloat : this.onFloatCallback, this.callbackContext = a)
                },
                getButton: function(a) {
                    return this._buttons[a] ? this._buttons[a] : null
                },
                pollStatus: function() {
                    if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
                        for (var a = 0; a < this._buttonsLen; a++) {
                            var b = isNaN(this._rawPad.buttons[a]) ? this._rawPad.buttons[a].value : this._rawPad.buttons[a];
                            b !== this._buttons[a].value && (1 === b ? this.processButtonDown(a, b) : 0 === b ? this.processButtonUp(a, b) : this.processButtonFloat(a, b))
                        }
                        for (var c = 0; c < this._axesLen; c++) {
                            var d = this._rawPad.axes[c];
                            d > 0 && d > this.deadZone || d < 0 && d < -this.deadZone ? this.processAxisChange(c, d) : this.processAxisChange(c, 0)
                        }
                        this._prevTimestamp = this._rawPad.timestamp
                    }
                },
                connect: function(a) {
                    var b = !this.connected;
                    this.connected = !0, this.index = a.index, this._rawPad = a, this._buttons = [], this._buttonsLen = a.buttons.length, this._axes = [], this._axesLen = a.axes.length;
                    for (var d = 0; d < this._axesLen; d++) this._axes[d] = a.axes[d];
                    for (var e in a.buttons) e = parseInt(e, 10), this._buttons[e] = new c.DeviceButton(this, e);
                    b && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index), b && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext)
                },
                disconnect: function() {
                    var a = this.connected,
                        b = this.index;
                    this.connected = !1, this.index = null, this._rawPad = void 0;
                    for (var c = 0; c < this._buttonsLen; c++) this._buttons[c].destroy();
                    this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, a && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, b), a && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext)
                },
                destroy: function() {
                    this._rawPad = void 0;
                    for (var a = 0; a < this._buttonsLen; a++) this._buttons[a].destroy();
                    this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null
                },
                processAxisChange: function(a, b) {
                    this._axes[a] !== b && (this._axes[a] = b, this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, a, b), this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, a, b))
                },
                processButtonDown: function(a, b) {
                    this._buttons[a] && this._buttons[a].start(null, b), this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, a, b, this.index), this.onDownCallback && this.onDownCallback.call(this.callbackContext, a, b)
                },
                processButtonUp: function(a, b) {
                    this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, a, b, this.index), this.onUpCallback && this.onUpCallback.call(this.callbackContext, a, b), this._buttons[a] && this._buttons[a].stop(null, b)
                },
                processButtonFloat: function(a, b) {
                    this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, a, b, this.index), this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, a, b), this._buttons[a] && this._buttons[a].padFloat(b)
                },
                axis: function(a) {
                    return !!this._axes[a] && this._axes[a]
                },
                isDown: function(a) {
                    return !!this._buttons[a] && this._buttons[a].isDown
                },
                isUp: function(a) {
                    return !!this._buttons[a] && this._buttons[a].isUp
                },
                justReleased: function(a, b) {
                    if (this._buttons[a]) return this._buttons[a].justReleased(b)
                },
                justPressed: function(a, b) {
                    if (this._buttons[a]) return this._buttons[a].justPressed(b)
                },
                buttonValue: function(a) {
                    return this._buttons[a] ? this._buttons[a].value : null
                },
                reset: function() {
                    for (var a = 0; a < this._axes.length; a++) this._axes[a] = 0
                }
            }, c.SinglePad.prototype.constructor = c.SinglePad, c.Key = function(a, b) {
                this.game = a, this._enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = -2500, this.repeats = 0, this.keyCode = b, this.onDown = new c.Signal, this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new c.Signal, this._justDown = !1, this._justUp = !1
            }, c.Key.prototype = {
                update: function() {
                    this._enabled && this.isDown && (this.duration = this.game.time.time - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this))
                },
                processKeyDown: function(a) {
                    this._enabled && (this.event = a, this.isDown || (this.altKey = a.altKey, this.ctrlKey = a.ctrlKey, this.shiftKey = a.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, this.repeats = 0, this._justDown = !0, this.onDown.dispatch(this)))
                },
                processKeyUp: function(a) {
                    this._enabled && (this.event = a, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, this._justUp = !0, this.onUp.dispatch(this)))
                },
                reset: function(a) {
                    void 0 === a && (a = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = 0, this._enabled = !0, this._justDown = !1, this._justUp = !1, a && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null)
                },
                downDuration: function(a) {
                    return void 0 === a && (a = 50), this.isDown && this.duration < a
                },
                upDuration: function(a) {
                    return void 0 === a && (a = 50), !this.isDown && this.game.time.time - this.timeUp < a
                }
            }, Object.defineProperty(c.Key.prototype, "justDown", {
                get: function() {
                    var a = this._justDown;
                    return this._justDown = !1, a
                }
            }), Object.defineProperty(c.Key.prototype, "justUp", {
                get: function() {
                    var a = this._justUp;
                    return this._justUp = !1, a
                }
            }), Object.defineProperty(c.Key.prototype, "enabled", {
                get: function() {
                    return this._enabled
                },
                set: function(a) {
                    a = !!a, a !== this._enabled && (a || this.reset(!1), this._enabled = a)
                }
            }), c.Key.prototype.constructor = c.Key, c.Keyboard = function(a) {
                this.game = a, this.enabled = !0, this.event = null, this.pressEvent = null, this.callbackContext = this, this.onDownCallback = null, this.onPressCallback = null, this.onUpCallback = null, this._keys = [], this._capture = [], this._onKeyDown = null, this._onKeyPress = null, this._onKeyUp = null, this._i = 0, this._k = 0
            }, c.Keyboard.prototype = {
                addCallbacks: function(a, b, c, d) {
                    this.callbackContext = a, void 0 !== b && null !== b && (this.onDownCallback = b), void 0 !== c && null !== c && (this.onUpCallback = c), void 0 !== d && null !== d && (this.onPressCallback = d)
                },
                addKey: function(a) {
                    return this._keys[a] || (this._keys[a] = new c.Key(this.game, a), this.addKeyCapture(a)), this._keys[a]
                },
                addKeys: function(a) {
                    var b = {};
                    for (var c in a) b[c] = this.addKey(a[c]);
                    return b
                },
                removeKey: function(a) {
                    this._keys[a] && (this._keys[a] = null, this.removeKeyCapture(a))
                },
                createCursorKeys: function() {
                    return this.addKeys({
                        up: c.KeyCode.UP,
                        down: c.KeyCode.DOWN,
                        left: c.KeyCode.LEFT,
                        right: c.KeyCode.RIGHT
                    })
                },
                start: function() {
                    if (!this.game.device.cocoonJS && null === this._onKeyDown) {
                        var a = this;
                        this._onKeyDown = function(b) {
                            return a.processKeyDown(b)
                        }, this._onKeyUp = function(b) {
                            return a.processKeyUp(b)
                        }, this._onKeyPress = function(b) {
                            return a.processKeyPress(b)
                        }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), window.addEventListener("keypress", this._onKeyPress, !1)
                    }
                },
                stop: function() {
                    window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, this._onKeyUp = null, this._onKeyPress = null
                },
                destroy: function() {
                    this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0
                },
                addKeyCapture: function(a) {
                    if ("object" == typeof a)
                        for (var b in a) this._capture[a[b]] = !0;
                    else this._capture[a] = !0
                },
                removeKeyCapture: function(a) {
                    delete this._capture[a]
                },
                clearCaptures: function() {
                    this._capture = {}
                },
                update: function() {
                    for (this._i = this._keys.length; this._i--;) this._keys[this._i] && this._keys[this._i].update()
                },
                processKeyDown: function(a) {
                    if (this.event = a, this.game.input.enabled && this.enabled) {
                        var b = a.keyCode;
                        this._capture[b] && a.preventDefault(), this._keys[b] || (this._keys[b] = new c.Key(this.game, b)), this._keys[b].processKeyDown(a), this._k = b, this.onDownCallback && this.onDownCallback.call(this.callbackContext, a)
                    }
                },
                processKeyPress: function(a) {
                    this.pressEvent = a, this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(a.charCode), a)
                },
                processKeyUp: function(a) {
                    if (this.event = a, this.game.input.enabled && this.enabled) {
                        var b = a.keyCode;
                        this._capture[b] && a.preventDefault(), this._keys[b] || (this._keys[b] = new c.Key(this.game, b)), this._keys[b].processKeyUp(a), this.onUpCallback && this.onUpCallback.call(this.callbackContext, a)
                    }
                },
                reset: function(a) {
                    void 0 === a && (a = !0), this.event = null;
                    for (var b = this._keys.length; b--;) this._keys[b] && this._keys[b].reset(a)
                },
                downDuration: function(a, b) {
                    return this._keys[a] ? this._keys[a].downDuration(b) : null
                },
                upDuration: function(a, b) {
                    return this._keys[a] ? this._keys[a].upDuration(b) : null
                },
                isDown: function(a) {
                    return this._keys[a] ? this._keys[a].isDown : null
                }
            }, Object.defineProperty(c.Keyboard.prototype, "lastChar", {
                get: function() {
                    return 32 === this.event.charCode ? "" : String.fromCharCode(this.pressEvent.charCode)
                }
            }), Object.defineProperty(c.Keyboard.prototype, "lastKey", {
                get: function() {
                    return this._keys[this._k]
                }
            }), c.Keyboard.prototype.constructor = c.Keyboard, c.KeyCode = {
                A: "A".charCodeAt(0),
                B: "B".charCodeAt(0),
                C: "C".charCodeAt(0),
                D: "D".charCodeAt(0),
                E: "E".charCodeAt(0),
                F: "F".charCodeAt(0),
                G: "G".charCodeAt(0),
                H: "H".charCodeAt(0),
                I: "I".charCodeAt(0),
                J: "J".charCodeAt(0),
                K: "K".charCodeAt(0),
                L: "L".charCodeAt(0),
                M: "M".charCodeAt(0),
                N: "N".charCodeAt(0),
                O: "O".charCodeAt(0),
                P: "P".charCodeAt(0),
                Q: "Q".charCodeAt(0),
                R: "R".charCodeAt(0),
                S: "S".charCodeAt(0),
                T: "T".charCodeAt(0),
                U: "U".charCodeAt(0),
                V: "V".charCodeAt(0),
                W: "W".charCodeAt(0),
                X: "X".charCodeAt(0),
                Y: "Y".charCodeAt(0),
                Z: "Z".charCodeAt(0),
                ZERO: "0".charCodeAt(0),
                ONE: "1".charCodeAt(0),
                TWO: "2".charCodeAt(0),
                THREE: "3".charCodeAt(0),
                FOUR: "4".charCodeAt(0),
                FIVE: "5".charCodeAt(0),
                SIX: "6".charCodeAt(0),
                SEVEN: "7".charCodeAt(0),
                EIGHT: "8".charCodeAt(0),
                NINE: "9".charCodeAt(0),
                NUMPAD_0: 96,
                NUMPAD_1: 97,
                NUMPAD_2: 98,
                NUMPAD_3: 99,
                NUMPAD_4: 100,
                NUMPAD_5: 101,
                NUMPAD_6: 102,
                NUMPAD_7: 103,
                NUMPAD_8: 104,
                NUMPAD_9: 105,
                NUMPAD_MULTIPLY: 106,
                NUMPAD_ADD: 107,
                NUMPAD_ENTER: 108,
                NUMPAD_SUBTRACT: 109,
                NUMPAD_DECIMAL: 110,
                NUMPAD_DIVIDE: 111,
                F1: 112,
                F2: 113,
                F3: 114,
                F4: 115,
                F5: 116,
                F6: 117,
                F7: 118,
                F8: 119,
                F9: 120,
                F10: 121,
                F11: 122,
                F12: 123,
                F13: 124,
                F14: 125,
                F15: 126,
                COLON: 186,
                EQUALS: 187,
                COMMA: 188,
                UNDERSCORE: 189,
                PERIOD: 190,
                QUESTION_MARK: 191,
                TILDE: 192,
                OPEN_BRACKET: 219,
                BACKWARD_SLASH: 220,
                CLOSED_BRACKET: 221,
                QUOTES: 222,
                BACKSPACE: 8,
                TAB: 9,
                CLEAR: 12,
                ENTER: 13,
                SHIFT: 16,
                CONTROL: 17,
                ALT: 18,
                CAPS_LOCK: 20,
                ESC: 27,
                SPACEBAR: 32,
                PAGE_UP: 33,
                PAGE_DOWN: 34,
                END: 35,
                HOME: 36,
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                DOWN: 40,
                PLUS: 43,
                MINUS: 44,
                INSERT: 45,
                DELETE: 46,
                HELP: 47,
                NUM_LOCK: 144
            };
        for (var e in c.KeyCode) c.KeyCode.hasOwnProperty(e) && !e.match(/[a-z]/) && (c.Keyboard[e] = c.KeyCode[e]);
        c.Component = function() {}, c.Component.Angle = function() {}, c.Component.Angle.prototype = {
            angle: {
                get: function() {
                    return c.Math.wrapAngle(c.Math.radToDeg(this.rotation))
                },
                set: function(a) {
                    this.rotation = c.Math.degToRad(c.Math.wrapAngle(a))
                }
            }
        }, c.Component.Animation = function() {}, c.Component.Animation.prototype = {
            play: function(a, b, c, d) {
                if (this.animations) return this.animations.play(a, b, c, d)
            }
        }, c.Component.AutoCull = function() {}, c.Component.AutoCull.prototype = {
            autoCull: !1,
            inCamera: {
                get: function() {
                    return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), this.game.world.camera.view.intersects(this._bounds)
                }
            }
        }, c.Component.Bounds = function() {}, c.Component.Bounds.prototype = {
            offsetX: {
                get: function() {
                    return this.anchor.x * this.width
                }
            },
            offsetY: {
                get: function() {
                    return this.anchor.y * this.height
                }
            },
            centerX: {
                get: function() {
                    return this.x - this.offsetX + .5 * this.width
                },
                set: function(a) {
                    this.x = a + this.offsetX - .5 * this.width
                }
            },
            centerY: {
                get: function() {
                    return this.y - this.offsetY + .5 * this.height
                },
                set: function(a) {
                    this.y = a + this.offsetY - .5 * this.height
                }
            },
            left: {
                get: function() {
                    return this.x - this.offsetX
                },
                set: function(a) {
                    this.x = a + this.offsetX
                }
            },
            right: {
                get: function() {
                    return this.x + this.width - this.offsetX
                },
                set: function(a) {
                    this.x = a - this.width + this.offsetX
                }
            },
            top: {
                get: function() {
                    return this.y - this.offsetY
                },
                set: function(a) {
                    this.y = a + this.offsetY
                }
            },
            bottom: {
                get: function() {
                    return this.y + this.height - this.offsetY
                },
                set: function(a) {
                    this.y = a - this.height + this.offsetY
                }
            },
            alignIn: function(a, b, d, e) {
                switch (void 0 === d && (d = 0), void 0 === e && (e = 0), b) {
                    default:
                        case c.TOP_LEFT:
                        this.left = a.left - d,
                    this.top = a.top - e;
                    break;
                    case c.TOP_CENTER:
                        this.centerX = a.centerX + d, this.top = a.top - e;
                        break;
                    case c.TOP_RIGHT:
                        this.right = a.right + d, this.top = a.top - e;
                        break;
                    case c.LEFT_CENTER:
                        this.left = a.left - d, this.centerY = a.centerY + e;
                        break;
                    case c.CENTER:
                        this.centerX = a.centerX + d, this.centerY = a.centerY + e;
                        break;
                    case c.RIGHT_CENTER:
                        this.right = a.right + d, this.centerY = a.centerY + e;
                        break;
                    case c.BOTTOM_LEFT:
                        this.left = a.left - d, this.bottom = a.bottom + e;
                        break;
                    case c.BOTTOM_CENTER:
                        this.centerX = a.centerX + d, this.bottom = a.bottom + e;
                        break;
                    case c.BOTTOM_RIGHT:
                        this.right = a.right + d, this.bottom = a.bottom + e
                }
                return this
            },
            alignTo: function(a, b, d, e) {
                switch (void 0 === d && (d = 0), void 0 === e && (e = 0), b) {
                    default:
                        case c.TOP_LEFT:
                        this.left = a.left - d,
                    this.bottom = a.top - e;
                    break;
                    case c.TOP_CENTER:
                        this.centerX = a.centerX + d, this.bottom = a.top - e;
                        break;
                    case c.TOP_RIGHT:
                        this.right = a.right + d, this.bottom = a.top - e;
                        break;
                    case c.LEFT_TOP:
                        this.right = a.left - d, this.top = a.top - e;
                        break;
                    case c.LEFT_CENTER:
                        this.right = a.left - d, this.centerY = a.centerY + e;
                        break;
                    case c.LEFT_BOTTOM:
                        this.right = a.left - d, this.bottom = a.bottom + e;
                        break;
                    case c.RIGHT_TOP:
                        this.left = a.right + d, this.top = a.top - e;
                        break;
                    case c.RIGHT_CENTER:
                        this.left = a.right + d, this.centerY = a.centerY + e;
                        break;
                    case c.RIGHT_BOTTOM:
                        this.left = a.right + d, this.bottom = a.bottom + e;
                        break;
                    case c.BOTTOM_LEFT:
                        this.left = a.left - d, this.top = a.bottom + e;
                        break;
                    case c.BOTTOM_CENTER:
                        this.centerX = a.centerX + d, this.top = a.bottom + e;
                        break;
                    case c.BOTTOM_RIGHT:
                        this.right = a.right + d, this.top = a.bottom + e
                }
                return this
            }
        }, c.Group.prototype.alignIn = c.Component.Bounds.prototype.alignIn, c.Group.prototype.alignTo = c.Component.Bounds.prototype.alignTo, c.Component.BringToTop = function() {}, c.Component.BringToTop.prototype.bringToTop = function() {
            return this.parent && this.parent.bringToTop(this), this
        }, c.Component.BringToTop.prototype.sendToBack = function() {
            return this.parent && this.parent.sendToBack(this), this
        }, c.Component.BringToTop.prototype.moveUp = function() {
            return this.parent && this.parent.moveUp(this), this
        }, c.Component.BringToTop.prototype.moveDown = function() {
            return this.parent && this.parent.moveDown(this), this
        }, c.Component.Core = function() {}, c.Component.Core.install = function(a) {
            c.Utils.mixinPrototype(this, c.Component.Core.prototype), this.components = {};
            for (var b = 0; b < a.length; b++) {
                var d = a[b],
                    e = !1;
                "Destroy" === d && (e = !0), c.Utils.mixinPrototype(this, c.Component[d].prototype, e), this.components[d] = !0
            }
        }, c.Component.Core.init = function(a, b, d, e, f) {
            this.game = a, this.key = e, this.data = {}, this.position.set(b, d), this.world = new c.Point(b, d), this.previousPosition = new c.Point(b, d), this.events = new c.Events(this), this._bounds = new c.Rectangle, this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new c.AnimationManager(this)), this.components.LoadTexture && null !== e && this.loadTexture(e, f), this.components.FixedToCamera && (this.cameraOffset = new c.Point(b, d))
        }, c.Component.Core.preUpdate = function() {
            if (this.pendingDestroy) return void this.destroy();
            if (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
            this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate();
            for (var a = 0; a < this.children.length; a++) this.children[a].preUpdate();
            return !0
        }, c.Component.Core.prototype = {
            game: null,
            name: "",
            data: {},
            components: {},
            z: 0,
            events: void 0,
            animations: void 0,
            key: "",
            world: null,
            debug: !1,
            previousPosition: null,
            previousRotation: 0,
            renderOrderID: 0,
            fresh: !0,
            pendingDestroy: !1,
            _bounds: null,
            _exists: !0,
            exists: {
                get: function() {
                    return this._exists
                },
                set: function(a) {
                    a ? (this._exists = !0, this.body && this.body.type === c.Physics.P2JS && this.body.addToWorld(), this.visible = !0) : (this._exists = !1, this.body && this.body.type === c.Physics.P2JS && this.body.removeFromWorld(), this.visible = !1)
                }
            },
            update: function() {},
            postUpdate: function() {
                this.customRender && this.key.render(), this.components.PhysicsBody && c.Component.PhysicsBody.postUpdate.call(this), this.components.FixedToCamera && c.Component.FixedToCamera.postUpdate.call(this);
                for (var a = 0; a < this.children.length; a++) this.children[a].postUpdate()
            }
        }, c.Component.Crop = function() {}, c.Component.Crop.prototype = {
            cropRect: null,
            _crop: null,
            crop: function(a, b) {
                void 0 === b && (b = !1), a ? (b && null !== this.cropRect ? this.cropRect.setTo(a.x, a.y, a.width, a.height) : b && null === this.cropRect ? this.cropRect = new c.Rectangle(a.x, a.y, a.width, a.height) : this.cropRect = a, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame())
            },
            updateCrop: function() {
                if (this.cropRect) {
                    var a = this.texture.crop.x,
                        b = this.texture.crop.y,
                        d = this.texture.crop.width,
                        e = this.texture.crop.height;
                    this._crop = c.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y;
                    var f = Math.max(this._frame.x, this._crop.x),
                        g = Math.max(this._frame.y, this._crop.y),
                        h = Math.min(this._frame.right, this._crop.right) - f,
                        i = Math.min(this._frame.bottom, this._crop.bottom) - g;
                    this.texture.crop.x = f, this.texture.crop.y = g, this.texture.crop.width = h, this.texture.crop.height = i, this.texture.frame.width = Math.min(h, this.cropRect.width), this.texture.frame.height = Math.min(i, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.texture._updateUvs(), 16777215 === this.tint || a === f && b === g && d === h && e === i || (this.texture.requiresReTint = !0)
                }
            }
        }, c.Component.Delta = function() {}, c.Component.Delta.prototype = {
            deltaX: {
                get: function() {
                    return this.world.x - this.previousPosition.x
                }
            },
            deltaY: {
                get: function() {
                    return this.world.y - this.previousPosition.y
                }
            },
            deltaZ: {
                get: function() {
                    return this.rotation - this.previousRotation
                }
            }
        }, c.Component.Destroy = function() {}, c.Component.Destroy.prototype = {
            destroyPhase: !1,
            destroy: function(a, b) {
                if (null !== this.game && !this.destroyPhase) {
                    void 0 === a && (a = !0), void 0 === b && (b = !1), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof c.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy(), this.game.tweens.removeFrom(this);
                    var d = this.children.length;
                    if (a)
                        for (; d--;) this.children[d].destroy(a);
                    else
                        for (; d--;) this.removeChild(this.children[d]);
                    this._crop && (this._crop = null, this.cropRect = null), this._frame && (this._frame = null), c.Video && this.key instanceof c.Video && this.key.onChangeSource.remove(this.resizeFrame, this), c.BitmapText && this._glyphs && (this._glyphs = []), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.data = {}, this.renderable = !1, this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null), this.hitArea = null, this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), b && this.texture.destroy(!0), this.destroyPhase = !1, this.pendingDestroy = !1
                }
            }
        }, c.Events = function(a) {
            this.parent = a
        }, c.Events.prototype = {
            destroy: function() {
                this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(), this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose()
            },
            onAddedToGroup: null,
            onRemovedFromGroup: null,
            onRemovedFromWorld: null,
            onDestroy: null,
            onKilled: null,
            onRevived: null,
            onOutOfBounds: null,
            onEnterBounds: null,
            onInputOver: null,
            onInputOut: null,
            onInputDown: null,
            onInputUp: null,
            onDragStart: null,
            onDragUpdate: null,
            onDragStop: null,
            onAnimationStart: null,
            onAnimationComplete: null,
            onAnimationLoop: null
        }, c.Events.prototype.constructor = c.Events;
        for (var f in c.Events.prototype) c.Events.prototype.hasOwnProperty(f) && 0 === f.indexOf("on") && null === c.Events.prototype[f] && ! function(a, b) {
            "use strict";
            Object.defineProperty(c.Events.prototype, a, {
                get: function() {
                    return this[b] || (this[b] = new c.Signal)
                }
            }), c.Events.prototype[a + "$dispatch"] = function() {
                return this[b] ? this[b].dispatch.apply(this[b], arguments) : null
            }
        }(f, "_" + f);
        c.Component.FixedToCamera = function() {}, c.Component.FixedToCamera.postUpdate = function() {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
        }, c.Component.FixedToCamera.prototype = {
            _fixedToCamera: !1,
            fixedToCamera: {
                get: function() {
                    return this._fixedToCamera
                },
                set: function(a) {
                    a ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1
                }
            },
            cameraOffset: new c.Point
        }, c.Component.Health = function() {}, c.Component.Health.prototype = {
            health: 1,
            maxHealth: 100,
            damage: function(a) {
                return this.alive && (this.health -= a, this.health <= 0 && this.kill()), this
            },
            setHealth: function(a) {
                return this.health = a, this.health > this.maxHealth && (this.health = this.maxHealth), this
            },
            heal: function(a) {
                return this.alive && (this.health += a, this.health > this.maxHealth && (this.health = this.maxHealth)), this
            }
        }, c.Component.InCamera = function() {}, c.Component.InCamera.prototype = {
            inCamera: {
                get: function() {
                    return this.game.world.camera.view.intersects(this._bounds)
                }
            }
        }, c.Component.InputEnabled = function() {}, c.Component.InputEnabled.prototype = {
            input: null,
            inputEnabled: {
                get: function() {
                    return this.input && this.input.enabled
                },
                set: function(a) {
                    a ? null === this.input ? (this.input = new c.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                }
            }
        }, c.Component.InWorld = function() {}, c.Component.InWorld.preUpdate = function() {
            if (this.autoCull || this.checkWorldBounds) {
                if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull)
                    if (this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0, this.game.world.camera.totalInView++;
                    else if (this.renderable = !1, this.outOfCameraBoundsKill) return this.kill(), !1;
                if (this.checkWorldBounds)
                    if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, this.events.onEnterBounds$dispatch(this);
                    else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), !1
            }
            return !0
        }, c.Component.InWorld.prototype = {
            checkWorldBounds: !1,
            outOfBoundsKill: !1,
            outOfCameraBoundsKill: !1,
            _outOfBoundsFired: !1,
            inWorld: {
                get: function() {
                    return this.game.world.bounds.intersects(this.getBounds())
                }
            }
        }, c.Component.LifeSpan = function() {}, c.Component.LifeSpan.preUpdate = function() {
            return !(this.lifespan > 0 && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0) && (this.kill(), 1))
        }, c.Component.LifeSpan.prototype = {
            alive: !0,
            lifespan: 0,
            revive: function(a) {
                return void 0 === a && (a = 100), this.alive = !0, this.exists = !0, this.visible = !0, "function" == typeof this.setHealth && this.setHealth(a), this.events && this.events.onRevived$dispatch(this), this
            },
            kill: function() {
                return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), this
            }
        }, c.Component.LoadTexture = function() {}, c.Component.LoadTexture.prototype = {
            customRender: !1,
            _frame: null,
            loadTexture: function(a, b, d) {
                a === c.PENDING_ATLAS ? (a = b, b = 0) : b = b || 0, (d || void 0 === d) && this.animations && this.animations.stop(), this.key = a, this.customRender = !1;
                var e = this.game.cache,
                    f = !0,
                    g = !this.texture.baseTexture.scaleMode;
                if (c.RenderTexture && a instanceof c.RenderTexture) this.key = a.key, this.setTexture(a);
                else if (c.BitmapData && a instanceof c.BitmapData) this.customRender = !0, this.setTexture(a.texture), f = e.hasFrameData(a.key, c.Cache.BITMAPDATA) ? !this.animations.loadFrameData(e.getFrameData(a.key, c.Cache.BITMAPDATA), b) : !this.animations.loadFrameData(a.frameData, 0);
                else if (c.Video && a instanceof c.Video) {
                    this.customRender = !0;
                    var h = a.texture.valid;
                    this.setTexture(a.texture), this.setFrame(a.texture.frame.clone()), a.onChangeSource.add(this.resizeFrame, this), this.texture.valid = h
                } else if (c.Tilemap && a instanceof c.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(a.canvas));
                else if (a instanceof PIXI.Texture) this.setTexture(a);
                else {
                    var i = e.getImage(a, !0);
                    this.key = i.key, this.setTexture(new PIXI.Texture(i.base)), "__default" === a ? this.texture.baseTexture.skipRender = !0 : this.texture.baseTexture.skipRender = !1, f = !this.animations.loadFrameData(i.frameData, b)
                }
                f && (this._frame = c.Rectangle.clone(this.texture.frame)), g || (this.texture.baseTexture.scaleMode = 1)
            },
            setFrame: function(a) {
                this._frame = a, this.texture.frame.x = a.x, this.texture.frame.y = a.y, this.texture.frame.width = a.width, this.texture.frame.height = a.height, this.texture.crop.x = a.x, this.texture.crop.y = a.y, this.texture.crop.width = a.width, this.texture.crop.height = a.height, a.trimmed ? (this.texture.trim ? (this.texture.trim.x = a.spriteSourceSizeX, this.texture.trim.y = a.spriteSourceSizeY, this.texture.trim.width = a.sourceSizeW, this.texture.trim.height = a.sourceSizeH) : this.texture.trim = {
                    x: a.spriteSourceSizeX,
                    y: a.spriteSourceSizeY,
                    width: a.sourceSizeW,
                    height: a.sourceSizeH
                }, this.texture.width = a.sourceSizeW, this.texture.height = a.sourceSizeH, this.texture.frame.width = a.sourceSizeW, this.texture.frame.height = a.sourceSizeH) : !a.trimmed && this.texture.trim && (this.texture.trim = null), this.cropRect && this.updateCrop(), this.texture.requiresReTint = !0, this.texture._updateUvs(), this.tilingTexture && (this.refreshTexture = !0)
            },
            resizeFrame: function(a, b, c) {
                this.texture.frame.resize(b, c), this.texture.setFrame(this.texture.frame)
            },
            resetFrame: function() {
                this._frame && this.setFrame(this._frame)
            },
            frame: {
                get: function() {
                    return this.animations.frame
                },
                set: function(a) {
                    this.animations.frame = a
                }
            },
            frameName: {
                get: function() {
                    return this.animations.frameName
                },
                set: function(a) {
                    this.animations.frameName = a
                }
            }
        }, c.Component.Overlap = function() {}, c.Component.Overlap.prototype = {
            overlap: function(a) {
                return c.Rectangle.intersects(this.getBounds(), a.getBounds())
            }
        }, c.Component.PhysicsBody = function() {}, c.Component.PhysicsBody.preUpdate = function() {
            return this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1, !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || (this.renderOrderID = -1, !1))
        }, c.Component.PhysicsBody.postUpdate = function() {
            this.exists && this.body && this.body.postUpdate()
        }, c.Component.PhysicsBody.prototype = {
            body: null,
            x: {
                get: function() {
                    return this.position.x
                },
                set: function(a) {
                    this.position.x = a, this.body && !this.body.dirty && (this.body._reset = !0)
                }
            },
            y: {
                get: function() {
                    return this.position.y
                },
                set: function(a) {
                    this.position.y = a, this.body && !this.body.dirty && (this.body._reset = !0)
                }
            }
        }, c.Component.Reset = function() {}, c.Component.Reset.prototype.reset = function(a, b, c) {
            return void 0 === c && (c = 1), this.world.set(a, b), this.position.set(a, b), this.fresh = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this.components.InWorld && (this._outOfBoundsFired = !1), this.components.LifeSpan && (this.alive = !0, this.health = c), this.components.PhysicsBody && this.body && this.body.reset(a, b, !1, !1), this
        }, c.Component.ScaleMinMax = function() {}, c.Component.ScaleMinMax.prototype = {
            transformCallback: null,
            transformCallbackContext: this,
            scaleMin: null,
            scaleMax: null,
            checkTransform: function(a) {
                this.scaleMin && (a.a < this.scaleMin.x && (a.a = this.scaleMin.x), a.d < this.scaleMin.y && (a.d = this.scaleMin.y)), this.scaleMax && (a.a > this.scaleMax.x && (a.a = this.scaleMax.x), a.d > this.scaleMax.y && (a.d = this.scaleMax.y))
            },
            setScaleMinMax: function(a, b, d, e) {
                void 0 === b ? b = d = e = a : void 0 === d && (d = e = b, b = a), null === a ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(a, b) : this.scaleMin = new c.Point(a, b), null === d ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(d, e) : this.scaleMax = new c.Point(d, e), null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform, this.transformCallbackContext = this)
            }
        }, c.Component.Smoothed = function() {}, c.Component.Smoothed.prototype = {
            smoothed: {
                get: function() {
                    return !this.texture.baseTexture.scaleMode
                },
                set: function(a) {
                    a ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1)
                }
            }
        }, c.GameObjectFactory = function(a) {
            this.game = a, this.world = this.game.world
        }, c.GameObjectFactory.prototype = {
            existing: function(a) {
                return this.world.add(a)
            },
            weapon: function(a, b, d, e) {
                var f = this.game.plugins.add(c.Weapon);
                return f.createBullets(a, b, d, e), f
            },
            image: function(a, b, d, e, f) {
                return void 0 === f && (f = this.world), f.add(new c.Image(this.game, a, b, d, e))
            },
            sprite: function(a, b, c, d, e) {
                return void 0 === e && (e = this.world), e.create(a, b, c, d)
            },
            creature: function(a, b, d, e, f) {
                void 0 === f && (f = this.world);
                var g = new c.Creature(this.game, a, b, d, e);
                return f.add(g), g
            },
            tween: function(a) {
                return this.game.tweens.create(a)
            },
            group: function(a, b, d, e, f) {
                return new c.Group(this.game, a, b, d, e, f)
            },
            physicsGroup: function(a, b, d, e) {
                return new c.Group(this.game, b, d, e, (!0), a)
            },
            spriteBatch: function(a, b, d) {
                return void 0 === a && (a = null), void 0 === b && (b = "group"), void 0 === d && (d = !1), new c.SpriteBatch(this.game, a, b, d)
            },
            audio: function(a, b, c, d) {
                return this.game.sound.add(a, b, c, d)
            },
            sound: function(a, b, c, d) {
                return this.game.sound.add(a, b, c, d)
            },
            audioSprite: function(a) {
                return this.game.sound.addSprite(a)
            },
            tileSprite: function(a, b, d, e, f, g, h) {
                return void 0 === h && (h = this.world), h.add(new c.TileSprite(this.game, a, b, d, e, f, g))
            },
            rope: function(a, b, d, e, f, g) {
                return void 0 === g && (g = this.world), g.add(new c.Rope(this.game, a, b, d, e, f))
            },
            text: function(a, b, d, e, f) {
                return void 0 === f && (f = this.world), f.add(new c.Text(this.game, a, b, d, e))
            },
            button: function(a, b, d, e, f, g, h, i, j, k) {
                return void 0 === k && (k = this.world), k.add(new c.Button(this.game, a, b, d, e, f, g, h, i, j))
            },
            graphics: function(a, b, d) {
                return void 0 === d && (d = this.world), d.add(new c.Graphics(this.game, a, b))
            },
            emitter: function(a, b, d) {
                return this.game.particles.add(new c.Particles.Arcade.Emitter(this.game, a, b, d))
            },
            retroFont: function(a, b, d, e, f, g, h, i, j) {
                return new c.RetroFont(this.game, a, b, d, e, f, g, h, i, j)
            },
            bitmapText: function(a, b, d, e, f, g) {
                return void 0 === g && (g = this.world), g.add(new c.BitmapText(this.game, a, b, d, e, f))
            },
            tilemap: function(a, b, d, e, f) {
                return new c.Tilemap(this.game, a, b, d, e, f)
            },
            renderTexture: function(a, b, d, e) {
                void 0 !== d && "" !== d || (d = this.game.rnd.uuid()), void 0 === e && (e = !1);
                var f = new c.RenderTexture(this.game, a, b, d);
                return e && this.game.cache.addRenderTexture(d, f), f
            },
            video: function(a, b) {
                return new c.Video(this.game, a, b)
            },
            bitmapData: function(a, b, d, e) {
                void 0 === e && (e = !1), void 0 !== d && "" !== d || (d = this.game.rnd.uuid());
                var f = new c.BitmapData(this.game, d, a, b);
                return e && this.game.cache.addBitmapData(d, f), f
            },
            filter: function(a) {
                var b = Array.prototype.slice.call(arguments, 1),
                    a = new c.Filter[a](this.game);
                return a.init.apply(a, b), a
            },
            plugin: function(a) {
                return this.game.plugins.add(a)
            }
        }, c.GameObjectFactory.prototype.constructor = c.GameObjectFactory, c.GameObjectCreator = function(a) {
            this.game = a, this.world = this.game.world
        }, c.GameObjectCreator.prototype = {
            image: function(a, b, d, e) {
                return new c.Image(this.game, a, b, d, e)
            },
            sprite: function(a, b, d, e) {
                return new c.Sprite(this.game, a, b, d, e)
            },
            tween: function(a) {
                return new c.Tween(a, this.game, this.game.tweens)
            },
            group: function(a, b, d, e, f) {
                return new c.Group(this.game, a, b, d, e, f)
            },
            spriteBatch: function(a, b, d) {
                return void 0 === b && (b = "group"), void 0 === d && (d = !1), new c.SpriteBatch(this.game, a, b, d)
            },
            audio: function(a, b, c, d) {
                return this.game.sound.add(a, b, c, d)
            },
            audioSprite: function(a) {
                return this.game.sound.addSprite(a)
            },
            sound: function(a, b, c, d) {
                return this.game.sound.add(a, b, c, d)
            },
            tileSprite: function(a, b, d, e, f, g) {
                return new c.TileSprite(this.game, a, b, d, e, f, g)
            },
            rope: function(a, b, d, e, f) {
                return new c.Rope(this.game, a, b, d, e, f)
            },
            text: function(a, b, d, e) {
                return new c.Text(this.game, a, b, d, e)
            },
            button: function(a, b, d, e, f, g, h, i, j) {
                return new c.Button(this.game, a, b, d, e, f, g, h, i, j)
            },
            graphics: function(a, b) {
                return new c.Graphics(this.game, a, b)
            },
            emitter: function(a, b, d) {
                return new c.Particles.Arcade.Emitter(this.game, a, b, d)
            },
            retroFont: function(a, b, d, e, f, g, h, i, j) {
                return new c.RetroFont(this.game, a, b, d, e, f, g, h, i, j)
            },
            bitmapText: function(a, b, d, e, f, g) {
                return new c.BitmapText(this.game, a, b, d, e, f, g)
            },
            tilemap: function(a, b, d, e, f) {
                return new c.Tilemap(this.game, a, b, d, e, f)
            },
            renderTexture: function(a, b, d, e) {
                void 0 !== d && "" !== d || (d = this.game.rnd.uuid()), void 0 === e && (e = !1);
                var f = new c.RenderTexture(this.game, a, b, d);
                return e && this.game.cache.addRenderTexture(d, f), f
            },
            bitmapData: function(a, b, d, e) {
                void 0 === e && (e = !1), void 0 !== d && "" !== d || (d = this.game.rnd.uuid());
                var f = new c.BitmapData(this.game, d, a, b);
                return e && this.game.cache.addBitmapData(d, f), f
            },
            filter: function(a) {
                var b = Array.prototype.slice.call(arguments, 1),
                    a = new c.Filter[a](this.game);
                return a.init.apply(a, b), a
            }
        }, c.GameObjectCreator.prototype.constructor = c.GameObjectCreator, c.Sprite = function(a, b, d, e, f) {
            b = b || 0, d = d || 0, e = e || null, f = f || null, this.type = c.SPRITE, this.physicsType = c.SPRITE, PIXI.Sprite.call(this, c.Cache.DEFAULT), c.Component.Core.init.call(this, a, b, d, e, f)
        }, c.Sprite.prototype = Object.create(PIXI.Sprite.prototype), c.Sprite.prototype.constructor = c.Sprite, c.Component.Core.install.call(c.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), c.Sprite.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate, c.Sprite.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate, c.Sprite.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.Sprite.prototype.preUpdateCore = c.Component.Core.preUpdate, c.Sprite.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, c.Image = function(a, b, d, e, f) {
            b = b || 0, d = d || 0, e = e || null, f = f || null, this.type = c.IMAGE, PIXI.Sprite.call(this, c.Cache.DEFAULT), c.Component.Core.init.call(this, a, b, d, e, f)
        }, c.Image.prototype = Object.create(PIXI.Sprite.prototype), c.Image.prototype.constructor = c.Image, c.Component.Core.install.call(c.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]), c.Image.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.Image.prototype.preUpdateCore = c.Component.Core.preUpdate, c.Image.prototype.preUpdate = function() {
            return !!this.preUpdateInWorld() && this.preUpdateCore()
        }, c.Button = function(a, b, d, e, f, g, h, i, j, k) {
            b = b || 0, d = d || 0, e = e || null, f = f || null, g = g || this, c.Image.call(this, a, b, d, e, i), this.type = c.BUTTON, this.physicsType = c.SPRITE, this._onOverFrame = null, this._onOutFrame = null, this._onDownFrame = null, this._onUpFrame = null, this.onOverSound = null, this.onOutSound = null, this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", this.onOutSoundMarker = "", this.onDownSoundMarker = "", this.onUpSoundMarker = "", this.onInputOver = new c.Signal, this.onInputOut = new c.Signal, this.onInputDown = new c.Signal, this.onInputUp = new c.Signal, this.onOverMouseOnly = !0, this.justReleasedPreventsOver = c.PointerMode.TOUCH, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.input.useHandCursor = !0, this.setFrames(h, i, j, k), null !== f && this.onInputUp.add(f, g), this.events.onInputOver.add(this.onInputOverHandler, this), this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), this.events.onInputUp.add(this.onInputUpHandler, this), this.events.onRemovedFromWorld.add(this.removedFromWorld, this)
        }, c.Button.prototype = Object.create(c.Image.prototype), c.Button.prototype.constructor = c.Button;
        var g = "Over",
            h = "Out",
            i = "Down",
            j = "Up";
        c.Button.prototype.clearFrames = function() {
            this.setFrames(null, null, null, null)
        }, c.Button.prototype.removedFromWorld = function() {
            this.inputEnabled = !1
        }, c.Button.prototype.setStateFrame = function(a, b, c) {
            var d = "_on" + a + "Frame";
            null !== b ? (this[d] = b, c && this.changeStateFrame(a)) : this[d] = null
        }, c.Button.prototype.changeStateFrame = function(a) {
            if (this.freezeFrames) return !1;
            var b = "_on" + a + "Frame",
                c = this[b];
            return "string" == typeof c ? (this.frameName = c, !0) : "number" == typeof c && (this.frame = c, !0)
        }, c.Button.prototype.setFrames = function(a, b, c, d) {
            this.setStateFrame(g, a, this.input.pointerOver()), this.setStateFrame(h, b, !this.input.pointerOver()), this.setStateFrame(i, c, this.input.pointerDown()), this.setStateFrame(j, d, this.input.pointerUp())
        }, c.Button.prototype.setStateSound = function(a, b, d) {
            var e = "on" + a + "Sound",
                f = "on" + a + "SoundMarker";
            b instanceof c.Sound || b instanceof c.AudioSprite ? (this[e] = b, this[f] = "string" == typeof d ? d : "") : (this[e] = null, this[f] = "")
        }, c.Button.prototype.playStateSound = function(a) {
            var b = "on" + a + "Sound",
                c = this[b];
            if (c) {
                var d = "on" + a + "SoundMarker",
                    e = this[d];
                return c.play(e), !0
            }
            return !1
        }, c.Button.prototype.setSounds = function(a, b, c, d, e, f, k, l) {
            this.setStateSound(g, a, b), this.setStateSound(h, e, f), this.setStateSound(i, c, d), this.setStateSound(j, k, l)
        }, c.Button.prototype.setOverSound = function(a, b) {
            this.setStateSound(g, a, b)
        }, c.Button.prototype.setOutSound = function(a, b) {
            this.setStateSound(h, a, b)
        }, c.Button.prototype.setDownSound = function(a, b) {
            this.setStateSound(i, a, b)
        }, c.Button.prototype.setUpSound = function(a, b) {
            this.setStateSound(j, a, b)
        }, c.Button.prototype.onInputOverHandler = function(a, b) {
            b.justReleased() && (this.justReleasedPreventsOver & b.pointerMode) === b.pointerMode || (this.changeStateFrame(g), this.onOverMouseOnly && !b.isMouse || (this.playStateSound(g), this.onInputOver && this.onInputOver.dispatch(this, b)))
        }, c.Button.prototype.onInputOutHandler = function(a, b) {
            this.changeStateFrame(h), this.playStateSound(h), this.onInputOut && this.onInputOut.dispatch(this, b)
        }, c.Button.prototype.onInputDownHandler = function(a, b) {
            this.changeStateFrame(i), this.playStateSound(i), this.onInputDown && this.onInputDown.dispatch(this, b)
        }, c.Button.prototype.onInputUpHandler = function(a, b, c) {
            if (this.playStateSound(j), this.onInputUp && this.onInputUp.dispatch(this, b, c), !this.freezeFrames)
                if (this.forceOut === !0 || (this.forceOut & b.pointerMode) === b.pointerMode) this.changeStateFrame(h);
                else {
                    var d = this.changeStateFrame(j);
                    d || (c ? this.changeStateFrame(g) : this.changeStateFrame(h))
                }
        }, c.SpriteBatch = function(a, b, d, e) {
            void 0 !== b && null !== b || (b = a.world), PIXI.SpriteBatch.call(this), c.Group.call(this, a, b, d, e), this.type = c.SPRITEBATCH
        }, c.SpriteBatch.prototype = c.Utils.extend(!0, c.SpriteBatch.prototype, PIXI.SpriteBatch.prototype, c.Group.prototype), c.SpriteBatch.prototype.constructor = c.SpriteBatch, c.BitmapData = function(a, b, d, e, f) {
            void 0 !== d && 0 !== d || (d = 256), void 0 !== e && 0 !== e || (e = 256), void 0 === f && (f = !1), this.game = a, this.key = b, this.width = d, this.height = e, this.canvas = c.Canvas.create(this, d, e, null, f), this.context = this.canvas.getContext("2d", {
                alpha: !0
            }), this.ctx = this.context, this.smoothProperty = a.renderType === c.CANVAS ? a.renderer.renderSession.smoothProperty : c.Canvas.getSmoothingPrefix(this.context), this.imageData = this.context.getImageData(0, 0, d, e), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data), this.baseTexture = new PIXI.BaseTexture(this.canvas), this.texture = new PIXI.Texture(this.baseTexture), this.frameData = new c.FrameData, this.textureFrame = this.frameData.addFrame(new c.Frame(0, 0, 0, d, e, "bitmapData")), this.texture.frame = this.textureFrame, this.type = c.BITMAPDATA, this.disableTextureUpload = !1, this.dirty = !1, this.cls = this.clear, this._image = null, this._pos = new c.Point, this._size = new c.Point, this._scale = new c.Point, this._rotate = 0, this._alpha = {
                prev: 1,
                current: 1
            }, this._anchor = new c.Point, this._tempR = 0, this._tempG = 0, this._tempB = 0, this._circle = new c.Circle, this._swapCanvas = void 0
        }, c.BitmapData.prototype = {
            move: function(a, b, c) {
                return 0 !== a && this.moveH(a, c), 0 !== b && this.moveV(b, c), this
            },
            moveH: function(a, b) {
                void 0 === b && (b = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                var c = this._swapCanvas,
                    d = c.getContext("2d"),
                    e = this.height,
                    f = this.canvas;
                if (d.clearRect(0, 0, this.width, this.height), a < 0) {
                    a = Math.abs(a);
                    var g = this.width - a;
                    b && d.drawImage(f, 0, 0, a, e, g, 0, a, e), d.drawImage(f, a, 0, g, e, 0, 0, g, e)
                } else {
                    var g = this.width - a;
                    b && d.drawImage(f, g, 0, a, e, 0, 0, a, e), d.drawImage(f, 0, 0, g, e, a, 0, g, e)
                }
                return this.clear(), this.copy(this._swapCanvas)
            },
            moveV: function(a, b) {
                void 0 === b && (b = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                var c = this._swapCanvas,
                    d = c.getContext("2d"),
                    e = this.width,
                    f = this.canvas;
                if (d.clearRect(0, 0, this.width, this.height), a < 0) {
                    a = Math.abs(a);
                    var g = this.height - a;
                    b && d.drawImage(f, 0, 0, e, a, 0, g, e, a), d.drawImage(f, 0, a, e, g, 0, 0, e, g)
                } else {
                    var g = this.height - a;
                    b && d.drawImage(f, 0, g, e, a, 0, 0, e, a), d.drawImage(f, 0, 0, e, g, 0, a, e, g)
                }
                return this.clear(), this.copy(this._swapCanvas)
            },
            add: function(a) {
                if (Array.isArray(a))
                    for (var b = 0; b < a.length; b++) a[b].loadTexture && a[b].loadTexture(this);
                else a.loadTexture(this);
                return this
            },
            load: function(a) {
                if ("string" == typeof a && (a = this.game.cache.getImage(a)), a) return this.resize(a.width, a.height), this.cls(), this.draw(a), this.update(), this
            },
            clear: function(a, b, c, d) {
                return void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = this.width), void 0 === d && (d = this.height), this.context.clearRect(a, b, c, d), this.dirty = !0, this
            },
            fill: function(a, b, c, d) {
                return void 0 === d && (d = 1), this.context.fillStyle = "rgba(" + a + "," + b + "," + c + "," + d + ")", this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0, this
            },
            generateTexture: function(a) {
                var b = new Image;
                b.src = this.canvas.toDataURL("image/png");
                var c = this.game.cache.addImage(a, "", b);
                return new PIXI.Texture(c.base)
            },
            resize: function(a, b) {
                return a === this.width && b === this.height || (this.width = a, this.height = b, this.canvas.width = a, this.canvas.height = b, void 0 !== this._swapCanvas && (this._swapCanvas.width = a, this._swapCanvas.height = b), this.baseTexture.width = a, this.baseTexture.height = b, this.textureFrame.width = a, this.textureFrame.height = b, this.texture.width = a, this.texture.height = b, this.texture.crop.width = a, this.texture.crop.height = b, this.update(), this.dirty = !0), this
            },
            update: function(a, b, c, d) {
                return void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = Math.max(1, this.width)), void 0 === d && (d = Math.max(1, this.height)), this.imageData = this.context.getImageData(a, b, c, d), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this
            },
            processPixelRGB: function(a, b, d, e, f, g) {
                void 0 === d && (d = 0), void 0 === e && (e = 0), void 0 === f && (f = this.width), void 0 === g && (g = this.height);
                for (var h = d + f, i = e + g, j = c.Color.createColor(), k = {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 0
                }, l = !1, m = e; m < i; m++)
                    for (var n = d; n < h; n++) c.Color.unpackPixel(this.getPixel32(n, m), j), k = a.call(b, j, n, m), k !== !1 && null !== k && void 0 !== k && (this.setPixel32(n, m, k.r, k.g, k.b, k.a, !1), l = !0);
                return l && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
            },
            processPixel: function(a, b, c, d, e, f) {
                void 0 === c && (c = 0), void 0 === d && (d = 0), void 0 === e && (e = this.width), void 0 === f && (f = this.height);
                for (var g = c + e, h = d + f, i = 0, j = 0, k = !1, l = d; l < h; l++)
                    for (var m = c; m < g; m++) i = this.getPixel32(m, l), j = a.call(b, i, m, l), j !== i && (this.pixels[l * this.width + m] = j, k = !0);
                return k && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
            },
            replaceRGB: function(a, b, d, e, f, g, h, i, j) {
                var k = 0,
                    l = 0,
                    m = this.width,
                    n = this.height,
                    o = c.Color.packPixel(a, b, d, e);
                void 0 !== j && j instanceof c.Rectangle && (k = j.x, l = j.y, m = j.width, n = j.height);
                for (var p = 0; p < n; p++)
                    for (var q = 0; q < m; q++) this.getPixel32(k + q, l + p) === o && this.setPixel32(k + q, l + p, f, g, h, i, !1);
                return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
            },
            setHSL: function(a, b, d, e) {
                var f = a || 0 === a,
                    g = b || 0 === b,
                    h = d || 0 === d;
                if (f || g || h) {
                    void 0 === e && (e = new c.Rectangle(0, 0, this.width, this.height));
                    for (var i = c.Color.createColor(), j = e.y; j < e.bottom; j++)
                        for (var k = e.x; k < e.right; k++) c.Color.unpackPixel(this.getPixel32(k, j), i, !0), f && (i.h = a), g && (i.s = b), h && (i.l = d), c.Color.HSLtoRGB(i.h, i.s, i.l, i), this.setPixel32(k, j, i.r, i.g, i.b, i.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                }
            },
            shiftHSL: function(a, b, d, e) {
                if (void 0 !== a && null !== a || (a = !1), void 0 !== b && null !== b || (b = !1), void 0 !== d && null !== d || (d = !1), a || b || d) {
                    void 0 === e && (e = new c.Rectangle(0, 0, this.width, this.height));
                    for (var f = c.Color.createColor(), g = e.y; g < e.bottom; g++)
                        for (var h = e.x; h < e.right; h++) c.Color.unpackPixel(this.getPixel32(h, g), f, !0), a && (f.h = this.game.math.wrap(f.h + a, 0, 1)), b && (f.s = this.game.math.clamp(f.s + b, 0, 1)), d && (f.l = this.game.math.clamp(f.l + d, 0, 1)), c.Color.HSLtoRGB(f.h, f.s, f.l, f), this.setPixel32(h, g, f.r, f.g, f.b, f.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                }
            },
            setPixel32: function(a, b, d, e, f, g, h) {
                return void 0 === h && (h = !0), a >= 0 && a <= this.width && b >= 0 && b <= this.height && (c.Device.LITTLE_ENDIAN ? this.pixels[b * this.width + a] = g << 24 | f << 16 | e << 8 | d : this.pixels[b * this.width + a] = d << 24 | e << 16 | f << 8 | g, h && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)), this
            },
            setPixel: function(a, b, c, d, e, f) {
                return this.setPixel32(a, b, c, d, e, 255, f)
            },
            getPixel: function(a, b, d) {
                d || (d = c.Color.createColor());
                var e = ~~(a + b * this.width);
                return e *= 4, d.r = this.data[e], d.g = this.data[++e], d.b = this.data[++e], d.a = this.data[++e], d
            },
            getPixel32: function(a, b) {
                if (a >= 0 && a <= this.width && b >= 0 && b <= this.height) return this.pixels[b * this.width + a]
            },
            getPixelRGB: function(a, b, d, e, f) {
                return c.Color.unpackPixel(this.getPixel32(a, b), d, e, f)
            },
            getPixels: function(a) {
                return this.context.getImageData(a.x, a.y, a.width, a.height)
            },
            getFirstPixel: function(a) {
                void 0 === a && (a = 0);
                var b = c.Color.createColor(),
                    d = 0,
                    e = 0,
                    f = 1,
                    g = !1;
                1 === a ? (f = -1, e = this.height) : 3 === a && (f = -1, d = this.width);
                do c.Color.unpackPixel(this.getPixel32(d, e), b), 0 === a || 1 === a ? (d++, d === this.width && (d = 0, e += f, (e >= this.height || e <= 0) && (g = !0))) : 2 !== a && 3 !== a || (e++, e === this.height && (e = 0, d += f, (d >= this.width || d <= 0) && (g = !0))); while (0 === b.a && !g);
                return b.x = d, b.y = e, b
            },
            getBounds: function(a) {
                return void 0 === a && (a = new c.Rectangle), a.x = this.getFirstPixel(2).x, a.x === this.width ? a.setTo(0, 0, 0, 0) : (a.y = this.getFirstPixel(0).y, a.width = this.getFirstPixel(3).x - a.x + 1, a.height = this.getFirstPixel(1).y - a.y + 1, a)
            },
            addToWorld: function(a, b, c, d, e, f) {
                e = e || 1, f = f || 1;
                var g = this.game.add.image(a, b, this);
                return g.anchor.set(c, d), g.scale.set(e, f), g
            },
            copy: function(a, b, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {
                if (void 0 !== a && null !== a || (a = this), (a instanceof c.RenderTexture || a instanceof PIXI.RenderTexture) && (a = a.getCanvas()), this._image = a, a instanceof c.Sprite || a instanceof c.Image || a instanceof c.Text || a instanceof PIXI.Sprite) this._pos.set(a.texture.crop.x, a.texture.crop.y), this._size.set(a.texture.crop.width, a.texture.crop.height), this._scale.set(a.scale.x, a.scale.y), this._anchor.set(a.anchor.x, a.anchor.y), this._rotate = a.rotation, this._alpha.current = a.alpha, a.texture instanceof c.RenderTexture || a.texture instanceof PIXI.RenderTexture ? this._image = a.texture.getCanvas() : this._image = a.texture.baseTexture.source, void 0 !== g && null !== g || (g = a.x), void 0 !== h && null !== h || (h = a.y), a.texture.trim && (g += a.texture.trim.x - a.anchor.x * a.texture.trim.width, h += a.texture.trim.y - a.anchor.y * a.texture.trim.height), 16777215 !== a.tint && (a.cachedTint !== a.tint && (a.cachedTint = a.tint, a.tintedTexture = PIXI.CanvasTinter.getTintedTexture(a, a.tint)), this._image = a.tintedTexture, this._pos.set(0));
                else {
                    if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, this._alpha.current = 1, a instanceof c.BitmapData) this._image = a.canvas;
                    else if ("string" == typeof a) {
                        if (a = this.game.cache.getImage(a), null === a) return;
                        this._image = a
                    }
                    this._size.set(this._image.width, this._image.height)
                } if (void 0 !== b && null !== b || (b = 0), void 0 !== d && null !== d || (d = 0), e && (this._size.x = e), f && (this._size.y = f), void 0 !== g && null !== g || (g = b), void 0 !== h && null !== h || (h = d), void 0 !== i && null !== i || (i = this._size.x), void 0 !== j && null !== j || (j = this._size.y), "number" == typeof k && (this._rotate = k), "number" == typeof l && (this._anchor.x = l), "number" == typeof m && (this._anchor.y = m), "number" == typeof n && (this._scale.x = n), "number" == typeof o && (this._scale.y = o), "number" == typeof p && (this._alpha.current = p), void 0 === q && (q = null), void 0 === r && (r = !1), !(this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y)) {
                    var s = this.context;
                    return this._alpha.prev = s.globalAlpha, s.save(), s.globalAlpha = this._alpha.current, q && (this.op = q), r && (g |= 0, h |= 0), s.translate(g, h), s.scale(this._scale.x, this._scale.y), s.rotate(this._rotate), s.drawImage(this._image, this._pos.x + b, this._pos.y + d, this._size.x, this._size.y, -i * this._anchor.x, -j * this._anchor.y, i, j), s.restore(), s.globalAlpha = this._alpha.prev, this.dirty = !0, this
                }
            },
            copyTransform: function(a, b, d) {
                if (void 0 === b && (b = null), void 0 === d && (d = !1), !a.hasOwnProperty("worldTransform") || !a.worldVisible || 0 === a.worldAlpha) return this;
                var e = a.worldTransform;
                if (this._pos.set(a.texture.crop.x, a.texture.crop.y), this._size.set(a.texture.crop.width, a.texture.crop.height), 0 === e.a || 0 === e.d || 0 === this._size.x || 0 === this._size.y) return this;
                a.texture instanceof c.RenderTexture || a.texture instanceof PIXI.RenderTexture ? this._image = a.texture.getCanvas() : this._image = a.texture.baseTexture.source;
                var f = e.tx,
                    g = e.ty;
                a.texture.trim && (f += a.texture.trim.x - a.anchor.x * a.texture.trim.width, g += a.texture.trim.y - a.anchor.y * a.texture.trim.height), 16777215 !== a.tint && (a.cachedTint !== a.tint && (a.cachedTint = a.tint, a.tintedTexture = PIXI.CanvasTinter.getTintedTexture(a, a.tint)), this._image = a.tintedTexture, this._pos.set(0)), d && (f |= 0, g |= 0);
                var h = this.context;
                return this._alpha.prev = h.globalAlpha, h.save(), h.globalAlpha = this._alpha.current, b && (this.op = b), h[this.smoothProperty] = a.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, h.setTransform(e.a, e.b, e.c, e.d, f, g), h.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * a.anchor.x, -this._size.y * a.anchor.y, this._size.x, this._size.y), h.restore(), h.globalAlpha = this._alpha.prev, this.dirty = !0, this
            },
            copyRect: function(a, b, c, d, e, f, g) {
                return this.copy(a, b.x, b.y, b.width, b.height, c, d, b.width, b.height, 0, 0, 0, 1, 1, e, f, g)
            },
            draw: function(a, b, c, d, e, f, g) {
                return this.copy(a, null, null, null, null, b, c, d, e, null, null, null, null, null, null, f, g)
            },
            drawGroup: function(a, b, c) {
                return a.total > 0 && a.forEachExists(this.drawGroupProxy, this, b, c), this
            },
            drawGroupProxy: function(a, b, d) {
                if (a.hasOwnProperty("texture") && this.copyTransform(a, b, d), a.type === c.GROUP && a.exists) this.drawGroup(a, b, d);
                else if (a.hasOwnProperty("children") && a.children.length > 0)
                    for (var e = 0; e < a.children.length; e++) a.children[e].exists && this.copyTransform(a.children[e], b, d)
            },
            drawFull: function(a, b, d) {
                if (a.worldVisible === !1 || 0 === a.worldAlpha || a.hasOwnProperty("exists") && a.exists === !1) return this;
                if (a.type !== c.GROUP && a.type !== c.EMITTER && a.type !== c.BITMAPTEXT)
                    if (a.type === c.GRAPHICS) {
                        var e = a.getBounds();
                        this.ctx.save(), this.ctx.translate(e.x, e.y), PIXI.CanvasGraphics.renderGraphics(a, this.ctx), this.ctx.restore()
                    } else this.copy(a, null, null, null, null, a.worldPosition.x, a.worldPosition.y, null, null, a.worldRotation, null, null, a.worldScale.x, a.worldScale.y, a.worldAlpha, b, d);
                if (a.children)
                    for (var f = 0; f < a.children.length; f++) this.drawFull(a.children[f], b, d);
                return this
            },
            shadow: function(a, b, c, d) {
                var e = this.context;
                return void 0 === a || null === a ? e.shadowColor = "rgba(0,0,0,0)" : (e.shadowColor = a, e.shadowBlur = b || 5, e.shadowOffsetX = c || 10, e.shadowOffsetY = d || 10), this
            },
            alphaMask: function(a, b, c, d) {
                return void 0 === d || null === d ? this.draw(b).blendSourceAtop() : this.draw(b, d.x, d.y, d.width, d.height).blendSourceAtop(), void 0 === c || null === c ? this.draw(a).blendReset() : this.draw(a, c.x, c.y, c.width, c.height).blendReset(), this
            },
            extract: function(a, b, c, d, e, f, g, h, i) {
                return void 0 === e && (e = 255), void 0 === f && (f = !1), void 0 === g && (g = b), void 0 === h && (h = c), void 0 === i && (i = d), f && a.resize(this.width, this.height), this.processPixelRGB(function(f, j, k) {
                    return f.r === b && f.g === c && f.b === d && a.setPixel32(j, k, g, h, i, e, !1), !1
                }, this), a.context.putImageData(a.imageData, 0, 0), a.dirty = !0, a
            },
            rect: function(a, b, c, d, e) {
                return "undefined" != typeof e && (this.context.fillStyle = e), this.context.fillRect(a, b, c, d), this
            },
            text: function(a, b, c, d, e, f) {
                void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = "14px Courier"), void 0 === e && (e = "rgb(255,255,255)"), void 0 === f && (f = !0);
                var g = this.context,
                    h = g.font;
                return g.font = d, f && (g.fillStyle = "rgb(0,0,0)", g.fillText(a, b + 1, c + 1)), g.fillStyle = e, g.fillText(a, b, c), g.font = h, this
            },
            circle: function(a, b, c, d) {
                var e = this.context;
                return void 0 !== d && (e.fillStyle = d), e.beginPath(), e.arc(a, b, c, 0, 2 * Math.PI, !1), e.closePath(), e.fill(), this
            },
            line: function(a, b, c, d, e, f) {
                void 0 === e && (e = "#fff"), void 0 === f && (f = 1);
                var g = this.context;
                return g.beginPath(), g.moveTo(a, b), g.lineTo(c, d), g.lineWidth = f, g.strokeStyle = e, g.stroke(), g.closePath(), this
            },
            textureLine: function(a, b, d) {
                if (void 0 === d && (d = "repeat-x"), "string" != typeof b || (b = this.game.cache.getImage(b))) {
                    var e = a.length;
                    "no-repeat" === d && e > b.width && (e = b.width);
                    var f = this.context;
                    return f.fillStyle = f.createPattern(b, d), this._circle = new c.Circle(a.start.x, a.start.y, b.height), this._circle.circumferencePoint(a.angle - 1.5707963267948966, !1, this._pos), f.save(), f.translate(this._pos.x, this._pos.y), f.rotate(a.angle), f.fillRect(0, 0, e, b.height), f.restore(), this.dirty = !0, this
                }
            },
            render: function() {
                return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1), this
            },
            destroy: function() {
                this.frameData.destroy(), this.texture.destroy(!0), PIXI.CanvasPool.remove(this)
            },
            blendReset: function() {
                return this.op = "source-over", this
            },
            blendSourceOver: function() {
                return this.op = "source-over", this
            },
            blendSourceIn: function() {
                return this.op = "source-in", this
            },
            blendSourceOut: function() {
                return this.op = "source-out", this
            },
            blendSourceAtop: function() {
                return this.op = "source-atop", this
            },
            blendDestinationOver: function() {
                return this.op = "destination-over", this
            },
            blendDestinationIn: function() {
                return this.op = "destination-in", this
            },
            blendDestinationOut: function() {
                return this.op = "destination-out", this
            },
            blendDestinationAtop: function() {
                return this.op = "destination-atop", this
            },
            blendXor: function() {
                return this.op = "xor", this
            },
            blendAdd: function() {
                return this.op = "lighter", this
            },
            blendMultiply: function() {
                return this.op = "multiply", this
            },
            blendScreen: function() {
                return this.op = "screen", this
            },
            blendOverlay: function() {
                return this.op = "overlay", this
            },
            blendDarken: function() {
                return this.op = "darken", this
            },
            blendLighten: function() {
                return this.op = "lighten", this
            },
            blendColorDodge: function() {
                return this.op = "color-dodge", this
            },
            blendColorBurn: function() {
                return this.op = "color-burn", this
            },
            blendHardLight: function() {
                return this.op = "hard-light", this
            },
            blendSoftLight: function() {
                return this.op = "soft-light", this
            },
            blendDifference: function() {
                return this.op = "difference", this
            },
            blendExclusion: function() {
                return this.op = "exclusion", this
            },
            blendHue: function() {
                return this.op = "hue", this
            },
            blendSaturation: function() {
                return this.op = "saturation", this
            },
            blendColor: function() {
                return this.op = "color", this
            },
            blendLuminosity: function() {
                return this.op = "luminosity", this
            }
        }, Object.defineProperty(c.BitmapData.prototype, "smoothed", {
            get: function() {
                c.Canvas.getSmoothingEnabled(this.context)
            },
            set: function(a) {
                c.Canvas.setSmoothingEnabled(this.context, a)
            }
        }), Object.defineProperty(c.BitmapData.prototype, "op", {
            get: function() {
                return this.context.globalCompositeOperation
            },
            set: function(a) {
                this.context.globalCompositeOperation = a
            }
        }), c.BitmapData.getTransform = function(a, b, c, d, e, f) {
            return "number" != typeof a && (a = 0), "number" != typeof b && (b = 0), "number" != typeof c && (c = 1), "number" != typeof d && (d = 1), "number" != typeof e && (e = 0), "number" != typeof f && (f = 0), {
                sx: c,
                sy: d,
                scaleX: c,
                scaleY: d,
                skewX: e,
                skewY: f,
                translateX: a,
                translateY: b,
                tx: a,
                ty: b
            }
        }, c.BitmapData.prototype.constructor = c.BitmapData, PIXI.Graphics = function() {
            PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], this.isMask = !1, this.boundsPadding = 0, this._localBounds = new PIXI.Rectangle(0, 0, 1, 1), this.dirty = !0, this._boundsDirty = !1, this.webGLDirty = !1, this.cachedSpriteDirty = !1
        }, PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), PIXI.Graphics.prototype.constructor = PIXI.Graphics, PIXI.Graphics.prototype.lineStyle = function(a, b, c) {
            return this.lineWidth = a || 0, this.lineColor = b || 0, this.lineAlpha = void 0 === c ? 1 : c, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this
        }, PIXI.Graphics.prototype.moveTo = function(a, b) {
            return this.drawShape(new PIXI.Polygon([a, b])), this
        }, PIXI.Graphics.prototype.lineTo = function(a, b) {
            return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(a, b), this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.quadraticCurveTo = function(a, b, c, d) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            var e, f, g = 20,
                h = this.currentPath.shape.points;
            0 === h.length && this.moveTo(0, 0);
            for (var i = h[h.length - 2], j = h[h.length - 1], k = 0, l = 1; l <= g; ++l) k = l / g, e = i + (a - i) * k, f = j + (b - j) * k, h.push(e + (a + (c - a) * k - e) * k, f + (b + (d - b) * k - f) * k);
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.bezierCurveTo = function(a, b, c, d, e, f) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            for (var g, h, i, j, k, l = 20, m = this.currentPath.shape.points, n = m[m.length - 2], o = m[m.length - 1], p = 0, q = 1; q <= l; ++q) p = q / l, g = 1 - p, h = g * g, i = h * g, j = p * p, k = j * p, m.push(i * n + 3 * h * p * a + 3 * g * j * c + k * e, i * o + 3 * h * p * b + 3 * g * j * d + k * f);
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.arcTo = function(a, b, c, d, e) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(a, b) : this.moveTo(a, b);
            var f = this.currentPath.shape.points,
                g = f[f.length - 2],
                h = f[f.length - 1],
                i = h - b,
                j = g - a,
                k = d - b,
                l = c - a,
                m = Math.abs(i * l - j * k);
            if (m < 1e-8 || 0 === e) f[f.length - 2] === a && f[f.length - 1] === b || f.push(a, b);
            else {
                var n = i * i + j * j,
                    o = k * k + l * l,
                    p = i * k + j * l,
                    q = e * Math.sqrt(n) / m,
                    r = e * Math.sqrt(o) / m,
                    s = q * p / n,
                    t = r * p / o,
                    u = q * l + r * j,
                    v = q * k + r * i,
                    w = j * (r + s),
                    x = i * (r + s),
                    y = l * (q + t),
                    z = k * (q + t),
                    A = Math.atan2(x - v, w - u),
                    B = Math.atan2(z - v, y - u);
                this.arc(u + a, v + b, e, A, B, j * k > l * i)
            }
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.arc = function(a, b, c, d, e, f, g) {
            if (d === e) return this;
            void 0 === f && (f = !1), void 0 === g && (g = 40), !f && e <= d ? e += 2 * Math.PI : f && d <= e && (d += 2 * Math.PI);
            var h = f ? (d - e) * -1 : e - d,
                i = Math.ceil(Math.abs(h) / (2 * Math.PI)) * g;
            if (0 === h) return this;
            var j = a + Math.cos(d) * c,
                k = b + Math.sin(d) * c;
            f && this.filling ? this.moveTo(a, b) : this.moveTo(j, k);
            for (var l = this.currentPath.shape.points, m = h / (2 * i), n = 2 * m, o = Math.cos(m), p = Math.sin(m), q = i - 1, r = q % 1 / q, s = 0; s <= q; s++) {
                var t = s + r * s,
                    u = m + d + n * t,
                    v = Math.cos(u),
                    w = -Math.sin(u);
                l.push((o * v + p * w) * c + a, (o * -w + p * v) * c + b)
            }
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.beginFill = function(a, b) {
            return this.filling = !0, this.fillColor = a || 0, this.fillAlpha = void 0 === b ? 1 : b, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this
        }, PIXI.Graphics.prototype.endFill = function() {
            return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this
        }, PIXI.Graphics.prototype.drawRect = function(a, b, c, d) {
            return this.drawShape(new PIXI.Rectangle(a, b, c, d)), this
        }, PIXI.Graphics.prototype.drawRoundedRect = function(a, b, c, d, e) {
            return this.drawShape(new PIXI.RoundedRectangle(a, b, c, d, e)), this
        }, PIXI.Graphics.prototype.drawCircle = function(a, b, c) {
            return this.drawShape(new PIXI.Circle(a, b, c)), this
        }, PIXI.Graphics.prototype.drawEllipse = function(a, b, c, d) {
            return this.drawShape(new PIXI.Ellipse(a, b, c, d)), this
        }, PIXI.Graphics.prototype.drawPolygon = function(a) {
            (a instanceof c.Polygon || a instanceof PIXI.Polygon) && (a = a.points);
            var b = a;
            if (!Array.isArray(b)) {
                b = new Array(arguments.length);
                for (var d = 0; d < b.length; ++d) b[d] = arguments[d]
            }
            return this.drawShape(new c.Polygon(b)), this
        }, PIXI.Graphics.prototype.clear = function() {
            return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this._boundsDirty = !0, this.clearDirty = !0, this.graphicsData = [], this.updateLocalBounds(), this
        }, PIXI.Graphics.prototype.generateTexture = function(a, b, c) {
            void 0 === a && (a = 1), void 0 === b && (b = PIXI.scaleModes.DEFAULT), void 0 === c && (c = 0);
            var d = this.getBounds();
            d.width += c, d.height += c;
            var e = new PIXI.CanvasBuffer(d.width * a, d.height * a),
                f = PIXI.Texture.fromCanvas(e.canvas, b);
            return f.baseTexture.resolution = a, e.context.scale(a, a), e.context.translate(-d.x, -d.y), PIXI.CanvasGraphics.renderGraphics(this, e.context), f
        }, PIXI.Graphics.prototype._renderWebGL = function(a) {
            if (this.visible !== !1 && 0 !== this.alpha && this.isMask !== !0) {
                if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, a);
                if (a.spriteBatch.stop(), a.blendModeManager.setBlendMode(this.blendMode), this._mask && a.maskManager.pushMask(this._mask, a), this._filters && a.filterManager.pushFilter(this._filterBlock), this.blendMode !== a.spriteBatch.currentBlendMode) {
                    a.spriteBatch.currentBlendMode = this.blendMode;
                    var b = PIXI.blendModesWebGL[a.spriteBatch.currentBlendMode];
                    a.spriteBatch.gl.blendFunc(b[0], b[1])
                }
                if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, a), this.children.length) {
                    a.spriteBatch.start();
                    for (var c = 0; c < this.children.length; c++) this.children[c]._renderWebGL(a);
                    a.spriteBatch.stop()
                }
                this._filters && a.filterManager.popFilter(), this._mask && a.maskManager.popMask(this.mask, a), a.drawCount++, a.spriteBatch.start()
            }
        }, PIXI.Graphics.prototype._renderCanvas = function(a) {
            if (this.visible !== !1 && 0 !== this.alpha && this.isMask !== !0) {
                if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, a);
                var b = a.context,
                    c = this.worldTransform;
                this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, b.globalCompositeOperation = PIXI.blendModesCanvas[a.currentBlendMode]), this._mask && a.maskManager.pushMask(this._mask, a);
                var d = a.resolution,
                    e = c.tx * a.resolution + a.shakeX,
                    f = c.ty * a.resolution + a.shakeY;
                b.setTransform(c.a * d, c.b * d, c.c * d, c.d * d, e, f), PIXI.CanvasGraphics.renderGraphics(this, b);
                for (var g = 0; g < this.children.length; g++) this.children[g]._renderCanvas(a);
                this._mask && a.maskManager.popMask(a)
            }
        }, PIXI.Graphics.prototype.getBounds = function(a) {
            if (!this._currentBounds) {
                if (!this.renderable) return PIXI.EmptyRectangle;
                this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, this.dirty = !1);
                var b = this._localBounds,
                    c = b.x,
                    d = b.width + b.x,
                    e = b.y,
                    f = b.height + b.y,
                    g = a || this.worldTransform,
                    h = g.a,
                    i = g.b,
                    j = g.c,
                    k = g.d,
                    l = g.tx,
                    m = g.ty,
                    n = h * d + j * f + l,
                    o = k * f + i * d + m,
                    p = h * c + j * f + l,
                    q = k * f + i * c + m,
                    r = h * c + j * e + l,
                    s = k * e + i * c + m,
                    t = h * d + j * e + l,
                    u = k * e + i * d + m,
                    v = n,
                    w = o,
                    x = n,
                    y = o;
                x = p < x ? p : x, x = r < x ? r : x, x = t < x ? t : x, y = q < y ? q : y, y = s < y ? s : y, y = u < y ? u : y, v = p > v ? p : v, v = r > v ? r : v, v = t > v ? t : v, w = q > w ? q : w, w = s > w ? s : w, w = u > w ? u : w, this._bounds.x = x, this._bounds.width = v - x, this._bounds.y = y, this._bounds.height = w - y, this._currentBounds = this._bounds
            }
            return this._currentBounds
        }, PIXI.Graphics.prototype.getLocalBounds = function() {
            var a = this.worldTransform;
            this.worldTransform = PIXI.identityMatrix;
            for (var b = 0; b < this.children.length; b++) this.children[b].updateTransform();
            var c = this.getBounds();
            for (this.worldTransform = a, b = 0; b < this.children.length; b++) this.children[b].updateTransform();
            return c
        }, PIXI.Graphics.prototype.containsPoint = function(a) {
            this.worldTransform.applyInverse(a, tempPoint);
            for (var b = this.graphicsData, c = 0; c < b.length; c++) {
                var d = b[c];
                if (d.fill && d.shape && d.shape.contains(tempPoint.x, tempPoint.y)) return !0
            }
            return !1
        }, PIXI.Graphics.prototype.updateLocalBounds = function() {
            var a = 1 / 0,
                b = -(1 / 0),
                d = 1 / 0,
                e = -(1 / 0);
            if (this.graphicsData.length)
                for (var f, g, h, i, j, k, l = 0; l < this.graphicsData.length; l++) {
                    var m = this.graphicsData[l],
                        n = m.type,
                        o = m.lineWidth;
                    if (f = m.shape, n === PIXI.Graphics.RECT || n === PIXI.Graphics.RREC) h = f.x - o / 2, i = f.y - o / 2, j = f.width + o, k = f.height + o, a = h < a ? h : a, b = h + j > b ? h + j : b, d = i < d ? i : d, e = i + k > e ? i + k : e;
                    else if (n === PIXI.Graphics.CIRC) h = f.x, i = f.y, j = f.radius + o / 2, k = f.radius + o / 2, a = h - j < a ? h - j : a, b = h + j > b ? h + j : b, d = i - k < d ? i - k : d, e = i + k > e ? i + k : e;
                    else if (n === PIXI.Graphics.ELIP) h = f.x, i = f.y, j = f.width + o / 2, k = f.height + o / 2, a = h - j < a ? h - j : a, b = h + j > b ? h + j : b, d = i - k < d ? i - k : d, e = i + k > e ? i + k : e;
                    else {
                        g = f.points;
                        for (var p = 0; p < g.length; p++) g[p] instanceof c.Point ? (h = g[p].x, i = g[p].y) : (h = g[p], i = g[p + 1], p < g.length - 1 && p++), a = h - o < a ? h - o : a, b = h + o > b ? h + o : b, d = i - o < d ? i - o : d, e = i + o > e ? i + o : e
                    }
                } else a = 0, b = 0, d = 0, e = 0;
            var q = this.boundsPadding;
            this._localBounds.x = a - q, this._localBounds.width = b - a + 2 * q, this._localBounds.y = d - q, this._localBounds.height = e - d + 2 * q
        }, PIXI.Graphics.prototype._generateCachedSprite = function() {
            var a = this.getLocalBounds();
            if (this._cachedSprite) this._cachedSprite.buffer.resize(a.width, a.height);
            else {
                var b = new PIXI.CanvasBuffer(a.width, a.height),
                    c = PIXI.Texture.fromCanvas(b.canvas);
                this._cachedSprite = new PIXI.Sprite(c), this._cachedSprite.buffer = b, this._cachedSprite.worldTransform = this.worldTransform
            }
            this._cachedSprite.anchor.x = -(a.x / a.width), this._cachedSprite.anchor.y = -(a.y / a.height), this._cachedSprite.buffer.context.translate(-a.x, -a.y), this.worldAlpha = 1, PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha
        }, PIXI.Graphics.prototype.updateCachedSpriteTexture = function() {
            var a = this._cachedSprite,
                b = a.texture,
                c = a.buffer.canvas;
            b.baseTexture.width = c.width, b.baseTexture.height = c.height, b.crop.width = b.frame.width = c.width, b.crop.height = b.frame.height = c.height, a._width = c.width, a._height = c.height, b.baseTexture.dirty()
        }, PIXI.Graphics.prototype.destroyCachedSprite = function() {
            this._cachedSprite.texture.destroy(!0), this._cachedSprite = null
        }, PIXI.Graphics.prototype.drawShape = function(a) {
            this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null, a instanceof c.Polygon && (a = a.clone(), a.flatten());
            var b = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, a);
            return this.graphicsData.push(b), b.type === PIXI.Graphics.POLY && (b.shape.closed = this.filling, this.currentPath = b), this.dirty = !0, this._boundsDirty = !0, b
        }, Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
            get: function() {
                return this._cacheAsBitmap
            },
            set: function(a) {
                this._cacheAsBitmap = a, this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(), this.dirty = !0, this.webGLDirty = !0
            }
        }), PIXI.GraphicsData = function(a, b, c, d, e, f, g) {
            this.lineWidth = a, this.lineColor = b, this.lineAlpha = c, this._lineTint = b, this.fillColor = d, this.fillAlpha = e, this._fillTint = d, this.fill = f, this.shape = g, this.type = g.type
        }, PIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData, PIXI.GraphicsData.prototype.clone = function() {
            return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape)
        }, PIXI.EarCut = {}, PIXI.EarCut.Triangulate = function(a, b, c) {
            c = c || 2;
            var d = b && b.length,
                e = d ? b[0] * c : a.length,
                f = PIXI.EarCut.linkedList(a, 0, e, c, !0),
                g = [];
            if (!f) return g;
            var h, i, j, k, l, m, n;
            if (d && (f = PIXI.EarCut.eliminateHoles(a, b, f, c)), a.length > 80 * c) {
                h = j = a[0], i = k = a[1];
                for (var o = c; o < e; o += c) l = a[o], m = a[o + 1], l < h && (h = l), m < i && (i = m), l > j && (j = l), m > k && (k = m);
                n = Math.max(j - h, k - i)
            }
            return PIXI.EarCut.earcutLinked(f, g, c, h, i, n), g
        }, PIXI.EarCut.linkedList = function(a, b, c, d, e) {
            var f, g, h, i = 0;
            for (f = b, g = c - d; f < c; f += d) i += (a[g] - a[f]) * (a[f + 1] + a[g + 1]), g = f;
            if (e === i > 0)
                for (f = b; f < c; f += d) h = PIXI.EarCut.insertNode(f, a[f], a[f + 1], h);
            else
                for (f = c - d; f >= b; f -= d) h = PIXI.EarCut.insertNode(f, a[f], a[f + 1], h);
            return h
        }, PIXI.EarCut.filterPoints = function(a, b) {
            if (!a) return a;
            b || (b = a);
            var c, d = a;
            do
                if (c = !1, d.steiner || !PIXI.EarCut.equals(d, d.next) && 0 !== PIXI.EarCut.area(d.prev, d, d.next)) d = d.next;
                else {
                    if (PIXI.EarCut.removeNode(d), d = b = d.prev, d === d.next) return null;
                    c = !0
                }
            while (c || d !== b);
            return b
        }, PIXI.EarCut.earcutLinked = function(a, b, c, d, e, f, g) {
            if (a) {
                !g && f && PIXI.EarCut.indexCurve(a, d, e, f);
                for (var h, i, j = a; a.prev !== a.next;)
                    if (h = a.prev, i = a.next, f ? PIXI.EarCut.isEarHashed(a, d, e, f) : PIXI.EarCut.isEar(a)) b.push(h.i / c), b.push(a.i / c), b.push(i.i / c), PIXI.EarCut.removeNode(a), a = i.next, j = i.next;
                    else if (a = i, a === j) {
                    g ? 1 === g ? (a = PIXI.EarCut.cureLocalIntersections(a, b, c), PIXI.EarCut.earcutLinked(a, b, c, d, e, f, 2)) : 2 === g && PIXI.EarCut.splitEarcut(a, b, c, d, e, f) : PIXI.EarCut.earcutLinked(PIXI.EarCut.filterPoints(a), b, c, d, e, f, 1);
                    break
                }
            }
        }, PIXI.EarCut.isEar = function(a) {
            var b = a.prev,
                c = a,
                d = a.next;
            if (PIXI.EarCut.area(b, c, d) >= 0) return !1;
            for (var e = a.next.next; e !== a.prev;) {
                if (PIXI.EarCut.pointInTriangle(b.x, b.y, c.x, c.y, d.x, d.y, e.x, e.y) && PIXI.EarCut.area(e.prev, e, e.next) >= 0) return !1;
                e = e.next
            }
            return !0
        }, PIXI.EarCut.isEarHashed = function(a, b, c, d) {
            var e = a.prev,
                f = a,
                g = a.next;
            if (PIXI.EarCut.area(e, f, g) >= 0) return !1;
            for (var h = e.x < f.x ? e.x < g.x ? e.x : g.x : f.x < g.x ? f.x : g.x, i = e.y < f.y ? e.y < g.y ? e.y : g.y : f.y < g.y ? f.y : g.y, j = e.x > f.x ? e.x > g.x ? e.x : g.x : f.x > g.x ? f.x : g.x, k = e.y > f.y ? e.y > g.y ? e.y : g.y : f.y > g.y ? f.y : g.y, l = PIXI.EarCut.zOrder(h, i, b, c, d), m = PIXI.EarCut.zOrder(j, k, b, c, d), n = a.nextZ; n && n.z <= m;) {
                if (n !== a.prev && n !== a.next && PIXI.EarCut.pointInTriangle(e.x, e.y, f.x, f.y, g.x, g.y, n.x, n.y) && PIXI.EarCut.area(n.prev, n, n.next) >= 0) return !1;
                n = n.nextZ
            }
            for (n = a.prevZ; n && n.z >= l;) {
                if (n !== a.prev && n !== a.next && PIXI.EarCut.pointInTriangle(e.x, e.y, f.x, f.y, g.x, g.y, n.x, n.y) && PIXI.EarCut.area(n.prev, n, n.next) >= 0) return !1;
                n = n.prevZ
            }
            return !0
        }, PIXI.EarCut.cureLocalIntersections = function(a, b, c) {
            var d = a;
            do {
                var e = d.prev,
                    f = d.next.next;
                PIXI.EarCut.intersects(e, d, d.next, f) && PIXI.EarCut.locallyInside(e, f) && PIXI.EarCut.locallyInside(f, e) && (b.push(e.i / c), b.push(d.i / c), b.push(f.i / c), PIXI.EarCut.removeNode(d), PIXI.EarCut.removeNode(d.next), d = a = f), d = d.next
            } while (d !== a);
            return d
        }, PIXI.EarCut.splitEarcut = function(a, b, c, d, e, f) {
            var g = a;
            do {
                for (var h = g.next.next; h !== g.prev;) {
                    if (g.i !== h.i && PIXI.EarCut.isValidDiagonal(g, h)) {
                        var i = PIXI.EarCut.splitPolygon(g, h);
                        return g = PIXI.EarCut.filterPoints(g, g.next), i = PIXI.EarCut.filterPoints(i, i.next), PIXI.EarCut.earcutLinked(g, b, c, d, e, f), void PIXI.EarCut.earcutLinked(i, b, c, d, e, f)
                    }
                    h = h.next
                }
                g = g.next
            } while (g !== a)
        }, PIXI.EarCut.eliminateHoles = function(a, b, c, d) {
            var e, f, g, h, i, j = [];
            for (e = 0, f = b.length; e < f; e++) g = b[e] * d, h = e < f - 1 ? b[e + 1] * d : a.length, i = PIXI.EarCut.linkedList(a, g, h, d, !1), i === i.next && (i.steiner = !0), j.push(PIXI.EarCut.getLeftmost(i));
            for (j.sort(compareX), e = 0; e < j.length; e++) PIXI.EarCut.eliminateHole(j[e], c), c = PIXI.EarCut.filterPoints(c, c.next);
            return c
        }, PIXI.EarCut.compareX = function(a, b) {
            return a.x - b.x
        }, PIXI.EarCut.eliminateHole = function(a, b) {
            if (b = PIXI.EarCut.findHoleBridge(a, b)) {
                var c = PIXI.EarCut.splitPolygon(b, a);
                PIXI.EarCut.filterPoints(c, c.next)
            }
        }, PIXI.EarCut.findHoleBridge = function(a, b) {
            var c, d = b,
                e = a.x,
                f = a.y,
                g = -(1 / 0);
            do {
                if (f <= d.y && f >= d.next.y) {
                    var h = d.x + (f - d.y) * (d.next.x - d.x) / (d.next.y - d.y);
                    h <= e && h > g && (g = h, c = d.x < d.next.x ? d : d.next)
                }
                d = d.next
            } while (d !== b);
            if (!c) return null;
            if (a.x === c.x) return c.prev;
            var i, j = c,
                k = 1 / 0;
            for (d = c.next; d !== j;) e >= d.x && d.x >= c.x && PIXI.EarCut.pointInTriangle(f < c.y ? e : g, f, c.x, c.y, f < c.y ? g : e, f, d.x, d.y) && (i = Math.abs(f - d.y) / (e - d.x), (i < k || i === k && d.x > c.x) && PIXI.EarCut.locallyInside(d, a) && (c = d, k = i)), d = d.next;
            return c
        }, PIXI.EarCut.indexCurve = function(a, b, c, d) {
            var e = a;
            do null === e.z && (e.z = PIXI.EarCut.zOrder(e.x, e.y, b, c, d)), e.prevZ = e.prev, e.nextZ = e.next, e = e.next; while (e !== a);
            e.prevZ.nextZ = null, e.prevZ = null, PIXI.EarCut.sortLinked(e)
        }, PIXI.EarCut.sortLinked = function(a) {
            var b, c, d, e, f, g, h, i, j = 1;
            do {
                for (c = a, a = null, f = null, g = 0; c;) {
                    for (g++, d = c, h = 0, b = 0; b < j && (h++, d = d.nextZ); b++);
                    for (i = j; h > 0 || i > 0 && d;) 0 === h ? (e = d, d = d.nextZ, i--) : 0 !== i && d ? c.z <= d.z ? (e = c, c = c.nextZ, h--) : (e = d, d = d.nextZ, i--) : (e = c, c = c.nextZ, h--), f ? f.nextZ = e : a = e, e.prevZ = f, f = e;
                    c = d
                }
                f.nextZ = null, j *= 2
            } while (g > 1);
            return a
        }, PIXI.EarCut.zOrder = function(a, b, c, d, e) {
            return a = 32767 * (a - c) / e, b = 32767 * (b - d) / e, a = 16711935 & (a | a << 8), a = 252645135 & (a | a << 4), a = 858993459 & (a | a << 2), a = 1431655765 & (a | a << 1), b = 16711935 & (b | b << 8), b = 252645135 & (b | b << 4), b = 858993459 & (b | b << 2), b = 1431655765 & (b | b << 1), a | b << 1
        }, PIXI.EarCut.getLeftmost = function(a) {
            var b = a,
                c = a;
            do b.x < c.x && (c = b), b = b.next; while (b !== a);
            return c
        }, PIXI.EarCut.pointInTriangle = function(a, b, c, d, e, f, g, h) {
            return (e - g) * (b - h) - (a - g) * (f - h) >= 0 && (a - g) * (d - h) - (c - g) * (b - h) >= 0 && (c - g) * (f - h) - (e - g) * (d - h) >= 0
        }, PIXI.EarCut.isValidDiagonal = function(a, b) {
            return PIXI.EarCut.equals(a, b) || a.next.i !== b.i && a.prev.i !== b.i && !PIXI.EarCut.intersectsPolygon(a, b) && PIXI.EarCut.locallyInside(a, b) && PIXI.EarCut.locallyInside(b, a) && PIXI.EarCut.middleInside(a, b)
        }, PIXI.EarCut.area = function(a, b, c) {
            return (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y)
        }, PIXI.EarCut.equals = function(a, b) {
            return a.x === b.x && a.y === b.y
        }, PIXI.EarCut.intersects = function(a, b, c, d) {
            return PIXI.EarCut.area(a, b, c) > 0 != PIXI.EarCut.area(a, b, d) > 0 && PIXI.EarCut.area(c, d, a) > 0 != PIXI.EarCut.area(c, d, b) > 0
        }, PIXI.EarCut.intersectsPolygon = function(a, b) {
            var c = a;
            do {
                if (c.i !== a.i && c.next.i !== a.i && c.i !== b.i && c.next.i !== b.i && PIXI.EarCut.intersects(c, c.next, a, b)) return !0;
                c = c.next
            } while (c !== a);
            return !1
        }, PIXI.EarCut.locallyInside = function(a, b) {
            return PIXI.EarCut.area(a.prev, a, a.next) < 0 ? PIXI.EarCut.area(a, b, a.next) >= 0 && PIXI.EarCut.area(a, a.prev, b) >= 0 : PIXI.EarCut.area(a, b, a.prev) < 0 || PIXI.EarCut.area(a, a.next, b) < 0
        }, PIXI.EarCut.middleInside = function(a, b) {
            var c = a,
                d = !1,
                e = (a.x + b.x) / 2,
                f = (a.y + b.y) / 2;
            do c.y > f != c.next.y > f && e < (c.next.x - c.x) * (f - c.y) / (c.next.y - c.y) + c.x && (d = !d), c = c.next; while (c !== a);
            return d
        }, PIXI.EarCut.splitPolygon = function(a, b) {
            var c = new PIXI.EarCut.Node(a.i, a.x, a.y),
                d = new PIXI.EarCut.Node(b.i, b.x, b.y),
                e = a.next,
                f = b.prev;
            return a.next = b, b.prev = a, c.next = e, e.prev = c, d.next = c, c.prev = d, f.next = d, d.prev = f, d
        }, PIXI.EarCut.insertNode = function(a, b, c, d) {
            var e = new PIXI.EarCut.Node(a, b, c);
            return d ? (e.next = d.next, e.prev = d, d.next.prev = e, d.next = e) : (e.prev = e, e.next = e), e
        }, PIXI.EarCut.removeNode = function(a) {
            a.next.prev = a.prev, a.prev.next = a.next, a.prevZ && (a.prevZ.nextZ = a.nextZ), a.nextZ && (a.nextZ.prevZ = a.prevZ)
        }, PIXI.EarCut.Node = function(a, b, c) {
            this.i = a, this.x = b, this.y = c, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }, PIXI.WebGLGraphics = function() {}, PIXI.WebGLGraphics.stencilBufferLimit = 6, PIXI.WebGLGraphics.renderGraphics = function(a, b) {
            var c, d = b.gl,
                e = b.projection,
                f = b.offset,
                g = b.shaderManager.primitiveShader;
            a.dirty && PIXI.WebGLGraphics.updateGraphics(a, d);
            for (var h = a._webGL[d.id], i = 0; i < h.data.length; i++) 1 === h.data[i].mode ? (c = h.data[i], b.stencilManager.pushStencil(a, c, b), d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (c.indices.length - 4)), b.stencilManager.popStencil(a, c, b)) : (c = h.data[i], b.shaderManager.setShader(g), g = b.shaderManager.primitiveShader, d.uniformMatrix3fv(g.translationMatrix, !1, a.worldTransform.toArray(!0)), d.uniform1f(g.flipY, 1), d.uniform2f(g.projectionVector, e.x, -e.y), d.uniform2f(g.offsetVector, -f.x, -f.y), d.uniform3fv(g.tintColor, PIXI.hex2rgb(a.tint)), d.uniform1f(g.alpha, a.worldAlpha), d.bindBuffer(d.ARRAY_BUFFER, c.buffer), d.vertexAttribPointer(g.aVertexPosition, 2, d.FLOAT, !1, 24, 0), d.vertexAttribPointer(g.colorAttribute, 4, d.FLOAT, !1, 24, 8), d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, c.indexBuffer), d.drawElements(d.TRIANGLE_STRIP, c.indices.length, d.UNSIGNED_SHORT, 0))
        }, PIXI.WebGLGraphics.updateGraphics = function(a, b) {
            var c = a._webGL[b.id];
            c || (c = a._webGL[b.id] = {
                lastIndex: 0,
                data: [],
                gl: b
            }), a.dirty = !1;
            var d;
            if (a.clearDirty) {
                for (a.clearDirty = !1, d = 0; d < c.data.length; d++) {
                    var e = c.data[d];
                    e.reset(), PIXI.WebGLGraphics.graphicsDataPool.push(e)
                }
                c.data = [], c.lastIndex = 0
            }
            var f;
            for (d = c.lastIndex; d < a.graphicsData.length; d++) {
                var g = a.graphicsData[d];
                if (g.type === PIXI.Graphics.POLY) {
                    if (g.points = g.shape.points.slice(), g.shape.closed && (g.points[0] === g.points[g.points.length - 2] && g.points[1] === g.points[g.points.length - 1] || g.points.push(g.points[0], g.points[1])), g.fill && g.points.length >= PIXI.WebGLGraphics.stencilBufferLimit)
                        if (g.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit) {
                            f = PIXI.WebGLGraphics.switchMode(c, 0);
                            var h = PIXI.WebGLGraphics.buildPoly(g, f);
                            h || (f = PIXI.WebGLGraphics.switchMode(c, 1), PIXI.WebGLGraphics.buildComplexPoly(g, f))
                        } else f = PIXI.WebGLGraphics.switchMode(c, 1), PIXI.WebGLGraphics.buildComplexPoly(g, f);
                    g.lineWidth > 0 && (f = PIXI.WebGLGraphics.switchMode(c, 0), PIXI.WebGLGraphics.buildLine(g, f))
                } else f = PIXI.WebGLGraphics.switchMode(c, 0), g.type === PIXI.Graphics.RECT ? PIXI.WebGLGraphics.buildRectangle(g, f) : g.type === PIXI.Graphics.CIRC || g.type === PIXI.Graphics.ELIP ? PIXI.WebGLGraphics.buildCircle(g, f) : g.type === PIXI.Graphics.RREC && PIXI.WebGLGraphics.buildRoundedRectangle(g, f);
                c.lastIndex++
            }
            for (d = 0; d < c.data.length; d++) f = c.data[d], f.dirty && f.upload()
        }, PIXI.WebGLGraphics.switchMode = function(a, b) {
            var c;
            return a.data.length ? (c = a.data[a.data.length - 1], c.mode === b && 1 !== b || (c = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(a.gl), c.mode = b, a.data.push(c))) : (c = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(a.gl), c.mode = b, a.data.push(c)), c.dirty = !0, c
        }, PIXI.WebGLGraphics.buildRectangle = function(a, b) {
            var c = a.shape,
                d = c.x,
                e = c.y,
                f = c.width,
                g = c.height;
            if (a.fill) {
                var h = PIXI.hex2rgb(a.fillColor),
                    i = a.fillAlpha,
                    j = h[0] * i,
                    k = h[1] * i,
                    l = h[2] * i,
                    m = b.points,
                    n = b.indices,
                    o = m.length / 6;
                m.push(d, e), m.push(j, k, l, i), m.push(d + f, e), m.push(j, k, l, i), m.push(d, e + g), m.push(j, k, l, i), m.push(d + f, e + g), m.push(j, k, l, i), n.push(o, o, o + 1, o + 2, o + 3, o + 3)
            }
            if (a.lineWidth) {
                var p = a.points;
                a.points = [d, e, d + f, e, d + f, e + g, d, e + g, d, e], PIXI.WebGLGraphics.buildLine(a, b), a.points = p
            }
        }, PIXI.WebGLGraphics.buildRoundedRectangle = function(a, b) {
            var c = a.shape,
                d = c.x,
                e = c.y,
                f = c.width,
                g = c.height,
                h = c.radius,
                i = [];
            if (i.push(d, e + h), i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d, e + g - h, d, e + g, d + h, e + g)), i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d + f - h, e + g, d + f, e + g, d + f, e + g - h)), i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d + f, e + h, d + f, e, d + f - h, e)), i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d + h, e, d, e, d, e + h)), a.fill) {
                var j = PIXI.hex2rgb(a.fillColor),
                    k = a.fillAlpha,
                    l = j[0] * k,
                    m = j[1] * k,
                    n = j[2] * k,
                    o = b.points,
                    p = b.indices,
                    q = o.length / 6,
                    r = PIXI.EarCut.Triangulate(i, null, 2),
                    s = 0;
                for (s = 0; s < r.length; s += 3) p.push(r[s] + q), p.push(r[s] + q), p.push(r[s + 1] + q), p.push(r[s + 2] + q), p.push(r[s + 2] + q);
                for (s = 0; s < i.length; s++) o.push(i[s], i[++s], l, m, n, k)
            }
            if (a.lineWidth) {
                var t = a.points;
                a.points = i, PIXI.WebGLGraphics.buildLine(a, b), a.points = t
            }
        }, PIXI.WebGLGraphics.quadraticBezierCurve = function(a, b, c, d, e, f) {
            function g(a, b, c) {
                var d = b - a;
                return a + d * c
            }
            for (var h, i, j, k, l, m, n = 20, o = [], p = 0, q = 0; q <= n; q++) p = q / n, h = g(a, c, p), i = g(b, d, p), j = g(c, e, p), k = g(d, f, p), l = g(h, j, p), m = g(i, k, p), o.push(l, m);
            return o
        }, PIXI.WebGLGraphics.buildCircle = function(a, b) {
            var c, d, e = a.shape,
                f = e.x,
                g = e.y;
            a.type === PIXI.Graphics.CIRC ? (c = e.radius, d = e.radius) : (c = e.width, d = e.height);
            var h = 40,
                i = 2 * Math.PI / h,
                j = 0;
            if (a.fill) {
                var k = PIXI.hex2rgb(a.fillColor),
                    l = a.fillAlpha,
                    m = k[0] * l,
                    n = k[1] * l,
                    o = k[2] * l,
                    p = b.points,
                    q = b.indices,
                    r = p.length / 6;
                for (q.push(r), j = 0; j < h + 1; j++) p.push(f, g, m, n, o, l), p.push(f + Math.sin(i * j) * c, g + Math.cos(i * j) * d, m, n, o, l), q.push(r++, r++);
                q.push(r - 1)
            }
            if (a.lineWidth) {
                var s = a.points;
                for (a.points = [], j = 0; j < h + 1; j++) a.points.push(f + Math.sin(i * j) * c, g + Math.cos(i * j) * d);
                PIXI.WebGLGraphics.buildLine(a, b), a.points = s
            }
        }, PIXI.WebGLGraphics.buildLine = function(a, b) {
            var c = 0,
                d = a.points;
            if (0 !== d.length) {
                if (a.lineWidth % 2)
                    for (c = 0; c < d.length; c++) d[c] += .5;
                var e = new PIXI.Point(d[0], d[1]),
                    f = new PIXI.Point(d[d.length - 2], d[d.length - 1]);
                if (e.x === f.x && e.y === f.y) {
                    d = d.slice(), d.pop(), d.pop(), f = new PIXI.Point(d[d.length - 2], d[d.length - 1]);
                    var g = f.x + .5 * (e.x - f.x),
                        h = f.y + .5 * (e.y - f.y);
                    d.unshift(g, h), d.push(g, h)
                }
                var i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F = b.points,
                    G = b.indices,
                    H = d.length / 2,
                    I = d.length,
                    J = F.length / 6,
                    K = a.lineWidth / 2,
                    L = PIXI.hex2rgb(a.lineColor),
                    M = a.lineAlpha,
                    N = L[0] * M,
                    O = L[1] * M,
                    P = L[2] * M;
                for (k = d[0], l = d[1], m = d[2], n = d[3], q = -(l - n), r = k - m, E = Math.sqrt(q * q + r * r), q /= E, r /= E, q *= K, r *= K, F.push(k - q, l - r, N, O, P, M), F.push(k + q, l + r, N, O, P, M), c = 1; c < H - 1; c++) k = d[2 * (c - 1)], l = d[2 * (c - 1) + 1], m = d[2 * c], n = d[2 * c + 1], o = d[2 * (c + 1)], p = d[2 * (c + 1) + 1], q = -(l - n), r = k - m, E = Math.sqrt(q * q + r * r), q /= E, r /= E, q *= K, r *= K, s = -(n - p), t = m - o, E = Math.sqrt(s * s + t * t), s /= E, t /= E, s *= K, t *= K, w = -r + l - (-r + n), x = -q + m - (-q + k), y = (-q + k) * (-r + n) - (-q + m) * (-r + l), z = -t + p - (-t + n), A = -s + m - (-s + o), B = (-s + o) * (-t + n) - (-s + m) * (-t + p), C = w * A - z * x, Math.abs(C) < .1 ? (C += 10.1, F.push(m - q, n - r, N, O, P, M), F.push(m + q, n + r, N, O, P, M)) : (i = (x * B - A * y) / C, j = (z * y - w * B) / C, D = (i - m) * (i - m) + (j - n) + (j - n), D > 19600 ? (u = q - s, v = r - t, E = Math.sqrt(u * u + v * v), u /= E, v /= E, u *= K, v *= K, F.push(m - u, n - v), F.push(N, O, P, M), F.push(m + u, n + v), F.push(N, O, P, M), F.push(m - u, n - v), F.push(N, O, P, M), I++) : (F.push(i, j), F.push(N, O, P, M), F.push(m - (i - m), n - (j - n)), F.push(N, O, P, M)));
                for (k = d[2 * (H - 2)], l = d[2 * (H - 2) + 1], m = d[2 * (H - 1)], n = d[2 * (H - 1) + 1], q = -(l - n), r = k - m, E = Math.sqrt(q * q + r * r), q /= E, r /= E, q *= K, r *= K, F.push(m - q, n - r), F.push(N, O, P, M), F.push(m + q, n + r), F.push(N, O, P, M), G.push(J), c = 0; c < I; c++) G.push(J++);
                G.push(J - 1)
            }
        }, PIXI.WebGLGraphics.buildComplexPoly = function(a, b) {
            var c = a.points.slice();
            if (!(c.length < 6)) {
                var d = b.indices;
                b.points = c, b.alpha = a.fillAlpha, b.color = PIXI.hex2rgb(a.fillColor);
                for (var e, f, g = 1 / 0, h = -(1 / 0), i = 1 / 0, j = -(1 / 0), k = 0; k < c.length; k += 2) e = c[k], f = c[k + 1], g = e < g ? e : g, h = e > h ? e : h, i = f < i ? f : i, j = f > j ? f : j;
                c.push(g, i, h, i, h, j, g, j);
                var l = c.length / 2;
                for (k = 0; k < l; k++) d.push(k)
            }
        }, PIXI.WebGLGraphics.buildPoly = function(a, b) {
            var c = a.points;
            if (!(c.length < 6)) {
                var d = b.points,
                    e = b.indices,
                    f = c.length / 2,
                    g = PIXI.hex2rgb(a.fillColor),
                    h = a.fillAlpha,
                    i = g[0] * h,
                    j = g[1] * h,
                    k = g[2] * h,
                    l = PIXI.EarCut.Triangulate(c, null, 2);
                if (!l) return !1;
                var m = d.length / 6,
                    n = 0;
                for (n = 0; n < l.length; n += 3) e.push(l[n] + m), e.push(l[n] + m), e.push(l[n + 1] + m), e.push(l[n + 2] + m), e.push(l[n + 2] + m);
                for (n = 0; n < f; n++) d.push(c[2 * n], c[2 * n + 1], i, j, k, h);
                return !0
            }
        }, PIXI.WebGLGraphics.graphicsDataPool = [], PIXI.WebGLGraphicsData = function(a) {
            this.gl = a, this.color = [0, 0, 0], this.points = [], this.indices = [], this.buffer = a.createBuffer(), this.indexBuffer = a.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0
        }, PIXI.WebGLGraphicsData.prototype.reset = function() {
            this.points = [], this.indices = []
        }, PIXI.WebGLGraphicsData.prototype.upload = function() {
            var a = this.gl;
            this.glPoints = new PIXI.Float32Array(this.points), a.bindBuffer(a.ARRAY_BUFFER, this.buffer), a.bufferData(a.ARRAY_BUFFER, this.glPoints, a.STATIC_DRAW), this.glIndicies = new PIXI.Uint16Array(this.indices), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.glIndicies, a.STATIC_DRAW), this.dirty = !1
        }, PIXI.CanvasGraphics = function() {}, PIXI.CanvasGraphics.renderGraphics = function(a, b) {
            var c = a.worldAlpha;
            a.dirty && (this.updateGraphicsTint(a), a.dirty = !1);
            for (var d = 0; d < a.graphicsData.length; d++) {
                var e = a.graphicsData[d],
                    f = e.shape,
                    g = e._fillTint,
                    h = e._lineTint;
                if (b.lineWidth = e.lineWidth, e.type === PIXI.Graphics.POLY) {
                    b.beginPath();
                    var i = f.points;
                    b.moveTo(i[0], i[1]);
                    for (var j = 1; j < i.length / 2; j++) b.lineTo(i[2 * j], i[2 * j + 1]);
                    f.closed && b.lineTo(i[0], i[1]), i[0] === i[i.length - 2] && i[1] === i[i.length - 1] && b.closePath(), e.fill && (b.globalAlpha = e.fillAlpha * c, b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6), b.fill()), e.lineWidth && (b.globalAlpha = e.lineAlpha * c, b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), b.stroke())
                } else if (e.type === PIXI.Graphics.RECT)(e.fillColor || 0 === e.fillColor) && (b.globalAlpha = e.fillAlpha * c, b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6), b.fillRect(f.x, f.y, f.width, f.height)), e.lineWidth && (b.globalAlpha = e.lineAlpha * c, b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), b.strokeRect(f.x, f.y, f.width, f.height));
                else if (e.type === PIXI.Graphics.CIRC) b.beginPath(), b.arc(f.x, f.y, f.radius, 0, 2 * Math.PI), b.closePath(), e.fill && (b.globalAlpha = e.fillAlpha * c, b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6), b.fill()), e.lineWidth && (b.globalAlpha = e.lineAlpha * c, b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), b.stroke());
                else if (e.type === PIXI.Graphics.ELIP) {
                    var k = 2 * f.width,
                        l = 2 * f.height,
                        m = f.x - k / 2,
                        n = f.y - l / 2;
                    b.beginPath();
                    var o = .5522848,
                        p = k / 2 * o,
                        q = l / 2 * o,
                        r = m + k,
                        s = n + l,
                        t = m + k / 2,
                        u = n + l / 2;
                    b.moveTo(m, u), b.bezierCurveTo(m, u - q, t - p, n, t, n), b.bezierCurveTo(t + p, n, r, u - q, r, u), b.bezierCurveTo(r, u + q, t + p, s, t, s), b.bezierCurveTo(t - p, s, m, u + q, m, u), b.closePath(), e.fill && (b.globalAlpha = e.fillAlpha * c, b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6), b.fill()), e.lineWidth && (b.globalAlpha = e.lineAlpha * c, b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), b.stroke())
                } else if (e.type === PIXI.Graphics.RREC) {
                    var v = f.x,
                        w = f.y,
                        x = f.width,
                        y = f.height,
                        z = f.radius,
                        A = Math.min(x, y) / 2 | 0;
                    z = z > A ? A : z, b.beginPath(), b.moveTo(v, w + z), b.lineTo(v, w + y - z), b.quadraticCurveTo(v, w + y, v + z, w + y), b.lineTo(v + x - z, w + y), b.quadraticCurveTo(v + x, w + y, v + x, w + y - z), b.lineTo(v + x, w + z), b.quadraticCurveTo(v + x, w, v + x - z, w), b.lineTo(v + z, w), b.quadraticCurveTo(v, w, v, w + z), b.closePath(), (e.fillColor || 0 === e.fillColor) && (b.globalAlpha = e.fillAlpha * c, b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6), b.fill()), e.lineWidth && (b.globalAlpha = e.lineAlpha * c, b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), b.stroke())
                }
            }
        }, PIXI.CanvasGraphics.renderGraphicsMask = function(a, b) {
            var c = a.graphicsData.length;
            if (0 !== c) {
                b.beginPath();
                for (var d = 0; d < c; d++) {
                    var e = a.graphicsData[d],
                        f = e.shape;
                    if (e.type === PIXI.Graphics.POLY) {
                        var g = f.points;
                        b.moveTo(g[0], g[1]);
                        for (var h = 1; h < g.length / 2; h++) b.lineTo(g[2 * h], g[2 * h + 1]);
                        g[0] === g[g.length - 2] && g[1] === g[g.length - 1] && b.closePath()
                    } else if (e.type === PIXI.Graphics.RECT) b.rect(f.x, f.y, f.width, f.height), b.closePath();
                    else if (e.type === PIXI.Graphics.CIRC) b.arc(f.x, f.y, f.radius, 0, 2 * Math.PI), b.closePath();
                    else if (e.type === PIXI.Graphics.ELIP) {
                        var i = 2 * f.width,
                            j = 2 * f.height,
                            k = f.x - i / 2,
                            l = f.y - j / 2,
                            m = .5522848,
                            n = i / 2 * m,
                            o = j / 2 * m,
                            p = k + i,
                            q = l + j,
                            r = k + i / 2,
                            s = l + j / 2;
                        b.moveTo(k, s), b.bezierCurveTo(k, s - o, r - n, l, r, l), b.bezierCurveTo(r + n, l, p, s - o, p, s), b.bezierCurveTo(p, s + o, r + n, q, r, q), b.bezierCurveTo(r - n, q, k, s + o, k, s), b.closePath()
                    } else if (e.type === PIXI.Graphics.RREC) {
                        var t = f.x,
                            u = f.y,
                            v = f.width,
                            w = f.height,
                            x = f.radius,
                            y = Math.min(v, w) / 2 | 0;
                        x = x > y ? y : x, b.moveTo(t, u + x), b.lineTo(t, u + w - x), b.quadraticCurveTo(t, u + w, t + x, u + w), b.lineTo(t + v - x, u + w), b.quadraticCurveTo(t + v, u + w, t + v, u + w - x), b.lineTo(t + v, u + x), b.quadraticCurveTo(t + v, u, t + v - x, u), b.lineTo(t + x, u), b.quadraticCurveTo(t, u, t, u + x), b.closePath()
                    }
                }
            }
        }, PIXI.CanvasGraphics.updateGraphicsTint = function(a) {
            if (16777215 !== a.tint)
                for (var b = (a.tint >> 16 & 255) / 255, c = (a.tint >> 8 & 255) / 255, d = (255 & a.tint) / 255, e = 0; e < a.graphicsData.length; e++) {
                    var f = a.graphicsData[e],
                        g = 0 | f.fillColor,
                        h = 0 | f.lineColor;
                    f._fillTint = ((g >> 16 & 255) / 255 * b * 255 << 16) + ((g >> 8 & 255) / 255 * c * 255 << 8) + (255 & g) / 255 * d * 255, f._lineTint = ((h >> 16 & 255) / 255 * b * 255 << 16) + ((h >> 8 & 255) / 255 * c * 255 << 8) + (255 & h) / 255 * d * 255
                }
        }, c.Graphics = function(a, b, d) {
            void 0 === b && (b = 0), void 0 === d && (d = 0), this.type = c.GRAPHICS, this.physicsType = c.SPRITE, this.anchor = new c.Point, PIXI.Graphics.call(this), c.Component.Core.init.call(this, a, b, d, "", null)
        }, c.Graphics.prototype = Object.create(PIXI.Graphics.prototype), c.Graphics.prototype.constructor = c.Graphics, c.Component.Core.install.call(c.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), c.Graphics.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate, c.Graphics.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate, c.Graphics.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.Graphics.prototype.preUpdateCore = c.Component.Core.preUpdate, c.Graphics.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, c.Graphics.prototype.postUpdate = function() {
            c.Component.PhysicsBody.postUpdate.call(this), c.Component.FixedToCamera.postUpdate.call(this), this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1);
            for (var a = 0; a < this.children.length; a++) this.children[a].postUpdate()
        }, c.Graphics.prototype.destroy = function(a) {
            this.clear(), c.Component.Destroy.prototype.destroy.call(this, a)
        }, c.Graphics.prototype.drawTriangle = function(a, b) {
            void 0 === b && (b = !1);
            var d = new c.Polygon(a);
            if (b) {
                var e = new c.Point(this.game.camera.x - a[0].x, this.game.camera.y - a[0].y),
                    f = new c.Point(a[1].x - a[0].x, a[1].y - a[0].y),
                    g = new c.Point(a[1].x - a[2].x, a[1].y - a[2].y),
                    h = g.cross(f);
                e.dot(h) > 0 && this.drawPolygon(d)
            } else this.drawPolygon(d)
        }, c.Graphics.prototype.drawTriangles = function(a, b, d) {
            void 0 === d && (d = !1);
            var e, f = new c.Point,
                g = new c.Point,
                h = new c.Point,
                i = [];
            if (b)
                if (a[0] instanceof c.Point)
                    for (e = 0; e < b.length / 3; e++) i.push(a[b[3 * e]]), i.push(a[b[3 * e + 1]]), i.push(a[b[3 * e + 2]]), 3 === i.length && (this.drawTriangle(i, d), i = []);
                else
                    for (e = 0; e < b.length; e++) f.x = a[2 * b[e]], f.y = a[2 * b[e] + 1], i.push(f.copyTo({})), 3 === i.length && (this.drawTriangle(i, d), i = []);
            else if (a[0] instanceof c.Point)
                for (e = 0; e < a.length / 3; e++) this.drawTriangle([a[3 * e], a[3 * e + 1], a[3 * e + 2]], d);
            else
                for (e = 0; e < a.length / 6; e++) f.x = a[6 * e + 0], f.y = a[6 * e + 1], g.x = a[6 * e + 2], g.y = a[6 * e + 3], h.x = a[6 * e + 4], h.y = a[6 * e + 5], this.drawTriangle([f, g, h], d)
        }, c.RenderTexture = function(a, b, d, e, f, g) {
            void 0 === e && (e = ""), void 0 === f && (f = c.scaleModes.DEFAULT), void 0 === g && (g = 1), this.game = a, this.key = e, this.type = c.RENDERTEXTURE, this._tempMatrix = new PIXI.Matrix, PIXI.RenderTexture.call(this, b, d, this.game.renderer, f, g), this.render = c.RenderTexture.prototype.render
        }, c.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype), c.RenderTexture.prototype.constructor = c.RenderTexture, c.RenderTexture.prototype.renderXY = function(a, b, c, d) {
            a.updateTransform(), this._tempMatrix.copyFrom(a.worldTransform), this._tempMatrix.tx = b, this._tempMatrix.ty = c, this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(a, this._tempMatrix, d) : this.renderCanvas(a, this._tempMatrix, d)
        }, c.RenderTexture.prototype.renderRawXY = function(a, b, c, d) {
            this._tempMatrix.identity().translate(b, c), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(a, this._tempMatrix, d) : this.renderCanvas(a, this._tempMatrix, d)
        }, c.RenderTexture.prototype.render = function(a, b, c) {
            void 0 === b || null === b ? this._tempMatrix.copyFrom(a.worldTransform) : this._tempMatrix.copyFrom(b), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(a, this._tempMatrix, c) : this.renderCanvas(a, this._tempMatrix, c)
        }, c.Text = function(a, b, d, e, f) {
            b = b || 0, d = d || 0, e = void 0 === e || null === e ? "" : e.toString(), f = c.Utils.extend({}, f), this.type = c.TEXT, this.physicsType = c.SPRITE, this.padding = new c.Point, this.textBounds = null, this.canvas = PIXI.CanvasPool.create(this), this.context = this.canvas.getContext("2d"), this.colors = [], this.strokeColors = [], this.fontStyles = [], this.fontWeights = [], this.autoRound = !1, this.useAdvancedWrap = !1, this._res = a.renderer.resolution, this._text = e, this._fontComponents = null, this._lineSpacing = 0, this._charCount = 0, this._width = 0, this._height = 0, c.Sprite.call(this, a, b, d, PIXI.Texture.fromCanvas(this.canvas)), this.setStyle(f), "" !== e && this.updateText()
        }, c.Text.prototype = Object.create(c.Sprite.prototype), c.Text.prototype.constructor = c.Text, c.Text.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, c.Text.prototype.update = function() {}, c.Text.prototype.destroy = function(a) {
            this.texture.destroy(!0), c.Component.Destroy.prototype.destroy.call(this, a)
        }, c.Text.prototype.setShadow = function(a, b, c, d, e, f) {
            return void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = "rgba(0, 0, 0, 1)"), void 0 === d && (d = 0), void 0 === e && (e = !0), void 0 === f && (f = !0), this.style.shadowOffsetX = a, this.style.shadowOffsetY = b, this.style.shadowColor = c, this.style.shadowBlur = d, this.style.shadowStroke = e, this.style.shadowFill = f, this.dirty = !0, this
        }, c.Text.prototype.setStyle = function(a, b) {
            void 0 === b && (b = !1), a = a || {}, a.font = a.font || "bold 20pt Arial", a.backgroundColor = a.backgroundColor || null, a.fill = a.fill || "black", a.align = a.align || "left", a.boundsAlignH = a.boundsAlignH || "left", a.boundsAlignV = a.boundsAlignV || "top", a.stroke = a.stroke || "black", a.strokeThickness = a.strokeThickness || 0, a.wordWrap = a.wordWrap || !1, a.wordWrapWidth = a.wordWrapWidth || 100, a.maxLines = a.maxLines || 0, a.shadowOffsetX = a.shadowOffsetX || 0, a.shadowOffsetY = a.shadowOffsetY || 0, a.shadowColor = a.shadowColor || "rgba(0,0,0,0)", a.shadowBlur = a.shadowBlur || 0, a.tabs = a.tabs || 0;
            var c = this.fontToComponents(a.font);
            return a.fontStyle && (c.fontStyle = a.fontStyle), a.fontVariant && (c.fontVariant = a.fontVariant), a.fontWeight && (c.fontWeight = a.fontWeight), a.fontSize && ("number" == typeof a.fontSize && (a.fontSize = a.fontSize + "px"), c.fontSize = a.fontSize), this._fontComponents = c, a.font = this.componentsToFont(this._fontComponents), this.style = a, this.dirty = !0, b && this.updateText(), this
        }, c.Text.prototype.updateText = function() {
            this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
            var a = this.text;
            this.style.wordWrap && (a = this.runWordWrap(this.text));
            var b = a.split(/(?:\r\n|\r|\n)/),
                c = this.style.tabs,
                d = [],
                e = 0,
                f = this.determineFontProperties(this.style.font),
                g = b.length;
            this.style.maxLines > 0 && this.style.maxLines < b.length && (g = this.style.maxLines), this._charCount = 0;
            for (var h = 0; h < g; h++) {
                if (0 === c) {
                    var i = this.style.strokeThickness + this.padding.x;
                    i += this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(b[h]) : this.context.measureText(b[h]).width, this.style.wordWrap && (i -= this.context.measureText(" ").width)
                } else {
                    var j = b[h].split(/(?:\t)/),
                        i = this.padding.x + this.style.strokeThickness;
                    if (Array.isArray(c))
                        for (var k = 0, l = 0; l < j.length; l++) {
                            var m = 0;
                            m = this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(j[l]) : Math.ceil(this.context.measureText(j[l]).width), l > 0 && (k += c[l - 1]), i = k + m
                        } else
                            for (var l = 0; l < j.length; l++) {
                                i += this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(j[l]) : Math.ceil(this.context.measureText(j[l]).width);
                                var n = this.game.math.snapToCeil(i, c) - i;
                                i += n
                            }
                }
                d[h] = Math.ceil(i), e = Math.max(e, d[h])
            }
            this.canvas.width = e * this._res;
            var o = f.fontSize + this.style.strokeThickness + this.padding.y,
                p = o * g,
                q = this._lineSpacing;
            q < 0 && Math.abs(q) > o && (q = -o), 0 !== q && (p += q > 0 ? q * b.length : q * (b.length - 1)), this.canvas.height = p * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round";
            var r, s;
            for (this._charCount = 0, h = 0; h < g; h++) r = this.style.strokeThickness / 2, s = this.style.strokeThickness / 2 + h * o + f.ascent, h > 0 && (s += q * h), "right" === this.style.align ? r += e - d[h] : "center" === this.style.align && (r += (e - d[h]) / 2), this.autoRound && (r = Math.round(r), s = Math.round(s)), this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.updateLine(b[h], r, s) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === c ? this.context.strokeText(b[h], r, s) : this.renderTabLine(b[h], r, s, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === c ? this.context.fillText(b[h], r, s) : this.renderTabLine(b[h], r, s, !0)));
            this.updateTexture(), this.dirty = !1
        }, c.Text.prototype.renderTabLine = function(a, b, c, d) {
            var e = a.split(/(?:\t)/),
                f = this.style.tabs,
                g = 0;
            if (Array.isArray(f))
                for (var h = 0, i = 0; i < e.length; i++) i > 0 && (h += f[i - 1]), g = b + h, d ? this.context.fillText(e[i], g, c) : this.context.strokeText(e[i], g, c);
            else
                for (var i = 0; i < e.length; i++) {
                    var j = Math.ceil(this.context.measureText(e[i]).width);
                    g = this.game.math.snapToCeil(b, f), d ? this.context.fillText(e[i], g, c) : this.context.strokeText(e[i], g, c), b = g + j
                }
        }, c.Text.prototype.updateShadow = function(a) {
            a ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0, this.context.shadowOffsetY = 0, this.context.shadowColor = 0, this.context.shadowBlur = 0)
        }, c.Text.prototype.measureLine = function(a) {
            for (var b = 0, c = 0; c < a.length; c++) {
                var d = a[c];
                if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                    var e = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (e.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (e.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(e)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)), b += this.context.measureText(d).width, this._charCount++
            }
            return Math.ceil(b)
        }, c.Text.prototype.updateLine = function(a, b, c) {
            for (var d = 0; d < a.length; d++) {
                var e = a[d];
                if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                    var f = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (f.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (f.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(f)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(e, b, c)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(e, b, c)), b += this.context.measureText(e).width, this._charCount++
            }
        }, c.Text.prototype.clearColors = function() {
            return this.colors = [], this.strokeColors = [], this.dirty = !0, this
        }, c.Text.prototype.clearFontValues = function() {
            return this.fontStyles = [], this.fontWeights = [], this.dirty = !0, this
        }, c.Text.prototype.addColor = function(a, b) {
            return this.colors[b] = a, this.dirty = !0, this
        }, c.Text.prototype.addStrokeColor = function(a, b) {
            return this.strokeColors[b] = a, this.dirty = !0, this
        }, c.Text.prototype.addFontStyle = function(a, b) {
            return this.fontStyles[b] = a, this.dirty = !0, this
        }, c.Text.prototype.addFontWeight = function(a, b) {
            return this.fontWeights[b] = a, this.dirty = !0, this
        }, c.Text.prototype.precalculateWordWrap = function(a) {
            this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
            var b = this.runWordWrap(a);
            return b.split(/(?:\r\n|\r|\n)/)
        }, c.Text.prototype.runWordWrap = function(a) {
            return this.useAdvancedWrap ? this.advancedWordWrap(a) : this.basicWordWrap(a)
        }, c.Text.prototype.advancedWordWrap = function(a) {
            for (var b = this.context, c = this.style.wordWrapWidth, d = "", e = a.replace(/ +/gi, " ").split(/\r?\n/gi), f = e.length, g = 0; g < f; g++) {
                var h = e[g],
                    i = "";
                h = h.replace(/^ *|\s*$/gi, "");
                var j = b.measureText(h).width;
                if (j < c) d += h + "\n";
                else {
                    for (var k = c, l = h.split(" "), m = 0; m < l.length; m++) {
                        var n = l[m],
                            o = n + " ",
                            p = b.measureText(o).width;
                        if (p > k) {
                            if (0 === m) {
                                for (var q = o; q.length && (q = q.slice(0, -1), p = b.measureText(q).width, !(p <= k)););
                                if (!q.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
                                var r = n.substr(q.length);
                                l[m] = r, i += q
                            }
                            var s = l[m].length ? m : m + 1,
                                t = l.slice(s).join(" ").replace(/[ \n]*$/gi, "");
                            e[g + 1] = t + " " + (e[g + 1] || ""), f = e.length;
                            break
                        }
                        i += o, k -= p
                    }
                    d += i.replace(/[ \n]*$/gi, "") + "\n"
                }
            }
            return d = d.replace(/[\s|\n]*$/gi, "")
        }, c.Text.prototype.basicWordWrap = function(a) {
            for (var b = "", c = a.split("\n"), d = 0; d < c.length; d++) {
                for (var e = this.style.wordWrapWidth, f = c[d].split(" "), g = 0; g < f.length; g++) {
                    var h = this.context.measureText(f[g]).width,
                        i = h + this.context.measureText(" ").width;
                    i > e ? (g > 0 && (b += "\n"), b += f[g] + " ", e = this.style.wordWrapWidth - h) : (e -= i, b += f[g] + " ")
                }
                d < c.length - 1 && (b += "\n")
            }
            return b
        }, c.Text.prototype.updateFont = function(a) {
            var b = this.componentsToFont(a);
            this.style.font !== b && (this.style.font = b, this.dirty = !0, this.parent && this.updateTransform())
        }, c.Text.prototype.fontToComponents = function(a) {
            var b = a.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
            if (b) {
                var c = b[5].trim();
                return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(c) || /['",]/.exec(c) || (c = "'" + c + "'"), {
                    font: a,
                    fontStyle: b[1] || "normal",
                    fontVariant: b[2] || "normal",
                    fontWeight: b[3] || "normal",
                    fontSize: b[4] || "medium",
                    fontFamily: c
                }
            }
            return {
                font: a
            }
        }, c.Text.prototype.componentsToFont = function(a) {
            var b, c = [];
            return b = a.fontStyle, b && "normal" !== b && c.push(b), b = a.fontVariant, b && "normal" !== b && c.push(b), b = a.fontWeight, b && "normal" !== b && c.push(b), b = a.fontSize, b && "medium" !== b && c.push(b), b = a.fontFamily, b && c.push(b), c.length || c.push(a.font), c.join(" ")
        }, c.Text.prototype.setText = function(a, b) {
            return void 0 === b && (b = !1), this.text = a.toString() || "", b ? this.updateText() : this.dirty = !0, this
        }, c.Text.prototype.parseList = function(a) {
            if (!Array.isArray(a)) return this;
            for (var b = "", c = 0; c < a.length; c++) Array.isArray(a[c]) ? (b += a[c].join("\t"), c < a.length - 1 && (b += "\n")) : (b += a[c], c < a.length - 1 && (b += "\t"));
            return this.text = b, this.dirty = !0, this
        }, c.Text.prototype.setTextBounds = function(a, b, d, e) {
            return void 0 === a ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(a, b, d, e) : this.textBounds = new c.Rectangle(a, b, d, e), this.style.wordWrapWidth > d && (this.style.wordWrapWidth = d)), this.updateTexture(), this
        }, c.Text.prototype.updateTexture = function() {
            var a = this.texture.baseTexture,
                b = this.texture.crop,
                c = this.texture.frame,
                d = this.canvas.width,
                e = this.canvas.height;
            if (a.width = d, a.height = e, b.width = d, b.height = e, c.width = d, c.height = e, this.texture.width = d, this.texture.height = e, this._width = d, this._height = e, this.textBounds) {
                var f = this.textBounds.x,
                    g = this.textBounds.y;
                "right" === this.style.boundsAlignH ? f += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (f += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2), "bottom" === this.style.boundsAlignV ? g += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (g += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2), this.pivot.x = -f, this.pivot.y = -g
            }
            this.renderable = 0 !== d && 0 !== e, this.texture.requiresReTint = !0, this.texture.baseTexture.dirty()
        }, c.Text.prototype._renderWebGL = function(a) {
            this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderWebGL.call(this, a)
        }, c.Text.prototype._renderCanvas = function(a) {
            this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderCanvas.call(this, a)
        }, c.Text.prototype.determineFontProperties = function(a) {
            var b = c.Text.fontPropertiesCache[a];
            if (!b) {
                b = {};
                var d = c.Text.fontPropertiesCanvas,
                    e = c.Text.fontPropertiesContext;
                e.font = a;
                var f = Math.ceil(e.measureText("|MÉq").width),
                    g = Math.ceil(e.measureText("|MÉq").width),
                    h = 2 * g;
                if (g = 1.4 * g | 0, d.width = f, d.height = h, e.fillStyle = "#f00", e.fillRect(0, 0, f, h), e.font = a, e.textBaseline = "alphabetic", e.fillStyle = "#000", e.fillText("|MÉq", 0, g), !e.getImageData(0, 0, f, h)) return b.ascent = g, b.descent = g + 6, b.fontSize = b.ascent + b.descent, c.Text.fontPropertiesCache[a] = b, b;
                var i, j, k = e.getImageData(0, 0, f, h).data,
                    l = k.length,
                    m = 4 * f,
                    n = 0,
                    o = !1;
                for (i = 0; i < g; i++) {
                    for (j = 0; j < m; j += 4)
                        if (255 !== k[n + j]) {
                            o = !0;
                            break
                        }
                    if (o) break;
                    n += m
                }
                for (b.ascent = g - i, n = l - m, o = !1, i = h; i > g; i--) {
                    for (j = 0; j < m; j += 4)
                        if (255 !== k[n + j]) {
                            o = !0;
                            break
                        }
                    if (o) break;
                    n -= m
                }
                b.descent = i - g, b.descent += 6, b.fontSize = b.ascent + b.descent, c.Text.fontPropertiesCache[a] = b
            }
            return b
        }, c.Text.prototype.getBounds = function(a) {
            return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, a)
        }, Object.defineProperty(c.Text.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(a) {
                a !== this._text && (this._text = a.toString() || "", this.dirty = !0, this.parent && this.updateTransform())
            }
        }), Object.defineProperty(c.Text.prototype, "cssFont", {
            get: function() {
                return this.componentsToFont(this._fontComponents)
            },
            set: function(a) {
                a = a || "bold 20pt Arial", this._fontComponents = this.fontToComponents(a), this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(c.Text.prototype, "font", {
            get: function() {
                return this._fontComponents.fontFamily
            },
            set: function(a) {
                a = a || "Arial", a = a.trim(), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(a) || /['",]/.exec(a) || (a = "'" + a + "'"), this._fontComponents.fontFamily = a, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(c.Text.prototype, "fontSize", {
            get: function() {
                var a = this._fontComponents.fontSize;
                return a && /(?:^0$|px$)/.exec(a) ? parseInt(a, 10) : a
            },
            set: function(a) {
                a = a || "0", "number" == typeof a && (a += "px"), this._fontComponents.fontSize = a, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(c.Text.prototype, "fontWeight", {
            get: function() {
                return this._fontComponents.fontWeight || "normal"
            },
            set: function(a) {
                a = a || "normal", this._fontComponents.fontWeight = a, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(c.Text.prototype, "fontStyle", {
            get: function() {
                return this._fontComponents.fontStyle || "normal"
            },
            set: function(a) {
                a = a || "normal", this._fontComponents.fontStyle = a, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(c.Text.prototype, "fontVariant", {
            get: function() {
                return this._fontComponents.fontVariant || "normal"
            },
            set: function(a) {
                a = a || "normal", this._fontComponents.fontVariant = a, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(c.Text.prototype, "fill", {
            get: function() {
                return this.style.fill
            },
            set: function(a) {
                a !== this.style.fill && (this.style.fill = a, this.dirty = !0)
            }
        }), Object.defineProperty(c.Text.prototype, "align", {
            get: function() {
                return this.style.align
            },
            set: function(a) {
                a !== this.style.align && (this.style.align = a, this.dirty = !0)
            }
        }), Object.defineProperty(c.Text.prototype, "resolution", {
            get: function() {
                return this._res
            },
            set: function(a) {
                a !== this._res && (this._res = a, this.dirty = !0)
            }
        }), Object.defineProperty(c.Text.prototype, "tabs", {
            get: function() {
                return this.style.tabs
            },
            set: function(a) {
                a !== this.style.tabs && (this.style.tabs = a, this.dirty = !0)
            }
        }), Object.defineProperty(c.Text.prototype, "boundsAlignH", {
            get: function() {
                return this.style.boundsAlignH
            },
            set: function(a) {
                a !== this.style.boundsAlignH && (this.style.boundsAlignH = a, this.dirty = !0)
            }
        }), Object.defineProperty(c.Text.prototype, "boundsAlignV", {
            get: function() {
                return this.style.boundsAlignV
            },
            set: function(a) {
                a !== this.style.boundsAlignV && (this.style.boundsAlignV = a, this.dirty = !0)
            }
        }), Object.defineProperty(c.Text.prototype, "stroke", {
            get: function() {
                return this.style.stroke
            },
            set: function(a) {
                a !== this.style.stroke && (this.style.stroke = a, this.dirty = !0)
            }
        }), Object.defineProperty(c.Text.prototype, "strokeThickness", {
            get: function() {
                return this.style.strokeThickness
            },
            set: function(a) {
                a !== this.style.strokeThickness && (this.style.strokeThickness = a, this.dirty = !0)
            }
        }), Object.defineProperty(c.Text.prototype, "wordWrap", {
            get: function() {
                return this.style.wordWrap
            },
            set: function(a) {
                a !== this.style.wordWrap && (this.style.wordWrap = a, this.dirty = !0)
            }
        }), Object.defineProperty(c.Text.prototype, "wordWrapWidth", {
            get: function() {
                return this.style.wordWrapWidth
            },
            set: function(a) {
                a !== this.style.wordWrapWidth && (this.style.wordWrapWidth = a, this.dirty = !0)
            }
        }), Object.defineProperty(c.Text.prototype, "lineSpacing", {
            get: function() {
                return this._lineSpacing
            },
            set: function(a) {
                a !== this._lineSpacing && (this._lineSpacing = parseFloat(a), this.dirty = !0, this.parent && this.updateTransform())
            }
        }), Object.defineProperty(c.Text.prototype, "shadowOffsetX", {
            get: function() {
                return this.style.shadowOffsetX
            },
            set: function(a) {
                a !== this.style.shadowOffsetX && (this.style.shadowOffsetX = a, this.dirty = !0)
            }
        }), Object.defineProperty(c.Text.prototype, "shadowOffsetY", {
            get: function() {
                return this.style.shadowOffsetY
            },
            set: function(a) {
                a !== this.style.shadowOffsetY && (this.style.shadowOffsetY = a, this.dirty = !0)
            }
        }), Object.defineProperty(c.Text.prototype, "shadowColor", {
            get: function() {
                return this.style.shadowColor
            },
            set: function(a) {
                a !== this.style.shadowColor && (this.style.shadowColor = a, this.dirty = !0)
            }
        }), Object.defineProperty(c.Text.prototype, "shadowBlur", {
            get: function() {
                return this.style.shadowBlur
            },
            set: function(a) {
                a !== this.style.shadowBlur && (this.style.shadowBlur = a, this.dirty = !0)
            }
        }), Object.defineProperty(c.Text.prototype, "shadowStroke", {
            get: function() {
                return this.style.shadowStroke
            },
            set: function(a) {
                a !== this.style.shadowStroke && (this.style.shadowStroke = a, this.dirty = !0)
            }
        }), Object.defineProperty(c.Text.prototype, "shadowFill", {
            get: function() {
                return this.style.shadowFill
            },
            set: function(a) {
                a !== this.style.shadowFill && (this.style.shadowFill = a, this.dirty = !0)
            }
        }), Object.defineProperty(c.Text.prototype, "width", {
            get: function() {
                return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * this.texture.frame.width
            },
            set: function(a) {
                this.scale.x = a / this.texture.frame.width, this._width = a
            }
        }), Object.defineProperty(c.Text.prototype, "height", {
            get: function() {
                return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * this.texture.frame.height
            },
            set: function(a) {
                this.scale.y = a / this.texture.frame.height, this._height = a
            }
        }), c.Text.fontPropertiesCache = {}, c.Text.fontPropertiesCanvas = document.createElement("canvas"), c.Text.fontPropertiesContext = c.Text.fontPropertiesCanvas.getContext("2d"), c.BitmapText = function(a, b, d, e, f, g, h) {
            b = b || 0, d = d || 0, e = e || "", f = f || "", g = g || 32, h = h || "left", PIXI.DisplayObjectContainer.call(this), this.type = c.BITMAPTEXT, this.physicsType = c.SPRITE, this.textWidth = 0, this.textHeight = 0, this.anchor = new c.Point, this._prevAnchor = new c.Point, this._glyphs = [], this._maxWidth = 0, this._text = f.toString() || "", this._data = a.cache.getBitmapFont(e), this._font = e, this._fontSize = g, this._align = h, this._tint = 16777215, this.updateText(), this.dirty = !1, c.Component.Core.init.call(this, a, b, d, "", null)
        }, c.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), c.BitmapText.prototype.constructor = c.BitmapText, c.Component.Core.install.call(c.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), c.BitmapText.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate, c.BitmapText.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate, c.BitmapText.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.BitmapText.prototype.preUpdateCore = c.Component.Core.preUpdate, c.BitmapText.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, c.BitmapText.prototype.postUpdate = function() {
            c.Component.PhysicsBody.postUpdate.call(this), c.Component.FixedToCamera.postUpdate.call(this), this.body && this.body.type === c.Physics.ARCADE && (this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight || this.body.setSize(this.textWidth, this.textHeight))
        }, c.BitmapText.prototype.setText = function(a) {
            this.text = a
        }, c.BitmapText.prototype.scanLine = function(a, b, c) {
            for (var d = 0, e = 0, f = -1, g = 0, h = null, i = this._maxWidth > 0 ? this._maxWidth : null, j = [], k = 0; k < c.length; k++) {
                var l = k === c.length - 1;
                if (/(?:\r\n|\r|\n)/.test(c.charAt(k))) return {
                    width: e,
                    text: c.substr(0, k),
                    end: l,
                    chars: j
                };
                var m = c.charCodeAt(k),
                    n = a.chars[m],
                    o = 0;
                void 0 === n && (m = 32, n = a.chars[m]);
                var p = h && n.kerning[h] ? n.kerning[h] : 0;
                if (/(\s)/.test(c.charAt(k)) && (f = k, g = e), o = (p + n.texture.width + n.xOffset) * b, i && e + o >= i && f > -1) return {
                    width: g || e,
                    text: c.substr(0, k - (k - f)),
                    end: l,
                    chars: j
                };
                e += (n.xAdvance + p) * b, j.push(d + (n.xOffset + p) * b), d += (n.xAdvance + p) * b, h = m
            }
            return {
                width: e,
                text: c,
                end: l,
                chars: j
            }
        }, c.BitmapText.prototype.cleanText = function(a, b) {
            void 0 === b && (b = "");
            var c = this._data.font;
            if (!c) return "";
            for (var d = /\r\n|\n\r|\n|\r/g, e = a.replace(d, "\n").split("\n"), f = 0; f < e.length; f++) {
                for (var g = "", h = e[f], i = 0; i < h.length; i++) g = c.chars[h.charCodeAt(i)] ? g.concat(h[i]) : g.concat(b);
                e[f] = g
            }
            return e.join("\n")
        }, c.BitmapText.prototype.updateText = function() {
            var a = this._data.font;
            if (a) {
                var b = this.text,
                    c = this._fontSize / a.size,
                    d = [],
                    e = 0;
                this.textWidth = 0;
                do {
                    var f = this.scanLine(a, c, b);
                    f.y = e, d.push(f), f.width > this.textWidth && (this.textWidth = f.width), e += a.lineHeight * c, b = b.substr(f.text.length + 1)
                } while (f.end === !1);
                this.textHeight = e;
                for (var g = 0, h = 0, i = this.textWidth * this.anchor.x, j = this.textHeight * this.anchor.y, k = 0; k < d.length; k++) {
                    var f = d[k];
                    "right" === this._align ? h = this.textWidth - f.width : "center" === this._align && (h = (this.textWidth - f.width) / 2);
                    for (var l = 0; l < f.text.length; l++) {
                        var m = f.text.charCodeAt(l),
                            n = a.chars[m];
                        void 0 === n && (m = 32, n = a.chars[m]);
                        var o = this._glyphs[g];
                        o ? o.texture = n.texture : (o = new PIXI.Sprite(n.texture), o.name = f.text[l], this._glyphs.push(o)), o.position.x = f.chars[l] + h - i, o.position.y = f.y + n.yOffset * c - j, o.scale.set(c), o.tint = this.tint, o.texture.requiresReTint = !0, o.parent || this.addChild(o), g++
                    }
                }
                for (k = g; k < this._glyphs.length; k++) this.removeChild(this._glyphs[k])
            }
        }, c.BitmapText.prototype.purgeGlyphs = function() {
            for (var a = this._glyphs.length, b = [], c = 0; c < this._glyphs.length; c++) this._glyphs[c].parent !== this ? this._glyphs[c].destroy() : b.push(this._glyphs[c]);
            return this._glyphs = [], this._glyphs = b, this.updateText(), a - b.length
        }, c.BitmapText.prototype.updateTransform = function() {
            !this.dirty && this.anchor.equals(this._prevAnchor) || (this.updateText(), this.dirty = !1, this._prevAnchor.copyFrom(this.anchor)), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
        }, Object.defineProperty(c.BitmapText.prototype, "align", {
            get: function() {
                return this._align
            },
            set: function(a) {
                a === this._align || "left" !== a && "center" !== a && "right" !== a || (this._align = a, this.updateText())
            }
        }), Object.defineProperty(c.BitmapText.prototype, "tint", {
            get: function() {
                return this._tint
            },
            set: function(a) {
                a !== this._tint && (this._tint = a, this.updateText())
            }
        }), Object.defineProperty(c.BitmapText.prototype, "font", {
            get: function() {
                return this._font
            },
            set: function(a) {
                a !== this._font && (this._font = a.trim(), this._data = this.game.cache.getBitmapFont(this._font), this.updateText())
            }
        }), Object.defineProperty(c.BitmapText.prototype, "fontSize", {
            get: function() {
                return this._fontSize
            },
            set: function(a) {
                a = parseInt(a, 10), a !== this._fontSize && a > 0 && (this._fontSize = a, this.updateText())
            }
        }), Object.defineProperty(c.BitmapText.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(a) {
                a !== this._text && (this._text = a.toString() || "", this.updateText())
            }
        }), Object.defineProperty(c.BitmapText.prototype, "maxWidth", {
            get: function() {
                return this._maxWidth
            },
            set: function(a) {
                a !== this._maxWidth && (this._maxWidth = a, this.updateText())
            }
        }), Object.defineProperty(c.BitmapText.prototype, "smoothed", {
            get: function() {
                return !this._data.base.scaleMode
            },
            set: function(a) {
                a ? this._data.base.scaleMode = 0 : this._data.base.scaleMode = 1
            }
        }), c.RetroFont = function(a, b, d, e, f, g, h, i, j, k) {
            if (!a.cache.checkImageKey(b)) return !1;
            void 0 !== g && null !== g || (g = a.cache.getImage(b).width / d), this.characterWidth = d, this.characterHeight = e, this.characterSpacingX = h || 0, this.characterSpacingY = i || 0, this.characterPerRow = g, this.offsetX = j || 0, this.offsetY = k || 0, this.align = "left", this.multiLine = !1, this.autoUpperCase = !0, this.customSpacingX = 0, this.customSpacingY = 0, this.fixedWidth = 0, this.fontSet = a.cache.getImage(b), this._text = "", this.grabData = [], this.frameData = new c.FrameData;
            for (var l = this.offsetX, m = this.offsetY, n = 0, o = 0; o < f.length; o++) {
                var p = this.frameData.addFrame(new c.Frame(o, l, m, this.characterWidth, this.characterHeight));
                this.grabData[f.charCodeAt(o)] = p.index, n++, n === this.characterPerRow ? (n = 0, l = this.offsetX, m += this.characterHeight + this.characterSpacingY) : l += this.characterWidth + this.characterSpacingX
            }
            a.cache.updateFrameData(b, this.frameData), this.stamp = new c.Image(a, 0, 0, b, 0), c.RenderTexture.call(this, a, 100, 100, "", c.scaleModes.NEAREST), this.type = c.RETROFONT
        }, c.RetroFont.prototype = Object.create(c.RenderTexture.prototype), c.RetroFont.prototype.constructor = c.RetroFont, c.RetroFont.ALIGN_LEFT = "left", c.RetroFont.ALIGN_RIGHT = "right", c.RetroFont.ALIGN_CENTER = "center", c.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", c.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", c.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", c.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789", c.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", c.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", c.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", c.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ", c.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", c.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", c.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789", c.RetroFont.prototype.setFixedWidth = function(a, b) {
            void 0 === b && (b = "left"), this.fixedWidth = a, this.align = b
        }, c.RetroFont.prototype.setText = function(a, b, c, d, e, f) {
            this.multiLine = b || !1, this.customSpacingX = c || 0, this.customSpacingY = d || 0, this.align = e || "left", f ? this.autoUpperCase = !1 : this.autoUpperCase = !0, a.length > 0 && (this.text = a)
        }, c.RetroFont.prototype.buildRetroFontText = function() {
            var a = 0,
                b = 0;
            if (this.clear(), this.multiLine) {
                var d = this._text.split("\n");
                this.fixedWidth > 0 ? this.resize(this.fixedWidth, d.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), d.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
                for (var e = 0; e < d.length; e++) a = 0, this.align === c.RetroFont.ALIGN_RIGHT ? a = this.width - d[e].length * (this.characterWidth + this.customSpacingX) : this.align === c.RetroFont.ALIGN_CENTER && (a = this.width / 2 - d[e].length * (this.characterWidth + this.customSpacingX) / 2, a += this.customSpacingX / 2), a < 0 && (a = 0), this.pasteLine(d[e], a, b, this.customSpacingX), b += this.characterHeight + this.customSpacingY
            } else this.fixedWidth > 0 ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0), a = 0, this.align === c.RetroFont.ALIGN_RIGHT ? a = this.width - this._text.length * (this.characterWidth + this.customSpacingX) : this.align === c.RetroFont.ALIGN_CENTER && (a = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2, a += this.customSpacingX / 2), a < 0 && (a = 0), this.pasteLine(this._text, a, 0, this.customSpacingX);
            this.requiresReTint = !0
        }, c.RetroFont.prototype.pasteLine = function(a, b, c, d) {
            for (var e = 0; e < a.length; e++)
                if (" " === a.charAt(e)) b += this.characterWidth + d;
                else if (this.grabData[a.charCodeAt(e)] >= 0 && (this.stamp.frame = this.grabData[a.charCodeAt(e)], this.renderXY(this.stamp, b, c, !1), b += this.characterWidth + d, b > this.width)) break
        }, c.RetroFont.prototype.getLongestLine = function() {
            var a = 0;
            if (this._text.length > 0)
                for (var b = this._text.split("\n"), c = 0; c < b.length; c++) b[c].length > a && (a = b[c].length);
            return a
        }, c.RetroFont.prototype.removeUnsupportedCharacters = function(a) {
            for (var b = "", c = 0; c < this._text.length; c++) {
                var d = this._text[c],
                    e = d.charCodeAt(0);
                (this.grabData[e] >= 0 || !a && "\n" === d) && (b = b.concat(d))
            }
            return b
        }, c.RetroFont.prototype.updateOffset = function(a, b) {
            if (this.offsetX !== a || this.offsetY !== b) {
                for (var c = a - this.offsetX, d = b - this.offsetY, e = this.game.cache.getFrameData(this.stamp.key).getFrames(), f = e.length; f--;) e[f].x += c, e[f].y += d;
                this.buildRetroFontText()
            }
        }, Object.defineProperty(c.RetroFont.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(a) {
                var b;
                b = this.autoUpperCase ? a.toUpperCase() : a, b !== this._text && (this._text = b, this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText())
            }
        }), Object.defineProperty(c.RetroFont.prototype, "smoothed", {
            get: function() {
                return this.stamp.smoothed
            },
            set: function(a) {
                this.stamp.smoothed = a, this.buildRetroFontText()
            }
        }), c.Rope = function(a, b, d, e, f, g) {
            this.points = [], this.points = g, this._hasUpdateAnimation = !1, this._updateAnimationCallback = null, b = b || 0, d = d || 0, e = e || null, f = f || null, this.type = c.ROPE, PIXI.Rope.call(this, c.Cache.DEFAULT, this.points), c.Component.Core.init.call(this, a, b, d, e, f)
        }, c.Rope.prototype = Object.create(PIXI.Rope.prototype), c.Rope.prototype.constructor = c.Rope, c.Component.Core.install.call(c.Rope.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), c.Rope.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate, c.Rope.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate, c.Rope.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.Rope.prototype.preUpdateCore = c.Component.Core.preUpdate, c.Rope.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, c.Rope.prototype.update = function() {
            this._hasUpdateAnimation && this.updateAnimation.call(this)
        }, c.Rope.prototype.reset = function(a, b) {
            return c.Component.Reset.prototype.reset.call(this, a, b), this
        }, Object.defineProperty(c.Rope.prototype, "updateAnimation", {
            get: function() {
                return this._updateAnimation
            },
            set: function(a) {
                a && "function" == typeof a ? (this._hasUpdateAnimation = !0, this._updateAnimation = a) : (this._hasUpdateAnimation = !1, this._updateAnimation = null)
            }
        }), Object.defineProperty(c.Rope.prototype, "segments", {
            get: function() {
                for (var a, b, d, e, f, g, h, i, j = [], k = 0; k < this.points.length; k++) a = 4 * k, b = this.vertices[a] * this.scale.x, d = this.vertices[a + 1] * this.scale.y, e = this.vertices[a + 4] * this.scale.x, f = this.vertices[a + 3] * this.scale.y, g = c.Math.difference(b, e), h = c.Math.difference(d, f), b += this.world.x, d += this.world.y, i = new c.Rectangle(b, d, g, h), j.push(i);
                return j
            }
        }), c.TileSprite = function(a, b, d, e, f, g, h) {
            b = b || 0, d = d || 0, e = e || 256, f = f || 256, g = g || null, h = h || null, this.type = c.TILESPRITE, this.physicsType = c.SPRITE, this._scroll = new c.Point;
            var i = a.cache.getImage("__default", !0);
            PIXI.TilingSprite.call(this, new PIXI.Texture(i.base), e, f), c.Component.Core.init.call(this, a, b, d, g, h)
        }, c.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype), c.TileSprite.prototype.constructor = c.TileSprite, c.Component.Core.install.call(c.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]), c.TileSprite.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate, c.TileSprite.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate, c.TileSprite.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.TileSprite.prototype.preUpdateCore = c.Component.Core.preUpdate, c.TileSprite.prototype.preUpdate = function() {
            return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, c.TileSprite.prototype.autoScroll = function(a, b) {
            this._scroll.set(a, b)
        }, c.TileSprite.prototype.stopScroll = function() {
            this._scroll.set(0, 0)
        }, c.TileSprite.prototype.destroy = function(a) {
            c.Component.Destroy.prototype.destroy.call(this, a), PIXI.TilingSprite.prototype.destroy.call(this)
        }, c.TileSprite.prototype.reset = function(a, b) {
            return c.Component.Reset.prototype.reset.call(this, a, b), this.tilePosition.x = 0, this.tilePosition.y = 0, this
        }, c.Device = function() {
            this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, this.iOSVersion = 0, this.cocoonJS = !1, this.cocoonJSApp = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, this.electron = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.canvasBitBltShift = null, this.webGL = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.worker = !1, this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, this.getUserMedia = !0, this.quirksMode = !1, this.touch = !1, this.mspointer = !1, this.wheelEvent = null, this.arora = !1, this.chrome = !1, this.chromeVersion = 0, this.epiphany = !1, this.firefox = !1, this.firefoxVersion = 0, this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.edge = !1, this.mobileSafari = !1, this.midori = !1, this.opera = !1, this.safari = !1, this.safariVersion = 0, this.webApp = !1, this.silk = !1, this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, this.wav = !1, this.m4a = !1, this.webm = !1, this.dolby = !1, this.oggVideo = !1, this.h264Video = !1, this.mp4Video = !1, this.webmVideo = !1, this.vp9Video = !1, this.hlsVideo = !1, this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.LITTLE_ENDIAN = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = "", this.fullscreenKeyboard = !1
        }, c.Device = new c.Device, c.Device.onInitialized = new c.Signal, c.Device.whenReady = function(a, b, c) {
            var d = this._readyCheck;
            if (this.deviceReadyAt || !d) a.call(b, this);
            else if (d._monitor || c) d._queue = d._queue || [], d._queue.push([a, b]);
            else {
                d._monitor = d.bind(this), d._queue = d._queue || [], d._queue.push([a, b]);
                var e = "undefined" != typeof window.cordova,
                    f = navigator.isCocoonJS;
                "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(d._monitor, 0) : e && !f ? document.addEventListener("deviceready", d._monitor, !1) : (document.addEventListener("DOMContentLoaded", d._monitor, !1), window.addEventListener("load", d._monitor, !1))
            }
        }, c.Device._readyCheck = function() {
            var a = this._readyCheck;
            if (document.body) {
                if (!this.deviceReadyAt) {
                    this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", a._monitor), document.removeEventListener("DOMContentLoaded", a._monitor), window.removeEventListener("load", a._monitor), this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this);
                    for (var b; b = a._queue.shift();) {
                        var c = b[0],
                            d = b[1];
                        c.call(d, this)
                    }
                    this._readyCheck = null, this._initialize = null, this.onInitialized = null
                }
            } else window.setTimeout(a._monitor, 20)
        }, c.Device._initialize = function() {
            function a() {
                var a = navigator.userAgent;
                /Playstation Vita/.test(a) ? l.vita = !0 : /Kindle/.test(a) || /\bKF[A-Z][A-Z]+/.test(a) || /Silk.*Mobile Safari/.test(a) ? l.kindle = !0 : /Android/.test(a) ? l.android = !0 : /CrOS/.test(a) ? l.chromeOS = !0 : /iP[ao]d|iPhone/i.test(a) ? (l.iOS = !0, navigator.appVersion.match(/OS (\d+)/), l.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(a) ? l.linux = !0 : /Mac OS/.test(a) ? l.macOS = !0 : /Windows/.test(a) && (l.windows = !0), (/Windows Phone/i.test(a) || /IEMobile/i.test(a)) && (l.android = !1, l.iOS = !1, l.macOS = !1, l.windows = !0, l.windowsPhone = !0);
                var b = /Silk/.test(a);
                (l.windows || l.macOS || l.linux && !b || l.chromeOS) && (l.desktop = !0), (l.windowsPhone || /Windows NT/i.test(a) && /Touch/i.test(a)) && (l.desktop = !1)
            }

            function b() {
                l.canvas = !!window.CanvasRenderingContext2D || l.cocoonJS;
                try {
                    l.localStorage = !!localStorage.getItem
                } catch (a) {
                    l.localStorage = !1
                }
                l.file = !!(window.File && window.FileReader && window.FileList && window.Blob), l.fileSystem = !!window.requestFileSystem, l.webGL = function() {
                    try {
                        var a = document.createElement("canvas");
                        return a.screencanvas = !1, !!window.WebGLRenderingContext && (a.getContext("webgl") || a.getContext("experimental-webgl"))
                    } catch (a) {
                        return !1
                    }
                }(), l.webGL = !!l.webGL, l.worker = !!window.Worker, l.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, l.quirksMode = "CSS1Compat" !== document.compatMode, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, l.getUserMedia = l.getUserMedia && !!navigator.getUserMedia && !!window.URL, l.firefox && l.firefoxVersion < 21 && (l.getUserMedia = !1), !l.iOS && (l.ie || l.firefox || l.chrome) && (l.canvasBitBltShift = !0), (l.safari || l.mobileSafari) && (l.canvasBitBltShift = !1);
            }

            function c() {
                ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) && (l.touch = !0), (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (l.mspointer = !0), l.cocoonJS || ("onwheel" in window || l.ie && "WheelEvent" in window ? l.wheelEvent = "wheel" : "onmousewheel" in window ? l.wheelEvent = "mousewheel" : l.firefox && "MouseScrollEvent" in window && (l.wheelEvent = "DOMMouseScroll"))
            }

            function d() {
                for (var a = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], b = document.createElement("div"), c = 0; c < a.length; c++)
                    if (b[a[c]]) {
                        l.fullscreen = !0, l.requestFullscreen = a[c];
                        break
                    }
                var d = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
                if (l.fullscreen)
                    for (var c = 0; c < d.length; c++)
                        if (document[d[c]]) {
                            l.cancelFullscreen = d[c];
                            break
                        }
                window.Element && Element.ALLOW_KEYBOARD_INPUT && (l.fullscreenKeyboard = !0)
            }

            function e() {
                var a = navigator.userAgent;
                if (/Arora/.test(a) ? l.arora = !0 : /Edge\/\d+/.test(a) ? l.edge = !0 : /Chrome\/(\d+)/.test(a) && !l.windowsPhone ? (l.chrome = !0, l.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(a) ? l.epiphany = !0 : /Firefox\D+(\d+)/.test(a) ? (l.firefox = !0, l.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(a) && l.iOS ? l.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(a) ? (l.ie = !0, l.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(a) ? l.midori = !0 : /Opera/.test(a) ? l.opera = !0 : /Safari\/(\d+)/.test(a) && !l.windowsPhone ? (l.safari = !0, /Version\/(\d+)\./.test(a) && (l.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(a) && (l.ie = !0, l.trident = !0, l.tridentVersion = parseInt(RegExp.$1, 10), l.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(a) && (l.silk = !0), navigator.standalone && (l.webApp = !0), "undefined" != typeof window.cordova && (l.cordova = !0), "undefined" != typeof process && "undefined" != typeof require && (l.node = !0), l.node && "object" == typeof process.versions && (l.nodeWebkit = !!process.versions["node-webkit"], l.electron = !!process.versions.electron), navigator.isCocoonJS && (l.cocoonJS = !0), l.cocoonJS) try {
                    l.cocoonJSApp = "undefined" != typeof CocoonJS
                } catch (a) {
                    l.cocoonJSApp = !1
                }
                "undefined" != typeof window.ejecta && (l.ejecta = !0), /Crosswalk/.test(a) && (l.crosswalk = !0)
            }

            function f() {
                var a = document.createElement("video"),
                    b = !1;
                try {
                    (b = !!a.canPlayType) && (a.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (l.oggVideo = !0), a.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (l.h264Video = !0, l.mp4Video = !0), a.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (l.webmVideo = !0), a.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (l.vp9Video = !0), a.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (l.hlsVideo = !0))
                } catch (a) {}
            }

            function g() {
                l.audioData = !!window.Audio, l.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
                var a = document.createElement("audio"),
                    b = !1;
                try {
                    if ((b = !!a.canPlayType) && (a.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (l.ogg = !0), (a.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || a.canPlayType("audio/opus;").replace(/^no$/, "")) && (l.opus = !0), a.canPlayType("audio/mpeg;").replace(/^no$/, "") && (l.mp3 = !0), a.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (l.wav = !0), (a.canPlayType("audio/x-m4a;") || a.canPlayType("audio/aac;").replace(/^no$/, "")) && (l.m4a = !0), a.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (l.webm = !0), "" !== a.canPlayType('audio/mp4;codecs="ec-3"')))
                        if (l.edge) l.dolby = !0;
                        else if (l.safari && l.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                        var c = parseInt(RegExp.$1, 10),
                            d = parseInt(RegExp.$2, 10);
                        (10 === c && d >= 11 || c > 10) && (l.dolby = !0)
                    }
                } catch (a) {}
            }

            function h() {
                var a = new ArrayBuffer(4),
                    b = new Uint8Array(a),
                    c = new Uint32Array(a);
                return b[0] = 161, b[1] = 178, b[2] = 195, b[3] = 212, 3569595041 === c[0] || 2712847316 !== c[0] && null
            }

            function i() {
                if (void 0 === Uint8ClampedArray) return !1;
                var a = PIXI.CanvasPool.create(this, 1, 1),
                    b = a.getContext("2d");
                if (!b) return !1;
                var c = b.createImageData(1, 1);
                return PIXI.CanvasPool.remove(this), c.data instanceof Uint8ClampedArray
            }

            function j() {
                l.pixelRatio = window.devicePixelRatio || 1, l.iPhone = navigator.userAgent.toLowerCase().indexOf("iphone") !== -1, l.iPhone4 = 2 === l.pixelRatio && l.iPhone, l.iPad = navigator.userAgent.toLowerCase().indexOf("ipad") !== -1, "undefined" != typeof Int8Array ? l.typedArray = !0 : l.typedArray = !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (l.littleEndian = h(), l.LITTLE_ENDIAN = l.littleEndian), l.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== l.littleEndian && i(), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (l.vibration = !0)
            }

            function k() {
                var a, b = document.createElement("p"),
                    c = {
                        webkitTransform: "-webkit-transform",
                        OTransform: "-o-transform",
                        msTransform: "-ms-transform",
                        MozTransform: "-moz-transform",
                        transform: "transform"
                    };
                document.body.insertBefore(b, null);
                for (var d in c) void 0 !== b.style[d] && (b.style[d] = "translate3d(1px,1px,1px)", a = window.getComputedStyle(b).getPropertyValue(c[d]));
                document.body.removeChild(b), l.css3D = void 0 !== a && a.length > 0 && "none" !== a
            }
            var l = this;
            a(), e(), g(), f(), k(), j(), b(), d(), c()
        }, c.Device.canPlayAudio = function(a) {
            return !!("mp3" === a && this.mp3 || "ogg" === a && (this.ogg || this.opus) || "m4a" === a && this.m4a || "opus" === a && this.opus || "wav" === a && this.wav || "webm" === a && this.webm || "mp4" === a && this.dolby)
        }, c.Device.canPlayVideo = function(a) {
            return !!("webm" === a && (this.webmVideo || this.vp9Video) || "mp4" === a && (this.mp4Video || this.h264Video) || ("ogg" === a || "ogv" === a) && this.oggVideo || "mpeg" === a && this.hlsVideo)
        }, c.Device.isConsoleOpen = function() {
            return !(!window.console || !window.console.firebug) || !(!window.console || (console.clear && void 0, !console.profiles)) && console.profiles.length > 0
        }, c.Device.isAndroidStockBrowser = function() {
            var a = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
            return a && a[1] < 537
        }, c.Canvas = {
            create: function(a, b, c, d, e) {
                b = b || 256, c = c || 256;
                var f = e ? document.createElement("canvas") : PIXI.CanvasPool.create(a, b, c);
                return "string" == typeof d && "" !== d && (f.id = d), f.width = b, f.height = c, f.style.display = "block", f
            },
            setBackgroundColor: function(a, b) {
                return b = b || "rgb(0,0,0)", a.style.backgroundColor = b, a
            },
            setTouchAction: function(a, b) {
                return b = b || "none", a.style.msTouchAction = b, a.style["ms-touch-action"] = b, a.style["touch-action"] = b, a
            },
            setUserSelect: function(a, b) {
                return b = b || "none", a.style["-webkit-touch-callout"] = b, a.style["-webkit-user-select"] = b, a.style["-khtml-user-select"] = b, a.style["-moz-user-select"] = b, a.style["-ms-user-select"] = b, a.style["user-select"] = b, a.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", a
            },
            addToDOM: function(a, b, c) {
                var d;
                return void 0 === c && (c = !0), b && ("string" == typeof b ? d = document.getElementById(b) : "object" == typeof b && 1 === b.nodeType && (d = b)), d || (d = document.body), c && d.style && (d.style.overflow = "hidden"), d.appendChild(a), a
            },
            removeFromDOM: function(a) {
                a.parentNode && a.parentNode.removeChild(a)
            },
            setTransform: function(a, b, c, d, e, f, g) {
                return a.setTransform(d, f, g, e, b, c), a
            },
            setSmoothingEnabled: function(a, b) {
                var d = c.Canvas.getSmoothingPrefix(a);
                return d && (a[d] = b), a
            },
            getSmoothingPrefix: function(a) {
                var b = ["i", "webkitI", "msI", "mozI", "oI"];
                for (var c in b) {
                    var d = b[c] + "mageSmoothingEnabled";
                    if (d in a) return d
                }
                return null
            },
            getSmoothingEnabled: function(a) {
                var b = c.Canvas.getSmoothingPrefix(a);
                if (b) return a[b]
            },
            setImageRenderingCrisp: function(a) {
                for (var b = ["optimizeSpeed", "crisp-edges", "-moz-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "pixelated"], c = 0; c < b.length; c++) a.style["image-rendering"] = b[c];
                return a.style.msInterpolationMode = "nearest-neighbor", a
            },
            setImageRenderingBicubic: function(a) {
                return a.style["image-rendering"] = "auto", a.style.msInterpolationMode = "bicubic", a
            }
        }, c.RequestAnimationFrame = function(a, b) {
            void 0 === b && (b = !1), this.game = a, this.isRunning = !1, this.forceSetTimeOut = b;
            for (var c = ["ms", "moz", "webkit", "o"], d = 0; d < c.length && !window.requestAnimationFrame; d++) window.requestAnimationFrame = window[c[d] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[c[d] + "CancelAnimationFrame"];
            this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null
        }, c.RequestAnimationFrame.prototype = {
            start: function() {
                this.isRunning = !0;
                var a = this;
                !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() {
                    return a.updateSetTimeout()
                }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(b) {
                    return a.updateRAF(b)
                }, this._timeOutID = window.requestAnimationFrame(this._onLoop))
            },
            updateRAF: function(a) {
                this.isRunning && (this.game.update(Math.floor(a)), this._timeOutID = window.requestAnimationFrame(this._onLoop))
            },
            updateSetTimeout: function() {
                this.isRunning && (this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall))
            },
            stop: function() {
                this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), this.isRunning = !1
            },
            isSetTimeOut: function() {
                return this._isSetTimeOut
            },
            isRAF: function() {
                return this._isSetTimeOut === !1
            }
        }, c.RequestAnimationFrame.prototype.constructor = c.RequestAnimationFrame, c.Math = {
            PI2: 2 * Math.PI,
            between: function(a, b) {
                return Math.floor(Math.random() * (b - a + 1) + a)
            },
            fuzzyEqual: function(a, b, c) {
                return void 0 === c && (c = 1e-4), Math.abs(a - b) < c
            },
            fuzzyLessThan: function(a, b, c) {
                return void 0 === c && (c = 1e-4), a < b + c
            },
            fuzzyGreaterThan: function(a, b, c) {
                return void 0 === c && (c = 1e-4), a > b - c
            },
            fuzzyCeil: function(a, b) {
                return void 0 === b && (b = 1e-4), Math.ceil(a - b)
            },
            fuzzyFloor: function(a, b) {
                return void 0 === b && (b = 1e-4), Math.floor(a + b)
            },
            average: function() {
                for (var a = 0, b = arguments.length, c = 0; c < b; c++) a += +arguments[c];
                return a / b
            },
            shear: function(a) {
                return a % 1
            },
            snapTo: function(a, b, c) {
                return void 0 === c && (c = 0), 0 === b ? a : (a -= c, a = b * Math.round(a / b), c + a)
            },
            snapToFloor: function(a, b, c) {
                return void 0 === c && (c = 0), 0 === b ? a : (a -= c, a = b * Math.floor(a / b), c + a)
            },
            snapToCeil: function(a, b, c) {
                return void 0 === c && (c = 0), 0 === b ? a : (a -= c, a = b * Math.ceil(a / b), c + a)
            },
            roundTo: function(a, b, c) {
                void 0 === b && (b = 0), void 0 === c && (c = 10);
                var d = Math.pow(c, -b);
                return Math.round(a * d) / d
            },
            floorTo: function(a, b, c) {
                void 0 === b && (b = 0), void 0 === c && (c = 10);
                var d = Math.pow(c, -b);
                return Math.floor(a * d) / d
            },
            ceilTo: function(a, b, c) {
                void 0 === b && (b = 0), void 0 === c && (c = 10);
                var d = Math.pow(c, -b);
                return Math.ceil(a * d) / d
            },
            rotateToAngle: function(a, b, d) {
                return void 0 === d && (d = .05), a === b ? a : (Math.abs(b - a) <= d || Math.abs(b - a) >= c.Math.PI2 - d ? a = b : (Math.abs(b - a) > Math.PI && (b < a ? b += c.Math.PI2 : b -= c.Math.PI2), b > a ? a += d : b < a && (a -= d)), a)
            },
            getShortestAngle: function(a, b) {
                var c = b - a;
                if (0 === c) return 0;
                var d = Math.floor((c - -180) / 360);
                return c - 360 * d
            },
            angleBetween: function(a, b, c, d) {
                return Math.atan2(d - b, c - a)
            },
            angleBetweenY: function(a, b, c, d) {
                return Math.atan2(c - a, d - b)
            },
            angleBetweenPoints: function(a, b) {
                return Math.atan2(b.y - a.y, b.x - a.x)
            },
            angleBetweenPointsY: function(a, b) {
                return Math.atan2(b.x - a.x, b.y - a.y)
            },
            reverseAngle: function(a) {
                return this.normalizeAngle(a + Math.PI, !0)
            },
            normalizeAngle: function(a) {
                return a %= 2 * Math.PI, a >= 0 ? a : a + 2 * Math.PI
            },
            maxAdd: function(a, b, c) {
                return Math.min(a + b, c)
            },
            minSub: function(a, b, c) {
                return Math.max(a - b, c)
            },
            wrap: function(a, b, c) {
                var d = c - b;
                if (d <= 0) return 0;
                var e = (a - b) % d;
                return e < 0 && (e += d), e + b
            },
            wrapValue: function(a, b, c) {
                var d;
                return a = Math.abs(a), b = Math.abs(b), c = Math.abs(c), d = (a + b) % c
            },
            isOdd: function(a) {
                return !!(1 & a)
            },
            isEven: function(a) {
                return !(1 & a)
            },
            min: function() {
                if (1 === arguments.length && "object" == typeof arguments[0]) var a = arguments[0];
                else var a = arguments;
                for (var b = 1, c = 0, d = a.length; b < d; b++) a[b] < a[c] && (c = b);
                return a[c]
            },
            max: function() {
                if (1 === arguments.length && "object" == typeof arguments[0]) var a = arguments[0];
                else var a = arguments;
                for (var b = 1, c = 0, d = a.length; b < d; b++) a[b] > a[c] && (c = b);
                return a[c]
            },
            minProperty: function(a) {
                if (2 === arguments.length && "object" == typeof arguments[1]) var b = arguments[1];
                else var b = arguments.slice(1);
                for (var c = 1, d = 0, e = b.length; c < e; c++) b[c][a] < b[d][a] && (d = c);
                return b[d][a]
            },
            maxProperty: function(a) {
                if (2 === arguments.length && "object" == typeof arguments[1]) var b = arguments[1];
                else var b = arguments.slice(1);
                for (var c = 1, d = 0, e = b.length; c < e; c++) b[c][a] > b[d][a] && (d = c);
                return b[d][a]
            },
            wrapAngle: function(a, b) {
                return b ? this.wrap(a, -Math.PI, Math.PI) : this.wrap(a, -180, 180)
            },
            linearInterpolation: function(a, b) {
                var c = a.length - 1,
                    d = c * b,
                    e = Math.floor(d);
                return b < 0 ? this.linear(a[0], a[1], d) : b > 1 ? this.linear(a[c], a[c - 1], c - d) : this.linear(a[e], a[e + 1 > c ? c : e + 1], d - e)
            },
            bezierInterpolation: function(a, b) {
                for (var c = 0, d = a.length - 1, e = 0; e <= d; e++) c += Math.pow(1 - b, d - e) * Math.pow(b, e) * a[e] * this.bernstein(d, e);
                return c
            },
            catmullRomInterpolation: function(a, b) {
                var c = a.length - 1,
                    d = c * b,
                    e = Math.floor(d);
                return a[0] === a[c] ? (b < 0 && (e = Math.floor(d = c * (1 + b))), this.catmullRom(a[(e - 1 + c) % c], a[e], a[(e + 1) % c], a[(e + 2) % c], d - e)) : b < 0 ? a[0] - (this.catmullRom(a[0], a[0], a[1], a[1], -d) - a[0]) : b > 1 ? a[c] - (this.catmullRom(a[c], a[c], a[c - 1], a[c - 1], d - c) - a[c]) : this.catmullRom(a[e ? e - 1 : 0], a[e], a[c < e + 1 ? c : e + 1], a[c < e + 2 ? c : e + 2], d - e)
            },
            linear: function(a, b, c) {
                return (b - a) * c + a
            },
            bernstein: function(a, b) {
                return this.factorial(a) / this.factorial(b) / this.factorial(a - b)
            },
            factorial: function(a) {
                if (0 === a) return 1;
                for (var b = a; --a;) b *= a;
                return b
            },
            catmullRom: function(a, b, c, d, e) {
                var f = .5 * (c - a),
                    g = .5 * (d - b),
                    h = e * e,
                    i = e * h;
                return (2 * b - 2 * c + f + g) * i + (-3 * b + 3 * c - 2 * f - g) * h + f * e + b
            },
            difference: function(a, b) {
                return Math.abs(a - b)
            },
            roundAwayFromZero: function(a) {
                return a > 0 ? Math.ceil(a) : Math.floor(a)
            },
            sinCosGenerator: function(a, b, c, d) {
                void 0 === b && (b = 1), void 0 === c && (c = 1), void 0 === d && (d = 1);
                for (var e = b, f = c, g = d * Math.PI / a, h = [], i = [], j = 0; j < a; j++) f -= e * g, e += f * g, h[j] = f, i[j] = e;
                return {
                    sin: i,
                    cos: h,
                    length: a
                }
            },
            distance: function(a, b, c, d) {
                var e = a - c,
                    f = b - d;
                return Math.sqrt(e * e + f * f)
            },
            distanceSq: function(a, b, c, d) {
                var e = a - c,
                    f = b - d;
                return e * e + f * f
            },
            distancePow: function(a, b, c, d, e) {
                return void 0 === e && (e = 2), Math.sqrt(Math.pow(c - a, e) + Math.pow(d - b, e))
            },
            clamp: function(a, b, c) {
                return a < b ? b : c < a ? c : a
            },
            clampBottom: function(a, b) {
                return a < b ? b : a
            },
            within: function(a, b, c) {
                return Math.abs(a - b) <= c
            },
            mapLinear: function(a, b, c, d, e) {
                return d + (a - b) * (e - d) / (c - b)
            },
            smoothstep: function(a, b, c) {
                return a = Math.max(0, Math.min(1, (a - b) / (c - b))), a * a * (3 - 2 * a)
            },
            smootherstep: function(a, b, c) {
                return a = Math.max(0, Math.min(1, (a - b) / (c - b))), a * a * a * (a * (6 * a - 15) + 10)
            },
            sign: function(a) {
                return a < 0 ? -1 : a > 0 ? 1 : 0
            },
            percent: function(a, b, c) {
                return void 0 === c && (c = 0), a > b || c > b ? 1 : a < c || c > a ? 0 : (a - c) / b
            }
        };
        var k = Math.PI / 180,
            l = 180 / Math.PI;
        return c.Math.degToRad = function(a) {
            return a * k
        }, c.Math.radToDeg = function(a) {
            return a * l
        }, c.RandomDataGenerator = function(a) {
            void 0 === a && (a = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, "string" == typeof a ? this.state(a) : this.sow(a)
        }, c.RandomDataGenerator.prototype = {
            rnd: function() {
                var a = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
                return this.c = 0 | a, this.s0 = this.s1, this.s1 = this.s2, this.s2 = a - this.c, this.s2
            },
            sow: function(a) {
                if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, a)
                    for (var b = 0; b < a.length && null != a[b]; b++) {
                        var c = a[b];
                        this.s0 -= this.hash(c), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(c), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(c), this.s2 += ~~(this.s2 < 0)
                    }
            },
            hash: function(a) {
                var b, c, d;
                for (d = 4022871197, a = a.toString(), c = 0; c < a.length; c++) d += a.charCodeAt(c), b = .02519603282416938 * d, d = b >>> 0, b -= d, b *= d, d = b >>> 0, b -= d, d += 4294967296 * b;
                return 2.3283064365386963e-10 * (d >>> 0)
            },
            integer: function() {
                return 4294967296 * this.rnd.apply(this)
            },
            frac: function() {
                return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0)
            },
            real: function() {
                return this.integer() + this.frac()
            },
            integerInRange: function(a, b) {
                return Math.floor(this.realInRange(0, b - a + 1) + a)
            },
            between: function(a, b) {
                return this.integerInRange(a, b)
            },
            realInRange: function(a, b) {
                return this.frac() * (b - a) + a
            },
            normal: function() {
                return 1 - 2 * this.frac()
            },
            uuid: function() {
                var a = "",
                    b = "";
                for (b = a = ""; a++ < 36; b += ~a % 5 | 3 * a & 4 ? (15 ^ a ? 8 ^ this.frac() * (20 ^ a ? 16 : 4) : 4).toString(16) : "-");
                return b
            },
            pick: function(a) {
                return a[this.integerInRange(0, a.length - 1)]
            },
            sign: function() {
                return this.pick([-1, 1])
            },
            weightedPick: function(a) {
                return a[~~(Math.pow(this.frac(), 2) * (a.length - 1) + .5)]
            },
            timestamp: function(a, b) {
                return this.realInRange(a || 9466848e5, b || 1577862e6)
            },
            angle: function() {
                return this.integerInRange(-180, 180)
            },
            state: function(a) {
                return "string" == typeof a && a.match(/^!rnd/) && (a = a.split(","), this.c = parseFloat(a[1]), this.s0 = parseFloat(a[2]), this.s1 = parseFloat(a[3]), this.s2 = parseFloat(a[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
            }
        }, c.RandomDataGenerator.prototype.constructor = c.RandomDataGenerator, c.QuadTree = function(a, b, c, d, e, f, g) {
            this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], this.nodes = [], this._empty = [], this.reset(a, b, c, d, e, f, g)
        }, c.QuadTree.prototype = {
            reset: function(a, b, c, d, e, f, g) {
                this.maxObjects = e || 10, this.maxLevels = f || 4, this.level = g || 0, this.bounds = {
                    x: Math.round(a),
                    y: Math.round(b),
                    width: c,
                    height: d,
                    subWidth: Math.floor(c / 2),
                    subHeight: Math.floor(d / 2),
                    right: Math.round(a) + Math.floor(c / 2),
                    bottom: Math.round(b) + Math.floor(d / 2)
                }, this.objects.length = 0, this.nodes.length = 0
            },
            populate: function(a) {
                a.forEach(this.populateHandler, this, !0)
            },
            populateHandler: function(a) {
                a.body && a.exists && this.insert(a.body)
            },
            split: function() {
                this.nodes[0] = new c.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[1] = new c.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[2] = new c.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[3] = new c.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)
            },
            insert: function(a) {
                var b, c = 0;
                if (null != this.nodes[0] && (b = this.getIndex(a), b !== -1)) return void this.nodes[b].insert(a);
                if (this.objects.push(a), this.objects.length > this.maxObjects && this.level < this.maxLevels)
                    for (null == this.nodes[0] && this.split(); c < this.objects.length;) b = this.getIndex(this.objects[c]), b !== -1 ? this.nodes[b].insert(this.objects.splice(c, 1)[0]) : c++
            },
            getIndex: function(a) {
                var b = -1;
                return a.x < this.bounds.right && a.right < this.bounds.right ? a.y < this.bounds.bottom && a.bottom < this.bounds.bottom ? b = 1 : a.y > this.bounds.bottom && (b = 2) : a.x > this.bounds.right && (a.y < this.bounds.bottom && a.bottom < this.bounds.bottom ? b = 0 : a.y > this.bounds.bottom && (b = 3)), b
            },
            retrieve: function(a) {
                if (a instanceof c.Rectangle) var b = this.objects,
                    d = this.getIndex(a);
                else {
                    if (!a.body) return this._empty;
                    var b = this.objects,
                        d = this.getIndex(a.body)
                }
                return this.nodes[0] && (d !== -1 ? b = b.concat(this.nodes[d].retrieve(a)) : (b = b.concat(this.nodes[0].retrieve(a)), b = b.concat(this.nodes[1].retrieve(a)), b = b.concat(this.nodes[2].retrieve(a)), b = b.concat(this.nodes[3].retrieve(a)))), b
            },
            clear: function() {
                this.objects.length = 0;
                for (var a = this.nodes.length; a--;) this.nodes[a].clear(), this.nodes.splice(a, 1);
                this.nodes.length = 0
            }
        }, c.QuadTree.prototype.constructor = c.QuadTree, c.Net = function(a) {
            this.game = a
        }, c.Net.prototype = {
            getHostName: function() {
                return window.location && window.location.hostname ? window.location.hostname : null
            },
            checkDomainName: function(a) {
                return window.location.hostname.indexOf(a) !== -1
            },
            updateQueryString: function(a, b, c, d) {
                void 0 === c && (c = !1), void 0 !== d && "" !== d || (d = window.location.href);
                var e = "",
                    f = new RegExp("([?|&])" + a + "=.*?(&|#|$)(.*)", "gi");
                if (f.test(d)) e = "undefined" != typeof b && null !== b ? d.replace(f, "$1" + a + "=" + b + "$2$3") : d.replace(f, "$1$3").replace(/(&|\?)$/, "");
                else if ("undefined" != typeof b && null !== b) {
                    var g = d.indexOf("?") !== -1 ? "&" : "?",
                        h = d.split("#");
                    d = h[0] + g + a + "=" + b, h[1] && (d += "#" + h[1]), e = d
                } else e = d;
                return c ? void(window.location.href = e) : e
            },
            getQueryString: function(a) {
                void 0 === a && (a = "");
                var b = {},
                    c = location.search.substring(1).split("&");
                for (var d in c) {
                    var e = c[d].split("=");
                    if (e.length > 1) {
                        if (a && a === this.decodeURI(e[0])) return this.decodeURI(e[1]);
                        b[this.decodeURI(e[0])] = this.decodeURI(e[1])
                    }
                }
                return b
            },
            decodeURI: function(a) {
                return decodeURIComponent(a.replace(/\+/g, " "))
            }
        }, c.Net.prototype.constructor = c.Net, c.TweenManager = function(a) {
            this.game = a, this.frameBased = !1, this._tweens = [], this._add = [], this.easeMap = {
                Power0: c.Easing.Power0,
                Power1: c.Easing.Power1,
                Power2: c.Easing.Power2,
                Power3: c.Easing.Power3,
                Power4: c.Easing.Power4,
                Linear: c.Easing.Linear.None,
                Quad: c.Easing.Quadratic.Out,
                Cubic: c.Easing.Cubic.Out,
                Quart: c.Easing.Quartic.Out,
                Quint: c.Easing.Quintic.Out,
                Sine: c.Easing.Sinusoidal.Out,
                Expo: c.Easing.Exponential.Out,
                Circ: c.Easing.Circular.Out,
                Elastic: c.Easing.Elastic.Out,
                Back: c.Easing.Back.Out,
                Bounce: c.Easing.Bounce.Out,
                "Quad.easeIn": c.Easing.Quadratic.In,
                "Cubic.easeIn": c.Easing.Cubic.In,
                "Quart.easeIn": c.Easing.Quartic.In,
                "Quint.easeIn": c.Easing.Quintic.In,
                "Sine.easeIn": c.Easing.Sinusoidal.In,
                "Expo.easeIn": c.Easing.Exponential.In,
                "Circ.easeIn": c.Easing.Circular.In,
                "Elastic.easeIn": c.Easing.Elastic.In,
                "Back.easeIn": c.Easing.Back.In,
                "Bounce.easeIn": c.Easing.Bounce.In,
                "Quad.easeOut": c.Easing.Quadratic.Out,
                "Cubic.easeOut": c.Easing.Cubic.Out,
                "Quart.easeOut": c.Easing.Quartic.Out,
                "Quint.easeOut": c.Easing.Quintic.Out,
                "Sine.easeOut": c.Easing.Sinusoidal.Out,
                "Expo.easeOut": c.Easing.Exponential.Out,
                "Circ.easeOut": c.Easing.Circular.Out,
                "Elastic.easeOut": c.Easing.Elastic.Out,
                "Back.easeOut": c.Easing.Back.Out,
                "Bounce.easeOut": c.Easing.Bounce.Out,
                "Quad.easeInOut": c.Easing.Quadratic.InOut,
                "Cubic.easeInOut": c.Easing.Cubic.InOut,
                "Quart.easeInOut": c.Easing.Quartic.InOut,
                "Quint.easeInOut": c.Easing.Quintic.InOut,
                "Sine.easeInOut": c.Easing.Sinusoidal.InOut,
                "Expo.easeInOut": c.Easing.Exponential.InOut,
                "Circ.easeInOut": c.Easing.Circular.InOut,
                "Elastic.easeInOut": c.Easing.Elastic.InOut,
                "Back.easeInOut": c.Easing.Back.InOut,
                "Bounce.easeInOut": c.Easing.Bounce.InOut
            }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this)
        }, c.TweenManager.prototype = {
            getAll: function() {
                return this._tweens
            },
            removeAll: function() {
                for (var a = 0; a < this._tweens.length; a++) this._tweens[a].pendingDelete = !0;
                this._add = []
            },
            removeFrom: function(a, b) {
                void 0 === b && (b = !0);
                var d, e;
                if (Array.isArray(a))
                    for (d = 0, e = a.length; d < e; d++) this.removeFrom(a[d]);
                else if (a.type === c.GROUP && b)
                    for (var d = 0, e = a.children.length; d < e; d++) this.removeFrom(a.children[d]);
                else {
                    for (d = 0, e = this._tweens.length; d < e; d++) a === this._tweens[d].target && this.remove(this._tweens[d]);
                    for (d = 0, e = this._add.length; d < e; d++) a === this._add[d].target && this.remove(this._add[d])
                }
            },
            add: function(a) {
                a._manager = this, this._add.push(a)
            },
            create: function(a) {
                return new c.Tween(a, this.game, this)
            },
            remove: function(a) {
                var b = this._tweens.indexOf(a);
                b !== -1 ? this._tweens[b].pendingDelete = !0 : (b = this._add.indexOf(a), b !== -1 && (this._add[b].pendingDelete = !0))
            },
            update: function() {
                var a = this._add.length,
                    b = this._tweens.length;
                if (0 === b && 0 === a) return !1;
                for (var c = 0; c < b;) this._tweens[c].update(this.game.time.time) ? c++ : (this._tweens.splice(c, 1), b--);
                return a > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), !0
            },
            isTweening: function(a) {
                return this._tweens.some(function(b) {
                    return b.target === a
                })
            },
            _pauseAll: function() {
                for (var a = this._tweens.length - 1; a >= 0; a--) this._tweens[a]._pause()
            },
            _resumeAll: function() {
                for (var a = this._tweens.length - 1; a >= 0; a--) this._tweens[a]._resume()
            },
            pauseAll: function() {
                for (var a = this._tweens.length - 1; a >= 0; a--) this._tweens[a].pause()
            },
            resumeAll: function() {
                for (var a = this._tweens.length - 1; a >= 0; a--) this._tweens[a].resume(!0)
            }
        }, c.TweenManager.prototype.constructor = c.TweenManager, c.Tween = function(a, b, d) {
            this.game = b, this.target = a, this.manager = d, this.timeline = [], this.reverse = !1, this.timeScale = 1, this.repeatCounter = 0, this.pendingDelete = !1, this.onStart = new c.Signal, this.onLoop = new c.Signal, this.onRepeat = new c.Signal, this.onChildComplete = new c.Signal, this.onComplete = new c.Signal, this.isRunning = !1, this.current = 0, this.properties = {}, this.chainedTween = null, this.isPaused = !1, this.frameBased = d.frameBased, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, this._pausedTime = 0, this._codePaused = !1, this._hasStarted = !1
        }, c.Tween.prototype = {
            to: function(a, b, d, e, f, g, h) {
                return (void 0 === b || b <= 0) && (b = 1e3), void 0 !== d && null !== d || (d = c.Easing.Default), void 0 === e && (e = !1), void 0 === f && (f = 0), void 0 === g && (g = 0), void 0 === h && (h = !1), "string" == typeof d && this.manager.easeMap[d] && (d = this.manager.easeMap[d]), this.isRunning ? this : (this.timeline.push(new c.TweenData(this).to(a, b, d, f, g, h)), e && this.start(), this)
            },
            from: function(a, b, d, e, f, g, h) {
                return void 0 === b && (b = 1e3), void 0 !== d && null !== d || (d = c.Easing.Default), void 0 === e && (e = !1), void 0 === f && (f = 0), void 0 === g && (g = 0), void 0 === h && (h = !1), "string" == typeof d && this.manager.easeMap[d] && (d = this.manager.easeMap[d]), this.isRunning ? this : (this.timeline.push(new c.TweenData(this).from(a, b, d, f, g, h)), e && this.start(), this)
            },
            start: function(a) {
                if (void 0 === a && (a = 0), null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this;
                for (var b = 0; b < this.timeline.length; b++)
                    for (var c in this.timeline[b].vEnd) this.properties[c] = this.target[c] || 0, Array.isArray(this.properties[c]) || (this.properties[c] *= 1);
                for (var b = 0; b < this.timeline.length; b++) this.timeline[b].loadValues();
                return this.manager.add(this), this.isRunning = !0, (a < 0 || a > this.timeline.length - 1) && (a = 0), this.current = a, this.timeline[this.current].start(), this
            },
            stop: function(a) {
                return void 0 === a && (a = !1), this.isRunning = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, a && (this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this
            },
            updateTweenData: function(a, b, c) {
                if (0 === this.timeline.length) return this;
                if (void 0 === c && (c = 0), c === -1)
                    for (var d = 0; d < this.timeline.length; d++) this.timeline[d][a] = b;
                else this.timeline[c][a] = b;
                return this
            },
            delay: function(a, b) {
                return this.updateTweenData("delay", a, b)
            },
            repeat: function(a, b, c) {
                return void 0 === b && (b = 0), this.updateTweenData("repeatCounter", a, c), this.updateTweenData("repeatDelay", b, c)
            },
            repeatDelay: function(a, b) {
                return this.updateTweenData("repeatDelay", a, b)
            },
            yoyo: function(a, b, c) {
                return void 0 === b && (b = 0), this.updateTweenData("yoyo", a, c), this.updateTweenData("yoyoDelay", b, c)
            },
            yoyoDelay: function(a, b) {
                return this.updateTweenData("yoyoDelay", a, b)
            },
            easing: function(a, b) {
                return "string" == typeof a && this.manager.easeMap[a] && (a = this.manager.easeMap[a]), this.updateTweenData("easingFunction", a, b)
            },
            interpolation: function(a, b, d) {
                return void 0 === b && (b = c.Math), this.updateTweenData("interpolationFunction", a, d), this.updateTweenData("interpolationContext", b, d)
            },
            repeatAll: function(a) {
                return void 0 === a && (a = 0), this.repeatCounter = a, this
            },
            chain: function() {
                for (var a = arguments.length; a--;) a > 0 ? arguments[a - 1].chainedTween = arguments[a] : this.chainedTween = arguments[a];
                return this
            },
            loop: function(a) {
                return void 0 === a && (a = !0), this.repeatCounter = a ? -1 : 0, this
            },
            onUpdateCallback: function(a, b) {
                return this._onUpdateCallback = a, this._onUpdateCallbackContext = b, this
            },
            pause: function() {
                this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.time
            },
            _pause: function() {
                this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time)
            },
            resume: function() {
                if (this.isPaused) {
                    this.isPaused = !1, this._codePaused = !1;
                    for (var a = 0; a < this.timeline.length; a++) this.timeline[a].isRunning || (this.timeline[a].startTime += this.game.time.time - this._pausedTime)
                }
            },
            _resume: function() {
                this._codePaused || this.resume()
            },
            update: function(a) {
                if (this.pendingDelete || !this.target) return !1;
                if (this.isPaused) return !0;
                var b = this.timeline[this.current].update(a);
                if (b === c.TweenData.PENDING) return !0;
                if (b === c.TweenData.RUNNING) return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = !0), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), this.isRunning;
                if (b === c.TweenData.LOOPED) return this.timeline[this.current].repeatCounter === -1 ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this), !0;
                if (b === c.TweenData.COMPLETE) {
                    var d = !1;
                    return this.reverse ? (this.current--, this.current < 0 && (this.current = this.timeline.length - 1, d = !0)) : (this.current++, this.current === this.timeline.length && (this.current = 0, d = !0)), d ? this.repeatCounter === -1 ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0) : this.repeatCounter > 0 ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start(), !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0)
                }
            },
            generateData: function(a, b) {
                if (null === this.game || null === this.target) return null;
                void 0 === a && (a = 60), void 0 === b && (b = []);
                for (var c = 0; c < this.timeline.length; c++)
                    for (var d in this.timeline[c].vEnd) this.properties[d] = this.target[d] || 0, Array.isArray(this.properties[d]) || (this.properties[d] *= 1);
                for (var c = 0; c < this.timeline.length; c++) this.timeline[c].loadValues();
                for (var c = 0; c < this.timeline.length; c++) b = b.concat(this.timeline[c].generateData(a));
                return b
            }
        }, Object.defineProperty(c.Tween.prototype, "totalDuration", {
            get: function() {
                for (var a = 0, b = 0; b < this.timeline.length; b++) a += this.timeline[b].duration;
                return a
            }
        }), c.Tween.prototype.constructor = c.Tween, c.TweenData = function(a) {
            this.parent = a, this.game = a.game, this.vStart = {}, this.vStartCache = {}, this.vEnd = {}, this.vEndCache = {}, this.duration = 1e3, this.percent = 0, this.value = 0, this.repeatCounter = 0, this.repeatDelay = 0, this.repeatTotal = 0, this.interpolate = !1, this.yoyo = !1, this.yoyoDelay = 0, this.inReverse = !1, this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = c.Easing.Default, this.interpolationFunction = c.Math.linearInterpolation, this.interpolationContext = c.Math, this.isRunning = !1, this.isFrom = !1
        }, c.TweenData.PENDING = 0, c.TweenData.RUNNING = 1, c.TweenData.LOOPED = 2, c.TweenData.COMPLETE = 3, c.TweenData.prototype = {
            to: function(a, b, c, d, e, f) {
                return this.vEnd = a, this.duration = b, this.easingFunction = c, this.delay = d, this.repeatTotal = e, this.yoyo = f, this.isFrom = !1, this
            },
            from: function(a, b, c, d, e, f) {
                return this.vEnd = a, this.duration = b, this.easingFunction = c, this.delay = d, this.repeatTotal = e, this.yoyo = f, this.isFrom = !0, this
            },
            start: function() {
                if (this.startTime = this.game.time.time + this.delay, this.parent.reverse ? this.dt = this.duration : this.dt = 0, this.delay > 0 ? this.isRunning = !1 : this.isRunning = !0, this.isFrom)
                    for (var a in this.vStartCache) this.vStart[a] = this.vEndCache[a], this.vEnd[a] = this.vStartCache[a], this.parent.target[a] = this.vStart[a];
                return this.value = 0, this.yoyoCounter = 0, this.repeatCounter = this.repeatTotal, this
            },
            loadValues: function() {
                for (var a in this.parent.properties) {
                    if (this.vStart[a] = this.parent.properties[a], Array.isArray(this.vEnd[a])) {
                        if (0 === this.vEnd[a].length) continue;
                        0 === this.percent && (this.vEnd[a] = [this.vStart[a]].concat(this.vEnd[a]))
                    }
                    "undefined" != typeof this.vEnd[a] ? ("string" == typeof this.vEnd[a] && (this.vEnd[a] = this.vStart[a] + parseFloat(this.vEnd[a], 10)), this.parent.properties[a] = this.vEnd[a]) : this.vEnd[a] = this.vStart[a], this.vStartCache[a] = this.vStart[a], this.vEndCache[a] = this.vEnd[a]
                }
                return this
            },
            update: function(a) {
                if (this.isRunning) {
                    if (a < this.startTime) return c.TweenData.RUNNING
                } else {
                    if (!(a >= this.startTime)) return c.TweenData.PENDING;
                    this.isRunning = !0
                }
                var b = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
                this.parent.reverse ? (this.dt -= b * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += b * this.parent.timeScale, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                for (var d in this.vEnd) {
                    var e = this.vStart[d],
                        f = this.vEnd[d];
                    Array.isArray(f) ? this.parent.target[d] = this.interpolationFunction.call(this.interpolationContext, f, this.value) : this.parent.target[d] = e + (f - e) * this.value
                }
                return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : c.TweenData.RUNNING
            },
            generateData: function(a) {
                this.parent.reverse ? this.dt = this.duration : this.dt = 0;
                var b = [],
                    c = !1,
                    d = 1 / a * 1e3;
                do {
                    this.parent.reverse ? (this.dt -= d, this.dt = Math.max(this.dt, 0)) : (this.dt += d, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration,
                        this.value = this.easingFunction(this.percent);
                    var e = {};
                    for (var f in this.vEnd) {
                        var g = this.vStart[f],
                            h = this.vEnd[f];
                        Array.isArray(h) ? e[f] = this.interpolationFunction(h, this.value) : e[f] = g + (h - g) * this.value
                    }
                    b.push(e), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (c = !0)
                } while (!c);
                if (this.yoyo) {
                    var i = b.slice();
                    i.reverse(), b = b.concat(i)
                }
                return b
            },
            repeat: function() {
                if (this.yoyo) {
                    if (this.inReverse && 0 === this.repeatCounter) {
                        for (var a in this.vStartCache) this.vStart[a] = this.vStartCache[a], this.vEnd[a] = this.vEndCache[a];
                        return this.inReverse = !1, c.TweenData.COMPLETE
                    }
                    this.inReverse = !this.inReverse
                } else if (0 === this.repeatCounter) return c.TweenData.COMPLETE;
                if (this.inReverse)
                    for (var a in this.vStartCache) this.vStart[a] = this.vEndCache[a], this.vEnd[a] = this.vStartCache[a];
                else {
                    for (var a in this.vStartCache) this.vStart[a] = this.vStartCache[a], this.vEnd[a] = this.vEndCache[a];
                    this.repeatCounter > 0 && this.repeatCounter--
                }
                return this.startTime = this.game.time.time, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), this.parent.reverse ? this.dt = this.duration : this.dt = 0, c.TweenData.LOOPED
            }
        }, c.TweenData.prototype.constructor = c.TweenData, c.Easing = {
            Linear: {
                None: function(a) {
                    return a
                }
            },
            Quadratic: {
                In: function(a) {
                    return a * a
                },
                Out: function(a) {
                    return a * (2 - a)
                },
                InOut: function(a) {
                    return (a *= 2) < 1 ? .5 * a * a : -.5 * (--a * (a - 2) - 1)
                }
            },
            Cubic: {
                In: function(a) {
                    return a * a * a
                },
                Out: function(a) {
                    return --a * a * a + 1
                },
                InOut: function(a) {
                    return (a *= 2) < 1 ? .5 * a * a * a : .5 * ((a -= 2) * a * a + 2)
                }
            },
            Quartic: {
                In: function(a) {
                    return a * a * a * a
                },
                Out: function(a) {
                    return 1 - --a * a * a * a
                },
                InOut: function(a) {
                    return (a *= 2) < 1 ? .5 * a * a * a * a : -.5 * ((a -= 2) * a * a * a - 2)
                }
            },
            Quintic: {
                In: function(a) {
                    return a * a * a * a * a
                },
                Out: function(a) {
                    return --a * a * a * a * a + 1
                },
                InOut: function(a) {
                    return (a *= 2) < 1 ? .5 * a * a * a * a * a : .5 * ((a -= 2) * a * a * a * a + 2)
                }
            },
            Sinusoidal: {
                In: function(a) {
                    return 0 === a ? 0 : 1 === a ? 1 : 1 - Math.cos(a * Math.PI / 2)
                },
                Out: function(a) {
                    return 0 === a ? 0 : 1 === a ? 1 : Math.sin(a * Math.PI / 2)
                },
                InOut: function(a) {
                    return 0 === a ? 0 : 1 === a ? 1 : .5 * (1 - Math.cos(Math.PI * a))
                }
            },
            Exponential: {
                In: function(a) {
                    return 0 === a ? 0 : Math.pow(1024, a - 1)
                },
                Out: function(a) {
                    return 1 === a ? 1 : 1 - Math.pow(2, -10 * a)
                },
                InOut: function(a) {
                    return 0 === a ? 0 : 1 === a ? 1 : (a *= 2) < 1 ? .5 * Math.pow(1024, a - 1) : .5 * (-Math.pow(2, -10 * (a - 1)) + 2)
                }
            },
            Circular: {
                In: function(a) {
                    return 1 - Math.sqrt(1 - a * a)
                },
                Out: function(a) {
                    return Math.sqrt(1 - --a * a)
                },
                InOut: function(a) {
                    return (a *= 2) < 1 ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1)
                }
            },
            Elastic: {
                In: function(a) {
                    var b, c = .1,
                        d = .4;
                    return 0 === a ? 0 : 1 === a ? 1 : (!c || c < 1 ? (c = 1, b = d / 4) : b = d * Math.asin(1 / c) / (2 * Math.PI), -(c * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - b) * (2 * Math.PI) / d)))
                },
                Out: function(a) {
                    var b, c = .1,
                        d = .4;
                    return 0 === a ? 0 : 1 === a ? 1 : (!c || c < 1 ? (c = 1, b = d / 4) : b = d * Math.asin(1 / c) / (2 * Math.PI), c * Math.pow(2, -10 * a) * Math.sin((a - b) * (2 * Math.PI) / d) + 1)
                },
                InOut: function(a) {
                    var b, c = .1,
                        d = .4;
                    return 0 === a ? 0 : 1 === a ? 1 : (!c || c < 1 ? (c = 1, b = d / 4) : b = d * Math.asin(1 / c) / (2 * Math.PI), (a *= 2) < 1 ? -.5 * (c * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - b) * (2 * Math.PI) / d)) : c * Math.pow(2, -10 * (a -= 1)) * Math.sin((a - b) * (2 * Math.PI) / d) * .5 + 1)
                }
            },
            Back: {
                In: function(a) {
                    var b = 1.70158;
                    return a * a * ((b + 1) * a - b)
                },
                Out: function(a) {
                    var b = 1.70158;
                    return --a * a * ((b + 1) * a + b) + 1
                },
                InOut: function(a) {
                    var b = 2.5949095;
                    return (a *= 2) < 1 ? .5 * (a * a * ((b + 1) * a - b)) : .5 * ((a -= 2) * a * ((b + 1) * a + b) + 2)
                }
            },
            Bounce: {
                In: function(a) {
                    return 1 - c.Easing.Bounce.Out(1 - a)
                },
                Out: function(a) {
                    return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375
                },
                InOut: function(a) {
                    return a < .5 ? .5 * c.Easing.Bounce.In(2 * a) : .5 * c.Easing.Bounce.Out(2 * a - 1) + .5
                }
            }
        }, c.Easing.Default = c.Easing.Linear.None, c.Easing.Power0 = c.Easing.Linear.None, c.Easing.Power1 = c.Easing.Quadratic.Out, c.Easing.Power2 = c.Easing.Cubic.Out, c.Easing.Power3 = c.Easing.Quartic.Out, c.Easing.Power4 = c.Easing.Quintic.Out, c.Time = function(a) {
            this.game = a, this.time = 0, this.prevTime = 0, this.now = 0, this.elapsed = 0, this.elapsedMS = 0, this.physicsElapsed = 1 / 60, this.physicsElapsedMS = 1 / 60 * 1e3, this.desiredFpsMult = 1 / 60, this._desiredFps = 60, this.suggestedFps = this.desiredFps, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, this.fps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new c.Timer(this.game, (!1)), this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, this._pauseStarted = 0, this._justResumed = !1, this._timers = []
        }, c.Time.prototype = {
            boot: function() {
                this._started = Date.now(), this.time = Date.now(), this.events.start(), this.timeExpected = this.time
            },
            add: function(a) {
                return this._timers.push(a), a
            },
            create: function(a) {
                void 0 === a && (a = !0);
                var b = new c.Timer(this.game, a);
                return this._timers.push(b), b
            },
            removeAll: function() {
                for (var a = 0; a < this._timers.length; a++) this._timers[a].destroy();
                this._timers = [], this.events.removeAll()
            },
            refresh: function() {
                var a = this.time;
                this.time = Date.now(), this.elapsedMS = this.time - a
            },
            update: function(a) {
                var b = this.time;
                this.time = Date.now(), this.elapsedMS = this.time - b, this.prevTime = this.now, this.now = a, this.elapsed = this.now - this.prevTime, this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - a))), this.timeExpected = a + this.timeToCall), this.advancedTiming && this.updateAdvancedTiming(), this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers())
            },
            updateTimers: function() {
                for (var a = 0, b = this._timers.length; a < b;) this._timers[a].update(this.time) ? a++ : (this._timers.splice(a, 1), b--)
            },
            updateAdvancedTiming: function() {
                this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3 && (this.fps = Math.round(1e3 * this.frames / (this.now - this._timeLastSecond)), this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0)
            },
            gamePaused: function() {
                this._pauseStarted = Date.now(), this.events.pause();
                for (var a = this._timers.length; a--;) this._timers[a]._pause()
            },
            gameResumed: function() {
                this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume();
                for (var a = this._timers.length; a--;) this._timers[a]._resume()
            },
            totalElapsedSeconds: function() {
                return .001 * (this.time - this._started)
            },
            elapsedSince: function(a) {
                return this.time - a
            },
            elapsedSecondsSince: function(a) {
                return .001 * (this.time - a)
            },
            reset: function() {
                this._started = this.time, this.removeAll()
            }
        }, Object.defineProperty(c.Time.prototype, "desiredFps", {
            get: function() {
                return this._desiredFps
            },
            set: function(a) {
                this._desiredFps = a, this.physicsElapsed = 1 / a, this.physicsElapsedMS = 1e3 * this.physicsElapsed, this.desiredFpsMult = 1 / a
            }
        }), c.Time.prototype.constructor = c.Time, c.Timer = function(a, b) {
            void 0 === b && (b = !0), this.game = a, this.running = !1, this.autoDestroy = b, this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new c.Signal, this.nextTick = 0, this.timeCap = 1e3, this.paused = !1, this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = Date.now(), this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0
        }, c.Timer.MINUTE = 6e4, c.Timer.SECOND = 1e3, c.Timer.HALF = 500, c.Timer.QUARTER = 250, c.Timer.prototype = {
            create: function(a, b, d, e, f, g) {
                a = Math.round(a);
                var h = a;
                h += 0 === this._now ? this.game.time.time : this._now;
                var i = new c.TimerEvent(this, a, h, d, b, e, f, g);
                return this.events.push(i), this.order(), this.expired = !1, i
            },
            add: function(a, b, c) {
                return this.create(a, !1, 0, b, c, Array.prototype.slice.call(arguments, 3))
            },
            repeat: function(a, b, c, d) {
                return this.create(a, !1, b, c, d, Array.prototype.slice.call(arguments, 4))
            },
            loop: function(a, b, c) {
                return this.create(a, !0, 0, b, c, Array.prototype.slice.call(arguments, 3))
            },
            start: function(a) {
                if (!this.running) {
                    this._started = this.game.time.time + (a || 0), this.running = !0;
                    for (var b = 0; b < this.events.length; b++) this.events[b].tick = this.events[b].delay + this._started
                }
            },
            stop: function(a) {
                this.running = !1, void 0 === a && (a = !0), a && (this.events.length = 0)
            },
            remove: function(a) {
                for (var b = 0; b < this.events.length; b++)
                    if (this.events[b] === a) return this.events[b].pendingDelete = !0, !0;
                return !1
            },
            order: function() {
                this.events.length > 0 && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick)
            },
            sortHandler: function(a, b) {
                return a.tick < b.tick ? -1 : a.tick > b.tick ? 1 : 0
            },
            clearPendingEvents: function() {
                for (this._i = this.events.length; this._i--;) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
                this._len = this.events.length, this._i = 0
            },
            update: function(a) {
                if (this.paused) return !0;
                if (this.elapsed = a - this._now, this._now = a, this.elapsed > this.timeCap && this.adjustEvents(a - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0) {
                    for (; this._i < this._len && this.running && this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete;) this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick), this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay), this.events[this._i].loop === !0 ? (this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : this.events[this._i].repeatCount > 0 ? (this.events[this._i].repeatCount--, this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : (this._marked++, this.events[this._i].pendingDelete = !0, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)), this._i++;
                    this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this))
                }
                return !this.expired || !this.autoDestroy
            },
            pause: function() {
                this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, this.paused = !0))
            },
            _pause: function() {
                !this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0)
            },
            adjustEvents: function(a) {
                for (var b = 0; b < this.events.length; b++)
                    if (!this.events[b].pendingDelete) {
                        var c = this.events[b].tick - a;
                        c < 0 && (c = 0), this.events[b].tick = this._now + c
                    }
                var d = this.nextTick - a;
                d < 0 ? this.nextTick = this._now : this.nextTick = this._now + d
            },
            resume: function() {
                if (this.paused) {
                    var a = this.game.time.time;
                    this._pauseTotal += a - this._now, this._now = a, this.adjustEvents(this._pauseStarted), this.paused = !1, this._codePaused = !1
                }
            },
            _resume: function() {
                this._codePaused || this.resume()
            },
            removeAll: function() {
                this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0
            },
            destroy: function() {
                this.onComplete.removeAll(), this.running = !1, this.events = [], this._len = 0, this._i = 0
            }
        }, Object.defineProperty(c.Timer.prototype, "next", {
            get: function() {
                return this.nextTick
            }
        }), Object.defineProperty(c.Timer.prototype, "duration", {
            get: function() {
                return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0
            }
        }), Object.defineProperty(c.Timer.prototype, "length", {
            get: function() {
                return this.events.length
            }
        }), Object.defineProperty(c.Timer.prototype, "ms", {
            get: function() {
                return this.running ? this._now - this._started - this._pauseTotal : 0
            }
        }), Object.defineProperty(c.Timer.prototype, "seconds", {
            get: function() {
                return this.running ? .001 * this.ms : 0
            }
        }), c.Timer.prototype.constructor = c.Timer, c.TimerEvent = function(a, b, c, d, e, f, g, h) {
            this.timer = a, this.delay = b, this.tick = c, this.repeatCount = d - 1, this.loop = e, this.callback = f, this.callbackContext = g, this.args = h, this.pendingDelete = !1
        }, c.TimerEvent.prototype.constructor = c.TimerEvent, c.AnimationManager = function(a) {
            this.sprite = a, this.game = a.game, this.currentFrame = null, this.currentAnim = null, this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, this._outputFrames = []
        }, c.AnimationManager.prototype = {
            loadFrameData: function(a, b) {
                if (void 0 === a) return !1;
                if (this.isLoaded)
                    for (var c in this._anims) this._anims[c].updateFrameData(a);
                return this._frameData = a, void 0 === b || null === b ? this.frame = 0 : "string" == typeof b ? this.frameName = b : this.frame = b, this.isLoaded = !0, !0
            },
            copyFrameData: function(a, b) {
                if (this._frameData = a.clone(), this.isLoaded)
                    for (var c in this._anims) this._anims[c].updateFrameData(this._frameData);
                return void 0 === b || null === b ? this.frame = 0 : "string" == typeof b ? this.frameName = b : this.frame = b, this.isLoaded = !0, !0
            },
            add: function(a, b, d, e, f) {
                return b = b || [], d = d || 60, void 0 === e && (e = !1), void 0 === f && (f = !(!b || "number" != typeof b[0])), this._outputFrames = [], this._frameData.getFrameIndexes(b, f, this._outputFrames), this._anims[a] = new c.Animation(this.game, this.sprite, a, this._frameData, this._outputFrames, d, e), this.currentAnim = this._anims[a], this.sprite.tilingTexture && (this.sprite.refreshTexture = !0), this._anims[a]
            },
            validateFrames: function(a, b) {
                void 0 === b && (b = !0);
                for (var c = 0; c < a.length; c++)
                    if (b === !0) {
                        if (a[c] > this._frameData.total) return !1
                    } else if (this._frameData.checkFrameName(a[c]) === !1) return !1;
                return !0
            },
            play: function(a, b, c, d) {
                if (this._anims[a]) return this.currentAnim === this._anims[a] ? this.currentAnim.isPlaying === !1 ? (this.currentAnim.paused = !1, this.currentAnim.play(b, c, d)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[a], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(b, c, d))
            },
            stop: function(a, b) {
                void 0 === b && (b = !1), !this.currentAnim || "string" == typeof a && a !== this.currentAnim.name || this.currentAnim.stop(b)
            },
            update: function() {
                return !(this.updateIfVisible && !this.sprite.visible || !this.currentAnim || !this.currentAnim.update() || (this.currentFrame = this.currentAnim.currentFrame, 0))
            },
            next: function(a) {
                this.currentAnim && (this.currentAnim.next(a), this.currentFrame = this.currentAnim.currentFrame)
            },
            previous: function(a) {
                this.currentAnim && (this.currentAnim.previous(a), this.currentFrame = this.currentAnim.currentFrame)
            },
            getAnimation: function(a) {
                return "string" == typeof a && this._anims[a] ? this._anims[a] : null
            },
            refreshFrame: function() {},
            destroy: function() {
                var a = null;
                for (var a in this._anims) this._anims.hasOwnProperty(a) && this._anims[a].destroy();
                this._anims = {}, this._outputFrames = [], this._frameData = null, this.currentAnim = null, this.currentFrame = null, this.sprite = null, this.game = null
            }
        }, c.AnimationManager.prototype.constructor = c.AnimationManager, Object.defineProperty(c.AnimationManager.prototype, "frameData", {
            get: function() {
                return this._frameData
            }
        }), Object.defineProperty(c.AnimationManager.prototype, "frameTotal", {
            get: function() {
                return this._frameData.total
            }
        }), Object.defineProperty(c.AnimationManager.prototype, "paused", {
            get: function() {
                return this.currentAnim.isPaused
            },
            set: function(a) {
                this.currentAnim.paused = a
            }
        }), Object.defineProperty(c.AnimationManager.prototype, "name", {
            get: function() {
                if (this.currentAnim) return this.currentAnim.name
            }
        }), Object.defineProperty(c.AnimationManager.prototype, "frame", {
            get: function() {
                if (this.currentFrame) return this.currentFrame.index
            },
            set: function(a) {
                "number" == typeof a && this._frameData && null !== this._frameData.getFrame(a) && (this.currentFrame = this._frameData.getFrame(a), this.currentFrame && this.sprite.setFrame(this.currentFrame))
            }
        }), Object.defineProperty(c.AnimationManager.prototype, "frameName", {
            get: function() {
                if (this.currentFrame) return this.currentFrame.name
            },
            set: function(a) {
                "string" == typeof a && this._frameData && null !== this._frameData.getFrameByName(a) ? (this.currentFrame = this._frameData.getFrameByName(a), this.currentFrame && (this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame))) : void 0
            }
        }), c.Animation = function(a, b, d, e, f, g, h) {
            void 0 === h && (h = !1), this.game = a, this._parent = b, this._frameData = e, this.name = d, this._frames = [], this._frames = this._frames.concat(f), this.delay = 1e3 / g, this.loop = h, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.onStart = new c.Signal, this.onUpdate = null, this.onComplete = new c.Signal, this.onLoop = new c.Signal, this.isReversed = !1, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this)
        }, c.Animation.prototype = {
            play: function(a, b, c) {
                return "number" == typeof a && (this.delay = 1e3 / a), "boolean" == typeof b && (this.loop = b), "undefined" != typeof c && (this.killOnComplete = c), this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = this.isReversed ? this._frames.length - 1 : 0, this.updateCurrentFrame(!1, !0), this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this
            },
            restart: function() {
                this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this.onStart.dispatch(this._parent, this)
            },
            reverse: function() {
                return this.reversed = !this.reversed, this
            },
            reverseOnce: function() {
                return this.onComplete.addOnce(this.reverse, this), this.reverse()
            },
            setFrame: function(a, b) {
                var c;
                if (void 0 === b && (b = !1), "string" == typeof a)
                    for (var d = 0; d < this._frames.length; d++) this._frameData.getFrame(this._frames[d]).name === a && (c = d);
                else if ("number" == typeof a)
                    if (b) c = a;
                    else
                        for (var d = 0; d < this._frames.length; d++) this._frames[d] === a && (c = d);
                c && (this._frameIndex = c - 1, this._timeNextFrame = this.game.time.time, this.update())
            },
            stop: function(a, b) {
                void 0 === a && (a = !1), void 0 === b && (b = !1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, a && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)), b && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this))
            },
            onPause: function() {
                this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time)
            },
            onResume: function() {
                this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff)
            },
            update: function() {
                return !this.isPaused && !!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1, this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), !1) : this.updateCurrentFrame(!0))
            },
            updateCurrentFrame: function(a, b) {
                if (void 0 === b && (b = !1), !this._frameData) return !1;
                var c = this.currentFrame.index;
                return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (b || !b && c !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame), !this.onUpdate || !a || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)
            },
            next: function(a) {
                void 0 === a && (a = 1);
                var b = this._frameIndex + a;
                b >= this._frames.length && (this.loop ? b %= this._frames.length : b = this._frames.length - 1), b !== this._frameIndex && (this._frameIndex = b, this.updateCurrentFrame(!0))
            },
            previous: function(a) {
                void 0 === a && (a = 1);
                var b = this._frameIndex - a;
                b < 0 && (this.loop ? b = this._frames.length + b : b++), b !== this._frameIndex && (this._frameIndex = b, this.updateCurrentFrame(!0))
            },
            updateFrameData: function(a) {
                this._frameData = a, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null
            },
            destroy: function() {
                this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose())
            },
            complete: function() {
                this._frameIndex = this._frames.length - 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill()
            }
        }, c.Animation.prototype.constructor = c.Animation, Object.defineProperty(c.Animation.prototype, "paused", {
            get: function() {
                return this.isPaused
            },
            set: function(a) {
                this.isPaused = a, a ? this._pauseStartTime = this.game.time.time : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay)
            }
        }), Object.defineProperty(c.Animation.prototype, "reversed", {
            get: function() {
                return this.isReversed
            },
            set: function(a) {
                this.isReversed = a
            }
        }), Object.defineProperty(c.Animation.prototype, "frameTotal", {
            get: function() {
                return this._frames.length
            }
        }), Object.defineProperty(c.Animation.prototype, "frame", {
            get: function() {
                return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
            },
            set: function(a) {
                this.currentFrame = this._frameData.getFrame(this._frames[a]), null !== this.currentFrame && (this._frameIndex = a, this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame))
            }
        }), Object.defineProperty(c.Animation.prototype, "speed", {
            get: function() {
                return 1e3 / this.delay
            },
            set: function(a) {
                a > 0 && (this.delay = 1e3 / a)
            }
        }), Object.defineProperty(c.Animation.prototype, "enableUpdate", {
            get: function() {
                return null !== this.onUpdate
            },
            set: function(a) {
                a && null === this.onUpdate ? this.onUpdate = new c.Signal : a || null === this.onUpdate || (this.onUpdate.dispose(), this.onUpdate = null)
            }
        }), c.Animation.generateFrameNames = function(a, b, d, e, f) {
            void 0 === e && (e = "");
            var g = [],
                h = "";
            if (b < d)
                for (var i = b; i <= d; i++) h = "number" == typeof f ? c.Utils.pad(i.toString(), f, "0", 1) : i.toString(), h = a + h + e, g.push(h);
            else
                for (var i = b; i >= d; i--) h = "number" == typeof f ? c.Utils.pad(i.toString(), f, "0", 1) : i.toString(), h = a + h + e, g.push(h);
            return g
        }, c.Frame = function(a, b, d, e, f, g) {
            this.index = a, this.x = b, this.y = d, this.width = e, this.height = f, this.name = g, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(f / 2), this.distance = c.Math.distance(0, 0, e, f), this.rotated = !1, this.rotationDirection = "cw", this.trimmed = !1, this.sourceSizeW = e, this.sourceSizeH = f, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height
        }, c.Frame.prototype = {
            resize: function(a, b) {
                this.width = a, this.height = b, this.centerX = Math.floor(a / 2), this.centerY = Math.floor(b / 2), this.distance = c.Math.distance(0, 0, a, b), this.sourceSizeW = a, this.sourceSizeH = b, this.right = this.x + a, this.bottom = this.y + b
            },
            setTrim: function(a, b, c, d, e, f, g) {
                this.trimmed = a, a && (this.sourceSizeW = b, this.sourceSizeH = c, this.centerX = Math.floor(b / 2), this.centerY = Math.floor(c / 2), this.spriteSourceSizeX = d, this.spriteSourceSizeY = e, this.spriteSourceSizeW = f, this.spriteSourceSizeH = g)
            },
            clone: function() {
                var a = new c.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
                for (var b in this) this.hasOwnProperty(b) && (a[b] = this[b]);
                return a
            },
            getRect: function(a) {
                return void 0 === a ? a = new c.Rectangle(this.x, this.y, this.width, this.height) : a.setTo(this.x, this.y, this.width, this.height), a
            }
        }, c.Frame.prototype.constructor = c.Frame, c.FrameData = function() {
            this._frames = [], this._frameNames = []
        }, c.FrameData.prototype = {
            addFrame: function(a) {
                return a.index = this._frames.length, this._frames.push(a), "" !== a.name && (this._frameNames[a.name] = a.index), a
            },
            getFrame: function(a) {
                return a >= this._frames.length && (a = 0), this._frames[a]
            },
            getFrameByName: function(a) {
                return "number" == typeof this._frameNames[a] ? this._frames[this._frameNames[a]] : null
            },
            checkFrameName: function(a) {
                return null != this._frameNames[a]
            },
            clone: function() {
                for (var a = new c.FrameData, b = 0; b < this._frames.length; b++) a._frames.push(this._frames[b].clone());
                for (var d in this._frameNames) this._frameNames.hasOwnProperty(d) && a._frameNames.push(this._frameNames[d]);
                return a
            },
            getFrameRange: function(a, b, c) {
                void 0 === c && (c = []);
                for (var d = a; d <= b; d++) c.push(this._frames[d]);
                return c
            },
            getFrames: function(a, b, c) {
                if (void 0 === b && (b = !0), void 0 === c && (c = []), void 0 === a || 0 === a.length)
                    for (var d = 0; d < this._frames.length; d++) c.push(this._frames[d]);
                else
                    for (var d = 0; d < a.length; d++) b ? c.push(this.getFrame(a[d])) : c.push(this.getFrameByName(a[d]));
                return c
            },
            getFrameIndexes: function(a, b, c) {
                if (void 0 === b && (b = !0), void 0 === c && (c = []), void 0 === a || 0 === a.length)
                    for (var d = 0; d < this._frames.length; d++) c.push(this._frames[d].index);
                else
                    for (var d = 0; d < a.length; d++) b && this._frames[a[d]] ? c.push(this._frames[a[d]].index) : this.getFrameByName(a[d]) && c.push(this.getFrameByName(a[d]).index);
                return c
            },
            destroy: function() {
                this._frames = null, this._frameNames = null
            }
        }, c.FrameData.prototype.constructor = c.FrameData, Object.defineProperty(c.FrameData.prototype, "total", {
            get: function() {
                return this._frames.length
            }
        }), c.AnimationParser = {
            spriteSheet: function(a, b, d, e, f, g, h) {
                var i = b;
                if ("string" == typeof b && (i = a.cache.getImage(b)), null === i) return null;
                var j = i.width,
                    k = i.height;
                d <= 0 && (d = Math.floor(-j / Math.min(-1, d))), e <= 0 && (e = Math.floor(-k / Math.min(-1, e)));
                var l = Math.floor((j - g) / (d + h)),
                    m = Math.floor((k - g) / (e + h)),
                    n = l * m;
                if (f !== -1 && (n = f), 0 === j || 0 === k || j < d || k < e || 0 === n) return null;
                for (var o = new c.FrameData, p = g, q = g, r = 0; r < n; r++) o.addFrame(new c.Frame(r, p, q, d, e, "")), p += d + h, p + d > j && (p = g, q += e + h);
                return o
            },
            JSONData: function(a, b) {
                if (b.frames) {
                    for (var d, e = new c.FrameData, f = b.frames, g = 0; g < f.length; g++) d = e.addFrame(new c.Frame(g, f[g].frame.x, f[g].frame.y, f[g].frame.w, f[g].frame.h, f[g].filename)), f[g].trimmed && d.setTrim(f[g].trimmed, f[g].sourceSize.w, f[g].sourceSize.h, f[g].spriteSourceSize.x, f[g].spriteSourceSize.y, f[g].spriteSourceSize.w, f[g].spriteSourceSize.h);
                    return e
                }
            },
            JSONDataPyxel: function(a, b) {
                var d = ["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"];
                if (d.forEach(function(a) {
                    !b[a]
                }), 1 === b.layers.length) {
                    for (var e, f = new c.FrameData, g = b.tileheight, h = b.tilewidth, i = b.layers[0].tiles, j = 0; j < i.length; j++) e = f.addFrame(new c.Frame(j, i[j].x, i[j].y, h, g, "frame_" + j)), e.setTrim(!1);
                    return f
                }
            },
            JSONDataHash: function(a, b) {
                if (b.frames) {
                    var d, e = new c.FrameData,
                        f = b.frames,
                        g = 0;
                    for (var h in f) d = e.addFrame(new c.Frame(g, f[h].frame.x, f[h].frame.y, f[h].frame.w, f[h].frame.h, h)), f[h].trimmed && d.setTrim(f[h].trimmed, f[h].sourceSize.w, f[h].sourceSize.h, f[h].spriteSourceSize.x, f[h].spriteSourceSize.y, f[h].spriteSourceSize.w, f[h].spriteSourceSize.h), g++;
                    return e
                }
            },
            XMLData: function(a, b) {
                if (b.getElementsByTagName("TextureAtlas")) {
                    for (var d, e, f, g, h, i, j, k, l, m, n, o = new c.FrameData, p = b.getElementsByTagName("SubTexture"), q = 0; q < p.length; q++) f = p[q].attributes, e = f.name.value, g = parseInt(f.x.value, 10), h = parseInt(f.y.value, 10), i = parseInt(f.width.value, 10), j = parseInt(f.height.value, 10), k = null, l = null, f.frameX && (k = Math.abs(parseInt(f.frameX.value, 10)), l = Math.abs(parseInt(f.frameY.value, 10)), m = parseInt(f.frameWidth.value, 10), n = parseInt(f.frameHeight.value, 10)), d = o.addFrame(new c.Frame(q, g, h, i, j, e)), null === k && null === l || d.setTrim(!0, i, j, k, l, m, n);
                    return o
                }
            }
        }, c.Cache = function(a) {
            this.game = a, this.autoResolveURL = !1, this._cache = {
                canvas: {},
                image: {},
                texture: {},
                sound: {},
                video: {},
                text: {},
                json: {},
                xml: {},
                physics: {},
                tilemap: {},
                binary: {},
                bitmapData: {},
                bitmapFont: {},
                shader: {},
                renderTexture: {}
            }, this._urlMap = {}, this._urlResolver = new Image, this._urlTemp = null, this.onSoundUnlock = new c.Signal, this._cacheMap = [], this._cacheMap[c.Cache.CANVAS] = this._cache.canvas, this._cacheMap[c.Cache.IMAGE] = this._cache.image, this._cacheMap[c.Cache.TEXTURE] = this._cache.texture, this._cacheMap[c.Cache.SOUND] = this._cache.sound, this._cacheMap[c.Cache.TEXT] = this._cache.text, this._cacheMap[c.Cache.PHYSICS] = this._cache.physics, this._cacheMap[c.Cache.TILEMAP] = this._cache.tilemap, this._cacheMap[c.Cache.BINARY] = this._cache.binary, this._cacheMap[c.Cache.BITMAPDATA] = this._cache.bitmapData, this._cacheMap[c.Cache.BITMAPFONT] = this._cache.bitmapFont, this._cacheMap[c.Cache.JSON] = this._cache.json, this._cacheMap[c.Cache.XML] = this._cache.xml, this._cacheMap[c.Cache.VIDEO] = this._cache.video, this._cacheMap[c.Cache.SHADER] = this._cache.shader, this._cacheMap[c.Cache.RENDER_TEXTURE] = this._cache.renderTexture, this.addDefaultImage(), this.addMissingImage()
        }, c.Cache.CANVAS = 1, c.Cache.IMAGE = 2, c.Cache.TEXTURE = 3, c.Cache.SOUND = 4, c.Cache.TEXT = 5, c.Cache.PHYSICS = 6, c.Cache.TILEMAP = 7, c.Cache.BINARY = 8, c.Cache.BITMAPDATA = 9, c.Cache.BITMAPFONT = 10, c.Cache.JSON = 11, c.Cache.XML = 12, c.Cache.VIDEO = 13, c.Cache.SHADER = 14, c.Cache.RENDER_TEXTURE = 15, c.Cache.DEFAULT = null, c.Cache.MISSING = null, c.Cache.prototype = {
            addCanvas: function(a, b, c) {
                void 0 === c && (c = b.getContext("2d")), this._cache.canvas[a] = {
                    canvas: b,
                    context: c
                }
            },
            addImage: function(a, b, d) {
                this.checkImageKey(a) && this.removeImage(a);
                var e = {
                    key: a,
                    url: b,
                    data: d,
                    base: new PIXI.BaseTexture(d),
                    frame: new c.Frame(0, 0, 0, d.width, d.height, a),
                    frameData: new c.FrameData
                };
                return e.frameData.addFrame(new c.Frame(0, 0, 0, d.width, d.height, b)), this._cache.image[a] = e, this._resolveURL(b, e), "__default" === a ? c.Cache.DEFAULT = new PIXI.Texture(e.base) : "__missing" === a && (c.Cache.MISSING = new PIXI.Texture(e.base)), e
            },
            addDefaultImage: function() {
                var a = new Image;
                a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
                var b = this.addImage("__default", null, a);
                b.base.skipRender = !0, c.Cache.DEFAULT = new PIXI.Texture(b.base)
            },
            addMissingImage: function() {
                var a = new Image;
                a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
                var b = this.addImage("__missing", null, a);
                c.Cache.MISSING = new PIXI.Texture(b.base)
            },
            addSound: function(a, b, c, d, e) {
                void 0 === d && (d = !0, e = !1), void 0 === e && (d = !1, e = !0);
                var f = !1;
                e && (f = !0), this._cache.sound[a] = {
                    url: b,
                    data: c,
                    isDecoding: !1,
                    decoded: f,
                    webAudio: d,
                    audioTag: e,
                    locked: this.game.sound.touchLocked
                }, this._resolveURL(b, this._cache.sound[a])
            },
            addText: function(a, b, c) {
                this._cache.text[a] = {
                    url: b,
                    data: c
                }, this._resolveURL(b, this._cache.text[a])
            },
            addPhysicsData: function(a, b, c, d) {
                this._cache.physics[a] = {
                    url: b,
                    data: c,
                    format: d
                }, this._resolveURL(b, this._cache.physics[a])
            },
            addTilemap: function(a, b, c, d) {
                this._cache.tilemap[a] = {
                    url: b,
                    data: c,
                    format: d
                }, this._resolveURL(b, this._cache.tilemap[a])
            },
            addBinary: function(a, b) {
                this._cache.binary[a] = b
            },
            addBitmapData: function(a, b, d) {
                return b.key = a, void 0 === d && (d = new c.FrameData, d.addFrame(b.textureFrame)), this._cache.bitmapData[a] = {
                    data: b,
                    frameData: d
                }, b
            },
            addBitmapFont: function(a, b, d, e, f, g, h) {
                var i = {
                    url: b,
                    data: d,
                    font: null,
                    base: new PIXI.BaseTexture(d)
                };
                void 0 === g && (g = 0), void 0 === h && (h = 0), "json" === f ? i.font = c.LoaderParser.jsonBitmapFont(e, i.base, g, h) : i.font = c.LoaderParser.xmlBitmapFont(e, i.base, g, h), this._cache.bitmapFont[a] = i, this._resolveURL(b, i)
            },
            addJSON: function(a, b, c) {
                this._cache.json[a] = {
                    url: b,
                    data: c
                }, this._resolveURL(b, this._cache.json[a])
            },
            addXML: function(a, b, c) {
                this._cache.xml[a] = {
                    url: b,
                    data: c
                }, this._resolveURL(b, this._cache.xml[a])
            },
            addVideo: function(a, b, c, d) {
                this._cache.video[a] = {
                    url: b,
                    data: c,
                    isBlob: d,
                    locked: !0
                }, this._resolveURL(b, this._cache.video[a])
            },
            addShader: function(a, b, c) {
                this._cache.shader[a] = {
                    url: b,
                    data: c
                }, this._resolveURL(b, this._cache.shader[a])
            },
            addRenderTexture: function(a, b) {
                this._cache.renderTexture[a] = {
                    texture: b,
                    frame: new c.Frame(0, 0, 0, b.width, b.height, "", "")
                }
            },
            addSpriteSheet: function(a, b, d, e, f, g, h, i) {
                void 0 === g && (g = -1), void 0 === h && (h = 0), void 0 === i && (i = 0);
                var j = {
                    key: a,
                    url: b,
                    data: d,
                    frameWidth: e,
                    frameHeight: f,
                    margin: h,
                    spacing: i,
                    base: new PIXI.BaseTexture(d),
                    frameData: c.AnimationParser.spriteSheet(this.game, d, e, f, g, h, i)
                };
                this._cache.image[a] = j, this._resolveURL(b, j)
            },
            addTextureAtlas: function(a, b, d, e, f) {
                var g = {
                    key: a,
                    url: b,
                    data: d,
                    base: new PIXI.BaseTexture(d)
                };
                f === c.Loader.TEXTURE_ATLAS_XML_STARLING ? g.frameData = c.AnimationParser.XMLData(this.game, e, a) : f === c.Loader.TEXTURE_ATLAS_JSON_PYXEL ? g.frameData = c.AnimationParser.JSONDataPyxel(this.game, e, a) : Array.isArray(e.frames) ? g.frameData = c.AnimationParser.JSONData(this.game, e, a) : g.frameData = c.AnimationParser.JSONDataHash(this.game, e, a), this._cache.image[a] = g, this._resolveURL(b, g)
            },
            reloadSound: function(a) {
                var b = this,
                    c = this.getSound(a);
                c && (c.data.src = c.url, c.data.addEventListener("canplaythrough", function() {
                    return b.reloadSoundComplete(a)
                }, !1), c.data.load())
            },
            reloadSoundComplete: function(a) {
                var b = this.getSound(a);
                b && (b.locked = !1, this.onSoundUnlock.dispatch(a))
            },
            updateSound: function(a, b, c) {
                var d = this.getSound(a);
                d && (d[b] = c)
            },
            decodedSound: function(a, b) {
                var c = this.getSound(a);
                c.data = b, c.decoded = !0, c.isDecoding = !1
            },
            isSoundDecoded: function(a) {
                var b = this.getItem(a, c.Cache.SOUND, "isSoundDecoded");
                if (b) return b.decoded
            },
            isSoundReady: function(a) {
                var b = this.getItem(a, c.Cache.SOUND, "isSoundDecoded");
                if (b) return b.decoded && !this.game.sound.touchLocked
            },
            checkKey: function(a, b) {
                return !!this._cacheMap[a][b]
            },
            checkURL: function(a) {
                return !!this._urlMap[this._resolveURL(a)]
            },
            checkCanvasKey: function(a) {
                return this.checkKey(c.Cache.CANVAS, a)
            },
            checkImageKey: function(a) {
                return this.checkKey(c.Cache.IMAGE, a)
            },
            checkTextureKey: function(a) {
                return this.checkKey(c.Cache.TEXTURE, a)
            },
            checkSoundKey: function(a) {
                return this.checkKey(c.Cache.SOUND, a)
            },
            checkTextKey: function(a) {
                return this.checkKey(c.Cache.TEXT, a)
            },
            checkPhysicsKey: function(a) {
                return this.checkKey(c.Cache.PHYSICS, a)
            },
            checkTilemapKey: function(a) {
                return this.checkKey(c.Cache.TILEMAP, a)
            },
            checkBinaryKey: function(a) {
                return this.checkKey(c.Cache.BINARY, a)
            },
            checkBitmapDataKey: function(a) {
                return this.checkKey(c.Cache.BITMAPDATA, a)
            },
            checkBitmapFontKey: function(a) {
                return this.checkKey(c.Cache.BITMAPFONT, a)
            },
            checkJSONKey: function(a) {
                return this.checkKey(c.Cache.JSON, a)
            },
            checkXMLKey: function(a) {
                return this.checkKey(c.Cache.XML, a)
            },
            checkVideoKey: function(a) {
                return this.checkKey(c.Cache.VIDEO, a)
            },
            checkShaderKey: function(a) {
                return this.checkKey(c.Cache.SHADER, a)
            },
            checkRenderTextureKey: function(a) {
                return this.checkKey(c.Cache.RENDER_TEXTURE, a)
            },
            getItem: function(a, b, c, d) {
                return this.checkKey(b, a) ? void 0 === d ? this._cacheMap[b][a] : this._cacheMap[b][a][d] : null
            },
            getCanvas: function(a) {
                return this.getItem(a, c.Cache.CANVAS, "getCanvas", "canvas")
            },
            getImage: function(a, b) {
                void 0 !== a && null !== a || (a = "__default"), void 0 === b && (b = !1);
                var d = this.getItem(a, c.Cache.IMAGE, "getImage");
                return null === d && (d = this.getItem("__missing", c.Cache.IMAGE, "getImage")), b ? d : d.data
            },
            getTextureFrame: function(a) {
                return this.getItem(a, c.Cache.TEXTURE, "getTextureFrame", "frame")
            },
            getSound: function(a) {
                return this.getItem(a, c.Cache.SOUND, "getSound")
            },
            getSoundData: function(a) {
                return this.getItem(a, c.Cache.SOUND, "getSoundData", "data")
            },
            getText: function(a) {
                return this.getItem(a, c.Cache.TEXT, "getText", "data")
            },
            getPhysicsData: function(a, b, d) {
                var e = this.getItem(a, c.Cache.PHYSICS, "getPhysicsData", "data");
                if (null === e || void 0 === b || null === b) return e;
                if (e[b]) {
                    var f = e[b];
                    if (!f || !d) return f;
                    for (var g in f)
                        if (g = f[g], g.fixtureKey === d) return g
                }
                return null
            },
            getTilemapData: function(a) {
                return this.getItem(a, c.Cache.TILEMAP, "getTilemapData")
            },
            getBinary: function(a) {
                return this.getItem(a, c.Cache.BINARY, "getBinary")
            },
            getBitmapData: function(a) {
                return this.getItem(a, c.Cache.BITMAPDATA, "getBitmapData", "data")
            },
            getBitmapFont: function(a) {
                return this.getItem(a, c.Cache.BITMAPFONT, "getBitmapFont")
            },
            getJSON: function(a, b) {
                var d = this.getItem(a, c.Cache.JSON, "getJSON", "data");
                return d ? b ? c.Utils.extend(!0, Array.isArray(d) ? [] : {}, d) : d : null
            },
            getXML: function(a) {
                return this.getItem(a, c.Cache.XML, "getXML", "data")
            },
            getVideo: function(a) {
                return this.getItem(a, c.Cache.VIDEO, "getVideo")
            },
            getShader: function(a) {
                return this.getItem(a, c.Cache.SHADER, "getShader", "data")
            },
            getRenderTexture: function(a) {
                return this.getItem(a, c.Cache.RENDER_TEXTURE, "getRenderTexture")
            },
            getBaseTexture: function(a, b) {
                return void 0 === b && (b = c.Cache.IMAGE), this.getItem(a, b, "getBaseTexture", "base")
            },
            getFrame: function(a, b) {
                return void 0 === b && (b = c.Cache.IMAGE), this.getItem(a, b, "getFrame", "frame")
            },
            getFrameCount: function(a, b) {
                var c = this.getFrameData(a, b);
                return c ? c.total : 0
            },
            getFrameData: function(a, b) {
                return void 0 === b && (b = c.Cache.IMAGE), this.getItem(a, b, "getFrameData", "frameData")
            },
            hasFrameData: function(a, b) {
                return void 0 === b && (b = c.Cache.IMAGE), null !== this.getItem(a, b, "", "frameData")
            },
            updateFrameData: function(a, b, d) {
                void 0 === d && (d = c.Cache.IMAGE), this._cacheMap[d][a] && (this._cacheMap[d][a].frameData = b)
            },
            getFrameByIndex: function(a, b, c) {
                var d = this.getFrameData(a, c);
                return d ? d.getFrame(b) : null
            },
            getFrameByName: function(a, b, c) {
                var d = this.getFrameData(a, c);
                return d ? d.getFrameByName(b) : null
            },
            getURL: function(a) {
                var a = this._resolveURL(a);
                return a ? this._urlMap[a] : null
            },
            getKeys: function(a) {
                void 0 === a && (a = c.Cache.IMAGE);
                var b = [];
                if (this._cacheMap[a])
                    for (var d in this._cacheMap[a]) "__default" !== d && "__missing" !== d && b.push(d);
                return b
            },
            removeCanvas: function(a) {
                delete this._cache.canvas[a]
            },
            removeImage: function(a, b) {
                void 0 === b && (b = !0);
                var c = this.getImage(a, !0);
                b && c.base && c.base.destroy(), delete this._cache.image[a]
            },
            removeSound: function(a) {
                delete this._cache.sound[a]
            },
            removeText: function(a) {
                delete this._cache.text[a]
            },
            removePhysics: function(a) {
                delete this._cache.physics[a]
            },
            removeTilemap: function(a) {
                delete this._cache.tilemap[a]
            },
            removeBinary: function(a) {
                delete this._cache.binary[a]
            },
            removeBitmapData: function(a) {
                delete this._cache.bitmapData[a]
            },
            removeBitmapFont: function(a) {
                delete this._cache.bitmapFont[a]
            },
            removeJSON: function(a) {
                delete this._cache.json[a]
            },
            removeXML: function(a) {
                delete this._cache.xml[a]
            },
            removeVideo: function(a) {
                delete this._cache.video[a]
            },
            removeShader: function(a) {
                delete this._cache.shader[a]
            },
            removeRenderTexture: function(a) {
                delete this._cache.renderTexture[a]
            },
            removeSpriteSheet: function(a) {
                delete this._cache.spriteSheet[a]
            },
            removeTextureAtlas: function(a) {
                delete this._cache.atlas[a]
            },
            clearGLTextures: function() {
                for (var a in this._cache.image) this._cache.image[a].base._glTextures = []
            },
            _resolveURL: function(a, b) {
                return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + a, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", b && (this._urlMap[this._urlTemp] = b), this._urlTemp) : null
            },
            destroy: function() {
                for (var a = 0; a < this._cacheMap.length; a++) {
                    var b = this._cacheMap[a];
                    for (var c in b) "__default" !== c && "__missing" !== c && (b[c].destroy && b[c].destroy(), delete b[c])
                }
                this._urlMap = null, this._urlResolver = null, this._urlTemp = null
            }
        }, c.Cache.prototype.constructor = c.Cache, c.Loader = function(a) {
            this.game = a, this.cache = a.cache, this.resetLocked = !1, this.isLoading = !1, this.hasLoaded = !1, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.path = "", this.headers = {
                requestedWith: !1,
                json: "application/json",
                xml: "application/xml"
            }, this.onLoadStart = new c.Signal, this.onLoadComplete = new c.Signal, this.onPackComplete = new c.Signal, this.onFileStart = new c.Signal, this.onFileComplete = new c.Signal, this.onFileError = new c.Signal, this.useXDomainRequest = !1, this._warnedAboutXDomainRequest = !1, this.enableParallel = !0, this.maxParallelDownloads = 4, this._withSyncPointDepth = 0, this._fileList = [], this._flightQueue = [], this._processingHead = 0, this._fileLoadStarted = !1, this._totalPackCount = 0, this._totalFileCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0
        }, c.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, c.Loader.TEXTURE_ATLAS_JSON_HASH = 1, c.Loader.TEXTURE_ATLAS_XML_STARLING = 2, c.Loader.PHYSICS_LIME_CORONA_JSON = 3, c.Loader.PHYSICS_PHASER_JSON = 4, c.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5, c.Loader.prototype = {
            setPreloadSprite: function(a, b) {
                b = b || 0, this.preloadSprite = {
                    sprite: a,
                    direction: b,
                    width: a.width,
                    height: a.height,
                    rect: null
                }, 0 === b ? this.preloadSprite.rect = new c.Rectangle(0, 0, 1, a.height) : this.preloadSprite.rect = new c.Rectangle(0, 0, a.width, 1), a.crop(this.preloadSprite.rect), a.visible = !0
            },
            resize: function() {
                this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height)
            },
            checkKeyExists: function(a, b) {
                return this.getAssetIndex(a, b) > -1
            },
            getAssetIndex: function(a, b) {
                for (var c = -1, d = 0; d < this._fileList.length; d++) {
                    var e = this._fileList[d];
                    if (e.type === a && e.key === b && (c = d, !e.loaded && !e.loading)) break
                }
                return c
            },
            getAsset: function(a, b) {
                var c = this.getAssetIndex(a, b);
                return c > -1 && {
                    index: c,
                    file: this._fileList[c]
                }
            },
            reset: function(a, b) {
                void 0 === b && (b = !1), this.resetLocked || (a && (this.preloadSprite = null), this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0, b && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll()))
            },
            addToFileList: function(a, b, c, d, e, f) {
                if (void 0 === e && (e = !1), void 0 === b || "" === b) return this;
                if (void 0 === c || null === c) {
                    if (!f) return this;
                    c = b + f
                }
                var g = {
                    type: a,
                    key: b,
                    path: this.path,
                    url: c,
                    syncPoint: this._withSyncPointDepth > 0,
                    data: null,
                    loading: !1,
                    loaded: !1,
                    error: !1
                };
                if (d)
                    for (var h in d) g[h] = d[h];
                var i = this.getAssetIndex(a, b);
                if (e && i > -1) {
                    var j = this._fileList[i];
                    j.loading || j.loaded ? (this._fileList.push(g), this._totalFileCount++) : this._fileList[i] = g
                } else i === -1 && (this._fileList.push(g), this._totalFileCount++);
                return this
            },
            replaceInFileList: function(a, b, c, d) {
                return this.addToFileList(a, b, c, d, !0)
            },
            pack: function(a, b, c, d) {
                if (void 0 === b && (b = null), void 0 === c && (c = null), void 0 === d && (d = null), !b && !c) return this;
                var e = {
                    type: "packfile",
                    key: a,
                    url: b,
                    path: this.path,
                    syncPoint: !0,
                    data: null,
                    loading: !1,
                    loaded: !1,
                    error: !1,
                    callbackContext: d
                };
                c && ("string" == typeof c && (c = JSON.parse(c)), e.data = c || {}, e.loaded = !0);
                for (var f = 0; f < this._fileList.length + 1; f++) {
                    var g = this._fileList[f];
                    if (!g || !g.loaded && !g.loading && "packfile" !== g.type) {
                        this._fileList.splice(f, 0, e), this._totalPackCount++;
                        break
                    }
                }
                return this
            },
            image: function(a, b, c) {
                return this.addToFileList("image", a, b, void 0, c, ".png")
            },
            images: function(a, b) {
                if (Array.isArray(b))
                    for (var c = 0; c < a.length; c++) this.image(a[c], b[c]);
                else
                    for (var c = 0; c < a.length; c++) this.image(a[c]);
                return this
            },
            text: function(a, b, c) {
                return this.addToFileList("text", a, b, void 0, c, ".txt")
            },
            json: function(a, b, c) {
                return this.addToFileList("json", a, b, void 0, c, ".json")
            },
            shader: function(a, b, c) {
                return this.addToFileList("shader", a, b, void 0, c, ".frag")
            },
            xml: function(a, b, c) {
                return this.addToFileList("xml", a, b, void 0, c, ".xml")
            },
            script: function(a, b, c, d) {
                return void 0 === c && (c = !1), c !== !1 && void 0 === d && (d = this), this.addToFileList("script", a, b, {
                    syncPoint: !0,
                    callback: c,
                    callbackContext: d
                }, !1, ".js")
            },
            binary: function(a, b, c, d) {
                return void 0 === c && (c = !1), c !== !1 && void 0 === d && (d = c), this.addToFileList("binary", a, b, {
                    callback: c,
                    callbackContext: d
                }, !1, ".bin")
            },
            spritesheet: function(a, b, c, d, e, f, g) {
                return void 0 === e && (e = -1), void 0 === f && (f = 0), void 0 === g && (g = 0), this.addToFileList("spritesheet", a, b, {
                    frameWidth: c,
                    frameHeight: d,
                    frameMax: e,
                    margin: f,
                    spacing: g
                }, !1, ".png")
            },
            audio: function(a, b, c) {
                return this.game.sound.noAudio ? this : (void 0 === c && (c = !0), "string" == typeof b && (b = [b]), this.addToFileList("audio", a, b, {
                    buffer: null,
                    autoDecode: c
                }))
            },
            audioSprite: function(a, b, c, d, e) {
                return this.game.sound.noAudio ? this : (void 0 === c && (c = null), void 0 === d && (d = null), void 0 === e && (e = !0), this.audio(a, b, e), c ? this.json(a + "-audioatlas", c) : d ? ("string" == typeof d && (d = JSON.parse(d)), this.cache.addJSON(a + "-audioatlas", "", d)) : void 0, this)
            },
            audiosprite: function(a, b, c, d, e) {
                return this.audioSprite(a, b, c, d, e)
            },
            video: function(a, b, c, d) {
                return void 0 === c && (c = this.game.device.firefox ? "loadeddata" : "canplaythrough"), void 0 === d && (d = !1), "string" == typeof b && (b = [b]), this.addToFileList("video", a, b, {
                    buffer: null,
                    asBlob: d,
                    loadEvent: c
                })
            },
            tilemap: function(a, b, d, e) {
                if (void 0 === b && (b = null), void 0 === d && (d = null), void 0 === e && (e = c.Tilemap.CSV), b || d || (b = e === c.Tilemap.CSV ? a + ".csv" : a + ".json"), d) {
                    switch (e) {
                        case c.Tilemap.CSV:
                            break;
                        case c.Tilemap.TILED_JSON:
                            "string" == typeof d && (d = JSON.parse(d))
                    }
                    this.cache.addTilemap(a, null, d, e)
                } else this.addToFileList("tilemap", a, b, {
                    format: e
                });
                return this
            },
            physics: function(a, b, d, e) {
                return void 0 === b && (b = null), void 0 === d && (d = null), void 0 === e && (e = c.Physics.LIME_CORONA_JSON), b || d || (b = a + ".json"), d ? ("string" == typeof d && (d = JSON.parse(d)), this.cache.addPhysicsData(a, null, d, e)) : this.addToFileList("physics", a, b, {
                    format: e
                }), this
            },
            bitmapFont: function(a, b, c, d, e, f) {
                if (void 0 !== b && null !== b || (b = a + ".png"), void 0 === c && (c = null), void 0 === d && (d = null), null === c && null === d && (c = a + ".xml"), void 0 === e && (e = 0), void 0 === f && (f = 0), c) this.addToFileList("bitmapfont", a, b, {
                    atlasURL: c,
                    xSpacing: e,
                    ySpacing: f
                });
                else if ("string" == typeof d) {
                    var g, h;
                    try {
                        g = JSON.parse(d)
                    } catch (a) {
                        h = this.parseXml(d)
                    }
                    if (!h && !g) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                    this.addToFileList("bitmapfont", a, b, {
                        atlasURL: null,
                        atlasData: g || h,
                        atlasType: g ? "json" : "xml",
                        xSpacing: e,
                        ySpacing: f
                    })
                }
                return this
            },
            atlasJSONArray: function(a, b, d, e) {
                return this.atlas(a, b, d, e, c.Loader.TEXTURE_ATLAS_JSON_ARRAY)
            },
            atlasJSONHash: function(a, b, d, e) {
                return this.atlas(a, b, d, e, c.Loader.TEXTURE_ATLAS_JSON_HASH)
            },
            atlasXML: function(a, b, d, e) {
                return void 0 === d && (d = null), void 0 === e && (e = null), d || e || (d = a + ".xml"), this.atlas(a, b, d, e, c.Loader.TEXTURE_ATLAS_XML_STARLING)
            },
            atlas: function(a, b, d, e, f) {
                if (void 0 !== b && null !== b || (b = a + ".png"), void 0 === d && (d = null), void 0 === e && (e = null), void 0 === f && (f = c.Loader.TEXTURE_ATLAS_JSON_ARRAY), d || e || (d = f === c.Loader.TEXTURE_ATLAS_XML_STARLING ? a + ".xml" : a + ".json"), d) this.addToFileList("textureatlas", a, b, {
                    atlasURL: d,
                    format: f
                });
                else {
                    switch (f) {
                        case c.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                            "string" == typeof e && (e = JSON.parse(e));
                            break;
                        case c.Loader.TEXTURE_ATLAS_XML_STARLING:
                            if ("string" == typeof e) {
                                var g = this.parseXml(e);
                                if (!g) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                                e = g
                            }
                    }
                    this.addToFileList("textureatlas", a, b, {
                        atlasURL: null,
                        atlasData: e,
                        format: f
                    })
                }
                return this
            },
            withSyncPoint: function(a, b) {
                this._withSyncPointDepth++;
                try {
                    a.call(b || this, this)
                } finally {
                    this._withSyncPointDepth--
                }
                return this
            },
            addSyncPoint: function(a, b) {
                var c = this.getAsset(a, b);
                return c && (c.file.syncPoint = !0), this
            },
            removeFile: function(a, b) {
                var c = this.getAsset(a, b);
                c && (c.loaded || c.loading || this._fileList.splice(c.index, 1))
            },
            removeAll: function() {
                this._fileList.length = 0, this._flightQueue.length = 0
            },
            start: function() {
                this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), this.processLoadQueue())
            },
            processLoadQueue: function() {
                if (!this.isLoading) return void this.finishedLoading(!0);
                for (var a = 0; a < this._flightQueue.length; a++) {
                    var b = this._flightQueue[a];
                    (b.loaded || b.error) && (this._flightQueue.splice(a, 1), a--, b.loading = !1, b.requestUrl = null, b.requestObject = null, b.error && this.onFileError.dispatch(b.key, b), "packfile" !== b.type ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, b.key, !b.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === b.type && b.error && (this._loadedPackCount++, this.onPackComplete.dispatch(b.key, !b.error, this._loadedPackCount, this._totalPackCount)))
                }
                for (var d = !1, e = this.enableParallel ? c.Math.clamp(this.maxParallelDownloads, 1, 12) : 1, a = this._processingHead; a < this._fileList.length; a++) {
                    var b = this._fileList[a];
                    if ("packfile" === b.type && !b.error && b.loaded && a === this._processingHead && (this.processPack(b), this._loadedPackCount++, this.onPackComplete.dispatch(b.key, !b.error, this._loadedPackCount, this._totalPackCount)), b.loaded || b.error ? a === this._processingHead && (this._processingHead = a + 1) : !b.loading && this._flightQueue.length < e && ("packfile" !== b.type || b.data ? d || (this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this._flightQueue.push(b), b.loading = !0, this.onFileStart.dispatch(this.progress, b.key, b.url), this.loadFile(b)) : (this._flightQueue.push(b), b.loading = !0, this.loadFile(b))), !b.loaded && b.syncPoint && (d = !0), this._flightQueue.length >= e || d && this._loadedPackCount === this._totalPackCount) break
                }
                if (this.updateProgress(), this._processingHead >= this._fileList.length) this.finishedLoading();
                else if (!this._flightQueue.length) {
                    var f = this;
                    setTimeout(function() {
                        f.finishedLoading(!0)
                    }, 2e3)
                }
            },
            finishedLoading: function(a) {
                this.hasLoaded || (this.hasLoaded = !0, this.isLoading = !1, a || this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this.onLoadComplete.dispatch(), this.game.state.loadComplete(), this.reset())
            },
            asyncComplete: function(a, b) {
                void 0 === b && (b = ""), a.loaded = !0, a.error = !!b, b && void(a.errorMessage = b), this.processLoadQueue()
            },
            processPack: function(a) {
                var b = a.data[a.key];
                if (b)
                    for (var d = 0; d < b.length; d++) {
                        var e = b[d];
                        switch (e.type) {
                            case "image":
                                this.image(e.key, e.url, e.overwrite);
                                break;
                            case "text":
                                this.text(e.key, e.url, e.overwrite);
                                break;
                            case "json":
                                this.json(e.key, e.url, e.overwrite);
                                break;
                            case "xml":
                                this.xml(e.key, e.url, e.overwrite);
                                break;
                            case "script":
                                this.script(e.key, e.url, e.callback, a.callbackContext || this);
                                break;
                            case "binary":
                                this.binary(e.key, e.url, e.callback, a.callbackContext || this);
                                break;
                            case "spritesheet":
                                this.spritesheet(e.key, e.url, e.frameWidth, e.frameHeight, e.frameMax, e.margin, e.spacing);
                                break;
                            case "video":
                                this.video(e.key, e.urls);
                                break;
                            case "audio":
                                this.audio(e.key, e.urls, e.autoDecode);
                                break;
                            case "audiosprite":
                                this.audiosprite(e.key, e.urls, e.jsonURL, e.jsonData, e.autoDecode);
                                break;
                            case "tilemap":
                                this.tilemap(e.key, e.url, e.data, c.Tilemap[e.format]);
                                break;
                            case "physics":
                                this.physics(e.key, e.url, e.data, c.Loader[e.format]);
                                break;
                            case "bitmapFont":
                                this.bitmapFont(e.key, e.textureURL, e.atlasURL, e.atlasData, e.xSpacing, e.ySpacing);
                                break;
                            case "atlasJSONArray":
                                this.atlasJSONArray(e.key, e.textureURL, e.atlasURL, e.atlasData);
                                break;
                            case "atlasJSONHash":
                                this.atlasJSONHash(e.key, e.textureURL, e.atlasURL, e.atlasData);
                                break;
                            case "atlasXML":
                                this.atlasXML(e.key, e.textureURL, e.atlasURL, e.atlasData);
                                break;
                            case "atlas":
                                this.atlas(e.key, e.textureURL, e.atlasURL, e.atlasData, c.Loader[e.format]);
                                break;
                            case "shader":
                                this.shader(e.key, e.url, e.overwrite)
                        }
                    }
            },
            transformUrl: function(a, b) {
                return !!a && (a.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? a : this.baseURL + b.path + a)
            },
            loadFile: function(a) {
                switch (a.type) {
                    case "packfile":
                        this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.fileComplete);
                        break;
                    case "image":
                    case "spritesheet":
                    case "textureatlas":
                    case "bitmapfont":
                        this.loadImageTag(a);
                        break;
                    case "audio":
                        a.url = this.getAudioURL(a.url), a.url ? this.game.sound.usingWebAudio ? this.xhrLoad(a, this.transformUrl(a.url, a), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(a) : this.fileError(a, null, "No supported audio URL specified or device does not have audio playback support");
                        break;
                    case "video":
                        a.url = this.getVideoURL(a.url), a.url ? a.asBlob ? this.xhrLoad(a, this.transformUrl(a.url, a), "blob", this.fileComplete) : this.loadVideoTag(a) : this.fileError(a, null, "No supported video URL specified or device does not have video playback support");
                        break;
                    case "json":
                        this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.jsonLoadComplete);
                        break;
                    case "xml":
                        this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.xmlLoadComplete);
                        break;
                    case "tilemap":
                        a.format === c.Tilemap.TILED_JSON ? this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.jsonLoadComplete) : a.format === c.Tilemap.CSV ? this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.csvLoadComplete) : this.asyncComplete(a, "invalid Tilemap format: " + a.format);
                        break;
                    case "text":
                    case "script":
                    case "shader":
                    case "physics":
                        this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.fileComplete);
                        break;
                    case "binary":
                        this.xhrLoad(a, this.transformUrl(a.url, a), "arraybuffer", this.fileComplete)
                }
            },
            loadImageTag: function(a) {
                var b = this;
                a.data = new Image, a.data.name = a.key, this.crossOrigin && (a.data.crossOrigin = this.crossOrigin), a.data.onload = function() {
                    a.data.onload && (a.data.onload = null, a.data.onerror = null, b.fileComplete(a))
                }, a.data.onerror = function() {
                    a.data.onload && (a.data.onload = null, a.data.onerror = null, b.fileError(a))
                }, a.data.src = this.transformUrl(a.url, a), a.data.complete && a.data.width && a.data.height && (a.data.onload = null, a.data.onerror = null, this.fileComplete(a))
            },
            loadVideoTag: function(a) {
                var b = this;
                a.data = document.createElement("video"), a.data.name = a.key, a.data.controls = !1, a.data.autoplay = !1;
                var d = function() {
                    a.data.removeEventListener(a.loadEvent, d, !1), a.data.onerror = null, a.data.canplay = !0, c.GAMES[b.game.id].load.fileComplete(a)
                };
                a.data.onerror = function() {
                    a.data.removeEventListener(a.loadEvent, d, !1), a.data.onerror = null, a.data.canplay = !1, b.fileError(a)
                }, a.data.addEventListener(a.loadEvent, d, !1), a.data.src = this.transformUrl(a.url, a), a.data.load()
            },
            loadAudioTag: function(a) {
                var b = this;
                if (this.game.sound.touchLocked) a.data = new Audio, a.data.name = a.key, a.data.preload = "auto", a.data.src = this.transformUrl(a.url, a), this.fileComplete(a);
                else {
                    a.data = new Audio, a.data.name = a.key;
                    var c = function() {
                        a.data.removeEventListener("canplaythrough", c, !1), a.data.onerror = null, b.fileComplete(a)
                    };
                    a.data.onerror = function() {
                        a.data.removeEventListener("canplaythrough", c, !1), a.data.onerror = null, b.fileError(a)
                    }, a.data.preload = "auto", a.data.src = this.transformUrl(a.url, a), a.data.addEventListener("canplaythrough", c, !1), a.data.load()
                }
            },
            xhrLoad: function(a, b, c, d, e) {
                if (this.useXDomainRequest && window.XDomainRequest) return void this.xhrLoadWithXDR(a, b, c, d, e);
                var f = new XMLHttpRequest;
                f.open("GET", b, !0), f.responseType = c, this.headers.requestedWith !== !1 && f.setRequestHeader("X-Requested-With", this.headers.requestedWith), this.headers[a.type] && f.setRequestHeader("Accept", this.headers[a.type]), e = e || this.fileError;
                var g = this;
                f.onload = function() {
                    try {
                        return 4 === f.readyState && f.status >= 400 && f.status <= 599 ? e.call(g, a, f) : d.call(g, a, f)
                    } catch (b) {
                        g.hasLoaded ? window.console && void 0 : g.asyncComplete(a, b.message || "Exception")
                    }
                }, f.onerror = function() {
                    try {
                        return e.call(g, a, f)
                    } catch (b) {
                        g.hasLoaded ? window.console && void 0 : g.asyncComplete(a, b.message || "Exception")
                    }
                }, a.requestObject = f, a.requestUrl = b, f.send()
            },
            xhrLoadWithXDR: function(a, b, c, d, e) {
                this._warnedAboutXDomainRequest || this.game.device.ie && !(this.game.device.ieVersion >= 10) || void(this._warnedAboutXDomainRequest = !0);
                var f = new window.XDomainRequest;
                f.open("GET", b, !0), f.responseType = c, f.timeout = 3e3, e = e || this.fileError;
                var g = this;
                f.onerror = function() {
                    try {
                        return e.call(g, a, f)
                    } catch (b) {
                        g.asyncComplete(a, b.message || "Exception")
                    }
                }, f.ontimeout = function() {
                    try {
                        return e.call(g, a, f)
                    } catch (b) {
                        g.asyncComplete(a, b.message || "Exception")
                    }
                }, f.onprogress = function() {}, f.onload = function() {
                    try {
                        return 4 === f.readyState && f.status >= 400 && f.status <= 599 ? e.call(g, a, f) : d.call(g, a, f)
                    } catch (b) {
                        g.asyncComplete(a, b.message || "Exception")
                    }
                }, a.requestObject = f, a.requestUrl = b, setTimeout(function() {
                    f.send()
                }, 0)
            },
            getVideoURL: function(a) {
                for (var b = 0; b < a.length; b++) {
                    var c, d = a[b];
                    if (d.uri) {
                        if (c = d.type, d = d.uri, this.game.device.canPlayVideo(c)) return d
                    } else {
                        if (0 === d.indexOf("blob:") || 0 === d.indexOf("data:")) return d;
                        d.indexOf("?") >= 0 && (d = d.substr(0, d.indexOf("?")));
                        var e = d.substr((Math.max(0, d.lastIndexOf(".")) || 1 / 0) + 1);
                        if (c = e.toLowerCase(), this.game.device.canPlayVideo(c)) return a[b]
                    }
                }
                return null
            },
            getAudioURL: function(a) {
                if (this.game.sound.noAudio) return null;
                for (var b = 0; b < a.length; b++) {
                    var c, d = a[b];
                    if (d.uri) {
                        if (c = d.type, d = d.uri, this.game.device.canPlayAudio(c)) return d
                    } else {
                        if (0 === d.indexOf("blob:") || 0 === d.indexOf("data:")) return d;
                        d.indexOf("?") >= 0 && (d = d.substr(0, d.indexOf("?")));
                        var e = d.substr((Math.max(0, d.lastIndexOf(".")) || 1 / 0) + 1);
                        if (c = e.toLowerCase(), this.game.device.canPlayAudio(c)) return a[b]
                    }
                }
                return null
            },
            fileError: function(a, b, c) {
                var d = a.requestUrl || this.transformUrl(a.url, a),
                    e = "error loading asset from URL " + d;
                !c && b && (c = b.status), c && (e = e + " (" + c + ")"), this.asyncComplete(a, e)
            },
            fileComplete: function(a, b) {
                var d = !0;
                switch (a.type) {
                    case "packfile":
                        var e = JSON.parse(b.responseText);
                        a.data = e || {};
                        break;
                    case "image":
                        this.cache.addImage(a.key, a.url, a.data);
                        break;
                    case "spritesheet":
                        this.cache.addSpriteSheet(a.key, a.url, a.data, a.frameWidth, a.frameHeight, a.frameMax, a.margin, a.spacing);
                        break;
                    case "textureatlas":
                        if (null == a.atlasURL) this.cache.addTextureAtlas(a.key, a.url, a.data, a.atlasData, a.format);
                        else if (d = !1, a.format === c.Loader.TEXTURE_ATLAS_JSON_ARRAY || a.format === c.Loader.TEXTURE_ATLAS_JSON_HASH || a.format === c.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", this.jsonLoadComplete);
                        else {
                            if (a.format !== c.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + a.format);
                            this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", this.xmlLoadComplete)
                        }
                        break;
                    case "bitmapfont":
                        a.atlasURL ? (d = !1, this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", function(a, b) {
                            var c;
                            try {
                                c = JSON.parse(b.responseText)
                            } catch (a) {}
                            c ? (a.atlasType = "json", this.jsonLoadComplete(a, b)) : (a.atlasType = "xml", this.xmlLoadComplete(a, b))
                        })) : this.cache.addBitmapFont(a.key, a.url, a.data, a.atlasData, a.atlasType, a.xSpacing, a.ySpacing);
                        break;
                    case "video":
                        if (a.asBlob) try {
                            a.data = b.response
                        } catch (b) {
                            throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + a.key)
                        }
                        this.cache.addVideo(a.key, a.url, a.data, a.asBlob);
                        break;
                    case "audio":
                        this.game.sound.usingWebAudio ? (a.data = b.response, this.cache.addSound(a.key, a.url, a.data, !0, !1), a.autoDecode && this.game.sound.decode(a.key)) : this.cache.addSound(a.key, a.url, a.data, !1, !0);
                        break;
                    case "text":
                        a.data = b.responseText, this.cache.addText(a.key, a.url, a.data);
                        break;
                    case "shader":
                        a.data = b.responseText, this.cache.addShader(a.key, a.url, a.data);
                        break;
                    case "physics":
                        var e = JSON.parse(b.responseText);
                        this.cache.addPhysicsData(a.key, a.url, e, a.format);
                        break;
                    case "script":
                        a.data = document.createElement("script"), a.data.language = "javascript", a.data.type = "text/javascript", a.data.defer = !1, a.data.text = b.responseText, document.head.appendChild(a.data), a.callback && (a.data = a.callback.call(a.callbackContext, a.key, b.responseText));
                        break;
                    case "binary":
                        a.callback ? a.data = a.callback.call(a.callbackContext, a.key, b.response) : a.data = b.response, this.cache.addBinary(a.key, a.data)
                }
                d && this.asyncComplete(a)
            },
            jsonLoadComplete: function(a, b) {
                var c = JSON.parse(b.responseText);
                "tilemap" === a.type ? this.cache.addTilemap(a.key, a.url, c, a.format) : "bitmapfont" === a.type ? this.cache.addBitmapFont(a.key, a.url, a.data, c, a.atlasType, a.xSpacing, a.ySpacing) : "json" === a.type ? this.cache.addJSON(a.key, a.url, c) : this.cache.addTextureAtlas(a.key, a.url, a.data, c, a.format), this.asyncComplete(a)
            },
            csvLoadComplete: function(a, b) {
                var c = b.responseText;
                this.cache.addTilemap(a.key, a.url, c, a.format), this.asyncComplete(a)
            },
            xmlLoadComplete: function(a, b) {
                var c = b.responseText,
                    d = this.parseXml(c);
                if (!d) {
                    b.responseType || b.contentType;
                    return void this.asyncComplete(a, "invalid XML")
                }
                "bitmapfont" === a.type ? this.cache.addBitmapFont(a.key, a.url, a.data, d, a.atlasType, a.xSpacing, a.ySpacing) : "textureatlas" === a.type ? this.cache.addTextureAtlas(a.key, a.url, a.data, d, a.format) : "xml" === a.type && this.cache.addXML(a.key, a.url, d), this.asyncComplete(a)
            },
            parseXml: function(a) {
                var b;
                try {
                    if (window.DOMParser) {
                        var c = new DOMParser;
                        b = c.parseFromString(a, "text/xml")
                    } else b = new ActiveXObject("Microsoft.XMLDOM"), b.async = "false", b.loadXML(a)
                } catch (a) {
                    b = null
                }
                return b && b.documentElement && !b.getElementsByTagName("parsererror").length ? b : null
            },
            updateProgress: function() {
                this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null)
            },
            totalLoadedFiles: function() {
                return this._loadedFileCount
            },
            totalQueuedFiles: function() {
                return this._totalFileCount - this._loadedFileCount
            },
            totalLoadedPacks: function() {
                return this._totalPackCount
            },
            totalQueuedPacks: function() {
                return this._totalPackCount - this._loadedPackCount
            }
        }, Object.defineProperty(c.Loader.prototype, "progressFloat", {
            get: function() {
                var a = this._loadedFileCount / this._totalFileCount * 100;
                return c.Math.clamp(a || 0, 0, 100)
            }
        }), Object.defineProperty(c.Loader.prototype, "progress", {
            get: function() {
                return Math.round(this.progressFloat)
            }
        }), c.Loader.prototype.constructor = c.Loader, c.LoaderParser = {
            bitmapFont: function(a, b, c, d) {
                return this.xmlBitmapFont(a, b, c, d)
            },
            xmlBitmapFont: function(a, b, c, d) {
                var e = {},
                    f = a.getElementsByTagName("info")[0],
                    g = a.getElementsByTagName("common")[0];
                e.font = f.getAttribute("face"), e.size = parseInt(f.getAttribute("size"), 10), e.lineHeight = parseInt(g.getAttribute("lineHeight"), 10) + d, e.chars = {};
                for (var h = a.getElementsByTagName("char"), i = 0; i < h.length; i++) {
                    var j = parseInt(h[i].getAttribute("id"), 10);
                    e.chars[j] = {
                        x: parseInt(h[i].getAttribute("x"), 10),
                        y: parseInt(h[i].getAttribute("y"), 10),
                        width: parseInt(h[i].getAttribute("width"), 10),
                        height: parseInt(h[i].getAttribute("height"), 10),
                        xOffset: parseInt(h[i].getAttribute("xoffset"), 10),
                        yOffset: parseInt(h[i].getAttribute("yoffset"), 10),
                        xAdvance: parseInt(h[i].getAttribute("xadvance"), 10) + c,
                        kerning: {}
                    }
                }
                var k = a.getElementsByTagName("kerning");
                for (i = 0; i < k.length; i++) {
                    var l = parseInt(k[i].getAttribute("first"), 10),
                        m = parseInt(k[i].getAttribute("second"), 10),
                        n = parseInt(k[i].getAttribute("amount"), 10);
                    e.chars[m].kerning[l] = n
                }
                return this.finalizeBitmapFont(b, e)
            },
            jsonBitmapFont: function(a, b, c, d) {
                var e = {
                    font: a.font.info._face,
                    size: parseInt(a.font.info._size, 10),
                    lineHeight: parseInt(a.font.common._lineHeight, 10) + d,
                    chars: {}
                };
                return a.font.chars["char"].forEach(function(a) {
                    var b = parseInt(a._id, 10);
                    e.chars[b] = {
                        x: parseInt(a._x, 10),
                        y: parseInt(a._y, 10),
                        width: parseInt(a._width, 10),
                        height: parseInt(a._height, 10),
                        xOffset: parseInt(a._xoffset, 10),
                        yOffset: parseInt(a._yoffset, 10),
                        xAdvance: parseInt(a._xadvance, 10) + c,
                        kerning: {}
                    }
                }), a.font.kernings && a.font.kernings.kerning && a.font.kernings.kerning.forEach(function(a) {
                    e.chars[a._second].kerning[a._first] = parseInt(a._amount, 10)
                }), this.finalizeBitmapFont(b, e)
            },
            finalizeBitmapFont: function(a, b) {
                return Object.keys(b.chars).forEach(function(d) {
                    var e = b.chars[d];
                    e.texture = new PIXI.Texture(a, new c.Rectangle(e.x, e.y, e.width, e.height))
                }), b
            }
        }, c.AudioSprite = function(a, b) {
            this.game = a, this.key = b, this.config = this.game.cache.getJSON(b + "-audioatlas"), this.autoplayKey = null, this.autoplay = !1, this.sounds = {};
            for (var c in this.config.spritemap) {
                var d = this.config.spritemap[c],
                    e = this.game.add.sound(this.key);
                e.addMarker(c, d.start, d.end - d.start, null, d.loop), this.sounds[c] = e
            }
            this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), this.autoplay = this.sounds[this.autoplayKey])
        }, c.AudioSprite.prototype = {
            play: function(a, b) {
                return void 0 === b && (b = 1), this.sounds[a].play(a, null, b)
            },
            stop: function(a) {
                if (a) this.sounds[a].stop();
                else
                    for (var b in this.sounds) this.sounds[b].stop()
            },
            get: function(a) {
                return this.sounds[a]
            }
        }, c.AudioSprite.prototype.constructor = c.AudioSprite, c.Sound = function(a, b, d, e, f) {
            void 0 === d && (d = 1), void 0 === e && (e = !1), void 0 === f && (f = a.sound.connectToMaster), this.game = a, this.name = b, this.key = b, this.loop = e, this.markers = {}, this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, this.isPlaying = !1, this.currentMarker = "", this.fadeTween = null, this.pendingPlayback = !1, this.override = !1, this.allowMultiple = !1, this.usingWebAudio = this.game.sound.usingWebAudio, this.usingAudioTag = this.game.sound.usingAudioTag, this.externalNode = null, this.masterGainNode = null, this.gainNode = null, this._sound = null, this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(), this.gainNode.gain.value = d * this.game.sound.volume, f && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(b) && this.game.cache.isSoundReady(b) ? (this._sound = this.game.cache.getSoundData(b), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)), this.onDecoded = new c.Signal, this.onPlay = new c.Signal, this.onPause = new c.Signal,
                this.onResume = new c.Signal, this.onLoop = new c.Signal, this.onStop = new c.Signal, this.onMute = new c.Signal, this.onMarkerComplete = new c.Signal, this.onFadeComplete = new c.Signal, this._volume = d, this._buffer = null, this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, this._tempVolume = 0, this._tempPause = 0, this._muteVolume = 0, this._tempLoop = 0, this._paused = !1, this._onDecodedEventDispatched = !1
        }, c.Sound.prototype = {
            soundHasUnlocked: function(a) {
                a === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration)
            },
            addMarker: function(a, b, c, d, e) {
                void 0 !== c && null !== c || (c = 1), void 0 !== d && null !== d || (d = 1), void 0 === e && (e = !1), this.markers[a] = {
                    name: a,
                    start: b,
                    stop: b + c,
                    volume: d,
                    duration: c,
                    durationMS: 1e3 * c,
                    loop: e
                }
            },
            removeMarker: function(a) {
                delete this.markers[a]
            },
            onEndedHandler: function() {
                this._sound.onended = null, this.isPlaying = !1, this.currentTime = this.durationMS, this.stop()
            },
            update: function() {
                return this.game.cache.checkSoundKey(this.key) ? (this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)), void(this.isPlaying && (this.currentTime = this.game.time.time - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), this.isPlaying = !1, "" === this.currentMarker ? (this.currentTime = 0, this.startTime = this.game.time.time, this.isPlaying = !0) : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker && (this.currentTime = 0, this.startTime = this.game.time.time), this.isPlaying = !1, this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop())))) : void this.destroy()
            },
            loopFull: function(a) {
                return this.play(null, 0, a, !0)
            },
            play: function(a, b, c, d, e) {
                if (void 0 !== a && a !== !1 && null !== a || (a = ""), void 0 === e && (e = !0), this.isPlaying && !this.allowMultiple && !e && !this.override) return this;
                if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || e)) {
                    if (this.usingWebAudio) {
                        if (void 0 === this._sound.stop) this._sound.noteOff(0);
                        else try {
                            this._sound.stop(0)
                        } catch (a) {}
                        this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                    } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                    this.isPlaying = !1
                }
                if ("" === a && Object.keys(this.markers).length > 0) return this;
                if ("" !== a) {
                    if (!this.markers[a]) return this;
                    this.currentMarker = a, this.position = this.markers[a].start, this.volume = this.markers[a].volume, this.loop = this.markers[a].loop, this.duration = this.markers[a].duration, this.durationMS = this.markers[a].durationMS, "undefined" != typeof c && (this.volume = c), "undefined" != typeof d && (this.loop = d), this._tempMarker = a, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop
                } else b = b || 0, void 0 === c && (c = this._volume), void 0 === d && (d = this.loop), this.position = Math.max(0, b), this.volume = c, this.loop = d, this.duration = 0, this.durationMS = 0, this._tempMarker = a, this._tempPosition = b, this._tempVolume = c, this._tempLoop = d;
                return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._sound = this.context.createBufferSource(), this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this._buffer = this.game.cache.getSoundData(this.key), this._sound.buffer = this._buffer, this.loop && "" === a && (this._sound.loop = !0), this.loop || "" !== a || (this._sound.onended = this.onEndedHandler.bind(this)), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = Math.ceil(1e3 * this.totalDuration)), void 0 === this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this.loop && "" === a ? this._sound.start(0, 0) : this._sound.start(0, this.position, this.duration), this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).isDecoding === !1 && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), this._sound.currentTime = this.position, this._sound.muted = this._muted, this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume, this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0, this
            },
            restart: function(a, b, c, d) {
                a = a || "", b = b || 0, c = c || 1, void 0 === d && (d = !1), this.play(a, b, c, d, !0)
            },
            pause: function() {
                this.isPlaying && this._sound && (this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.time, this._tempPause = this._sound.currentTime, this.onPause.dispatch(this), this.stop())
            },
            resume: function() {
                if (this.paused && this._sound) {
                    if (this.usingWebAudio) {
                        var a = Math.max(0, this.position + this.pausedPosition / 1e3);
                        this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this.loop && (this._sound.loop = !0), this.loop || "" !== this.currentMarker || (this._sound.onended = this.onEndedHandler.bind(this));
                        var b = this.duration - this.pausedPosition / 1e3;
                        void 0 === this._sound.start ? this._sound.noteGrainOn(0, a, b) : this.loop && this.game.device.chrome ? 42 === this.game.device.chromeVersion ? this._sound.start(0) : this._sound.start(0, a) : this._sound.start(0, a, b)
                    } else this._sound.currentTime = this._tempPause, this._sound.play();
                    this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.time - this.pausedTime, this.onResume.dispatch(this)
                }
            },
            stop: function() {
                if (this.isPlaying && this._sound)
                    if (this.usingWebAudio) {
                        if (void 0 === this._sound.stop) this._sound.noteOff(0);
                        else try {
                            this._sound.stop(0)
                        } catch (a) {}
                        this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                    } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                if (this.pendingPlayback = !1, this.isPlaying = !1, !this.paused) {
                    var a = this.currentMarker;
                    "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), this.currentMarker = "", null !== this.fadeTween && this.fadeTween.stop(), this.onStop.dispatch(this, a)
                }
            },
            fadeIn: function(a, b, c) {
                void 0 === b && (b = !1), void 0 === c && (c = this.currentMarker), this.paused || (this.play(c, 0, 0, b), this.fadeTo(a, 1))
            },
            fadeOut: function(a) {
                this.fadeTo(a, 0)
            },
            fadeTo: function(a, b) {
                if (this.isPlaying && !this.paused && b !== this.volume) {
                    if (void 0 === a && (a = 1e3), void 0 === b) return;
                    this.fadeTween = this.game.add.tween(this).to({
                        volume: b
                    }, a, c.Easing.Linear.None, !0), this.fadeTween.onComplete.add(this.fadeComplete, this)
                }
            },
            fadeComplete: function() {
                this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop()
            },
            updateGlobalVolume: function(a) {
                this.usingAudioTag && this._sound && (this._sound.volume = a * this._volume)
            },
            destroy: function(a) {
                void 0 === a && (a = !0), this.stop(), a ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose())
            }
        }, c.Sound.prototype.constructor = c.Sound, Object.defineProperty(c.Sound.prototype, "isDecoding", {
            get: function() {
                return this.game.cache.getSound(this.key).isDecoding
            }
        }), Object.defineProperty(c.Sound.prototype, "isDecoded", {
            get: function() {
                return this.game.cache.isSoundDecoded(this.key)
            }
        }), Object.defineProperty(c.Sound.prototype, "mute", {
            get: function() {
                return this._muted || this.game.sound.mute
            },
            set: function(a) {
                a = a || !1, a !== this._muted && (a ? (this._muted = !0, this._muteVolume = this._tempVolume, this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), this.onMute.dispatch(this))
            }
        }), Object.defineProperty(c.Sound.prototype, "volume", {
            get: function() {
                return this._volume
            },
            set: function(a) {
                return this.game.device.firefox && this.usingAudioTag && (a = this.game.math.clamp(a, 0, 1)), this._muted ? void(this._muteVolume = a) : (this._tempVolume = a, this._volume = a, void(this.usingWebAudio ? this.gainNode.gain.value = a : this.usingAudioTag && this._sound && (this._sound.volume = a)))
            }
        }), c.SoundManager = function(a) {
            this.game = a, this.onSoundDecode = new c.Signal, this.onVolumeChange = new c.Signal, this.onMute = new c.Signal, this.onUnMute = new c.Signal, this.context = null, this.usingWebAudio = !1, this.usingAudioTag = !1, this.noAudio = !1, this.connectToMaster = !0, this.touchLocked = !1, this.channels = 32, this.muteOnPause = !0, this._codeMuted = !1, this._muted = !1, this._unlockSource = null, this._volume = 1, this._sounds = [], this._watchList = new c.ArraySet, this._watching = !1, this._watchCallback = null, this._watchContext = null
        }, c.SoundManager.prototype = {
            boot: function() {
                if (this.game.device.iOS && this.game.device.webAudio === !1 && (this.channels = 1), window.PhaserGlobal) {
                    if (window.PhaserGlobal.disableAudio === !0) return this.noAudio = !0, void(this.touchLocked = !1);
                    if (window.PhaserGlobal.disableWebAudio === !0) return this.usingAudioTag = !0, void(this.touchLocked = !1)
                }
                if (window.PhaserGlobal && window.PhaserGlobal.audioContext) this.context = window.PhaserGlobal.audioContext;
                else if (window.AudioContext) try {
                        this.context = new window.AudioContext
                    } catch (a) {
                        this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
                    } else if (window.webkitAudioContext) try {
                        this.context = new window.webkitAudioContext
                    } catch (a) {
                        this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
                    }
                    if (null === this.context) {
                        if (void 0 === window.Audio) return void(this.noAudio = !0);
                        this.usingAudioTag = !0
                    } else this.usingWebAudio = !0, void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination);
                this.noAudio || (!this.game.device.cocoonJS && this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock) && this.setTouchLock()
            },
            setTouchLock: function() {
                this.noAudio || window.PhaserGlobal && window.PhaserGlobal.disableAudio === !0 || (this.game.device.iOSVersion > 8 ? this.game.input.touch.addTouchLockCallback(this.unlock, this, !0) : this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0)
            },
            unlock: function() {
                if (this.noAudio || !this.touchLocked || null !== this._unlockSource) return !0;
                if (this.usingAudioTag) this.touchLocked = !1, this._unlockSource = null;
                else if (this.usingWebAudio) {
                    var a = this.context.createBuffer(1, 1, 22050);
                    this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = a, this._unlockSource.connect(this.context.destination), void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0)
                }
                return !0
            },
            stopAll: function() {
                if (!this.noAudio)
                    for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].stop()
            },
            pauseAll: function() {
                if (!this.noAudio)
                    for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].pause()
            },
            resumeAll: function() {
                if (!this.noAudio)
                    for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].resume()
            },
            decode: function(a, b) {
                b = b || null;
                var c = this.game.cache.getSoundData(a);
                if (c && this.game.cache.isSoundDecoded(a) === !1) {
                    this.game.cache.updateSound(a, "isDecoding", !0);
                    var d = this;
                    try {
                        this.context.decodeAudioData(c, function(c) {
                            c && (d.game.cache.decodedSound(a, c), d.onSoundDecode.dispatch(a, b))
                        })
                    } catch (a) {}
                }
            },
            setDecodedCallback: function(a, b, d) {
                "string" == typeof a && (a = [a]), this._watchList.reset();
                for (var e = 0; e < a.length; e++) a[e] instanceof c.Sound ? this.game.cache.isSoundDecoded(a[e].key) || this._watchList.add(a[e].key) : this.game.cache.isSoundDecoded(a[e]) || this._watchList.add(a[e]);
                0 === this._watchList.total ? (this._watching = !1, b.call(d)) : (this._watching = !0, this._watchCallback = b, this._watchContext = d)
            },
            update: function() {
                if (!this.noAudio) {
                    !this.touchLocked || null === this._unlockSource || this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE || (this.touchLocked = !1, this._unlockSource = null);
                    for (var a = 0; a < this._sounds.length; a++) this._sounds[a].update();
                    if (this._watching) {
                        for (var b = this._watchList.first; b;) this.game.cache.isSoundDecoded(b) && this._watchList.remove(b), b = this._watchList.next;
                        0 === this._watchList.total && (this._watching = !1, this._watchCallback.call(this._watchContext))
                    }
                }
            },
            add: function(a, b, d, e) {
                void 0 === b && (b = 1), void 0 === d && (d = !1), void 0 === e && (e = this.connectToMaster);
                var f = new c.Sound(this.game, a, b, d, e);
                return this._sounds.push(f), f
            },
            addSprite: function(a) {
                var b = new c.AudioSprite(this.game, a);
                return b
            },
            remove: function(a) {
                for (var b = this._sounds.length; b--;)
                    if (this._sounds[b] === a) return this._sounds[b].destroy(!1), this._sounds.splice(b, 1), !0;
                return !1
            },
            removeByKey: function(a) {
                for (var b = this._sounds.length, c = 0; b--;) this._sounds[b].key === a && (this._sounds[b].destroy(!1), this._sounds.splice(b, 1), c++);
                return c
            },
            play: function(a, b, c) {
                if (!this.noAudio) {
                    var d = this.add(a, b, c);
                    return d.play(), d
                }
            },
            setMute: function() {
                if (!this._muted) {
                    this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0);
                    for (var a = 0; a < this._sounds.length; a++) this._sounds[a].usingAudioTag && (this._sounds[a].mute = !0);
                    this.onMute.dispatch()
                }
            },
            unsetMute: function() {
                if (this._muted && !this._codeMuted) {
                    this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                    for (var a = 0; a < this._sounds.length; a++) this._sounds[a].usingAudioTag && (this._sounds[a].mute = !1);
                    this.onUnMute.dispatch()
                }
            },
            destroy: function() {
                this.stopAll();
                for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].destroy();
                this._sounds = [], this.onSoundDecode.dispose(), this.context && (window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context : this.context.close && this.context.close())
            }
        }, c.SoundManager.prototype.constructor = c.SoundManager, Object.defineProperty(c.SoundManager.prototype, "mute", {
            get: function() {
                return this._muted
            },
            set: function(a) {
                if (a = a || !1) {
                    if (this._muted) return;
                    this._codeMuted = !0, this.setMute()
                } else {
                    if (!this._muted) return;
                    this._codeMuted = !1, this.unsetMute()
                }
            }
        }), Object.defineProperty(c.SoundManager.prototype, "volume", {
            get: function() {
                return this._volume
            },
            set: function(a) {
                if (a < 0 ? a = 0 : a > 1 && (a = 1), this._volume !== a) {
                    if (this._volume = a, this.usingWebAudio) this.masterGain.gain.value = a;
                    else
                        for (var b = 0; b < this._sounds.length; b++) this._sounds[b].usingAudioTag && this._sounds[b].updateGlobalVolume(a);
                    this.onVolumeChange.dispatch(a)
                }
            }
        }), c.ScaleManager = function(a, b, d) {
            this.game = a, this.dom = c.DOM, this.grid = null, this.width = 0, this.height = 0, this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, this.offset = new c.Point, this.forceLandscape = !1, this.forcePortrait = !1, this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, this.onOrientationChange = new c.Signal, this.enterIncorrectOrientation = new c.Signal, this.leaveIncorrectOrientation = new c.Signal, this.hasPhaserSetFullScreen = !1, this.fullScreenTarget = null, this._createdFullScreenTarget = null, this.onFullScreenInit = new c.Signal, this.onFullScreenChange = new c.Signal, this.onFullScreenError = new c.Signal, this.screenOrientation = this.dom.getScreenOrientation(), this.scaleFactor = new c.Point(1, 1), this.scaleFactorInversed = new c.Point(1, 1), this.margin = {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0,
                x: 0,
                y: 0
            }, this.bounds = new c.Rectangle, this.aspectRatio = 0, this.sourceAspectRatio = 0, this.event = null, this.windowConstraints = {
                right: "layout",
                bottom: ""
            }, this.compatibility = {
                supportsFullScreen: !1,
                orientationFallback: null,
                noMargins: !1,
                scrollTo: null,
                forceMinimumDocumentHeight: !1,
                canExpandParent: !0,
                clickTrampoline: ""
            }, this._scaleMode = c.ScaleManager.NO_SCALE, this._fullScreenScaleMode = c.ScaleManager.NO_SCALE, this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new c.Point(1, 1), this.trackParentInterval = 2e3, this.onSizeChange = new c.Signal, this.onResize = null, this.onResizeContext = null, this._pendingScaleMode = null, this._fullScreenRestore = null, this._gameSize = new c.Rectangle, this._userScaleFactor = new c.Point(1, 1), this._userScaleTrim = new c.Point(0, 0), this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, this._parentBounds = new c.Rectangle, this._tempBounds = new c.Rectangle, this._lastReportedCanvasSize = new c.Rectangle, this._lastReportedGameSize = new c.Rectangle, this._booted = !1, a.config && this.parseConfig(a.config), this.setupScale(b, d)
        }, c.ScaleManager.EXACT_FIT = 0, c.ScaleManager.NO_SCALE = 1, c.ScaleManager.SHOW_ALL = 2, c.ScaleManager.RESIZE = 3, c.ScaleManager.USER_SCALE = 4, c.ScaleManager.prototype = {
            boot: function() {
                var a = this.compatibility;
                a.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? a.scrollTo = new c.Point(0, 1) : a.scrollTo = new c.Point(0, 0)), this.game.device.desktop ? (a.orientationFallback = "screen", a.clickTrampoline = "when-not-mouse") : (a.orientationFallback = "", a.clickTrampoline = "");
                var b = this;
                this._orientationChange = function(a) {
                    return b.orientationChange(a)
                }, this._windowResize = function(a) {
                    return b.windowResize(a)
                }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (this._fullScreenChange = function(a) {
                    return b.fullScreenChange(a)
                }, this._fullScreenError = function(a) {
                    return b.fullScreenError(a)
                }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), c.FlexGrid && (this.grid = new c.FlexGrid(this, this.width, this.height)), this._booted = !0, null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, this._pendingScaleMode = null)
            },
            parseConfig: function(a) {
                void 0 !== a.scaleMode && (this._booted ? this.scaleMode = a.scaleMode : this._pendingScaleMode = a.scaleMode), void 0 !== a.fullScreenScaleMode && (this.fullScreenScaleMode = a.fullScreenScaleMode), a.fullScreenTarget && (this.fullScreenTarget = a.fullScreenTarget)
            },
            setupScale: function(a, b) {
                var d, e = new c.Rectangle;
                "" !== this.game.parent && ("string" == typeof this.game.parent ? d = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (d = this.game.parent)), d ? (this.parentNode = d, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds), e.width = this._parentBounds.width, e.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, this.parentIsWindow = !0, e.width = this.dom.visualBounds.width, e.height = this.dom.visualBounds.height, this.offset.set(0, 0));
                var f = 0,
                    g = 0;
                "number" == typeof a ? f = a : (this.parentScaleFactor.x = parseInt(a, 10) / 100, f = e.width * this.parentScaleFactor.x), "number" == typeof b ? g = b : (this.parentScaleFactor.y = parseInt(b, 10) / 100, g = e.height * this.parentScaleFactor.y), f = Math.floor(f), g = Math.floor(g), this._gameSize.setTo(0, 0, f, g), this.updateDimensions(f, g, !1)
            },
            _gameResumed: function() {
                this.queueUpdate(!0)
            },
            setGameSize: function(a, b) {
                this._gameSize.setTo(0, 0, a, b), this.currentScaleMode !== c.ScaleManager.RESIZE && this.updateDimensions(a, b, !0), this.queueUpdate(!0)
            },
            setUserScale: function(a, b, c, d) {
                this._userScaleFactor.setTo(a, b), this._userScaleTrim.setTo(0 | c, 0 | d), this.queueUpdate(!0)
            },
            setResizeCallback: function(a, b) {
                this.onResize = a, this.onResizeContext = b
            },
            signalSizeChange: function() {
                if (!c.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !c.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                    var a = this.width,
                        b = this.height;
                    this._lastReportedCanvasSize.setTo(0, 0, a, b), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), this.grid && this.grid.onResize(a, b), this.onSizeChange.dispatch(this, a, b), this.currentScaleMode === c.ScaleManager.RESIZE && (this.game.state.resize(a, b), this.game.load.resize(a, b))
                }
            },
            setMinMax: function(a, b, c, d) {
                this.minWidth = a, this.minHeight = b, "undefined" != typeof c && (this.maxWidth = c), "undefined" != typeof d && (this.maxHeight = d)
            },
            preUpdate: function() {
                if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                    var a = this._updateThrottle;
                    this._updateThrottleReset = a >= 400 ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset);
                    var b = this._parentBounds.width,
                        d = this._parentBounds.height,
                        e = this.getParentBounds(this._parentBounds),
                        f = e.width !== b || e.height !== d,
                        g = this.updateOrientationState();
                    (f || g) && (this.onResize && this.onResize.call(this.onResizeContext, this, e), this.updateLayout(), this.signalSizeChange());
                    var h = 2 * this._updateThrottle;
                    this._updateThrottle < a && (h = Math.min(a, this._updateThrottleReset)), this._updateThrottle = c.Math.clamp(h, 25, this.trackParentInterval), this._lastUpdate = this.game.time.time
                }
            },
            pauseUpdate: function() {
                this.preUpdate(), this._updateThrottle = this.trackParentInterval
            },
            updateDimensions: function(a, b, c) {
                this.width = a * this.parentScaleFactor.x, this.height = b * this.parentScaleFactor.y, this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, this.updateScalingAndBounds(), c && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height))
            },
            updateScalingAndBounds: function() {
                this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y)
            },
            forceOrientation: function(a, b) {
                void 0 === b && (b = !1), this.forceLandscape = a, this.forcePortrait = b, this.queueUpdate(!0)
            },
            classifyOrientation: function(a) {
                return "portrait-primary" === a || "portrait-secondary" === a ? "portrait" : "landscape-primary" === a || "landscape-secondary" === a ? "landscape" : null
            },
            updateOrientationState: function() {
                var a = this.screenOrientation,
                    b = this.incorrectOrientation;
                this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
                var c = a !== this.screenOrientation,
                    d = b !== this.incorrectOrientation;
                return d && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), (c || d) && this.onOrientationChange.dispatch(this, a, b), c || d
            },
            orientationChange: function(a) {
                this.event = a, this.queueUpdate(!0)
            },
            windowResize: function(a) {
                this.event = a, this.queueUpdate(!0)
            },
            scrollTop: function() {
                var a = this.compatibility.scrollTo;
                a && window.scrollTo(a.x, a.y)
            },
            refresh: function() {
                this.scrollTop(), this.queueUpdate(!0)
            },
            updateLayout: function() {
                var a = this.currentScaleMode;
                if (a === c.ScaleManager.RESIZE) return void this.reflowGame();
                if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : a === c.ScaleManager.EXACT_FIT ? this.setExactFit() : a === c.ScaleManager.SHOW_ALL ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent ? (this.setShowAll(!0), this.resetCanvas(), this.setShowAll()) : this.setShowAll() : a === c.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : a === c.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), !this.compatibility.canExpandParent && (a === c.ScaleManager.SHOW_ALL || a === c.ScaleManager.USER_SCALE)) {
                    var b = this.getParentBounds(this._tempBounds);
                    this.width = Math.min(this.width, b.width), this.height = Math.min(this.height, b.height)
                }
                this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas()
            },
            getParentBounds: function(a) {
                var b = a || new c.Rectangle,
                    d = this.boundingParent,
                    e = this.dom.visualBounds,
                    f = this.dom.layoutBounds;
                if (d) {
                    var g = d.getBoundingClientRect(),
                        h = d.offsetParent ? d.offsetParent.getBoundingClientRect() : d.getBoundingClientRect();
                    b.setTo(g.left - h.left, g.top - h.top, g.width, g.height);
                    var i = this.windowConstraints;
                    if (i.right) {
                        var j = "layout" === i.right ? f : e;
                        b.right = Math.min(b.right, j.width)
                    }
                    if (i.bottom) {
                        var j = "layout" === i.bottom ? f : e;
                        b.bottom = Math.min(b.bottom, j.height)
                    }
                } else b.setTo(0, 0, e.width, e.height);
                return b.setTo(Math.round(b.x), Math.round(b.y), Math.round(b.width), Math.round(b.height)), b
            },
            alignCanvas: function(a, b) {
                var c = this.getParentBounds(this._tempBounds),
                    d = this.game.canvas,
                    e = this.margin;
                if (a) {
                    e.left = e.right = 0;
                    var f = d.getBoundingClientRect();
                    if (this.width < c.width && !this.incorrectOrientation) {
                        var g = f.left - c.x,
                            h = c.width / 2 - this.width / 2;
                        h = Math.max(h, 0);
                        var i = h - g;
                        e.left = Math.round(i)
                    }
                    d.style.marginLeft = e.left + "px", 0 !== e.left && (e.right = -(c.width - f.width - e.left), d.style.marginRight = e.right + "px")
                }
                if (b) {
                    e.top = e.bottom = 0;
                    var f = d.getBoundingClientRect();
                    if (this.height < c.height && !this.incorrectOrientation) {
                        var g = f.top - c.y,
                            h = c.height / 2 - this.height / 2;
                        h = Math.max(h, 0);
                        var i = h - g;
                        e.top = Math.round(i)
                    }
                    d.style.marginTop = e.top + "px", 0 !== e.top && (e.bottom = -(c.height - f.height - e.top), d.style.marginBottom = e.bottom + "px")
                }
                e.x = e.left, e.y = e.top
            },
            reflowGame: function() {
                this.resetCanvas("", "");
                var a = this.getParentBounds(this._tempBounds);
                this.updateDimensions(a.width, a.height, !0)
            },
            reflowCanvas: function() {
                this.incorrectOrientation || (this.width = c.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), this.height = c.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), this.updateScalingAndBounds()
            },
            resetCanvas: function(a, b) {
                void 0 === a && (a = this.width + "px"), void 0 === b && (b = this.height + "px");
                var c = this.game.canvas;
                this.compatibility.noMargins || (c.style.marginLeft = "", c.style.marginTop = "", c.style.marginRight = "", c.style.marginBottom = ""), c.style.width = a, c.style.height = b
            },
            queueUpdate: function(a) {
                a && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset
            },
            reset: function(a) {
                a && this.grid && this.grid.reset()
            },
            setMaximum: function() {
                this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height
            },
            setShowAll: function(a) {
                var b, c = this.getParentBounds(this._tempBounds),
                    d = c.width,
                    e = c.height;
                b = a ? Math.max(e / this.game.height, d / this.game.width) : Math.min(e / this.game.height, d / this.game.width), this.width = Math.round(this.game.width * b), this.height = Math.round(this.game.height * b)
            },
            setExactFit: function() {
                var a = this.getParentBounds(this._tempBounds);
                this.width = a.width, this.height = a.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)))
            },
            createFullScreenTarget: function() {
                var a = document.createElement("div");
                return a.style.margin = "0", a.style.padding = "0", a.style.background = "#000", a
            },
            startFullScreen: function(a, b) {
                if (this.isFullScreen) return !1;
                if (!this.compatibility.supportsFullScreen) {
                    var d = this;
                    return void setTimeout(function() {
                        d.fullScreenError()
                    }, 10)
                }
                if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                    var e = this.game.input;
                    if (e.activePointer && e.activePointer !== e.mousePointer && (b || b !== !1)) return void e.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [a, !1])
                }
                void 0 !== a && this.game.renderType === c.CANVAS && (this.game.stage.smoothed = a);
                var f = this.fullScreenTarget;
                f || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), f = this._createdFullScreenTarget);
                var g = {
                    targetElement: f
                };
                if (this.hasPhaserSetFullScreen = !0, this.onFullScreenInit.dispatch(this, g), this._createdFullScreenTarget) {
                    var h = this.game.canvas,
                        i = h.parentNode;
                    i.insertBefore(f, h), f.appendChild(h)
                }
                return this.game.device.fullscreenKeyboard ? f[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : f[this.game.device.requestFullscreen](), !0
            },
            stopFullScreen: function() {
                return !(!this.isFullScreen || !this.compatibility.supportsFullScreen || (this.hasPhaserSetFullScreen = !1, document[this.game.device.cancelFullscreen](), 0))
            },
            cleanupCreatedTarget: function() {
                var a = this._createdFullScreenTarget;
                if (a && a.parentNode) {
                    var b = a.parentNode;
                    b.insertBefore(this.game.canvas, a), b.removeChild(a)
                }
                this._createdFullScreenTarget = null
            },
            prepScreenMode: function(a) {
                var b = !!this._createdFullScreenTarget,
                    d = this._createdFullScreenTarget || this.fullScreenTarget;
                a ? (b || this.fullScreenScaleMode === c.ScaleManager.EXACT_FIT) && d !== this.game.canvas && (this._fullScreenRestore = {
                    targetWidth: d.style.width,
                    targetHeight: d.style.height
                }, d.style.width = "100%", d.style.height = "100%") : (this._fullScreenRestore && (d.style.width = this._fullScreenRestore.targetWidth, d.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas())
            },
            fullScreenChange: function(a) {
                this.event = a, this.isFullScreen ? (this.prepScreenMode(!0), this.updateLayout(), this.queueUpdate(!0)) : (this.prepScreenMode(!1), this.cleanupCreatedTarget(), this.updateLayout(), this.queueUpdate(!0)), this.onFullScreenChange.dispatch(this, this.width, this.height)
            },
            fullScreenError: function(a) {
                this.event = a, this.cleanupCreatedTarget(), this.onFullScreenError.dispatch(this)
            },
            scaleSprite: function(a, b, c, d) {
                if (void 0 === b && (b = this.width), void 0 === c && (c = this.height), void 0 === d && (d = !1), !a || !a.scale) return a;
                if (a.scale.x = 1, a.scale.y = 1, a.width <= 0 || a.height <= 0 || b <= 0 || c <= 0) return a;
                var e = b,
                    f = a.height * b / a.width,
                    g = a.width * c / a.height,
                    h = c,
                    i = g > b;
                return i = i ? d : !d, i ? (a.width = Math.floor(e), a.height = Math.floor(f)) : (a.width = Math.floor(g), a.height = Math.floor(h)), a
            },
            destroy: function() {
                this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), document.removeEventListener("fullscreenerror", this._fullScreenError, !1))
            }
        }, c.ScaleManager.prototype.constructor = c.ScaleManager, Object.defineProperty(c.ScaleManager.prototype, "boundingParent", {
            get: function() {
                if (this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget) return null;
                var a = this.game.canvas && this.game.canvas.parentNode;
                return a || null;
            }
        }), Object.defineProperty(c.ScaleManager.prototype, "scaleMode", {
            get: function() {
                return this._scaleMode
            },
            set: function(a) {
                return a !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), this._scaleMode = a), this._scaleMode
            }
        }), Object.defineProperty(c.ScaleManager.prototype, "fullScreenScaleMode", {
            get: function() {
                return this._fullScreenScaleMode
            },
            set: function(a) {
                return a !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), this._fullScreenScaleMode = a, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = a), this._fullScreenScaleMode
            }
        }), Object.defineProperty(c.ScaleManager.prototype, "currentScaleMode", {
            get: function() {
                return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode
            }
        }), Object.defineProperty(c.ScaleManager.prototype, "pageAlignHorizontally", {
            get: function() {
                return this._pageAlignHorizontally
            },
            set: function(a) {
                a !== this._pageAlignHorizontally && (this._pageAlignHorizontally = a, this.queueUpdate(!0))
            }
        }), Object.defineProperty(c.ScaleManager.prototype, "pageAlignVertically", {
            get: function() {
                return this._pageAlignVertically
            },
            set: function(a) {
                a !== this._pageAlignVertically && (this._pageAlignVertically = a, this.queueUpdate(!0))
            }
        }), Object.defineProperty(c.ScaleManager.prototype, "isFullScreen", {
            get: function() {
                return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
            }
        }), Object.defineProperty(c.ScaleManager.prototype, "isPortrait", {
            get: function() {
                return "portrait" === this.classifyOrientation(this.screenOrientation)
            }
        }), Object.defineProperty(c.ScaleManager.prototype, "isLandscape", {
            get: function() {
                return "landscape" === this.classifyOrientation(this.screenOrientation)
            }
        }), Object.defineProperty(c.ScaleManager.prototype, "isGamePortrait", {
            get: function() {
                return this.height > this.width
            }
        }), Object.defineProperty(c.ScaleManager.prototype, "isGameLandscape", {
            get: function() {
                return this.width > this.height
            }
        }), c.Utils.Debug = function(a) {
            this.game = a, this.sprite = null, this.bmd = null, this.canvas = null, this.context = null, this.font = "14px Courier", this.columnWidth = 100, this.lineHeight = 16, this.renderShadow = !0, this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1
        }, c.Utils.Debug.prototype = {
            boot: function() {
                this.game.renderType === c.CANVAS ? this.context = this.game.context : (this.bmd = new c.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, (!0)), this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), this.game.scale.onSizeChange.add(this.resize, this), this.canvas = PIXI.CanvasPool.create(this, this.game.width, this.game.height), this.context = this.canvas.getContext("2d"))
            },
            resize: function(a, b, c) {
                this.bmd.resize(b, c), this.canvas.width = b, this.canvas.height = c
            },
            preUpdate: function() {
                this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1)
            },
            reset: function() {
                this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), this.sprite && this.bmd.clear()
            },
            start: function(a, b, c, d) {
                "number" != typeof a && (a = 0), "number" != typeof b && (b = 0), c = c || "rgb(255,255,255)", void 0 === d && (d = 0), this.currentX = a, this.currentY = b, this.currentColor = c, this.columnWidth = d, this.dirty = !0, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.strokeStyle = c, this.context.fillStyle = c, this.context.font = this.font, this.context.globalAlpha = this.currentAlpha
            },
            stop: function() {
                this.context.restore()
            },
            line: function() {
                for (var a = this.currentX, b = 0; b < arguments.length; b++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[b], a + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(arguments[b], a, this.currentY), a += this.columnWidth;
                this.currentY += this.lineHeight
            },
            soundInfo: function(a, b, c, d) {
                this.start(b, c, d), this.line("Sound: " + a.key + " Locked: " + a.game.sound.touchLocked), this.line("Is Ready?: " + this.game.cache.isSoundReady(a.key) + " Pending Playback: " + a.pendingPlayback), this.line("Decoded: " + a.isDecoded + " Decoding: " + a.isDecoding), this.line("Total Duration: " + a.totalDuration + " Playing: " + a.isPlaying), this.line("Time: " + a.currentTime), this.line("Volume: " + a.volume + " Muted: " + a.mute), this.line("WebAudio: " + a.usingWebAudio + " Audio: " + a.usingAudioTag), "" !== a.currentMarker && (this.line("Marker: " + a.currentMarker + " Duration: " + a.duration + " (ms: " + a.durationMS + ")"), this.line("Start: " + a.markers[a.currentMarker].start + " Stop: " + a.markers[a.currentMarker].stop), this.line("Position: " + a.position)), this.stop()
            },
            cameraInfo: function(a, b, c, d) {
                this.start(b, c, d), this.line("Camera (" + a.width + " x " + a.height + ")"), this.line("X: " + a.x + " Y: " + a.y), a.bounds && this.line("Bounds x: " + a.bounds.x + " Y: " + a.bounds.y + " w: " + a.bounds.width + " h: " + a.bounds.height), this.line("View x: " + a.view.x + " Y: " + a.view.y + " w: " + a.view.width + " h: " + a.view.height), this.line("Total in view: " + a.totalInView), this.stop()
            },
            timer: function(a, b, c, d) {
                this.start(b, c, d), this.line("Timer (running: " + a.running + " expired: " + a.expired + ")"), this.line("Next Tick: " + a.next + " Duration: " + a.duration), this.line("Paused: " + a.paused + " Length: " + a.length), this.stop()
            },
            pointer: function(a, b, c, d, e) {
                null != a && (void 0 === b && (b = !1), c = c || "rgba(0,255,0,0.5)", d = d || "rgba(255,0,0,0.5)", b === !0 && a.isUp === !0 || (this.start(a.x, a.y - 100, e), this.context.beginPath(), this.context.arc(a.x, a.y, a.circle.radius, 0, 2 * Math.PI), a.active ? this.context.fillStyle = c : this.context.fillStyle = d, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(a.positionDown.x, a.positionDown.y), this.context.lineTo(a.position.x, a.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath(), this.line("ID: " + a.id + " Active: " + a.active), this.line("World X: " + a.worldX + " World Y: " + a.worldY), this.line("Screen X: " + a.x + " Screen Y: " + a.y + " In: " + a.withinGame), this.line("Duration: " + a.duration + " ms"), this.line("is Down: " + a.isDown + " is Up: " + a.isUp), this.stop()))
            },
            spriteInputInfo: function(a, b, c, d) {
                this.start(b, c, d), this.line("Sprite Input: (" + a.width + " x " + a.height + ")"), this.line("x: " + a.input.pointerX().toFixed(1) + " y: " + a.input.pointerY().toFixed(1)), this.line("over: " + a.input.pointerOver() + " duration: " + a.input.overDuration().toFixed(0)), this.line("down: " + a.input.pointerDown() + " duration: " + a.input.downDuration().toFixed(0)), this.line("just over: " + a.input.justOver() + " just out: " + a.input.justOut()), this.stop()
            },
            key: function(a, b, c, d) {
                this.start(b, c, d, 150), this.line("Key:", a.keyCode, "isDown:", a.isDown), this.line("justDown:", a.justDown, "justUp:", a.justUp), this.line("Time Down:", a.timeDown.toFixed(0), "duration:", a.duration.toFixed(0)), this.stop()
            },
            inputInfo: function(a, b, c) {
                this.start(a, b, c), this.line("Input"), this.line("X: " + this.game.input.x + " Y: " + this.game.input.y), this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY), this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)), this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY), this.stop()
            },
            spriteBounds: function(a, b, c) {
                var d = a.getBounds();
                d.x += this.game.camera.x, d.y += this.game.camera.y, this.rectangle(d, b, c)
            },
            ropeSegments: function(a, b, c) {
                var d = a.segments,
                    e = this;
                d.forEach(function(a) {
                    e.rectangle(a, b, c)
                }, this)
            },
            spriteInfo: function(a, b, c, d) {
                this.start(b, c, d), this.line("Sprite:  (" + a.width + " x " + a.height + ") anchor: " + a.anchor.x + " x " + a.anchor.y), this.line("x: " + a.x.toFixed(1) + " y: " + a.y.toFixed(1)), this.line("angle: " + a.angle.toFixed(1) + " rotation: " + a.rotation.toFixed(1)), this.line("visible: " + a.visible + " in camera: " + a.inCamera), this.line("bounds x: " + a._bounds.x.toFixed(1) + " y: " + a._bounds.y.toFixed(1) + " w: " + a._bounds.width.toFixed(1) + " h: " + a._bounds.height.toFixed(1)), this.stop()
            },
            spriteCoords: function(a, b, c, d) {
                this.start(b, c, d, 100), a.name && this.line(a.name), this.line("x:", a.x.toFixed(2), "y:", a.y.toFixed(2)), this.line("pos x:", a.position.x.toFixed(2), "pos y:", a.position.y.toFixed(2)), this.line("world x:", a.world.x.toFixed(2), "world y:", a.world.y.toFixed(2)), this.stop()
            },
            lineInfo: function(a, b, c, d) {
                this.start(b, c, d, 80), this.line("start.x:", a.start.x.toFixed(2), "start.y:", a.start.y.toFixed(2)), this.line("end.x:", a.end.x.toFixed(2), "end.y:", a.end.y.toFixed(2)), this.line("length:", a.length.toFixed(2), "angle:", a.angle), this.stop()
            },
            pixel: function(a, b, c, d) {
                d = d || 2, this.start(), this.context.fillStyle = c, this.context.fillRect(a, b, d, d), this.stop()
            },
            geom: function(a, b, d, e) {
                void 0 === d && (d = !0), void 0 === e && (e = 0), b = b || "rgba(0,255,0,0.4)", this.start(), this.context.fillStyle = b, this.context.strokeStyle = b, a instanceof c.Rectangle || 1 === e ? d ? this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height) : this.context.strokeRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height) : a instanceof c.Circle || 2 === e ? (this.context.beginPath(), this.context.arc(a.x - this.game.camera.x, a.y - this.game.camera.y, a.radius, 0, 2 * Math.PI, !1), this.context.closePath(), d ? this.context.fill() : this.context.stroke()) : a instanceof c.Point || 3 === e ? this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, 4, 4) : (a instanceof c.Line || 4 === e) && (this.context.lineWidth = 1, this.context.beginPath(), this.context.moveTo(a.start.x + .5 - this.game.camera.x, a.start.y + .5 - this.game.camera.y), this.context.lineTo(a.end.x + .5 - this.game.camera.x, a.end.y + .5 - this.game.camera.y), this.context.closePath(), this.context.stroke()), this.stop()
            },
            rectangle: function(a, b, c) {
                void 0 === c && (c = !0), b = b || "rgba(0, 255, 0, 0.4)", this.start(), c ? (this.context.fillStyle = b, this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height)) : (this.context.strokeStyle = b, this.context.strokeRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height)), this.stop()
            },
            text: function(a, b, c, d, e) {
                d = d || "rgb(255,255,255)", e = e || "16px Courier", this.start(), this.context.font = e, this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(a, b + 1, c + 1)), this.context.fillStyle = d, this.context.fillText(a, b, c), this.stop()
            },
            quadTree: function(a, b) {
                b = b || "rgba(255,0,0,0.3)", this.start();
                var c = a.bounds;
                if (0 === a.nodes.length) {
                    this.context.strokeStyle = b, this.context.strokeRect(c.x, c.y, c.width, c.height), this.text("size: " + a.objects.length, c.x + 4, c.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)";
                    for (var d = 0; d < a.objects.length; d++) this.context.strokeRect(a.objects[d].x, a.objects[d].y, a.objects[d].width, a.objects[d].height)
                } else
                    for (var d = 0; d < a.nodes.length; d++) this.quadTree(a.nodes[d]);
                this.stop()
            },
            body: function(a, b, d) {
                a.body && (this.start(), a.body.type === c.Physics.ARCADE ? c.Physics.Arcade.Body.render(this.context, a.body, b, d) : a.body.type === c.Physics.NINJA ? c.Physics.Ninja.Body.render(this.context, a.body, b, d) : a.body.type === c.Physics.BOX2D && c.Physics.Box2D.renderBody(this.context, a.body, b), this.stop())
            },
            bodyInfo: function(a, b, d, e) {
                a.body && (this.start(b, d, e, 210), a.body.type === c.Physics.ARCADE ? c.Physics.Arcade.Body.renderBodyInfo(this, a.body) : a.body.type === c.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, a.body), this.stop())
            },
            box2dWorld: function() {
                this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0), this.game.physics.box2d.renderDebugDraw(this.context), this.stop()
            },
            box2dBody: function(a, b) {
                this.start(), c.Physics.Box2D.renderBody(this.context, a, b), this.stop()
            },
            displayList: function(a) {
                if (void 0 === a && (a = this.game.world), a.hasOwnProperty("renderOrderID"), void 0, a.children && a.children.length > 0)
                    for (var b = 0; b < a.children.length; b++) this.game.debug.displayList(a.children[b])
            },
            destroy: function() {
                PIXI.CanvasPool.remove(this)
            }
        }, c.Utils.Debug.prototype.constructor = c.Utils.Debug, c.DOM = {
            getOffset: function(a, b) {
                b = b || new c.Point;
                var d = a.getBoundingClientRect(),
                    e = c.DOM.scrollY,
                    f = c.DOM.scrollX,
                    g = document.documentElement.clientTop,
                    h = document.documentElement.clientLeft;
                return b.x = d.left + f - h, b.y = d.top + e - g, b
            },
            getBounds: function(a, b) {
                return void 0 === b && (b = 0), a = a && !a.nodeType ? a[0] : a, !(!a || 1 !== a.nodeType) && this.calibrate(a.getBoundingClientRect(), b)
            },
            calibrate: function(a, b) {
                b = +b || 0;
                var c = {
                    width: 0,
                    height: 0,
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                };
                return c.width = (c.right = a.right + b) - (c.left = a.left - b), c.height = (c.bottom = a.bottom + b) - (c.top = a.top - b), c
            },
            getAspectRatio: function(a) {
                a = null == a ? this.visualBounds : 1 === a.nodeType ? this.getBounds(a) : a;
                var b = a.width,
                    c = a.height;
                return "function" == typeof b && (b = b.call(a)), "function" == typeof c && (c = c.call(a)), b / c
            },
            inLayoutViewport: function(a, b) {
                var c = this.getBounds(a, b);
                return !!c && c.bottom >= 0 && c.right >= 0 && c.top <= this.layoutBounds.width && c.left <= this.layoutBounds.height
            },
            getScreenOrientation: function(a) {
                var b = window.screen,
                    c = b.orientation || b.mozOrientation || b.msOrientation;
                if (c && "string" == typeof c.type) return c.type;
                if ("string" == typeof c) return c;
                var d = "portrait-primary",
                    e = "landscape-primary";
                if ("screen" === a) return b.height > b.width ? d : e;
                if ("viewport" === a) return this.visualBounds.height > this.visualBounds.width ? d : e;
                if ("window.orientation" === a && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? d : e;
                if (window.matchMedia) {
                    if (window.matchMedia("(orientation: portrait)").matches) return d;
                    if (window.matchMedia("(orientation: landscape)").matches) return e
                }
                return this.visualBounds.height > this.visualBounds.width ? d : e
            },
            visualBounds: new c.Rectangle,
            layoutBounds: new c.Rectangle,
            documentBounds: new c.Rectangle
        }, c.Device.whenReady(function(a) {
            var b = window && "pageXOffset" in window ? function() {
                    return window.pageXOffset
                } : function() {
                    return document.documentElement.scrollLeft
                },
                d = window && "pageYOffset" in window ? function() {
                    return window.pageYOffset
                } : function() {
                    return document.documentElement.scrollTop
                };
            Object.defineProperty(c.DOM, "scrollX", {
                get: b
            }), Object.defineProperty(c.DOM, "scrollY", {
                get: d
            }), Object.defineProperty(c.DOM.visualBounds, "x", {
                get: b
            }), Object.defineProperty(c.DOM.visualBounds, "y", {
                get: d
            }), Object.defineProperty(c.DOM.layoutBounds, "x", {
                value: 0
            }), Object.defineProperty(c.DOM.layoutBounds, "y", {
                value: 0
            });
            var e = a.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight;
            if (e) {
                var f = function() {
                        return Math.max(window.innerWidth, document.documentElement.clientWidth)
                    },
                    g = function() {
                        return Math.max(window.innerHeight, document.documentElement.clientHeight)
                    };
                Object.defineProperty(c.DOM.visualBounds, "width", {
                    get: f
                }), Object.defineProperty(c.DOM.visualBounds, "height", {
                    get: g
                }), Object.defineProperty(c.DOM.layoutBounds, "width", {
                    get: f
                }), Object.defineProperty(c.DOM.layoutBounds, "height", {
                    get: g
                })
            } else Object.defineProperty(c.DOM.visualBounds, "width", {
                get: function() {
                    return window.innerWidth
                }
            }), Object.defineProperty(c.DOM.visualBounds, "height", {
                get: function() {
                    return window.innerHeight
                }
            }), Object.defineProperty(c.DOM.layoutBounds, "width", {
                get: function() {
                    var a = document.documentElement.clientWidth,
                        b = window.innerWidth;
                    return a < b ? b : a
                }
            }), Object.defineProperty(c.DOM.layoutBounds, "height", {
                get: function() {
                    var a = document.documentElement.clientHeight,
                        b = window.innerHeight;
                    return a < b ? b : a
                }
            });
            Object.defineProperty(c.DOM.documentBounds, "x", {
                value: 0
            }), Object.defineProperty(c.DOM.documentBounds, "y", {
                value: 0
            }), Object.defineProperty(c.DOM.documentBounds, "width", {
                get: function() {
                    var a = document.documentElement;
                    return Math.max(a.clientWidth, a.offsetWidth, a.scrollWidth)
                }
            }), Object.defineProperty(c.DOM.documentBounds, "height", {
                get: function() {
                    var a = document.documentElement;
                    return Math.max(a.clientHeight, a.offsetHeight, a.scrollHeight)
                }
            })
        }, null, !0), c.ArraySet = function(a) {
            this.position = 0, this.list = a || []
        }, c.ArraySet.prototype = {
            add: function(a) {
                return this.exists(a) || this.list.push(a), a
            },
            getIndex: function(a) {
                return this.list.indexOf(a)
            },
            getByKey: function(a, b) {
                for (var c = this.list.length; c--;)
                    if (this.list[c][a] === b) return this.list[c];
                return null
            },
            exists: function(a) {
                return this.list.indexOf(a) > -1
            },
            reset: function() {
                this.list.length = 0
            },
            remove: function(a) {
                var b = this.list.indexOf(a);
                if (b > -1) return this.list.splice(b, 1), a
            },
            setAll: function(a, b) {
                for (var c = this.list.length; c--;) this.list[c] && (this.list[c][a] = b)
            },
            callAll: function(a) {
                for (var b = Array.prototype.slice.call(arguments, 1), c = this.list.length; c--;) this.list[c] && this.list[c][a] && this.list[c][a].apply(this.list[c], b)
            },
            removeAll: function(a) {
                void 0 === a && (a = !1);
                for (var b = this.list.length; b--;)
                    if (this.list[b]) {
                        var c = this.remove(this.list[b]);
                        a && c.destroy()
                    }
                this.position = 0, this.list = []
            }
        }, Object.defineProperty(c.ArraySet.prototype, "total", {
            get: function() {
                return this.list.length
            }
        }), Object.defineProperty(c.ArraySet.prototype, "first", {
            get: function() {
                return this.position = 0, this.list.length > 0 ? this.list[0] : null
            }
        }), Object.defineProperty(c.ArraySet.prototype, "next", {
            get: function() {
                return this.position < this.list.length ? (this.position++, this.list[this.position]) : null
            }
        }), c.ArraySet.prototype.constructor = c.ArraySet, c.ArrayUtils = {
            getRandomItem: function(a, b, c) {
                if (null === a) return null;
                void 0 === b && (b = 0), void 0 === c && (c = a.length);
                var d = b + Math.floor(Math.random() * c);
                return void 0 === a[d] ? null : a[d]
            },
            removeRandomItem: function(a, b, c) {
                if (null == a) return null;
                void 0 === b && (b = 0), void 0 === c && (c = a.length);
                var d = b + Math.floor(Math.random() * c);
                if (d < a.length) {
                    var e = a.splice(d, 1);
                    return void 0 === e[0] ? null : e[0]
                }
                return null
            },
            shuffle: function(a) {
                for (var b = a.length - 1; b > 0; b--) {
                    var c = Math.floor(Math.random() * (b + 1)),
                        d = a[b];
                    a[b] = a[c], a[c] = d
                }
                return a
            },
            transposeMatrix: function(a) {
                for (var b = a.length, c = a[0].length, d = new Array(c), e = 0; e < c; e++) {
                    d[e] = new Array(b);
                    for (var f = b - 1; f > -1; f--) d[e][f] = a[f][e]
                }
                return d
            },
            rotateMatrix: function(a, b) {
                if ("string" != typeof b && (b = (b % 360 + 360) % 360), 90 === b || b === -270 || "rotateLeft" === b) a = c.ArrayUtils.transposeMatrix(a), a = a.reverse();
                else if (b === -90 || 270 === b || "rotateRight" === b) a = a.reverse(), a = c.ArrayUtils.transposeMatrix(a);
                else if (180 === Math.abs(b) || "rotate180" === b) {
                    for (var d = 0; d < a.length; d++) a[d].reverse();
                    a = a.reverse()
                }
                return a
            },
            findClosest: function(a, b) {
                if (!b.length) return NaN;
                if (1 === b.length || a < b[0]) return b[0];
                for (var c = 1; b[c] < a;) c++;
                var d = b[c - 1],
                    e = c < b.length ? b[c] : Number.POSITIVE_INFINITY;
                return e - a <= a - d ? e : d
            },
            rotateRight: function(a) {
                var b = a.pop();
                return a.unshift(b), b
            },
            rotateLeft: function(a) {
                var b = a.shift();
                return a.push(b), b
            },
            rotate: function(a) {
                var b = a.shift();
                return a.push(b), b
            },
            numberArray: function(a, b) {
                for (var c = [], d = a; d <= b; d++) c.push(d);
                return c
            },
            numberArrayStep: function(a, b, d) {
                void 0 !== a && null !== a || (a = 0), void 0 !== b && null !== b || (b = a, a = 0), void 0 === d && (d = 1);
                for (var e = [], f = Math.max(c.Math.roundAwayFromZero((b - a) / (d || 1)), 0), g = 0; g < f; g++) e.push(a), a += d;
                return e
            }
        }, c.LinkedList = function() {
            this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0
        }, c.LinkedList.prototype = {
            add: function(a) {
                return 0 === this.total && null === this.first && null === this.last ? (this.first = a, this.last = a, this.next = a, a.prev = this, this.total++, a) : (this.last.next = a, a.prev = this.last, this.last = a, this.total++, a)
            },
            reset: function() {
                this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0
            },
            remove: function(a) {
                return 1 === this.total ? (this.reset(), void(a.next = a.prev = null)) : (a === this.first ? this.first = this.first.next : a === this.last && (this.last = this.last.prev), a.prev && (a.prev.next = a.next), a.next && (a.next.prev = a.prev), a.next = a.prev = null, null === this.first && (this.last = null), void this.total--)
            },
            callAll: function(a) {
                if (this.first && this.last) {
                    var b = this.first;
                    do b && b[a] && b[a].call(b), b = b.next; while (b !== this.last.next)
                }
            }
        }, c.LinkedList.prototype.constructor = c.LinkedList, c.Create = function(a) {
            this.game = a, this.bmd = null, this.canvas = null, this.ctx = null, this.palettes = [{
                0: "#000",
                1: "#9D9D9D",
                2: "#FFF",
                3: "#BE2633",
                4: "#E06F8B",
                5: "#493C2B",
                6: "#A46422",
                7: "#EB8931",
                8: "#F7E26B",
                9: "#2F484E",
                A: "#44891A",
                B: "#A3CE27",
                C: "#1B2632",
                D: "#005784",
                E: "#31A2F2",
                F: "#B2DCEF"
            }, {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#f5f4eb"
            }, {
                0: "#000",
                1: "#2234d1",
                2: "#0c7e45",
                3: "#44aacc",
                4: "#8a3622",
                5: "#5c2e78",
                6: "#aa5c3d",
                7: "#b5b5b5",
                8: "#5e606e",
                9: "#4c81fb",
                A: "#6cd947",
                B: "#7be2f9",
                C: "#eb8a60",
                D: "#e23d69",
                E: "#ffd93f",
                F: "#fff"
            }, {
                0: "#000",
                1: "#fff",
                2: "#8b4131",
                3: "#7bbdc5",
                4: "#8b41ac",
                5: "#6aac41",
                6: "#3931a4",
                7: "#d5de73",
                8: "#945a20",
                9: "#5a4100",
                A: "#bd736a",
                B: "#525252",
                C: "#838383",
                D: "#acee8b",
                E: "#7b73de",
                F: "#acacac"
            }, {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#fff"
            }]
        }, c.Create.PALETTE_ARNE = 0, c.Create.PALETTE_JMP = 1, c.Create.PALETTE_CGA = 2, c.Create.PALETTE_C64 = 3, c.Create.PALETTE_JAPANESE_MACHINE = 4, c.Create.prototype = {
            texture: function(a, b, c, d, e) {
                void 0 === c && (c = 8), void 0 === d && (d = c), void 0 === e && (e = 0);
                var f = b[0].length * c,
                    g = b.length * d;
                null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(f, g), this.bmd.clear();
                for (var h = 0; h < b.length; h++)
                    for (var i = b[h], j = 0; j < i.length; j++) {
                        var k = i[j];
                        "." !== k && " " !== k && (this.ctx.fillStyle = this.palettes[e][k], this.ctx.fillRect(j * c, h * d, c, d))
                    }
                return this.bmd.generateTexture(a)
            },
            grid: function(a, b, c, d, e, f) {
                null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(b, c), this.ctx.fillStyle = f;
                for (var g = 0; g < c; g += e) this.ctx.fillRect(0, g, b, 1);
                for (var h = 0; h < b; h += d) this.ctx.fillRect(h, 0, 1, c);
                return this.bmd.generateTexture(a)
            }
        }, c.Create.prototype.constructor = c.Create, c.FlexGrid = function(a, b, d) {
            this.game = a.game, this.manager = a, this.width = b, this.height = d, this.boundsCustom = new c.Rectangle(0, 0, b, d), this.boundsFluid = new c.Rectangle(0, 0, b, d), this.boundsFull = new c.Rectangle(0, 0, b, d), this.boundsNone = new c.Rectangle(0, 0, b, d), this.positionCustom = new c.Point(0, 0), this.positionFluid = new c.Point(0, 0), this.positionFull = new c.Point(0, 0), this.positionNone = new c.Point(0, 0), this.scaleCustom = new c.Point(1, 1), this.scaleFluid = new c.Point(1, 1), this.scaleFluidInversed = new c.Point(1, 1), this.scaleFull = new c.Point(1, 1), this.scaleNone = new c.Point(1, 1), this.customWidth = 0, this.customHeight = 0, this.customOffsetX = 0, this.customOffsetY = 0, this.ratioH = b / d, this.ratioV = d / b, this.multiplier = 0, this.layers = []
        }, c.FlexGrid.prototype = {
            setSize: function(a, b) {
                this.width = a, this.height = b, this.ratioH = a / b, this.ratioV = b / a, this.scaleNone = new c.Point(1, 1), this.boundsNone.width = this.width, this.boundsNone.height = this.height, this.refresh()
            },
            createCustomLayer: function(a, b, d, e) {
                void 0 === e && (e = !0), this.customWidth = a, this.customHeight = b, this.boundsCustom.width = a, this.boundsCustom.height = b;
                var f = new c.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
                return e && this.game.world.add(f), this.layers.push(f), "undefined" != typeof d && null !== typeof d && f.addMultiple(d), f
            },
            createFluidLayer: function(a, b) {
                void 0 === b && (b = !0);
                var d = new c.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
                return b && this.game.world.add(d), this.layers.push(d), "undefined" != typeof a && null !== typeof a && d.addMultiple(a), d
            },
            createFullLayer: function(a) {
                var b = new c.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
                return this.game.world.add(b), this.layers.push(b), "undefined" != typeof a && b.addMultiple(a), b
            },
            createFixedLayer: function(a) {
                var b = new c.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
                return this.game.world.add(b), this.layers.push(b), "undefined" != typeof a && b.addMultiple(a), b
            },
            reset: function() {
                for (var a = this.layers.length; a--;) this.layers[a].persist || (this.layers[a].position = null, this.layers[a].scale = null, this.layers.slice(a, 1))
            },
            onResize: function(a, b) {
                this.ratioH = a / b, this.ratioV = b / a, this.refresh(a, b)
            },
            refresh: function() {
                this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width), this.boundsFluid.width = Math.round(this.width * this.multiplier), this.boundsFluid.height = Math.round(this.height * this.multiplier), this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height), this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height), this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height), this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x), this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y), this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y), this.positionNone.set(this.boundsNone.x, this.boundsNone.y)
            },
            fitSprite: function(a) {
                this.manager.scaleSprite(a), a.x = this.manager.bounds.centerX, a.y = this.manager.bounds.centerY
            },
            debug: function() {
                this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16), this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1)
            }
        }, c.FlexGrid.prototype.constructor = c.FlexGrid, c.FlexLayer = function(a, b, d, e) {
            c.Group.call(this, a.game, null, "__flexLayer" + a.game.rnd.uuid(), !1), this.manager = a.manager, this.grid = a, this.persist = !1, this.position = b, this.bounds = d, this.scale = e, this.topLeft = d.topLeft, this.topMiddle = new c.Point(d.halfWidth, 0), this.topRight = d.topRight, this.bottomLeft = d.bottomLeft, this.bottomMiddle = new c.Point(d.halfWidth, d.bottom), this.bottomRight = d.bottomRight
        }, c.FlexLayer.prototype = Object.create(c.Group.prototype), c.FlexLayer.prototype.constructor = c.FlexLayer, c.FlexLayer.prototype.resize = function() {}, c.FlexLayer.prototype.debug = function() {
            this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16), this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1), this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9")
        }, c.Color = {
            packPixel: function(a, b, d, e) {
                return c.Device.LITTLE_ENDIAN ? (e << 24 | d << 16 | b << 8 | a) >>> 0 : (a << 24 | b << 16 | d << 8 | e) >>> 0
            },
            unpackPixel: function(a, b, d, e) {
                return void 0 !== b && null !== b || (b = c.Color.createColor()), void 0 !== d && null !== d || (d = !1), void 0 !== e && null !== e || (e = !1), c.Device.LITTLE_ENDIAN ? (b.a = (4278190080 & a) >>> 24, b.b = (16711680 & a) >>> 16, b.g = (65280 & a) >>> 8, b.r = 255 & a) : (b.r = (4278190080 & a) >>> 24, b.g = (16711680 & a) >>> 16, b.b = (65280 & a) >>> 8, b.a = 255 & a), b.color = a, b.rgba = "rgba(" + b.r + "," + b.g + "," + b.b + "," + b.a / 255 + ")", d && c.Color.RGBtoHSL(b.r, b.g, b.b, b), e && c.Color.RGBtoHSV(b.r, b.g, b.b, b), b
            },
            fromRGBA: function(a, b) {
                return b || (b = c.Color.createColor()), b.r = (4278190080 & a) >>> 24, b.g = (16711680 & a) >>> 16, b.b = (65280 & a) >>> 8, b.a = 255 & a, b.rgba = "rgba(" + b.r + "," + b.g + "," + b.b + "," + b.a + ")", b
            },
            toRGBA: function(a, b, c, d) {
                return a << 24 | b << 16 | c << 8 | d
            },
            toABGR: function(a, b, c, d) {
                return (d << 24 | c << 16 | b << 8 | a) >>> 0
            },
            RGBtoHSL: function(a, b, d, e) {
                e || (e = c.Color.createColor(a, b, d, 1)), a /= 255, b /= 255, d /= 255;
                var f = Math.min(a, b, d),
                    g = Math.max(a, b, d);
                if (e.h = 0, e.s = 0, e.l = (g + f) / 2, g !== f) {
                    var h = g - f;
                    e.s = e.l > .5 ? h / (2 - g - f) : h / (g + f), g === a ? e.h = (b - d) / h + (b < d ? 6 : 0) : g === b ? e.h = (d - a) / h + 2 : g === d && (e.h = (a - b) / h + 4), e.h /= 6
                }
                return e
            },
            HSLtoRGB: function(a, b, d, e) {
                if (e ? (e.r = d, e.g = d, e.b = d) : e = c.Color.createColor(d, d, d), 0 !== b) {
                    var f = d < .5 ? d * (1 + b) : d + b - d * b,
                        g = 2 * d - f;
                    e.r = c.Color.hueToColor(g, f, a + 1 / 3), e.g = c.Color.hueToColor(g, f, a), e.b = c.Color.hueToColor(g, f, a - 1 / 3)
                }
                return e.r = Math.floor(255 * e.r | 0), e.g = Math.floor(255 * e.g | 0), e.b = Math.floor(255 * e.b | 0), c.Color.updateColor(e), e
            },
            RGBtoHSV: function(a, b, d, e) {
                e || (e = c.Color.createColor(a, b, d, 255)), a /= 255, b /= 255, d /= 255;
                var f = Math.min(a, b, d),
                    g = Math.max(a, b, d),
                    h = g - f;
                return e.h = 0, e.s = 0 === g ? 0 : h / g, e.v = g, g !== f && (g === a ? e.h = (b - d) / h + (b < d ? 6 : 0) : g === b ? e.h = (d - a) / h + 2 : g === d && (e.h = (a - b) / h + 4), e.h /= 6), e
            },
            HSVtoRGB: function(a, b, d, e) {
                void 0 === e && (e = c.Color.createColor(0, 0, 0, 1, a, b, 0, d));
                var f, g, h, i = Math.floor(6 * a),
                    j = 6 * a - i,
                    k = d * (1 - b),
                    l = d * (1 - j * b),
                    m = d * (1 - (1 - j) * b);
                switch (i % 6) {
                    case 0:
                        f = d, g = m, h = k;
                        break;
                    case 1:
                        f = l, g = d, h = k;
                        break;
                    case 2:
                        f = k, g = d, h = m;
                        break;
                    case 3:
                        f = k, g = l, h = d;
                        break;
                    case 4:
                        f = m, g = k, h = d;
                        break;
                    case 5:
                        f = d, g = k, h = l
                }
                return e.r = Math.floor(255 * f), e.g = Math.floor(255 * g), e.b = Math.floor(255 * h), c.Color.updateColor(e), e
            },
            hueToColor: function(a, b, c) {
                return c < 0 && (c += 1), c > 1 && (c -= 1), c < 1 / 6 ? a + 6 * (b - a) * c : c < .5 ? b : c < 2 / 3 ? a + (b - a) * (2 / 3 - c) * 6 : a
            },
            createColor: function(a, b, d, e, f, g, h, i) {
                var j = {
                    r: a || 0,
                    g: b || 0,
                    b: d || 0,
                    a: e || 1,
                    h: f || 0,
                    s: g || 0,
                    l: h || 0,
                    v: i || 0,
                    color: 0,
                    color32: 0,
                    rgba: ""
                };
                return c.Color.updateColor(j)
            },
            updateColor: function(a) {
                return a.rgba = "rgba(" + a.r.toString() + "," + a.g.toString() + "," + a.b.toString() + "," + a.a.toString() + ")", a.color = c.Color.getColor(a.r, a.g, a.b), a.color32 = c.Color.getColor32(255 * a.a, a.r, a.g, a.b), a
            },
            getColor32: function(a, b, c, d) {
                return a << 24 | b << 16 | c << 8 | d
            },
            getColor: function(a, b, c) {
                return a << 16 | b << 8 | c
            },
            RGBtoString: function(a, b, d, e, f) {
                return void 0 === e && (e = 255), void 0 === f && (f = "#"), "#" === f ? "#" + ((1 << 24) + (a << 16) + (b << 8) + d).toString(16).slice(1) : "0x" + c.Color.componentToHex(e) + c.Color.componentToHex(a) + c.Color.componentToHex(b) + c.Color.componentToHex(d)
            },
            hexToRGB: function(a) {
                var b = c.Color.hexToColor(a);
                if (b) return c.Color.getColor32(b.a, b.r, b.g, b.b)
            },
            hexToColor: function(a, b) {
                a = a.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(a, b, c, d) {
                    return b + b + c + c + d + d
                });
                var d = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);
                if (d) {
                    var e = parseInt(d[1], 16),
                        f = parseInt(d[2], 16),
                        g = parseInt(d[3], 16);
                    b ? (b.r = e, b.g = f, b.b = g) : b = c.Color.createColor(e, f, g)
                }
                return b
            },
            webToColor: function(a, b) {
                b || (b = c.Color.createColor());
                var d = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(a);
                return d && (b.r = parseInt(d[1], 10), b.g = parseInt(d[2], 10), b.b = parseInt(d[3], 10), b.a = void 0 !== d[4] ? parseFloat(d[4]) : 1, c.Color.updateColor(b)), b
            },
            valueToColor: function(a, b) {
                if (b || (b = c.Color.createColor()), "string" == typeof a) return 0 === a.indexOf("rgb") ? c.Color.webToColor(a, b) : (b.a = 1, c.Color.hexToColor(a, b));
                if ("number" == typeof a) {
                    var d = c.Color.getRGB(a);
                    return b.r = d.r, b.g = d.g, b.b = d.b, b.a = d.a / 255, b
                }
                return b
            },
            componentToHex: function(a) {
                var b = a.toString(16);
                return 1 === b.length ? "0" + b : b
            },
            HSVColorWheel: function(a, b) {
                void 0 === a && (a = 1), void 0 === b && (b = 1);
                for (var d = [], e = 0; e <= 359; e++) d.push(c.Color.HSVtoRGB(e / 359, a, b));
                return d
            },
            HSLColorWheel: function(a, b) {
                void 0 === a && (a = .5), void 0 === b && (b = .5);
                for (var d = [], e = 0; e <= 359; e++) d.push(c.Color.HSLtoRGB(e / 359, a, b));
                return d
            },
            interpolateColor: function(a, b, d, e, f) {
                void 0 === f && (f = 255);
                var g = c.Color.getRGB(a),
                    h = c.Color.getRGB(b),
                    i = (h.red - g.red) * e / d + g.red,
                    j = (h.green - g.green) * e / d + g.green,
                    k = (h.blue - g.blue) * e / d + g.blue;
                return c.Color.getColor32(f, i, j, k)
            },
            interpolateColorWithRGB: function(a, b, d, e, f, g) {
                var h = c.Color.getRGB(a),
                    i = (b - h.red) * g / f + h.red,
                    j = (d - h.green) * g / f + h.green,
                    k = (e - h.blue) * g / f + h.blue;
                return c.Color.getColor(i, j, k)
            },
            interpolateRGB: function(a, b, d, e, f, g, h, i) {
                var j = (e - a) * i / h + a,
                    k = (f - b) * i / h + b,
                    l = (g - d) * i / h + d;
                return c.Color.getColor(j, k, l)
            },
            getRandomColor: function(a, b, d) {
                if (void 0 === a && (a = 0), void 0 === b && (b = 255), void 0 === d && (d = 255), b > 255 || a > b) return c.Color.getColor(255, 255, 255);
                var e = a + Math.round(Math.random() * (b - a)),
                    f = a + Math.round(Math.random() * (b - a)),
                    g = a + Math.round(Math.random() * (b - a));
                return c.Color.getColor32(d, e, f, g)
            },
            getRGB: function(a) {
                return a > 16777215 ? {
                    alpha: a >>> 24,
                    red: a >> 16 & 255,
                    green: a >> 8 & 255,
                    blue: 255 & a,
                    a: a >>> 24,
                    r: a >> 16 & 255,
                    g: a >> 8 & 255,
                    b: 255 & a
                } : {
                    alpha: 255,
                    red: a >> 16 & 255,
                    green: a >> 8 & 255,
                    blue: 255 & a,
                    a: 255,
                    r: a >> 16 & 255,
                    g: a >> 8 & 255,
                    b: 255 & a
                }
            },
            getWebRGB: function(a) {
                if ("object" == typeof a) return "rgba(" + a.r.toString() + "," + a.g.toString() + "," + a.b.toString() + "," + (a.a / 255).toString() + ")";
                var b = c.Color.getRGB(a);
                return "rgba(" + b.r.toString() + "," + b.g.toString() + "," + b.b.toString() + "," + (b.a / 255).toString() + ")"
            },
            getAlpha: function(a) {
                return a >>> 24
            },
            getAlphaFloat: function(a) {
                return (a >>> 24) / 255
            },
            getRed: function(a) {
                return a >> 16 & 255
            },
            getGreen: function(a) {
                return a >> 8 & 255
            },
            getBlue: function(a) {
                return 255 & a
            },
            blendNormal: function(a) {
                return a
            },
            blendLighten: function(a, b) {
                return b > a ? b : a
            },
            blendDarken: function(a, b) {
                return b > a ? a : b
            },
            blendMultiply: function(a, b) {
                return a * b / 255
            },
            blendAverage: function(a, b) {
                return (a + b) / 2
            },
            blendAdd: function(a, b) {
                return Math.min(255, a + b)
            },
            blendSubtract: function(a, b) {
                return Math.max(0, a + b - 255)
            },
            blendDifference: function(a, b) {
                return Math.abs(a - b)
            },
            blendNegation: function(a, b) {
                return 255 - Math.abs(255 - a - b)
            },
            blendScreen: function(a, b) {
                return 255 - ((255 - a) * (255 - b) >> 8)
            },
            blendExclusion: function(a, b) {
                return a + b - 2 * a * b / 255
            },
            blendOverlay: function(a, b) {
                return b < 128 ? 2 * a * b / 255 : 255 - 2 * (255 - a) * (255 - b) / 255
            },
            blendSoftLight: function(a, b) {
                return b < 128 ? 2 * ((a >> 1) + 64) * (b / 255) : 255 - 2 * (255 - ((a >> 1) + 64)) * (255 - b) / 255
            },
            blendHardLight: function(a, b) {
                return c.Color.blendOverlay(b, a)
            },
            blendColorDodge: function(a, b) {
                return 255 === b ? b : Math.min(255, (a << 8) / (255 - b))
            },
            blendColorBurn: function(a, b) {
                return 0 === b ? b : Math.max(0, 255 - (255 - a << 8) / b)
            },
            blendLinearDodge: function(a, b) {
                return c.Color.blendAdd(a, b)
            },
            blendLinearBurn: function(a, b) {
                return c.Color.blendSubtract(a, b)
            },
            blendLinearLight: function(a, b) {
                return b < 128 ? c.Color.blendLinearBurn(a, 2 * b) : c.Color.blendLinearDodge(a, 2 * (b - 128))
            },
            blendVividLight: function(a, b) {
                return b < 128 ? c.Color.blendColorBurn(a, 2 * b) : c.Color.blendColorDodge(a, 2 * (b - 128))
            },
            blendPinLight: function(a, b) {
                return b < 128 ? c.Color.blendDarken(a, 2 * b) : c.Color.blendLighten(a, 2 * (b - 128))
            },
            blendHardMix: function(a, b) {
                return c.Color.blendVividLight(a, b) < 128 ? 0 : 255
            },
            blendReflect: function(a, b) {
                return 255 === b ? b : Math.min(255, a * a / (255 - b))
            },
            blendGlow: function(a, b) {
                return c.Color.blendReflect(b, a)
            },
            blendPhoenix: function(a, b) {
                return Math.min(a, b) - Math.max(a, b) + 255
            }
        }, c.Physics = function(a, b) {
            b = b || {}, this.game = a, this.config = b, this.arcade = null, this.p2 = null, this.ninja = null, this.box2d = null, this.chipmunk = null, this.matter = null, this.parseConfig()
        }, c.Physics.ARCADE = 0, c.Physics.P2JS = 1, c.Physics.NINJA = 2, c.Physics.BOX2D = 3, c.Physics.CHIPMUNK = 4, c.Physics.MATTERJS = 5, c.Physics.prototype = {
            parseConfig: function() {
                this.config.hasOwnProperty("arcade") && this.config.arcade !== !0 || !c.Physics.hasOwnProperty("Arcade") || (this.arcade = new c.Physics.Arcade(this.game)), this.config.hasOwnProperty("ninja") && this.config.ninja === !0 && c.Physics.hasOwnProperty("Ninja") && (this.ninja = new c.Physics.Ninja(this.game)), this.config.hasOwnProperty("p2") && this.config.p2 === !0 && c.Physics.hasOwnProperty("P2") && (this.p2 = new c.Physics.P2(this.game, this.config)), this.config.hasOwnProperty("box2d") && this.config.box2d === !0 && c.Physics.hasOwnProperty("BOX2D") && (this.box2d = new c.Physics.BOX2D(this.game, this.config)), this.config.hasOwnProperty("matter") && this.config.matter === !0 && c.Physics.hasOwnProperty("Matter") && (this.matter = new c.Physics.Matter(this.game, this.config))
            },
            startSystem: function(a) {
                a === c.Physics.ARCADE ? this.arcade = new c.Physics.Arcade(this.game) : a === c.Physics.P2JS ? null === this.p2 ? this.p2 = new c.Physics.P2(this.game, this.config) : this.p2.reset() : a === c.Physics.NINJA ? this.ninja = new c.Physics.Ninja(this.game) : a === c.Physics.BOX2D ? null === this.box2d ? this.box2d = new c.Physics.Box2D(this.game, this.config) : this.box2d.reset() : a === c.Physics.MATTERJS && (null === this.matter ? this.matter = new c.Physics.Matter(this.game, this.config) : this.matter.reset())
            },
            enable: function(a, b, d) {
                void 0 === b && (b = c.Physics.ARCADE), void 0 === d && (d = !1), b === c.Physics.ARCADE ? this.arcade.enable(a) : b === c.Physics.P2JS && this.p2 ? this.p2.enable(a, d) : b === c.Physics.NINJA && this.ninja ? this.ninja.enableAABB(a) : b === c.Physics.BOX2D && this.box2d ? this.box2d.enable(a) : b === c.Physics.MATTERJS && this.matter ? this.matter.enable(a) : void 0
            },
            preUpdate: function() {
                this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate(), this.matter && this.matter.preUpdate()
            },
            update: function() {
                this.p2 && this.p2.update(), this.box2d && this.box2d.update(), this.matter && this.matter.update()
            },
            setBoundsToWorld: function() {
                this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld(), this.matter && this.matter.setBoundsToWorld()
            },
            clear: function() {
                this.p2 && this.p2.clear(), this.box2d && this.box2d.clear(), this.matter && this.matter.clear()
            },
            reset: function() {
                this.p2 && this.p2.reset(), this.box2d && this.box2d.reset(), this.matter && this.matter.reset()
            },
            destroy: function() {
                this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.matter && this.matter.destroy(), this.arcade = null, this.ninja = null, this.p2 = null, this.box2d = null, this.matter = null
            }
        }, c.Physics.prototype.constructor = c.Physics, c.Physics.Arcade = function(a) {
            this.game = a, this.gravity = new c.Point, this.bounds = new c.Rectangle(0, 0, a.world.width, a.world.height), this.checkCollision = {
                up: !0,
                down: !0,
                left: !0,
                right: !0
            }, this.maxObjects = 10, this.maxLevels = 4, this.OVERLAP_BIAS = 4, this.forceX = !1, this.sortDirection = c.Physics.Arcade.LEFT_RIGHT, this.skipQuadTree = !0, this.isPaused = !1, this.quadTree = new c.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this._total = 0, this.setBoundsToWorld()
        }, c.Physics.Arcade.prototype.constructor = c.Physics.Arcade, c.Physics.Arcade.SORT_NONE = 0, c.Physics.Arcade.LEFT_RIGHT = 1, c.Physics.Arcade.RIGHT_LEFT = 2, c.Physics.Arcade.TOP_BOTTOM = 3, c.Physics.Arcade.BOTTOM_TOP = 4, c.Physics.Arcade.prototype = {
            setBounds: function(a, b, c, d) {
                this.bounds.setTo(a, b, c, d)
            },
            setBoundsToWorld: function() {
                this.bounds.copyFrom(this.game.world.bounds)
            },
            enable: function(a, b) {
                void 0 === b && (b = !0);
                var d = 1;
                if (Array.isArray(a))
                    for (d = a.length; d--;) a[d] instanceof c.Group ? this.enable(a[d].children, b) : (this.enableBody(a[d]), b && a[d].hasOwnProperty("children") && a[d].children.length > 0 && this.enable(a[d], !0));
                else a instanceof c.Group ? this.enable(a.children, b) : (this.enableBody(a), b && a.hasOwnProperty("children") && a.children.length > 0 && this.enable(a.children, !0))
            },
            enableBody: function(a) {
                a.hasOwnProperty("body") && null === a.body && (a.body = new c.Physics.Arcade.Body(a), a.parent && a.parent instanceof c.Group && a.parent.addToHash(a))
            },
            updateMotion: function(a) {
                var b = this.computeVelocity(0, a, a.angularVelocity, a.angularAcceleration, a.angularDrag, a.maxAngular) - a.angularVelocity;
                a.angularVelocity += b, a.rotation += a.angularVelocity * this.game.time.physicsElapsed, a.velocity.x = this.computeVelocity(1, a, a.velocity.x, a.acceleration.x, a.drag.x, a.maxVelocity.x), a.velocity.y = this.computeVelocity(2, a, a.velocity.y, a.acceleration.y, a.drag.y, a.maxVelocity.y)
            },
            computeVelocity: function(a, b, c, d, e, f) {
                return void 0 === f && (f = 1e4), 1 === a && b.allowGravity ? c += (this.gravity.x + b.gravity.x) * this.game.time.physicsElapsed : 2 === a && b.allowGravity && (c += (this.gravity.y + b.gravity.y) * this.game.time.physicsElapsed), d ? c += d * this.game.time.physicsElapsed : e && (e *= this.game.time.physicsElapsed, c - e > 0 ? c -= e : c + e < 0 ? c += e : c = 0), c > f ? c = f : c < -f && (c = -f), c
            },
            overlap: function(a, b, c, d, e) {
                if (c = c || null, d = d || null, e = e || c, this._total = 0, !Array.isArray(a) && Array.isArray(b))
                    for (var f = 0; f < b.length; f++) this.collideHandler(a, b[f], c, d, e, !0);
                else if (Array.isArray(a) && !Array.isArray(b))
                    for (var f = 0; f < a.length; f++) this.collideHandler(a[f], b, c, d, e, !0);
                else if (Array.isArray(a) && Array.isArray(b))
                    for (var f = 0; f < a.length; f++)
                        for (var g = 0; g < b.length; g++) this.collideHandler(a[f], b[g], c, d, e, !0);
                else this.collideHandler(a, b, c, d, e, !0);
                return this._total > 0
            },
            collide: function(a, b, c, d, e) {
                if (c = c || null, d = d || null, e = e || c, this._total = 0, !Array.isArray(a) && Array.isArray(b))
                    for (var f = 0; f < b.length; f++) this.collideHandler(a, b[f], c, d, e, !1);
                else if (Array.isArray(a) && !Array.isArray(b))
                    for (var f = 0; f < a.length; f++) this.collideHandler(a[f], b, c, d, e, !1);
                else if (Array.isArray(a) && Array.isArray(b))
                    for (var f = 0; f < a.length; f++)
                        for (var g = 0; g < b.length; g++) this.collideHandler(a[f], b[g], c, d, e, !1);
                else this.collideHandler(a, b, c, d, e, !1);
                return this._total > 0
            },
            sortLeftRight: function(a, b) {
                return a.body && b.body ? a.body.x - b.body.x : 0
            },
            sortRightLeft: function(a, b) {
                return a.body && b.body ? b.body.x - a.body.x : 0
            },
            sortTopBottom: function(a, b) {
                return a.body && b.body ? a.body.y - b.body.y : 0
            },
            sortBottomTop: function(a, b) {
                return a.body && b.body ? b.body.y - a.body.y : 0
            },
            sort: function(a, b) {
                null !== a.physicsSortDirection ? b = a.physicsSortDirection : void 0 === b && (b = this.sortDirection), b === c.Physics.Arcade.LEFT_RIGHT ? a.hash.sort(this.sortLeftRight) : b === c.Physics.Arcade.RIGHT_LEFT ? a.hash.sort(this.sortRightLeft) : b === c.Physics.Arcade.TOP_BOTTOM ? a.hash.sort(this.sortTopBottom) : b === c.Physics.Arcade.BOTTOM_TOP && a.hash.sort(this.sortBottomTop)
            },
            collideHandler: function(a, b, d, e, f, g) {
                return void 0 === b && a.physicsType === c.GROUP ? (this.sort(a), void this.collideGroupVsSelf(a, d, e, f, g)) : void(a && b && a.exists && b.exists && (this.sortDirection !== c.Physics.Arcade.SORT_NONE && (a.physicsType === c.GROUP && this.sort(a), b.physicsType === c.GROUP && this.sort(b)), a.physicsType === c.SPRITE ? b.physicsType === c.SPRITE ? this.collideSpriteVsSprite(a, b, d, e, f, g) : b.physicsType === c.GROUP ? this.collideSpriteVsGroup(a, b, d, e, f, g) : b.physicsType === c.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(a, b, d, e, f, g) : a.physicsType === c.GROUP ? b.physicsType === c.SPRITE ? this.collideSpriteVsGroup(b, a, d, e, f, g) : b.physicsType === c.GROUP ? this.collideGroupVsGroup(a, b, d, e, f, g) : b.physicsType === c.TILEMAPLAYER && this.collideGroupVsTilemapLayer(a, b, d, e, f, g) : a.physicsType === c.TILEMAPLAYER && (b.physicsType === c.SPRITE ? this.collideSpriteVsTilemapLayer(b, a, d, e, f, g) : b.physicsType === c.GROUP && this.collideGroupVsTilemapLayer(b, a, d, e, f, g))))
            },
            collideSpriteVsSprite: function(a, b, c, d, e, f) {
                return !(!a.body || !b.body || (this.separate(a.body, b.body, d, e, f) && (c && c.call(e, a, b), this._total++), 0))
            },
            collideSpriteVsGroup: function(a, b, d, e, f, g) {
                if (0 !== b.length && a.body)
                    if (this.skipQuadTree || a.body.skipQuadTree)
                        for (var h = {}, i = 0; i < b.hash.length; i++) {
                            var j = b.hash[i];
                            if (j && j.exists && j.body) {
                                if (h = j.body.getBounds(h), this.sortDirection === c.Physics.Arcade.LEFT_RIGHT) {
                                    if (a.body.right < h.x) break;
                                    if (h.right < a.body.x) continue
                                } else if (this.sortDirection === c.Physics.Arcade.RIGHT_LEFT) {
                                    if (a.body.x > h.right) break;
                                    if (h.x > a.body.right) continue
                                } else if (this.sortDirection === c.Physics.Arcade.TOP_BOTTOM) {
                                    if (a.body.bottom < h.y) break;
                                    if (h.bottom < a.body.y) continue
                                } else if (this.sortDirection === c.Physics.Arcade.BOTTOM_TOP) {
                                    if (a.body.y > h.bottom) break;
                                    if (h.y > a.body.bottom) continue
                                }
                                this.collideSpriteVsSprite(a, j, d, e, f, g)
                            }
                        } else {
                            this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(b);
                            for (var k = this.quadTree.retrieve(a), i = 0; i < k.length; i++) this.separate(a.body, k[i], e, f, g) && (d && d.call(f, a, k[i].sprite), this._total++)
                        }
            },
            collideGroupVsSelf: function(a, b, d, e, f) {
                if (0 !== a.length)
                    for (var g = 0; g < a.hash.length; g++) {
                        var h = {},
                            i = a.hash[g];
                        if (i && i.exists && i.body) {
                            h = i.body.getBounds(h);
                            for (var j = g + 1; j < a.hash.length; j++) {
                                var k = {},
                                    l = a.hash[j];
                                if (l && l.exists && l.body) {
                                    if (k = l.body.getBounds(k), this.sortDirection === c.Physics.Arcade.LEFT_RIGHT) {
                                        if (h.right < k.x) break;
                                        if (k.right < h.x) continue
                                    } else if (this.sortDirection === c.Physics.Arcade.RIGHT_LEFT) {
                                        if (h.x > k.right) continue;
                                        if (k.x > h.right) break
                                    } else if (this.sortDirection === c.Physics.Arcade.TOP_BOTTOM) {
                                        if (h.bottom < k.y) continue;
                                        if (k.bottom < h.y) break
                                    } else if (this.sortDirection === c.Physics.Arcade.BOTTOM_TOP) {
                                        if (h.y > k.bottom) continue;
                                        if (k.y > i.body.bottom) break
                                    }
                                    this.collideSpriteVsSprite(i, l, b, d, e, f)
                                }
                            }
                        }
                    }
            },
            collideGroupVsGroup: function(a, b, d, e, f, g) {
                if (0 !== a.length && 0 !== b.length)
                    for (var h = 0; h < a.children.length; h++) a.children[h].exists && (a.children[h].physicsType === c.GROUP ? this.collideGroupVsGroup(a.children[h], b, d, e, f, g) : this.collideSpriteVsGroup(a.children[h], b, d, e, f, g))
            },
            separate: function(a, b, c, d, e) {
                if (!a.enable || !b.enable || a.checkCollision.none || b.checkCollision.none || !this.intersects(a, b)) return !1;
                if (c && c.call(d, a.sprite, b.sprite) === !1) return !1;
                if (a.isCircle && b.isCircle) return this.separateCircle(a, b, e);
                if (a.isCircle !== b.isCircle) {
                    var f = a.isCircle ? b : a,
                        g = a.isCircle ? a : b,
                        h = {
                            x: f.x,
                            y: f.y,
                            right: f.right,
                            bottom: f.bottom
                        },
                        i = {
                            x: g.x + g.radius,
                            y: g.y + g.radius
                        };
                    if ((i.y < h.y || i.y > h.bottom) && (i.x < h.x || i.x > h.right)) return this.separateCircle(a, b, e)
                }
                var j = !1,
                    k = !1;
                this.forceX || Math.abs(this.gravity.y + a.gravity.y) < Math.abs(this.gravity.x + a.gravity.x) ? (j = this.separateX(a, b, e), this.intersects(a, b) && (k = this.separateY(a, b, e))) : (k = this.separateY(a, b, e), this.intersects(a, b) && (j = this.separateX(a, b, e)));
                var l = j || k;
                return l && (e ? (a.onOverlap && a.onOverlap.dispatch(a.sprite, b.sprite), b.onOverlap && b.onOverlap.dispatch(b.sprite, a.sprite)) : (a.onCollide && a.onCollide.dispatch(a.sprite, b.sprite), b.onCollide && b.onCollide.dispatch(b.sprite, a.sprite))), l
            },
            intersects: function(a, b) {
                return a !== b && (a.isCircle ? b.isCircle ? c.Math.distance(a.center.x, a.center.y, b.center.x, b.center.y) <= a.radius + b.radius : this.circleBodyIntersects(a, b) : b.isCircle ? this.circleBodyIntersects(b, a) : !(a.right <= b.position.x || a.bottom <= b.position.y || a.position.x >= b.right || a.position.y >= b.bottom))
            },
            circleBodyIntersects: function(a, b) {
                var d = c.Math.clamp(a.center.x, b.left, b.right),
                    e = c.Math.clamp(a.center.y, b.top, b.bottom),
                    f = (a.center.x - d) * (a.center.x - d),
                    g = (a.center.y - e) * (a.center.y - e);
                return f + g <= a.radius * a.radius
            },
            separateCircle: function(a, b, d) {
                this.getOverlapX(a, b), this.getOverlapY(a, b);
                var e = b.center.x - a.center.x,
                    f = b.center.y - a.center.y,
                    g = Math.atan2(f, e),
                    h = 0;
                if (a.isCircle !== b.isCircle) {
                    var i = {
                            x: b.isCircle ? a.position.x : b.position.x,
                            y: b.isCircle ? a.position.y : b.position.y,
                            right: b.isCircle ? a.right : b.right,
                            bottom: b.isCircle ? a.bottom : b.bottom
                        },
                        j = {
                            x: a.isCircle ? a.position.x + a.radius : b.position.x + b.radius,
                            y: a.isCircle ? a.position.y + a.radius : b.position.y + b.radius,
                            radius: a.isCircle ? a.radius : b.radius
                        };
                    j.y < i.y ? j.x < i.x ? h = c.Math.distance(j.x, j.y, i.x, i.y) - j.radius : j.x > i.right && (h = c.Math.distance(j.x, j.y, i.right, i.y) - j.radius) : j.y > i.bottom && (j.x < i.x ? h = c.Math.distance(j.x, j.y, i.x, i.bottom) - j.radius : j.x > i.right && (h = c.Math.distance(j.x, j.y, i.right, i.bottom) - j.radius)), h *= -1
                } else h = a.radius + b.radius - c.Math.distance(a.center.x, a.center.y, b.center.x, b.center.y); if (d || 0 === h || a.immovable && b.immovable || a.customSeparateX || b.customSeparateX) return 0 !== h && (a.onOverlap && a.onOverlap.dispatch(a.sprite, b.sprite), b.onOverlap && b.onOverlap.dispatch(b.sprite, a.sprite)), 0 !== h;
                var k = {
                        x: a.velocity.x * Math.cos(g) + a.velocity.y * Math.sin(g),
                        y: a.velocity.x * Math.sin(g) - a.velocity.y * Math.cos(g)
                    },
                    l = {
                        x: b.velocity.x * Math.cos(g) + b.velocity.y * Math.sin(g),
                        y: b.velocity.x * Math.sin(g) - b.velocity.y * Math.cos(g)
                    },
                    m = ((a.mass - b.mass) * k.x + 2 * b.mass * l.x) / (a.mass + b.mass),
                    n = (2 * a.mass * k.x + (b.mass - a.mass) * l.x) / (a.mass + b.mass);
                return a.immovable || (a.velocity.x = (m * Math.cos(g) - k.y * Math.sin(g)) * a.bounce.x, a.velocity.y = (k.y * Math.cos(g) + m * Math.sin(g)) * a.bounce.y), b.immovable || (b.velocity.x = (n * Math.cos(g) - l.y * Math.sin(g)) * b.bounce.x, b.velocity.y = (l.y * Math.cos(g) + n * Math.sin(g)) * b.bounce.y), Math.abs(g) < Math.PI / 2 ? a.velocity.x > 0 && !a.immovable && b.velocity.x > a.velocity.x ? a.velocity.x *= -1 : b.velocity.x < 0 && !b.immovable && a.velocity.x < b.velocity.x ? b.velocity.x *= -1 : a.velocity.y > 0 && !a.immovable && b.velocity.y > a.velocity.y ? a.velocity.y *= -1 : b.velocity.y < 0 && !b.immovable && a.velocity.y < b.velocity.y && (b.velocity.y *= -1) : Math.abs(g) > Math.PI / 2 && (a.velocity.x < 0 && !a.immovable && b.velocity.x < a.velocity.x ? a.velocity.x *= -1 : b.velocity.x > 0 && !b.immovable && a.velocity.x > b.velocity.x ? b.velocity.x *= -1 : a.velocity.y < 0 && !a.immovable && b.velocity.y < a.velocity.y ? a.velocity.y *= -1 : b.velocity.y > 0 && !b.immovable && a.velocity.x > b.velocity.y && (b.velocity.y *= -1)), a.immovable || (a.x += a.velocity.x * this.game.time.physicsElapsed - h * Math.cos(g), a.y += a.velocity.y * this.game.time.physicsElapsed - h * Math.sin(g)), b.immovable || (b.x += b.velocity.x * this.game.time.physicsElapsed + h * Math.cos(g), b.y += b.velocity.y * this.game.time.physicsElapsed + h * Math.sin(g)), a.onCollide && a.onCollide.dispatch(a.sprite, b.sprite), b.onCollide && b.onCollide.dispatch(b.sprite, a.sprite), !0
            },
            getOverlapX: function(a, b, c) {
                var d = 0,
                    e = a.deltaAbsX() + b.deltaAbsX() + this.OVERLAP_BIAS;
                return 0 === a.deltaX() && 0 === b.deltaX() ? (a.embedded = !0, b.embedded = !0) : a.deltaX() > b.deltaX() ? (d = a.right - b.x, d > e && !c || a.checkCollision.right === !1 || b.checkCollision.left === !1 ? d = 0 : (a.touching.none = !1, a.touching.right = !0, b.touching.none = !1, b.touching.left = !0)) : a.deltaX() < b.deltaX() && (d = a.x - b.width - b.x, -d > e && !c || a.checkCollision.left === !1 || b.checkCollision.right === !1 ? d = 0 : (a.touching.none = !1, a.touching.left = !0, b.touching.none = !1, b.touching.right = !0)), a.overlapX = d, b.overlapX = d, d
            },
            getOverlapY: function(a, b, c) {
                var d = 0,
                    e = a.deltaAbsY() + b.deltaAbsY() + this.OVERLAP_BIAS;
                return 0 === a.deltaY() && 0 === b.deltaY() ? (a.embedded = !0, b.embedded = !0) : a.deltaY() > b.deltaY() ? (d = a.bottom - b.y, d > e && !c || a.checkCollision.down === !1 || b.checkCollision.up === !1 ? d = 0 : (a.touching.none = !1, a.touching.down = !0, b.touching.none = !1, b.touching.up = !0)) : a.deltaY() < b.deltaY() && (d = a.y - b.bottom, -d > e && !c || a.checkCollision.up === !1 || b.checkCollision.down === !1 ? d = 0 : (a.touching.none = !1, a.touching.up = !0, b.touching.none = !1, b.touching.down = !0)), a.overlapY = d, b.overlapY = d, d
            },
            separateX: function(a, b, c) {
                var d = this.getOverlapX(a, b, c);
                if (c || 0 === d || a.immovable && b.immovable || a.customSeparateX || b.customSeparateX) return 0 !== d || a.embedded && b.embedded;
                var e = a.velocity.x,
                    f = b.velocity.x;
                if (a.immovable || b.immovable) a.immovable ? (b.x += d, b.velocity.x = e - f * b.bounce.x, a.moves && (b.y += (a.y - a.prev.y) * a.friction.y)) : (a.x -= d, a.velocity.x = f - e * a.bounce.x, b.moves && (a.y += (b.y - b.prev.y) * b.friction.y));
                else {
                    d *= .5, a.x -= d, b.x += d;
                    var g = Math.sqrt(f * f * b.mass / a.mass) * (f > 0 ? 1 : -1),
                        h = Math.sqrt(e * e * a.mass / b.mass) * (e > 0 ? 1 : -1),
                        i = .5 * (g + h);
                    g -= i, h -= i, a.velocity.x = i + g * a.bounce.x, b.velocity.x = i + h * b.bounce.x
                }
                return !0
            },
            separateY: function(a, b, c) {
                var d = this.getOverlapY(a, b, c);
                if (c || 0 === d || a.immovable && b.immovable || a.customSeparateY || b.customSeparateY) return 0 !== d || a.embedded && b.embedded;
                var e = a.velocity.y,
                    f = b.velocity.y;
                if (a.immovable || b.immovable) a.immovable ? (b.y += d, b.velocity.y = e - f * b.bounce.y, a.moves && (b.x += (a.x - a.prev.x) * a.friction.x)) : (a.y -= d, a.velocity.y = f - e * a.bounce.y, b.moves && (a.x += (b.x - b.prev.x) * b.friction.x));
                else {
                    d *= .5, a.y -= d, b.y += d;
                    var g = Math.sqrt(f * f * b.mass / a.mass) * (f > 0 ? 1 : -1),
                        h = Math.sqrt(e * e * a.mass / b.mass) * (e > 0 ? 1 : -1),
                        i = .5 * (g + h);
                    g -= i, h -= i, a.velocity.y = i + g * a.bounce.y, b.velocity.y = i + h * b.bounce.y
                }
                return !0
            },
            getObjectsUnderPointer: function(a, b, c, d) {
                if (0 !== b.length && a.exists) return this.getObjectsAtLocation(a.x, a.y, b, c, d, a)
            },
            getObjectsAtLocation: function(a, b, d, e, f, g) {
                this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(d);
                for (var h = new c.Rectangle(a, b, 1, 1), i = [], j = this.quadTree.retrieve(h), k = 0; k < j.length; k++) j[k].hitTest(a, b) && (e && e.call(f, g, j[k].sprite), i.push(j[k].sprite));
                return i
            },
            moveToObject: function(a, b, c, d) {
                void 0 === c && (c = 60), void 0 === d && (d = 0);
                var e = Math.atan2(b.y - a.y, b.x - a.x);
                return d > 0 && (c = this.distanceBetween(a, b) / (d / 1e3)), a.body.velocity.x = Math.cos(e) * c, a.body.velocity.y = Math.sin(e) * c, e
            },
            moveToPointer: function(a, b, c, d) {
                void 0 === b && (b = 60), c = c || this.game.input.activePointer, void 0 === d && (d = 0);
                var e = this.angleToPointer(a, c);
                return d > 0 && (b = this.distanceToPointer(a, c) / (d / 1e3)), a.body.velocity.x = Math.cos(e) * b, a.body.velocity.y = Math.sin(e) * b, e
            },
            moveToXY: function(a, b, c, d, e) {
                void 0 === d && (d = 60), void 0 === e && (e = 0);
                var f = Math.atan2(c - a.y, b - a.x);
                return e > 0 && (d = this.distanceToXY(a, b, c) / (e / 1e3)), a.body.velocity.x = Math.cos(f) * d, a.body.velocity.y = Math.sin(f) * d, f
            },
            velocityFromAngle: function(a, b, d) {
                return void 0 === b && (b = 60), d = d || new c.Point, d.setTo(Math.cos(this.game.math.degToRad(a)) * b, Math.sin(this.game.math.degToRad(a)) * b)
            },
            velocityFromRotation: function(a, b, d) {
                return void 0 === b && (b = 60), d = d || new c.Point, d.setTo(Math.cos(a) * b, Math.sin(a) * b)
            },
            accelerationFromRotation: function(a, b, d) {
                return void 0 === b && (b = 60), d = d || new c.Point, d.setTo(Math.cos(a) * b, Math.sin(a) * b)
            },
            accelerateToObject: function(a, b, c, d, e) {
                void 0 === c && (c = 60), void 0 === d && (d = 1e3), void 0 === e && (e = 1e3);
                var f = this.angleBetween(a, b);
                return a.body.acceleration.setTo(Math.cos(f) * c, Math.sin(f) * c), a.body.maxVelocity.setTo(d, e), f
            },
            accelerateToPointer: function(a, b, c, d, e) {
                void 0 === c && (c = 60), void 0 === b && (b = this.game.input.activePointer), void 0 === d && (d = 1e3), void 0 === e && (e = 1e3);
                var f = this.angleToPointer(a, b);
                return a.body.acceleration.setTo(Math.cos(f) * c, Math.sin(f) * c), a.body.maxVelocity.setTo(d, e), f
            },
            accelerateToXY: function(a, b, c, d, e, f) {
                void 0 === d && (d = 60), void 0 === e && (e = 1e3), void 0 === f && (f = 1e3);
                var g = this.angleToXY(a, b, c);
                return a.body.acceleration.setTo(Math.cos(g) * d, Math.sin(g) * d), a.body.maxVelocity.setTo(e, f), g
            },
            distanceBetween: function(a, b, c) {
                void 0 === c && (c = !1);
                var d = c ? a.world.x - b.world.x : a.x - b.x,
                    e = c ? a.world.y - b.world.y : a.y - b.y;
                return Math.sqrt(d * d + e * e)
            },
            distanceToXY: function(a, b, c, d) {
                void 0 === d && (d = !1);
                var e = d ? a.world.x - b : a.x - b,
                    f = d ? a.world.y - c : a.y - c;
                return Math.sqrt(e * e + f * f)
            },
            distanceToPointer: function(a, b, c) {
                void 0 === b && (b = this.game.input.activePointer), void 0 === c && (c = !1);
                var d = c ? a.world.x - b.worldX : a.x - b.worldX,
                    e = c ? a.world.y - b.worldY : a.y - b.worldY;
                return Math.sqrt(d * d + e * e)
            },
            angleBetween: function(a, b, c) {
                return void 0 === c && (c = !1), c ? Math.atan2(b.world.y - a.world.y, b.world.x - a.world.x) : Math.atan2(b.y - a.y, b.x - a.x)
            },
            angleBetweenCenters: function(a, b) {
                var c = b.centerX - a.centerX,
                    d = b.centerY - a.centerY;
                return Math.atan2(d, c)
            },
            angleToXY: function(a, b, c, d) {
                return void 0 === d && (d = !1), d ? Math.atan2(c - a.world.y, b - a.world.x) : Math.atan2(c - a.y, b - a.x)
            },
            angleToPointer: function(a, b, c) {
                return void 0 === b && (b = this.game.input.activePointer), void 0 === c && (c = !1), c ? Math.atan2(b.worldY - a.world.y, b.worldX - a.world.x) : Math.atan2(b.worldY - a.y, b.worldX - a.x)
            },
            worldAngleToPointer: function(a, b) {
                return this.angleToPointer(a, b, !0)
            }
        }, c.Physics.Arcade.Body = function(a) {
            this.sprite = a, this.game = a.game, this.type = c.Physics.ARCADE, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new c.Point, this.position = new c.Point(a.x, a.y), this.prev = new c.Point(this.position.x, this.position.y), this.allowRotation = !0, this.rotation = a.angle, this.preRotation = a.angle, this.width = a.width, this.height = a.height, this.sourceWidth = a.width, this.sourceHeight = a.height, a.texture && (this.sourceWidth = a.texture.frame.width, this.sourceHeight = a.texture.frame.height), this.halfWidth = Math.abs(a.width / 2), this.halfHeight = Math.abs(a.height / 2), this.center = new c.Point(a.x + this.halfWidth, a.y + this.halfHeight), this.velocity = new c.Point, this.newVelocity = new c.Point, this.deltaMax = new c.Point, this.acceleration = new c.Point, this.drag = new c.Point, this.allowGravity = !0, this.gravity = new c.Point, this.bounce = new c.Point, this.worldBounce = null, this.onWorldBounds = null, this.onCollide = null, this.onOverlap = null, this.maxVelocity = new c.Point(1e4, 1e4), this.friction = new c.Point(1, 0), this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = c.NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
                none: !1,
                any: !0,
                up: !0,
                down: !0,
                left: !0,
                right: !0
            }, this.touching = {
                none: !0,
                up: !1,
                down: !1,
                left: !1,
                right: !1
            }, this.wasTouching = {
                none: !0,
                up: !1,
                down: !1,
                left: !1,
                right: !1
            }, this.blocked = {
                up: !1,
                down: !1,
                left: !1,
                right: !1
            }, this.tilePadding = new c.Point, this.dirty = !1, this.skipQuadTree = !1, this.syncBounds = !1, this.isMoving = !1, this.stopVelocityOnCollide = !0, this.moveTimer = 0, this.moveDistance = 0, this.moveDuration = 0, this.moveTarget = null, this.moveEnd = null, this.onMoveComplete = new c.Signal, this.movementCallback = null, this.movementCallbackContext = null, this._reset = !0, this._sx = a.scale.x, this._sy = a.scale.y, this._dx = 0, this._dy = 0
        }, c.Physics.Arcade.Body.prototype = {
            updateBounds: function() {
                if (this.syncBounds) {
                    var a = this.sprite.getBounds();
                    a.ceilAll(), a.width === this.width && a.height === this.height || (this.width = a.width, this.height = a.height, this._reset = !0)
                } else {
                    var b = Math.abs(this.sprite.scale.x),
                        c = Math.abs(this.sprite.scale.y);
                    b === this._sx && c === this._sy || (this.width = this.sourceWidth * b, this.height = this.sourceHeight * c, this._sx = b, this._sy = c, this._reset = !0)
                }
                this._reset && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight))
            },
            preUpdate: function() {
                this.enable && !this.game.physics.arcade.isPaused && (this.dirty = !0, this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1, this.touching.right = !1, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.embedded = !1, this.updateBounds(), this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.rotation = this.sprite.angle, this.preRotation = this.rotation, (this._reset || this.sprite.fresh) && (this.prev.x = this.position.x, this.prev.y = this.position.y), this.moves && (this.game.physics.arcade.updateMotion(this), this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed), this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, this.position.x === this.prev.x && this.position.y === this.prev.y || (this.angle = Math.atan2(this.velocity.y, this.velocity.x)), this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1)
            },
            updateMovement: function() {
                var a = 0,
                    b = 0 !== this.overlapX || 0 !== this.overlapY;
                if (this.moveDuration > 0 ? (this.moveTimer += this.game.time.elapsedMS, a = this.moveTimer / this.moveDuration) : (this.moveTarget.end.set(this.position.x, this.position.y), a = this.moveTarget.length / this.moveDistance), this.movementCallback) var c = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, a);
                return !(b || a >= 1 || void 0 !== c && c !== !0) || (this.stopMovement(a >= 1 || this.stopVelocityOnCollide && b), !1)
            },
            stopMovement: function(a) {
                this.isMoving && (this.isMoving = !1, a && this.velocity.set(0), this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY))
            },
            postUpdate: function() {
                this.enable && this.dirty && (this.isMoving && this.updateMovement(), this.dirty = !1, this.deltaX() < 0 ? this.facing = c.LEFT : this.deltaX() > 0 && (this.facing = c.RIGHT), this.deltaY() < 0 ? this.facing = c.UP : this.deltaY() > 0 && (this.facing = c.DOWN), this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.sprite.position.x += this._dx, this.sprite.position.y += this._dy, this._reset = !0), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y)
            },
            checkWorldBounds: function() {
                var a = this.position,
                    b = this.game.physics.arcade.bounds,
                    c = this.game.physics.arcade.checkCollision,
                    d = this.worldBounce ? -this.worldBounce.x : -this.bounce.x,
                    e = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
                if (this.isCircle) {
                    var f = {
                        x: this.center.x - this.radius,
                        y: this.center.y - this.radius,
                        right: this.center.x + this.radius,
                        bottom: this.center.y + this.radius
                    };
                    f.x < b.x && c.left ? (a.x = b.x - this.halfWidth + this.radius, this.velocity.x *= d, this.blocked.left = !0) : f.right > b.right && c.right && (a.x = b.right - this.halfWidth - this.radius, this.velocity.x *= d, this.blocked.right = !0), f.y < b.y && c.up ? (a.y = b.y - this.halfHeight + this.radius, this.velocity.y *= e, this.blocked.up = !0) : f.bottom > b.bottom && c.down && (a.y = b.bottom - this.halfHeight - this.radius, this.velocity.y *= e, this.blocked.down = !0)
                } else a.x < b.x && c.left ? (a.x = b.x, this.velocity.x *= d, this.blocked.left = !0) : this.right > b.right && c.right && (a.x = b.right - this.width, this.velocity.x *= d, this.blocked.right = !0), a.y < b.y && c.up ? (a.y = b.y, this.velocity.y *= e, this.blocked.up = !0) : this.bottom > b.bottom && c.down && (a.y = b.bottom - this.height, this.velocity.y *= e, this.blocked.down = !0);
                return this.blocked.up || this.blocked.down || this.blocked.left || this.blocked.right
            },
            moveFrom: function(a, b, c) {
                if (void 0 === b && (b = this.speed), 0 === b) return !1;
                var d;
                return void 0 === c ? (d = this.angle, c = this.game.math.radToDeg(d)) : d = this.game.math.degToRad(c), this.moveTimer = 0, this.moveDuration = a, 0 === c || 180 === c ? this.velocity.set(Math.cos(d) * b, 0) : 90 === c || 270 === c ? this.velocity.set(0, Math.sin(d) * b) : this.velocity.set(Math.cos(d) * b, Math.sin(d) * b), this.isMoving = !0, !0
            },
            moveTo: function(a, b, d) {
                var e = b / (a / 1e3);
                if (0 === e) return !1;
                var f;
                return void 0 === d ? (f = this.angle, d = this.game.math.radToDeg(f)) : f = this.game.math.degToRad(d), b = Math.abs(b), this.moveDuration = 0, this.moveDistance = b, null === this.moveTarget && (this.moveTarget = new c.Line, this.moveEnd = new c.Point), this.moveTarget.fromAngle(this.x, this.y, f, b), this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y), this.moveTarget.setTo(this.x, this.y, this.x, this.y), 0 === d || 180 === d ? this.velocity.set(Math.cos(f) * e, 0) : 90 === d || 270 === d ? this.velocity.set(0, Math.sin(f) * e) : this.velocity.set(Math.cos(f) * e, Math.sin(f) * e), this.isMoving = !0, !0
            },
            setSize: function(a, b, c, d) {
                void 0 === c && (c = this.offset.x), void 0 === d && (d = this.offset.y), this.sourceWidth = a, this.sourceHeight = b, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(c, d), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.isCircle = !1, this.radius = 0
            },
            setCircle: function(a, b, c) {
                void 0 === b && (b = this.offset.x), void 0 === c && (c = this.offset.y), a > 0 ? (this.isCircle = !0, this.radius = a, this.sourceWidth = 2 * a, this.sourceHeight = 2 * a, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(b, c), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)) : this.isCircle = !1
            },
            reset: function(a, b) {
                this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this.position.x = a - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = b - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.prev.x = this.position.x, this.prev.y = this.position.y, this.rotation = this.sprite.angle, this.preRotation = this.rotation, this._sx = this.sprite.scale.x, this._sy = this.sprite.scale.y, this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
            },
            getBounds: function(a) {
                return this.isCircle ? (a.x = this.center.x - this.radius, a.y = this.center.y - this.radius, a.right = this.center.x + this.radius, a.bottom = this.center.y + this.radius) : (a.x = this.x, a.y = this.y, a.right = this.right, a.bottom = this.bottom), a
            },
            hitTest: function(a, b) {
                return this.isCircle ? c.Circle.contains(this, a, b) : c.Rectangle.contains(this, a, b)
            },
            onFloor: function() {
                return this.blocked.down
            },
            onCeiling: function() {
                return this.blocked.up
            },
            onWall: function() {
                return this.blocked.left || this.blocked.right
            },
            deltaAbsX: function() {
                return this.deltaX() > 0 ? this.deltaX() : -this.deltaX()
            },
            deltaAbsY: function() {
                return this.deltaY() > 0 ? this.deltaY() : -this.deltaY()
            },
            deltaX: function() {
                return this.position.x - this.prev.x
            },
            deltaY: function() {
                return this.position.y - this.prev.y
            },
            deltaZ: function() {
                return this.rotation - this.preRotation
            },
            destroy: function() {
                this.sprite.parent && this.sprite.parent instanceof c.Group && this.sprite.parent.removeFromHash(this.sprite), this.sprite.body = null, this.sprite = null
            }
        }, Object.defineProperty(c.Physics.Arcade.Body.prototype, "left", {
            get: function() {
                return this.position.x
            }
        }), Object.defineProperty(c.Physics.Arcade.Body.prototype, "right", {
            get: function() {
                return this.position.x + this.width
            }
        }), Object.defineProperty(c.Physics.Arcade.Body.prototype, "top", {
            get: function() {
                return this.position.y
            }
        }), Object.defineProperty(c.Physics.Arcade.Body.prototype, "bottom", {
            get: function() {
                return this.position.y + this.height
            }
        }), Object.defineProperty(c.Physics.Arcade.Body.prototype, "x", {
            get: function() {
                return this.position.x
            },
            set: function(a) {
                this.position.x = a
            }
        }), Object.defineProperty(c.Physics.Arcade.Body.prototype, "y", {
            get: function() {
                return this.position.y
            },
            set: function(a) {
                this.position.y = a;
            }
        }), c.Physics.Arcade.Body.render = function(a, b, c, d) {
            void 0 === d && (d = !0), c = c || "rgba(0,255,0,0.4)", a.fillStyle = c, a.strokeStyle = c, b.isCircle ? (a.beginPath(), a.arc(b.center.x - b.game.camera.x, b.center.y - b.game.camera.y, b.radius, 0, 2 * Math.PI), d ? a.fill() : a.stroke()) : d ? a.fillRect(b.position.x - b.game.camera.x, b.position.y - b.game.camera.y, b.width, b.height) : a.strokeRect(b.position.x - b.game.camera.x, b.position.y - b.game.camera.y, b.width, b.height)
        }, c.Physics.Arcade.Body.renderBodyInfo = function(a, b) {
            a.line("x: " + b.x.toFixed(2), "y: " + b.y.toFixed(2), "width: " + b.width, "height: " + b.height), a.line("velocity x: " + b.velocity.x.toFixed(2), "y: " + b.velocity.y.toFixed(2), "deltaX: " + b._dx.toFixed(2), "deltaY: " + b._dy.toFixed(2)), a.line("acceleration x: " + b.acceleration.x.toFixed(2), "y: " + b.acceleration.y.toFixed(2), "speed: " + b.speed.toFixed(2), "angle: " + b.angle.toFixed(2)), a.line("gravity x: " + b.gravity.x, "y: " + b.gravity.y, "bounce x: " + b.bounce.x.toFixed(2), "y: " + b.bounce.y.toFixed(2)), a.line("touching left: " + b.touching.left, "right: " + b.touching.right, "up: " + b.touching.up, "down: " + b.touching.down), a.line("blocked left: " + b.blocked.left, "right: " + b.blocked.right, "up: " + b.blocked.up, "down: " + b.blocked.down)
        }, c.Physics.Arcade.Body.prototype.constructor = c.Physics.Arcade.Body, c.Physics.Arcade.TilemapCollision = function() {}, c.Physics.Arcade.TilemapCollision.prototype = {
            TILE_BIAS: 16,
            collideSpriteVsTilemapLayer: function(a, b, c, d, e, f) {
                if (a.body) {
                    var g = b.getTiles(a.body.position.x - a.body.tilePadding.x, a.body.position.y - a.body.tilePadding.y, a.body.width + a.body.tilePadding.x, a.body.height + a.body.tilePadding.y, !1, !1);
                    if (0 !== g.length)
                        for (var h = 0; h < g.length; h++) d ? d.call(e, a, g[h]) && this.separateTile(h, a.body, g[h], b, f) && (this._total++, c && c.call(e, a, g[h])) : this.separateTile(h, a.body, g[h], b, f) && (this._total++, c && c.call(e, a, g[h]))
                }
            },
            collideGroupVsTilemapLayer: function(a, b, c, d, e, f) {
                if (0 !== a.length)
                    for (var g = 0; g < a.children.length; g++) a.children[g].exists && this.collideSpriteVsTilemapLayer(a.children[g], b, c, d, e, f)
            },
            separateTile: function(a, b, c, d, e) {
                if (!b.enable) return !1;
                var f = d.fixedToCamera ? 0 : d.position.x,
                    g = d.fixedToCamera ? 0 : d.position.y;
                if (!c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g)) return !1;
                if (e) return !0;
                if (c.collisionCallback && !c.collisionCallback.call(c.collisionCallbackContext, b.sprite, c)) return !1;
                if ("undefined" != typeof c.layer.callbacks && c.layer.callbacks[c.index] && !c.layer.callbacks[c.index].callback.call(c.layer.callbacks[c.index].callbackContext, b.sprite, c)) return !1;
                if (!(c.faceLeft || c.faceRight || c.faceTop || c.faceBottom)) return !1;
                var h = 0,
                    i = 0,
                    j = 0,
                    k = 1;
                if (b.deltaAbsX() > b.deltaAbsY() ? j = -1 : b.deltaAbsX() < b.deltaAbsY() && (k = -1), 0 !== b.deltaX() && 0 !== b.deltaY() && (c.faceLeft || c.faceRight) && (c.faceTop || c.faceBottom) && (j = Math.min(Math.abs(b.position.x - f - c.right), Math.abs(b.right - f - c.left)), k = Math.min(Math.abs(b.position.y - g - c.bottom), Math.abs(b.bottom - g - c.top))), j < k) {
                    if ((c.faceLeft || c.faceRight) && (h = this.tileCheckX(b, c, d), 0 !== h && !c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g))) return !0;
                    (c.faceTop || c.faceBottom) && (i = this.tileCheckY(b, c, d))
                } else {
                    if ((c.faceTop || c.faceBottom) && (i = this.tileCheckY(b, c, d), 0 !== i && !c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g))) return !0;
                    (c.faceLeft || c.faceRight) && (h = this.tileCheckX(b, c, d))
                }
                return 0 !== h || 0 !== i
            },
            tileCheckX: function(a, b, c) {
                var d = 0,
                    e = c.fixedToCamera ? 0 : c.position.x;
                return a.deltaX() < 0 && !a.blocked.left && b.collideRight && a.checkCollision.left ? b.faceRight && a.x - e < b.right && (d = a.x - e - b.right, d < -this.TILE_BIAS && (d = 0)) : a.deltaX() > 0 && !a.blocked.right && b.collideLeft && a.checkCollision.right && b.faceLeft && a.right - e > b.left && (d = a.right - e - b.left, d > this.TILE_BIAS && (d = 0)), 0 !== d && (a.customSeparateX ? a.overlapX = d : this.processTileSeparationX(a, d)), d
            },
            tileCheckY: function(a, b, c) {
                var d = 0,
                    e = c.fixedToCamera ? 0 : c.position.y;
                return a.deltaY() < 0 && !a.blocked.up && b.collideDown && a.checkCollision.up ? b.faceBottom && a.y - e < b.bottom && (d = a.y - e - b.bottom, d < -this.TILE_BIAS && (d = 0)) : a.deltaY() > 0 && !a.blocked.down && b.collideUp && a.checkCollision.down && b.faceTop && a.bottom - e > b.top && (d = a.bottom - e - b.top, d > this.TILE_BIAS && (d = 0)), 0 !== d && (a.customSeparateY ? a.overlapY = d : this.processTileSeparationY(a, d)), d
            },
            processTileSeparationX: function(a, b) {
                b < 0 ? a.blocked.left = !0 : b > 0 && (a.blocked.right = !0), a.position.x -= b, 0 === a.bounce.x ? a.velocity.x = 0 : a.velocity.x = -a.velocity.x * a.bounce.x
            },
            processTileSeparationY: function(a, b) {
                b < 0 ? a.blocked.up = !0 : b > 0 && (a.blocked.down = !0), a.position.y -= b, 0 === a.bounce.y ? a.velocity.y = 0 : a.velocity.y = -a.velocity.y * a.bounce.y
            }
        }, c.Utils.mixinPrototype(c.Physics.Arcade.prototype, c.Physics.Arcade.TilemapCollision.prototype), p2.Body.prototype.parent = null, p2.Spring.prototype.parent = null, c.Physics.P2 = function(a, b) {
            this.game = a, void 0 === b ? b = {
                gravity: [0, 0],
                broadphase: new p2.SAPBroadphase
            } : (b.hasOwnProperty("gravity") || (b.gravity = [0, 0]), b.hasOwnProperty("broadphase") || (b.broadphase = new p2.SAPBroadphase)), this.config = b, this.world = new p2.World(this.config), this.frameRate = 1 / 60, this.useElapsedTime = !1, this.paused = !1, this.materials = [], this.gravity = new c.Physics.P2.InversePointProxy(this, this.world.gravity), this.walls = {
                left: null,
                right: null,
                top: null,
                bottom: null
            }, this.onBodyAdded = new c.Signal, this.onBodyRemoved = new c.Signal, this.onSpringAdded = new c.Signal, this.onSpringRemoved = new c.Signal, this.onConstraintAdded = new c.Signal, this.onConstraintRemoved = new c.Signal, this.onContactMaterialAdded = new c.Signal, this.onContactMaterialRemoved = new c.Signal, this.postBroadphaseCallback = null, this.callbackContext = null, this.onBeginContact = new c.Signal, this.onEndContact = new c.Signal, b.hasOwnProperty("mpx") && b.hasOwnProperty("pxm") && b.hasOwnProperty("mpxi") && b.hasOwnProperty("pxmi") && (this.mpx = b.mpx, this.mpxi = b.mpxi, this.pxm = b.pxm, this.pxmi = b.pxmi), this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.collisionGroups = [], this.nothingCollisionGroup = new c.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new c.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new c.Physics.P2.CollisionGroup(2147483648), this.boundsCollidesWith = [], this._toRemove = [], this._collisionGroupID = 2, this._boundsLeft = !0, this._boundsRight = !0, this._boundsTop = !0, this._boundsBottom = !0, this._boundsOwnGroup = !1, this.setBoundsToWorld(!0, !0, !0, !0, !1)
        }, c.Physics.P2.prototype = {
            removeBodyNextStep: function(a) {
                this._toRemove.push(a)
            },
            preUpdate: function() {
                for (var a = this._toRemove.length; a--;) this.removeBody(this._toRemove[a]);
                this._toRemove.length = 0
            },
            enable: function(a, b, d) {
                void 0 === b && (b = !1), void 0 === d && (d = !0);
                var e = 1;
                if (Array.isArray(a))
                    for (e = a.length; e--;) a[e] instanceof c.Group ? this.enable(a[e].children, b, d) : (this.enableBody(a[e], b), d && a[e].hasOwnProperty("children") && a[e].children.length > 0 && this.enable(a[e], b, !0));
                else a instanceof c.Group ? this.enable(a.children, b, d) : (this.enableBody(a, b), d && a.hasOwnProperty("children") && a.children.length > 0 && this.enable(a.children, b, !0))
            },
            enableBody: function(a, b) {
                a.hasOwnProperty("body") && null === a.body && (a.body = new c.Physics.P2.Body(this.game, a, a.x, a.y, 1), a.body.debug = b, "undefined" != typeof a.anchor && a.anchor.set(.5))
            },
            setImpactEvents: function(a) {
                a ? this.world.on("impact", this.impactHandler, this) : this.world.off("impact", this.impactHandler, this)
            },
            setPostBroadphaseCallback: function(a, b) {
                this.postBroadphaseCallback = a, this.callbackContext = b, null !== a ? this.world.on("postBroadphase", this.postBroadphaseHandler, this) : this.world.off("postBroadphase", this.postBroadphaseHandler, this)
            },
            postBroadphaseHandler: function(a) {
                if (this.postBroadphaseCallback && 0 !== a.pairs.length)
                    for (var b = a.pairs.length - 2; b >= 0; b -= 2) a.pairs[b].parent && a.pairs[b + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, a.pairs[b].parent, a.pairs[b + 1].parent) && a.pairs.splice(b, 2)
            },
            impactHandler: function(a) {
                if (a.bodyA.parent && a.bodyB.parent) {
                    var b = a.bodyA.parent,
                        c = a.bodyB.parent;
                    b._bodyCallbacks[a.bodyB.id] && b._bodyCallbacks[a.bodyB.id].call(b._bodyCallbackContext[a.bodyB.id], b, c, a.shapeA, a.shapeB), c._bodyCallbacks[a.bodyA.id] && c._bodyCallbacks[a.bodyA.id].call(c._bodyCallbackContext[a.bodyA.id], c, b, a.shapeB, a.shapeA), b._groupCallbacks[a.shapeB.collisionGroup] && b._groupCallbacks[a.shapeB.collisionGroup].call(b._groupCallbackContext[a.shapeB.collisionGroup], b, c, a.shapeA, a.shapeB), c._groupCallbacks[a.shapeA.collisionGroup] && c._groupCallbacks[a.shapeA.collisionGroup].call(c._groupCallbackContext[a.shapeA.collisionGroup], c, b, a.shapeB, a.shapeA)
                }
            },
            beginContactHandler: function(a) {
                a.bodyA && a.bodyB && (this.onBeginContact.dispatch(a.bodyA, a.bodyB, a.shapeA, a.shapeB, a.contactEquations), a.bodyA.parent && a.bodyA.parent.onBeginContact.dispatch(a.bodyB.parent, a.bodyB, a.shapeA, a.shapeB, a.contactEquations), a.bodyB.parent && a.bodyB.parent.onBeginContact.dispatch(a.bodyA.parent, a.bodyA, a.shapeB, a.shapeA, a.contactEquations))
            },
            endContactHandler: function(a) {
                a.bodyA && a.bodyB && (this.onEndContact.dispatch(a.bodyA, a.bodyB, a.shapeA, a.shapeB), a.bodyA.parent && a.bodyA.parent.onEndContact.dispatch(a.bodyB.parent, a.bodyB, a.shapeA, a.shapeB), a.bodyB.parent && a.bodyB.parent.onEndContact.dispatch(a.bodyA.parent, a.bodyA, a.shapeB, a.shapeA))
            },
            setBoundsToWorld: function(a, b, c, d, e) {
                this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, a, b, c, d, e)
            },
            setWorldMaterial: function(a, b, c, d, e) {
                void 0 === b && (b = !0), void 0 === c && (c = !0), void 0 === d && (d = !0), void 0 === e && (e = !0), b && this.walls.left && (this.walls.left.shapes[0].material = a), c && this.walls.right && (this.walls.right.shapes[0].material = a), d && this.walls.top && (this.walls.top.shapes[0].material = a), e && this.walls.bottom && (this.walls.bottom.shapes[0].material = a)
            },
            updateBoundsCollisionGroup: function(a) {
                void 0 === a && (a = !0);
                var b = a ? this.boundsCollisionGroup.mask : this.everythingCollisionGroup.mask;
                this.walls.left && (this.walls.left.shapes[0].collisionGroup = b), this.walls.right && (this.walls.right.shapes[0].collisionGroup = b), this.walls.top && (this.walls.top.shapes[0].collisionGroup = b), this.walls.bottom && (this.walls.bottom.shapes[0].collisionGroup = b), this._boundsOwnGroup = a
            },
            setBounds: function(a, b, c, d, e, f, g, h, i) {
                void 0 === e && (e = this._boundsLeft), void 0 === f && (f = this._boundsRight), void 0 === g && (g = this._boundsTop), void 0 === h && (h = this._boundsBottom), void 0 === i && (i = this._boundsOwnGroup), this.setupWall(e, "left", a, b, 1.5707963267948966, i), this.setupWall(f, "right", a + c, b, -1.5707963267948966, i), this.setupWall(g, "top", a, b, -3.141592653589793, i), this.setupWall(h, "bottom", a, b + d, 0, i), this._boundsLeft = e, this._boundsRight = f, this._boundsTop = g, this._boundsBottom = h, this._boundsOwnGroup = i
            },
            setupWall: function(a, b, c, d, e, f) {
                a ? (this.walls[b] ? this.walls[b].position = [this.pxmi(c), this.pxmi(d)] : (this.walls[b] = new p2.Body({
                    mass: 0,
                    position: [this.pxmi(c), this.pxmi(d)],
                    angle: e
                }), this.walls[b].addShape(new p2.Plane), this.world.addBody(this.walls[b])), f && (this.walls[b].shapes[0].collisionGroup = this.boundsCollisionGroup.mask)) : this.walls[b] && (this.world.removeBody(this.walls[b]), this.walls[b] = null)
            },
            pause: function() {
                this.paused = !0
            },
            resume: function() {
                this.paused = !1
            },
            update: function() {
                this.paused || (this.useElapsedTime ? this.world.step(this.game.time.physicsElapsed) : this.world.step(this.frameRate))
            },
            reset: function() {
                this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.nothingCollisionGroup = new c.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new c.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new c.Physics.P2.CollisionGroup(2147483648), this._collisionGroupID = 2, this.setBoundsToWorld(!0, !0, !0, !0, !1)
            },
            clear: function() {
                this.world.time = 0, this.world.fixedStepTime = 0, this.world.solver && this.world.solver.equations.length && this.world.solver.removeAllEquations();
                for (var a = this.world.constraints, b = a.length - 1; b >= 0; b--) this.world.removeConstraint(a[b]);
                for (var c = this.world.bodies, b = c.length - 1; b >= 0; b--) this.world.removeBody(c[b]);
                for (var d = this.world.springs, b = d.length - 1; b >= 0; b--) this.world.removeSpring(d[b]);
                for (var e = this.world.contactMaterials, b = e.length - 1; b >= 0; b--) this.world.removeContactMaterial(e[b]);
                this.world.off("beginContact", this.beginContactHandler, this), this.world.off("endContact", this.endContactHandler, this), this.postBroadphaseCallback = null, this.callbackContext = null, this.impactCallback = null, this.collisionGroups = [], this._toRemove = [], this.boundsCollidesWith = [], this.walls = {
                    left: null,
                    right: null,
                    top: null,
                    bottom: null
                }
            },
            destroy: function() {
                this.clear(), this.game = null
            },
            addBody: function(a) {
                return !a.data.world && (this.world.addBody(a.data), this.onBodyAdded.dispatch(a), !0)
            },
            removeBody: function(a) {
                return a.data.world === this.world && (this.world.removeBody(a.data), this.onBodyRemoved.dispatch(a)), a
            },
            addSpring: function(a) {
                return a instanceof c.Physics.P2.Spring || a instanceof c.Physics.P2.RotationalSpring ? this.world.addSpring(a.data) : this.world.addSpring(a), this.onSpringAdded.dispatch(a), a
            },
            removeSpring: function(a) {
                return a instanceof c.Physics.P2.Spring || a instanceof c.Physics.P2.RotationalSpring ? this.world.removeSpring(a.data) : this.world.removeSpring(a), this.onSpringRemoved.dispatch(a), a
            },
            createDistanceConstraint: function(a, b, d, e, f, g) {
                return a = this.getBody(a), b = this.getBody(b), a && b ? this.addConstraint(new c.Physics.P2.DistanceConstraint(this, a, b, d, e, f, g)) : void 0
            },
            createGearConstraint: function(a, b, d, e) {
                return a = this.getBody(a), b = this.getBody(b), a && b ? this.addConstraint(new c.Physics.P2.GearConstraint(this, a, b, d, e)) : void 0
            },
            createRevoluteConstraint: function(a, b, d, e, f, g) {
                return a = this.getBody(a), d = this.getBody(d), a && d ? this.addConstraint(new c.Physics.P2.RevoluteConstraint(this, a, b, d, e, f, g)) : void 0
            },
            createLockConstraint: function(a, b, d, e, f) {
                return a = this.getBody(a), b = this.getBody(b), a && b ? this.addConstraint(new c.Physics.P2.LockConstraint(this, a, b, d, e, f)) : void 0
            },
            createPrismaticConstraint: function(a, b, d, e, f, g, h) {
                return a = this.getBody(a), b = this.getBody(b), a && b ? this.addConstraint(new c.Physics.P2.PrismaticConstraint(this, a, b, d, e, f, g, h)) : void 0
            },
            addConstraint: function(a) {
                return this.world.addConstraint(a), this.onConstraintAdded.dispatch(a), a
            },
            removeConstraint: function(a) {
                return this.world.removeConstraint(a), this.onConstraintRemoved.dispatch(a), a
            },
            addContactMaterial: function(a) {
                return this.world.addContactMaterial(a), this.onContactMaterialAdded.dispatch(a), a
            },
            removeContactMaterial: function(a) {
                return this.world.removeContactMaterial(a), this.onContactMaterialRemoved.dispatch(a), a
            },
            getContactMaterial: function(a, b) {
                return this.world.getContactMaterial(a, b)
            },
            setMaterial: function(a, b) {
                for (var c = b.length; c--;) b[c].setMaterial(a)
            },
            createMaterial: function(a, b) {
                a = a || "";
                var d = new c.Physics.P2.Material(a);
                return this.materials.push(d), "undefined" != typeof b && b.setMaterial(d), d
            },
            createContactMaterial: function(a, b, d) {
                void 0 === a && (a = this.createMaterial()), void 0 === b && (b = this.createMaterial());
                var e = new c.Physics.P2.ContactMaterial(a, b, d);
                return this.addContactMaterial(e)
            },
            getBodies: function() {
                for (var a = [], b = this.world.bodies.length; b--;) a.push(this.world.bodies[b].parent);
                return a
            },
            getBody: function(a) {
                return a instanceof p2.Body ? a : a instanceof c.Physics.P2.Body ? a.data : a.body && a.body.type === c.Physics.P2JS ? a.body.data : null
            },
            getSprings: function() {
                for (var a = [], b = this.world.springs.length; b--;) a.push(this.world.springs[b].parent);
                return a
            },
            getConstraints: function() {
                for (var a = [], b = this.world.constraints.length; b--;) a.push(this.world.constraints[b]);
                return a
            },
            hitTest: function(a, b, d, e) {
                void 0 === b && (b = this.world.bodies), void 0 === d && (d = 5), void 0 === e && (e = !1);
                for (var f = [this.pxmi(a.x), this.pxmi(a.y)], g = [], h = b.length; h--;) b[h] instanceof c.Physics.P2.Body && (!e || b[h].data.type !== p2.Body.STATIC) ? g.push(b[h].data) : b[h] instanceof p2.Body && b[h].parent && (!e || b[h].type !== p2.Body.STATIC) ? g.push(b[h]) : b[h] instanceof c.Sprite && b[h].hasOwnProperty("body") && (!e || b[h].body.data.type !== p2.Body.STATIC) && g.push(b[h].body.data);
                return this.world.hitTest(f, g, d)
            },
            toJSON: function() {
                return this.world.toJSON()
            },
            createCollisionGroup: function(a) {
                var b = Math.pow(2, this._collisionGroupID);
                this.walls.left && (this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | b), this.walls.right && (this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | b), this.walls.top && (this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | b), this.walls.bottom && (this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | b), this._collisionGroupID++;
                var d = new c.Physics.P2.CollisionGroup(b);
                return this.collisionGroups.push(d), a && this.setCollisionGroup(a, d), d
            },
            setCollisionGroup: function(a, b) {
                if (a instanceof c.Group)
                    for (var d = 0; d < a.total; d++) a.children[d].body && a.children[d].body.type === c.Physics.P2JS && a.children[d].body.setCollisionGroup(b);
                else a.body.setCollisionGroup(b)
            },
            createSpring: function(a, b, d, e, f, g, h, i, j) {
                return a = this.getBody(a), b = this.getBody(b), a && b ? this.addSpring(new c.Physics.P2.Spring(this, a, b, d, e, f, g, h, i, j)) : void 0
            },
            createRotationalSpring: function(a, b, d, e, f) {
                return a = this.getBody(a), b = this.getBody(b), a && b ? this.addSpring(new c.Physics.P2.RotationalSpring(this, a, b, d, e, f)) : void 0
            },
            createBody: function(a, b, d, e, f, g) {
                void 0 === e && (e = !1);
                var h = new c.Physics.P2.Body(this.game, null, a, b, d);
                if (g) {
                    var i = h.addPolygon(f, g);
                    if (!i) return !1
                }
                return e && this.world.addBody(h.data), h
            },
            createParticle: function(a, b, d, e, f, g) {
                void 0 === e && (e = !1);
                var h = new c.Physics.P2.Body(this.game, null, a, b, d);
                if (g) {
                    var i = h.addPolygon(f, g);
                    if (!i) return !1
                }
                return e && this.world.addBody(h.data), h
            },
            convertCollisionObjects: function(a, b, c) {
                void 0 === c && (c = !0);
                for (var d = [], e = 0, f = a.collision[b].length; e < f; e++) {
                    var g = a.collision[b][e],
                        h = this.createBody(g.x, g.y, 0, c, {}, g.polyline);
                    h && d.push(h)
                }
                return d
            },
            clearTilemapLayerBodies: function(a, b) {
                b = a.getLayer(b);
                for (var c = a.layers[b].bodies.length; c--;) a.layers[b].bodies[c].destroy();
                a.layers[b].bodies.length = 0
            },
            convertTilemap: function(a, b, c, d) {
                b = a.getLayer(b), void 0 === c && (c = !0), void 0 === d && (d = !0), this.clearTilemapLayerBodies(a, b);
                for (var e = 0, f = 0, g = 0, h = 0, i = a.layers[b].height; h < i; h++) {
                    e = 0;
                    for (var j = 0, k = a.layers[b].width; j < k; j++) {
                        var l = a.layers[b].data[h][j];
                        if (l && l.index > -1 && l.collides)
                            if (d) {
                                var m = a.getTileRight(b, j, h);
                                if (0 === e && (f = l.x * l.width, g = l.y * l.height, e = l.width), m && m.collides) e += l.width;
                                else {
                                    var n = this.createBody(f, g, 0, !1);
                                    n.addRectangle(e, l.height, e / 2, l.height / 2, 0), c && this.addBody(n), a.layers[b].bodies.push(n), e = 0
                                }
                            } else {
                                var n = this.createBody(l.x * l.width, l.y * l.height, 0, !1);
                                n.addRectangle(l.width, l.height, l.width / 2, l.height / 2, 0), c && this.addBody(n), a.layers[b].bodies.push(n)
                            }
                    }
                }
                return a.layers[b].bodies
            },
            mpx: function(a) {
                return a *= 20
            },
            pxm: function(a) {
                return .05 * a
            },
            mpxi: function(a) {
                return a *= -20
            },
            pxmi: function(a) {
                return a * -.05
            }
        }, Object.defineProperty(c.Physics.P2.prototype, "friction", {
            get: function() {
                return this.world.defaultContactMaterial.friction
            },
            set: function(a) {
                this.world.defaultContactMaterial.friction = a
            }
        }), Object.defineProperty(c.Physics.P2.prototype, "restitution", {
            get: function() {
                return this.world.defaultContactMaterial.restitution
            },
            set: function(a) {
                this.world.defaultContactMaterial.restitution = a
            }
        }), Object.defineProperty(c.Physics.P2.prototype, "contactMaterial", {
            get: function() {
                return this.world.defaultContactMaterial
            },
            set: function(a) {
                this.world.defaultContactMaterial = a
            }
        }), Object.defineProperty(c.Physics.P2.prototype, "applySpringForces", {
            get: function() {
                return this.world.applySpringForces
            },
            set: function(a) {
                this.world.applySpringForces = a
            }
        }), Object.defineProperty(c.Physics.P2.prototype, "applyDamping", {
            get: function() {
                return this.world.applyDamping
            },
            set: function(a) {
                this.world.applyDamping = a
            }
        }), Object.defineProperty(c.Physics.P2.prototype, "applyGravity", {
            get: function() {
                return this.world.applyGravity
            },
            set: function(a) {
                this.world.applyGravity = a
            }
        }), Object.defineProperty(c.Physics.P2.prototype, "solveConstraints", {
            get: function() {
                return this.world.solveConstraints
            },
            set: function(a) {
                this.world.solveConstraints = a
            }
        }), Object.defineProperty(c.Physics.P2.prototype, "time", {
            get: function() {
                return this.world.time
            }
        }), Object.defineProperty(c.Physics.P2.prototype, "emitImpactEvent", {
            get: function() {
                return this.world.emitImpactEvent
            },
            set: function(a) {
                this.world.emitImpactEvent = a
            }
        }), Object.defineProperty(c.Physics.P2.prototype, "sleepMode", {
            get: function() {
                return this.world.sleepMode
            },
            set: function(a) {
                this.world.sleepMode = a
            }
        }), Object.defineProperty(c.Physics.P2.prototype, "total", {
            get: function() {
                return this.world.bodies.length
            }
        }), c.Physics.P2.FixtureList = function(a) {
            Array.isArray(a) || (a = [a]), this.rawList = a, this.init(), this.parse(this.rawList)
        }, c.Physics.P2.FixtureList.prototype = {
            init: function() {
                this.namedFixtures = {}, this.groupedFixtures = [], this.allFixtures = []
            },
            setCategory: function(a, b) {
                var c = function(b) {
                    b.collisionGroup = a
                };
                this.getFixtures(b).forEach(c)
            },
            setMask: function(a, b) {
                var c = function(b) {
                    b.collisionMask = a
                };
                this.getFixtures(b).forEach(c)
            },
            setSensor: function(a, b) {
                var c = function(b) {
                    b.sensor = a
                };
                this.getFixtures(b).forEach(c)
            },
            setMaterial: function(a, b) {
                var c = function(b) {
                    b.material = a
                };
                this.getFixtures(b).forEach(c)
            },
            getFixtures: function(a) {
                var b = [];
                if (a) {
                    a instanceof Array || (a = [a]);
                    var c = this;
                    return a.forEach(function(a) {
                        c.namedFixtures[a] && b.push(c.namedFixtures[a])
                    }), this.flatten(b)
                }
                return this.allFixtures
            },
            getFixtureByKey: function(a) {
                return this.namedFixtures[a]
            },
            getGroup: function(a) {
                return this.groupedFixtures[a]
            },
            parse: function() {
                var a, b, c, d;
                c = this.rawList, d = [];
                for (a in c) b = c[a], isNaN(a - 0) ? this.namedFixtures[a] = this.flatten(b) : (this.groupedFixtures[a] = this.groupedFixtures[a] || [], this.groupedFixtures[a] = this.groupedFixtures[a].concat(b)), d.push(this.allFixtures = this.flatten(this.groupedFixtures))
            },
            flatten: function(a) {
                var b, c;
                return b = [], c = arguments.callee, a.forEach(function(a) {
                    return Array.prototype.push.apply(b, Array.isArray(a) ? c(a) : [a])
                }), b
            }
        }, c.Physics.P2.PointProxy = function(a, b) {
            this.world = a, this.destination = b
        }, c.Physics.P2.PointProxy.prototype.constructor = c.Physics.P2.PointProxy, Object.defineProperty(c.Physics.P2.PointProxy.prototype, "x", {
            get: function() {
                return this.world.mpx(this.destination[0])
            },
            set: function(a) {
                this.destination[0] = this.world.pxm(a)
            }
        }), Object.defineProperty(c.Physics.P2.PointProxy.prototype, "y", {
            get: function() {
                return this.world.mpx(this.destination[1])
            },
            set: function(a) {
                this.destination[1] = this.world.pxm(a)
            }
        }), Object.defineProperty(c.Physics.P2.PointProxy.prototype, "mx", {
            get: function() {
                return this.destination[0]
            },
            set: function(a) {
                this.destination[0] = a
            }
        }), Object.defineProperty(c.Physics.P2.PointProxy.prototype, "my", {
            get: function() {
                return this.destination[1]
            },
            set: function(a) {
                this.destination[1] = a
            }
        }), c.Physics.P2.InversePointProxy = function(a, b) {
            this.world = a, this.destination = b
        }, c.Physics.P2.InversePointProxy.prototype.constructor = c.Physics.P2.InversePointProxy, Object.defineProperty(c.Physics.P2.InversePointProxy.prototype, "x", {
            get: function() {
                return this.world.mpxi(this.destination[0])
            },
            set: function(a) {
                this.destination[0] = this.world.pxmi(a)
            }
        }), Object.defineProperty(c.Physics.P2.InversePointProxy.prototype, "y", {
            get: function() {
                return this.world.mpxi(this.destination[1])
            },
            set: function(a) {
                this.destination[1] = this.world.pxmi(a)
            }
        }), Object.defineProperty(c.Physics.P2.InversePointProxy.prototype, "mx", {
            get: function() {
                return this.destination[0]
            },
            set: function(a) {
                this.destination[0] = -a
            }
        }), Object.defineProperty(c.Physics.P2.InversePointProxy.prototype, "my", {
            get: function() {
                return this.destination[1]
            },
            set: function(a) {
                this.destination[1] = -a
            }
        }), c.Physics.P2.Body = function(a, b, d, e, f) {
            b = b || null, d = d || 0, e = e || 0, void 0 === f && (f = 1), this.game = a, this.world = a.physics.p2, this.sprite = b, this.type = c.Physics.P2JS, this.offset = new c.Point, this.data = new p2.Body({
                position: [this.world.pxmi(d), this.world.pxmi(e)],
                mass: f
            }), this.data.parent = this, this.velocity = new c.Physics.P2.InversePointProxy(this.world, this.data.velocity), this.force = new c.Physics.P2.InversePointProxy(this.world, this.data.force), this.gravity = new c.Point, this.onBeginContact = new c.Signal, this.onEndContact = new c.Signal, this.collidesWith = [], this.removeNextStep = !1, this.debugBody = null, this.dirty = !1, this._collideWorldBounds = !0, this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this._reset = !1, b && (this.setRectangleFromSprite(b), b.exists && this.game.physics.p2.addBody(this))
        }, c.Physics.P2.Body.prototype = {
            createBodyCallback: function(a, b, c) {
                var d = -1;
                a.id ? d = a.id : a.body && (d = a.body.id), d > -1 && (null === b ? (delete this._bodyCallbacks[d], delete this._bodyCallbackContext[d]) : (this._bodyCallbacks[d] = b, this._bodyCallbackContext[d] = c))
            },
            createGroupCallback: function(a, b, c) {
                null === b ? (delete this._groupCallbacks[a.mask], delete this._groupCallbackContext[a.mask]) : (this._groupCallbacks[a.mask] = b, this._groupCallbackContext[a.mask] = c)
            },
            getCollisionMask: function() {
                var a = 0;
                this._collideWorldBounds && (a = this.game.physics.p2.boundsCollisionGroup.mask);
                for (var b = 0; b < this.collidesWith.length; b++) a |= this.collidesWith[b].mask;
                return a
            },
            updateCollisionMask: function(a) {
                var b = this.getCollisionMask();
                if (void 0 === a)
                    for (var c = this.data.shapes.length - 1; c >= 0; c--) this.data.shapes[c].collisionMask = b;
                else a.collisionMask = b
            },
            setCollisionGroup: function(a, b) {
                var c = this.getCollisionMask();
                if (void 0 === b)
                    for (var d = this.data.shapes.length - 1; d >= 0; d--) this.data.shapes[d].collisionGroup = a.mask, this.data.shapes[d].collisionMask = c;
                else b.collisionGroup = a.mask, b.collisionMask = c
            },
            clearCollision: function(a, b, c) {
                if (void 0 === a && (a = !0), void 0 === b && (b = !0), void 0 === c)
                    for (var d = this.data.shapes.length - 1; d >= 0; d--) a && (this.data.shapes[d].collisionGroup = null), b && (this.data.shapes[d].collisionMask = null);
                else a && (c.collisionGroup = null), b && (c.collisionMask = null);
                a && (this.collidesWith.length = 0)
            },
            removeCollisionGroup: function(a, b, c) {
                void 0 === b && (b = !0);
                var d;
                if (Array.isArray(a))
                    for (var e = 0; e < a.length; e++) d = this.collidesWith.indexOf(a[e]), d > -1 && (this.collidesWith.splice(d, 1), b && (delete this._groupCallbacks[a.mask], delete this._groupCallbackContext[a.mask]));
                else d = this.collidesWith.indexOf(a), d > -1 && (this.collidesWith.splice(d, 1), b && (delete this._groupCallbacks[a.mask], delete this._groupCallbackContext[a.mask]));
                var f = this.getCollisionMask();
                if (void 0 === c)
                    for (var e = this.data.shapes.length - 1; e >= 0; e--) this.data.shapes[e].collisionMask = f;
                else c.collisionMask = f
            },
            collides: function(a, b, c, d) {
                if (Array.isArray(a))
                    for (var e = 0; e < a.length; e++) this.collidesWith.indexOf(a[e]) === -1 && (this.collidesWith.push(a[e]), b && this.createGroupCallback(a[e], b, c));
                else this.collidesWith.indexOf(a) === -1 && (this.collidesWith.push(a), b && this.createGroupCallback(a, b, c));
                var f = this.getCollisionMask();
                if (void 0 === d)
                    for (var e = this.data.shapes.length - 1; e >= 0; e--) this.data.shapes[e].collisionMask = f;
                else d.collisionMask = f
            },
            adjustCenterOfMass: function() {
                this.data.adjustCenterOfMass(), this.shapeChanged()
            },
            getVelocityAtPoint: function(a, b) {
                return this.data.getVelocityAtPoint(a, b)
            },
            applyDamping: function(a) {
                this.data.applyDamping(a)
            },
            applyImpulse: function(a, b, c) {
                this.data.applyImpulse(a, [this.world.pxmi(b), this.world.pxmi(c)])
            },
            applyImpulseLocal: function(a, b, c) {
                this.data.applyImpulseLocal(a, [this.world.pxmi(b), this.world.pxmi(c)])
            },
            applyForce: function(a, b, c) {
                this.data.applyForce(a, [this.world.pxmi(b), this.world.pxmi(c)])
            },
            setZeroForce: function() {
                this.data.setZeroForce()
            },
            setZeroRotation: function() {
                this.data.angularVelocity = 0
            },
            setZeroVelocity: function() {
                this.data.velocity[0] = 0, this.data.velocity[1] = 0
            },
            setZeroDamping: function() {
                this.data.damping = 0, this.data.angularDamping = 0
            },
            toLocalFrame: function(a, b) {
                return this.data.toLocalFrame(a, b)
            },
            toWorldFrame: function(a, b) {
                return this.data.toWorldFrame(a, b)
            },
            rotateLeft: function(a) {
                this.data.angularVelocity = this.world.pxm(-a)
            },
            rotateRight: function(a) {
                this.data.angularVelocity = this.world.pxm(a)
            },
            moveForward: function(a) {
                var b = this.world.pxmi(-a),
                    c = this.data.angle + Math.PI / 2;
                this.data.velocity[0] = b * Math.cos(c), this.data.velocity[1] = b * Math.sin(c)
            },
            moveBackward: function(a) {
                var b = this.world.pxmi(-a),
                    c = this.data.angle + Math.PI / 2;
                this.data.velocity[0] = -(b * Math.cos(c)), this.data.velocity[1] = -(b * Math.sin(c))
            },
            thrust: function(a) {
                var b = this.world.pxmi(-a),
                    c = this.data.angle + Math.PI / 2;
                this.data.force[0] += b * Math.cos(c), this.data.force[1] += b * Math.sin(c)
            },
            thrustLeft: function(a) {
                var b = this.world.pxmi(-a),
                    c = this.data.angle;
                this.data.force[0] += b * Math.cos(c), this.data.force[1] += b * Math.sin(c)
            },
            thrustRight: function(a) {
                var b = this.world.pxmi(-a),
                    c = this.data.angle;
                this.data.force[0] -= b * Math.cos(c), this.data.force[1] -= b * Math.sin(c)
            },
            reverse: function(a) {
                var b = this.world.pxmi(-a),
                    c = this.data.angle + Math.PI / 2;
                this.data.force[0] -= b * Math.cos(c), this.data.force[1] -= b * Math.sin(c)
            },
            moveLeft: function(a) {
                this.data.velocity[0] = this.world.pxmi(-a)
            },
            moveRight: function(a) {
                this.data.velocity[0] = this.world.pxmi(a)
            },
            moveUp: function(a) {
                this.data.velocity[1] = this.world.pxmi(-a)
            },
            moveDown: function(a) {
                this.data.velocity[1] = this.world.pxmi(a)
            },
            preUpdate: function() {
                this.dirty = !0, this.removeNextStep && (this.removeFromWorld(), this.removeNextStep = !1)
            },
            postUpdate: function() {
                this.sprite.x = this.world.mpxi(this.data.position[0]) + this.offset.x, this.sprite.y = this.world.mpxi(this.data.position[1]) + this.offset.y, this.fixedRotation || (this.sprite.rotation = this.data.angle), this.debugBody && this.debugBody.updateSpriteTransform(), this.dirty = !1
            },
            reset: function(a, b, c, d) {
                void 0 === c && (c = !1), void 0 === d && (d = !1), this.setZeroForce(), this.setZeroVelocity(), this.setZeroRotation(), c && this.setZeroDamping(), d && (this.mass = 1), this.x = a, this.y = b
            },
            addToWorld: function() {
                if (this.game.physics.p2._toRemove)
                    for (var a = 0; a < this.game.physics.p2._toRemove.length; a++) this.game.physics.p2._toRemove[a] === this && this.game.physics.p2._toRemove.splice(a, 1);
                this.data.world !== this.game.physics.p2.world && this.game.physics.p2.addBody(this)
            },
            removeFromWorld: function() {
                this.data.world === this.game.physics.p2.world && this.game.physics.p2.removeBodyNextStep(this)
            },
            destroy: function() {
                this.removeFromWorld(), this.clearShapes(), this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this.debugBody && this.debugBody.destroy(!0, !0), this.debugBody = null, this.sprite && (this.sprite.body = null, this.sprite = null)
            },
            clearShapes: function() {
                for (var a = this.data.shapes.length; a--;) this.data.removeShape(this.data.shapes[a]);
                this.shapeChanged()
            },
            addShape: function(a, b, c, d) {
                return void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = 0), this.data.addShape(a, [this.world.pxmi(b), this.world.pxmi(c)], d), this.shapeChanged(), a
            },
            addCircle: function(a, b, c, d) {
                var e = new p2.Circle({
                    radius: this.world.pxm(a)
                });
                return this.addShape(e, b, c, d)
            },
            addRectangle: function(a, b, c, d, e) {
                var f = new p2.Box({
                    width: this.world.pxm(a),
                    height: this.world.pxm(b)
                });
                return this.addShape(f, c, d, e)
            },
            addPlane: function(a, b, c) {
                var d = new p2.Plane;
                return this.addShape(d, a, b, c)
            },
            addParticle: function(a, b, c) {
                var d = new p2.Particle;
                return this.addShape(d, a, b, c)
            },
            addLine: function(a, b, c, d) {
                var e = new p2.Line({
                    length: this.world.pxm(a)
                });
                return this.addShape(e, b, c, d)
            },
            addCapsule: function(a, b, c, d, e) {
                var f = new p2.Capsule({
                    length: this.world.pxm(a),
                    radius: this.world.pxm(b)
                });
                return this.addShape(f, c, d, e)
            },
            addPolygon: function(a, b) {
                a = a || {}, Array.isArray(b) || (b = Array.prototype.slice.call(arguments, 1));
                var c = [];
                if (1 === b.length && Array.isArray(b[0])) c = b[0].slice(0);
                else if (Array.isArray(b[0])) c = b.slice();
                else if ("number" == typeof b[0])
                    for (var d = 0, e = b.length; d < e; d += 2) c.push([b[d], b[d + 1]]);
                var f = c.length - 1;
                c[f][0] === c[0][0] && c[f][1] === c[0][1] && c.pop();
                for (var g = 0; g < c.length; g++) c[g][0] = this.world.pxmi(c[g][0]), c[g][1] = this.world.pxmi(c[g][1]);
                var h = this.data.fromPolygon(c, a);
                return this.shapeChanged(), h
            },
            removeShape: function(a) {
                var b = this.data.removeShape(a);
                return this.shapeChanged(), b
            },
            setCircle: function(a, b, c, d) {
                return this.clearShapes(), this.addCircle(a, b, c, d)
            },
            setRectangle: function(a, b, c, d, e) {
                return void 0 === a && (a = 16), void 0 === b && (b = 16), this.clearShapes(), this.addRectangle(a, b, c, d, e)
            },
            setRectangleFromSprite: function(a) {
                return void 0 === a && (a = this.sprite), this.clearShapes(), this.addRectangle(a.width, a.height, 0, 0, a.rotation)
            },
            setMaterial: function(a, b) {
                if (void 0 === b)
                    for (var c = this.data.shapes.length - 1; c >= 0; c--) this.data.shapes[c].material = a;
                else b.material = a
            },
            shapeChanged: function() {
                this.debugBody && this.debugBody.draw()
            },
            addPhaserPolygon: function(a, b) {
                for (var c = this.game.cache.getPhysicsData(a, b), d = [], e = 0; e < c.length; e++) {
                    var f = c[e],
                        g = this.addFixture(f);
                    d[f.filter.group] = d[f.filter.group] || [], d[f.filter.group] = d[f.filter.group].concat(g), f.fixtureKey && (d[f.fixtureKey] = g)
                }
                return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), d
            },
            addFixture: function(a) {
                var b = [];
                if (a.circle) {
                    var c = new p2.Circle({
                        radius: this.world.pxm(a.circle.radius)
                    });
                    c.collisionGroup = a.filter.categoryBits, c.collisionMask = a.filter.maskBits, c.sensor = a.isSensor;
                    var d = p2.vec2.create();
                    d[0] = this.world.pxmi(a.circle.position[0] - this.sprite.width / 2), d[1] = this.world.pxmi(a.circle.position[1] - this.sprite.height / 2), this.data.addShape(c, d), b.push(c)
                } else
                    for (var e = a.polygons, f = p2.vec2.create(), g = 0; g < e.length; g++) {
                        for (var h = e[g], i = [], j = 0; j < h.length; j += 2) i.push([this.world.pxmi(h[j]), this.world.pxmi(h[j + 1])]);
                        for (var c = new p2.Convex({
                            vertices: i
                        }), k = 0; k !== c.vertices.length; k++) {
                            var l = c.vertices[k];
                            p2.vec2.sub(l, l, c.centerOfMass)
                        }
                        p2.vec2.scale(f, c.centerOfMass, 1), f[0] -= this.world.pxmi(this.sprite.width / 2), f[1] -= this.world.pxmi(this.sprite.height / 2), c.updateTriangles(), c.updateCenterOfMass(), c.updateBoundingRadius(), c.collisionGroup = a.filter.categoryBits, c.collisionMask = a.filter.maskBits, c.sensor = a.isSensor, this.data.addShape(c, f), b.push(c)
                    }
                return b
            },
            loadPolygon: function(a, b) {
                if (null === a) var c = b;
                else var c = this.game.cache.getPhysicsData(a, b);
                for (var d = p2.vec2.create(), e = 0; e < c.length; e++) {
                    for (var f = [], g = 0; g < c[e].shape.length; g += 2) f.push([this.world.pxmi(c[e].shape[g]), this.world.pxmi(c[e].shape[g + 1])]);
                    for (var h = new p2.Convex({
                        vertices: f
                    }), i = 0; i !== h.vertices.length; i++) {
                        var j = h.vertices[i];
                        p2.vec2.sub(j, j, h.centerOfMass)
                    }
                    p2.vec2.scale(d, h.centerOfMass, 1), d[0] -= this.world.pxmi(this.sprite.width / 2), d[1] -= this.world.pxmi(this.sprite.height / 2), h.updateTriangles(), h.updateCenterOfMass(), h.updateBoundingRadius(), this.data.addShape(h, d)
                }
                return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), !0
            }
        }, c.Physics.P2.Body.prototype.constructor = c.Physics.P2.Body, c.Physics.P2.Body.DYNAMIC = 1, c.Physics.P2.Body.STATIC = 2, c.Physics.P2.Body.KINEMATIC = 4, Object.defineProperty(c.Physics.P2.Body.prototype, "static", {
            get: function() {
                return this.data.type === c.Physics.P2.Body.STATIC
            },
            set: function(a) {
                a && this.data.type !== c.Physics.P2.Body.STATIC ? (this.data.type = c.Physics.P2.Body.STATIC, this.mass = 0) : a || this.data.type !== c.Physics.P2.Body.STATIC || (this.data.type = c.Physics.P2.Body.DYNAMIC, this.mass = 1)
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "dynamic", {
            get: function() {
                return this.data.type === c.Physics.P2.Body.DYNAMIC
            },
            set: function(a) {
                a && this.data.type !== c.Physics.P2.Body.DYNAMIC ? (this.data.type = c.Physics.P2.Body.DYNAMIC, this.mass = 1) : a || this.data.type !== c.Physics.P2.Body.DYNAMIC || (this.data.type = c.Physics.P2.Body.STATIC, this.mass = 0)
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "kinematic", {
            get: function() {
                return this.data.type === c.Physics.P2.Body.KINEMATIC
            },
            set: function(a) {
                a && this.data.type !== c.Physics.P2.Body.KINEMATIC ? (this.data.type = c.Physics.P2.Body.KINEMATIC, this.mass = 4) : a || this.data.type !== c.Physics.P2.Body.KINEMATIC || (this.data.type = c.Physics.P2.Body.STATIC, this.mass = 0)
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "allowSleep", {
            get: function() {
                return this.data.allowSleep
            },
            set: function(a) {
                a !== this.data.allowSleep && (this.data.allowSleep = a)
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "angle", {
            get: function() {
                return c.Math.wrapAngle(c.Math.radToDeg(this.data.angle))
            },
            set: function(a) {
                this.data.angle = c.Math.degToRad(c.Math.wrapAngle(a))
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "angularDamping", {
            get: function() {
                return this.data.angularDamping
            },
            set: function(a) {
                this.data.angularDamping = a
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "angularForce", {
            get: function() {
                return this.data.angularForce
            },
            set: function(a) {
                this.data.angularForce = a
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "angularVelocity", {
            get: function() {
                return this.data.angularVelocity
            },
            set: function(a) {
                this.data.angularVelocity = a
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "damping", {
            get: function() {
                return this.data.damping
            },
            set: function(a) {
                this.data.damping = a
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "fixedRotation", {
            get: function() {
                return this.data.fixedRotation
            },
            set: function(a) {
                a !== this.data.fixedRotation && (this.data.fixedRotation = a)
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "inertia", {
            get: function() {
                return this.data.inertia
            },
            set: function(a) {
                this.data.inertia = a
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "mass", {
            get: function() {
                return this.data.mass
            },
            set: function(a) {
                a !== this.data.mass && (this.data.mass = a, this.data.updateMassProperties())
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "motionState", {
            get: function() {
                return this.data.type
            },
            set: function(a) {
                a !== this.data.type && (this.data.type = a)
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "rotation", {
            get: function() {
                return this.data.angle
            },
            set: function(a) {
                this.data.angle = a
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "sleepSpeedLimit", {
            get: function() {
                return this.data.sleepSpeedLimit
            },
            set: function(a) {
                this.data.sleepSpeedLimit = a
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "x", {
            get: function() {
                return this.world.mpxi(this.data.position[0])
            },
            set: function(a) {
                this.data.position[0] = this.world.pxmi(a)
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "y", {
            get: function() {
                return this.world.mpxi(this.data.position[1])
            },
            set: function(a) {
                this.data.position[1] = this.world.pxmi(a)
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "id", {
            get: function() {
                return this.data.id
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "debug", {
            get: function() {
                return null !== this.debugBody
            },
            set: function(a) {
                a && !this.debugBody ? this.debugBody = new c.Physics.P2.BodyDebug(this.game, this.data) : !a && this.debugBody && (this.debugBody.destroy(), this.debugBody = null)
            }
        }), Object.defineProperty(c.Physics.P2.Body.prototype, "collideWorldBounds", {
            get: function() {
                return this._collideWorldBounds
            },
            set: function(a) {
                a && !this._collideWorldBounds ? (this._collideWorldBounds = !0, this.updateCollisionMask()) : !a && this._collideWorldBounds && (this._collideWorldBounds = !1, this.updateCollisionMask())
            }
        }), c.Physics.P2.BodyDebug = function(a, b, d) {
            c.Group.call(this, a);
            var e = {
                pixelsPerLengthUnit: a.physics.p2.mpx(1),
                debugPolygons: !1,
                lineWidth: 1,
                alpha: .5
            };
            this.settings = c.Utils.extend(e, d), this.ppu = this.settings.pixelsPerLengthUnit, this.ppu = -1 * this.ppu, this.body = b, this.canvas = new c.Graphics(a), this.canvas.alpha = this.settings.alpha, this.add(this.canvas), this.draw(), this.updateSpriteTransform()
        }, c.Physics.P2.BodyDebug.prototype = Object.create(c.Group.prototype), c.Physics.P2.BodyDebug.prototype.constructor = c.Physics.P2.BodyDebug, c.Utils.extend(c.Physics.P2.BodyDebug.prototype, {
            updateSpriteTransform: function() {
                this.position.x = this.body.position[0] * this.ppu, this.position.y = this.body.position[1] * this.ppu, this.rotation = this.body.angle
            },
            draw: function() {
                var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o;
                if (h = this.body, j = this.canvas, j.clear(), c = parseInt(this.randomPastelHex(), 16), f = 16711680, g = this.lineWidth, h instanceof p2.Body && h.shapes.length) {
                    var p = h.shapes.length;
                    for (d = 0; d !== p;) {
                        if (b = h.shapes[d], i = b.position || 0, a = b.angle || 0, b instanceof p2.Circle) this.drawCircle(j, i[0] * this.ppu, i[1] * this.ppu, a, b.radius * this.ppu, c, g);
                        else if (b instanceof p2.Capsule) this.drawCapsule(j, i[0] * this.ppu, i[1] * this.ppu, a, b.length * this.ppu, b.radius * this.ppu, f, c, g);
                        else if (b instanceof p2.Plane) this.drawPlane(j, i[0] * this.ppu, -i[1] * this.ppu, c, f, 5 * g, 10 * g, 10 * g, 100 * this.ppu, a);
                        else if (b instanceof p2.Line) this.drawLine(j, b.length * this.ppu, f, g);
                        else if (b instanceof p2.Box) this.drawRectangle(j, i[0] * this.ppu, i[1] * this.ppu, a, b.width * this.ppu, b.height * this.ppu, f, c, g);
                        else if (b instanceof p2.Convex) {
                            for (l = [], m = p2.vec2.create(), e = n = 0, o = b.vertices.length; 0 <= o ? n < o : n > o; e = 0 <= o ? ++n : --n) k = b.vertices[e], p2.vec2.rotate(m, k, a), l.push([(m[0] + i[0]) * this.ppu, -(m[1] + i[1]) * this.ppu]);
                            this.drawConvex(j, l, b.triangles, f, c, g, this.settings.debugPolygons, [i[0] * this.ppu, -i[1] * this.ppu])
                        }
                        d++
                    }
                }
            },
            drawRectangle: function(a, b, c, d, e, f, g, h, i) {
                void 0 === i && (i = 1), void 0 === g && (g = 0), a.lineStyle(i, g, 1), a.beginFill(h), a.drawRect(b - e / 2, c - f / 2, e, f)
            },
            drawCircle: function(a, b, c, d, e, f, g) {
                void 0 === g && (g = 1), void 0 === f && (f = 16777215), a.lineStyle(g, 0, 1), a.beginFill(f, 1), a.drawCircle(b, c, 2 * -e), a.endFill(), a.moveTo(b, c), a.lineTo(b + e * Math.cos(-d), c + e * Math.sin(-d))
            },
            drawLine: function(a, b, c, d) {
                void 0 === d && (d = 1), void 0 === c && (c = 0), a.lineStyle(5 * d, c, 1), a.moveTo(-b / 2, 0), a.lineTo(b / 2, 0)
            },
            drawConvex: function(a, b, c, d, e, f, g, h) {
                var i, j, k, l, m, n, o, p, q, r, s;
                if (void 0 === f && (f = 1), void 0 === d && (d = 0), g) {
                    for (i = [16711680, 65280, 255], j = 0; j !== b.length + 1;) l = b[j % b.length], m = b[(j + 1) % b.length], o = l[0], r = l[1], p = m[0], s = m[1], a.lineStyle(f, i[j % i.length], 1), a.moveTo(o, -r), a.lineTo(p, -s), a.drawCircle(o, -r, 2 * f), j++;
                    return a.lineStyle(f, 0, 1), a.drawCircle(h[0], h[1], 2 * f)
                }
                for (a.lineStyle(f, d, 1), a.beginFill(e), j = 0; j !== b.length;) k = b[j], n = k[0], q = k[1], 0 === j ? a.moveTo(n, -q) : a.lineTo(n, -q), j++;
                if (a.endFill(), b.length > 2) return a.moveTo(b[b.length - 1][0], -b[b.length - 1][1]), a.lineTo(b[0][0], -b[0][1])
            },
            drawPath: function(a, b, c, d, e) {
                var f, g, h, i, j, k, l, m, n, o, p, q, r;
                for (void 0 === e && (e = 1), void 0 === c && (c = 0), a.lineStyle(e, c, 1), "number" == typeof d && a.beginFill(d), h = null, i = null, g = 0; g < b.length;) p = b[g], q = p[0], r = p[1], q === h && r === i || (0 === g ? a.moveTo(q, r) : (j = h, k = i, l = q, m = r, n = b[(g + 1) % b.length][0], o = b[(g + 1) % b.length][1], f = (l - j) * (o - k) - (n - j) * (m - k), 0 !== f && a.lineTo(q, r)), h = q, i = r), g++;
                "number" == typeof d && a.endFill(), b.length > 2 && "number" == typeof d && (a.moveTo(b[b.length - 1][0], b[b.length - 1][1]), a.lineTo(b[0][0], b[0][1]))
            },
            drawPlane: function(a, b, c, d, e, f, g, h, i, j) {
                var k, l, m;
                void 0 === f && (f = 1), void 0 === d && (d = 16777215), a.lineStyle(f, e, 11), a.beginFill(d), k = i, a.moveTo(b, -c), l = b + Math.cos(j) * this.game.width, m = c + Math.sin(j) * this.game.height, a.lineTo(l, -m), a.moveTo(b, -c), l = b + Math.cos(j) * -this.game.width, m = c + Math.sin(j) * -this.game.height, a.lineTo(l, -m)
            },
            drawCapsule: function(a, b, c, d, e, f, g, h, i) {
                void 0 === i && (i = 1), void 0 === g && (g = 0), a.lineStyle(i, g, 1);
                var j = Math.cos(d),
                    k = Math.sin(d);
                a.beginFill(h, 1), a.drawCircle(-e / 2 * j + b, -e / 2 * k + c, 2 * -f), a.drawCircle(e / 2 * j + b, e / 2 * k + c, 2 * -f), a.endFill(), a.lineStyle(i, g, 0), a.beginFill(h, 1), a.moveTo(-e / 2 * j + f * k + b, -e / 2 * k + f * j + c), a.lineTo(e / 2 * j + f * k + b, e / 2 * k + f * j + c), a.lineTo(e / 2 * j - f * k + b, e / 2 * k - f * j + c), a.lineTo(-e / 2 * j - f * k + b, -e / 2 * k - f * j + c), a.endFill(), a.lineStyle(i, g, 1), a.moveTo(-e / 2 * j + f * k + b, -e / 2 * k + f * j + c), a.lineTo(e / 2 * j + f * k + b, e / 2 * k + f * j + c), a.moveTo(-e / 2 * j - f * k + b, -e / 2 * k - f * j + c), a.lineTo(e / 2 * j - f * k + b, e / 2 * k - f * j + c)
            },
            randomPastelHex: function() {
                var a, b, c, d;
                return c = [255, 255, 255], d = Math.floor(256 * Math.random()), b = Math.floor(256 * Math.random()), a = Math.floor(256 * Math.random()), d = Math.floor((d + 3 * c[0]) / 4), b = Math.floor((b + 3 * c[1]) / 4), a = Math.floor((a + 3 * c[2]) / 4), this.rgbToHex(d, b, a)
            },
            rgbToHex: function(a, b, c) {
                return this.componentToHex(a) + this.componentToHex(b) + this.componentToHex(c)
            },
            componentToHex: function(a) {
                var b;
                return b = a.toString(16), 2 === b.length ? b : b + "0"
            }
        }), c.Physics.P2.Spring = function(a, b, c, d, e, f, g, h, i, j) {
            this.game = a.game, this.world = a, void 0 === d && (d = 1), void 0 === e && (e = 100), void 0 === f && (f = 1), d = a.pxm(d);
            var k = {
                restLength: d,
                stiffness: e,
                damping: f
            };
            "undefined" != typeof g && null !== g && (k.worldAnchorA = [a.pxm(g[0]), a.pxm(g[1])]), "undefined" != typeof h && null !== h && (k.worldAnchorB = [a.pxm(h[0]), a.pxm(h[1])]), "undefined" != typeof i && null !== i && (k.localAnchorA = [a.pxm(i[0]), a.pxm(i[1])]), "undefined" != typeof j && null !== j && (k.localAnchorB = [a.pxm(j[0]), a.pxm(j[1])]), this.data = new p2.LinearSpring(b, c, k), this.data.parent = this
        }, c.Physics.P2.Spring.prototype.constructor = c.Physics.P2.Spring, c.Physics.P2.RotationalSpring = function(a, b, c, d, e, f) {
            this.game = a.game, this.world = a, void 0 === d && (d = null), void 0 === e && (e = 100), void 0 === f && (f = 1), d && (d = a.pxm(d));
            var g = {
                restAngle: d,
                stiffness: e,
                damping: f
            };
            this.data = new p2.RotationalSpring(b, c, g), this.data.parent = this
        }, c.Physics.P2.Spring.prototype.constructor = c.Physics.P2.Spring, c.Physics.P2.Material = function(a) {
            this.name = a, p2.Material.call(this)
        }, c.Physics.P2.Material.prototype = Object.create(p2.Material.prototype), c.Physics.P2.Material.prototype.constructor = c.Physics.P2.Material, c.Physics.P2.ContactMaterial = function(a, b, c) {
            p2.ContactMaterial.call(this, a, b, c)
        }, c.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype), c.Physics.P2.ContactMaterial.prototype.constructor = c.Physics.P2.ContactMaterial, c.Physics.P2.CollisionGroup = function(a) {
            this.mask = a
        }, c.Physics.P2.DistanceConstraint = function(a, b, c, d, e, f, g) {
            void 0 === d && (d = 100), void 0 === e && (e = [0, 0]), void 0 === f && (f = [0, 0]), void 0 === g && (g = Number.MAX_VALUE), this.game = a.game, this.world = a, d = a.pxm(d), e = [a.pxmi(e[0]), a.pxmi(e[1])], f = [a.pxmi(f[0]), a.pxmi(f[1])];
            var h = {
                distance: d,
                localAnchorA: e,
                localAnchorB: f,
                maxForce: g
            };
            p2.DistanceConstraint.call(this, b, c, h)
        }, c.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype), c.Physics.P2.DistanceConstraint.prototype.constructor = c.Physics.P2.DistanceConstraint, c.Physics.P2.GearConstraint = function(a, b, c, d, e) {
            void 0 === d && (d = 0), void 0 === e && (e = 1), this.game = a.game, this.world = a;
            var f = {
                angle: d,
                ratio: e
            };
            p2.GearConstraint.call(this, b, c, f)
        }, c.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype), c.Physics.P2.GearConstraint.prototype.constructor = c.Physics.P2.GearConstraint, c.Physics.P2.LockConstraint = function(a, b, c, d, e, f) {
            void 0 === d && (d = [0, 0]), void 0 === e && (e = 0), void 0 === f && (f = Number.MAX_VALUE), this.game = a.game, this.world = a, d = [a.pxm(d[0]), a.pxm(d[1])];
            var g = {
                localOffsetB: d,
                localAngleB: e,
                maxForce: f
            };
            p2.LockConstraint.call(this, b, c, g)
        }, c.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype), c.Physics.P2.LockConstraint.prototype.constructor = c.Physics.P2.LockConstraint, c.Physics.P2.PrismaticConstraint = function(a, b, c, d, e, f, g, h) {
            void 0 === d && (d = !0), void 0 === e && (e = [0, 0]), void 0 === f && (f = [0, 0]), void 0 === g && (g = [0, 0]), void 0 === h && (h = Number.MAX_VALUE), this.game = a.game, this.world = a, e = [a.pxmi(e[0]), a.pxmi(e[1])], f = [a.pxmi(f[0]), a.pxmi(f[1])];
            var i = {
                localAnchorA: e,
                localAnchorB: f,
                localAxisA: g,
                maxForce: h,
                disableRotationalLock: !d
            };
            p2.PrismaticConstraint.call(this, b, c, i)
        }, c.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype), c.Physics.P2.PrismaticConstraint.prototype.constructor = c.Physics.P2.PrismaticConstraint, c.Physics.P2.RevoluteConstraint = function(a, b, c, d, e, f, g) {
            void 0 === f && (f = Number.MAX_VALUE), void 0 === g && (g = null), this.game = a.game, this.world = a, c = [a.pxmi(c[0]), a.pxmi(c[1])], e = [a.pxmi(e[0]), a.pxmi(e[1])], g && (g = [a.pxmi(g[0]), a.pxmi(g[1])]);
            var h = {
                worldPivot: g,
                localPivotA: c,
                localPivotB: e,
                maxForce: f
            };
            p2.RevoluteConstraint.call(this, b, d, h)
        }, c.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype), c.Physics.P2.RevoluteConstraint.prototype.constructor = c.Physics.P2.RevoluteConstraint, c.ImageCollection = function(a, b, c, d, e, f, g) {
            (void 0 === c || c <= 0) && (c = 32), (void 0 === d || d <= 0) && (d = 32), void 0 === e && (e = 0), void 0 === f && (f = 0), this.name = a, this.firstgid = 0 | b, this.imageWidth = 0 | c, this.imageHeight = 0 | d, this.imageMargin = 0 | e, this.imageSpacing = 0 | f, this.properties = g || {}, this.images = [], this.total = 0
        }, c.ImageCollection.prototype = {
            containsImageIndex: function(a) {
                return a >= this.firstgid && a < this.firstgid + this.total
            },
            addImage: function(a, b) {
                this.images.push({
                    gid: a,
                    image: b
                }), this.total++
            }
        }, c.ImageCollection.prototype.constructor = c.ImageCollection, c.Tile = function(a, b, c, d, e, f) {
            this.layer = a, this.index = b, this.x = c, this.y = d, this.rotation = 0, this.flipped = !1, this.worldX = c * e, this.worldY = d * f, this.width = e, this.height = f, this.centerX = Math.abs(e / 2), this.centerY = Math.abs(f / 2), this.alpha = 1, this.properties = {}, this.scanned = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.collisionCallback = null, this.collisionCallbackContext = this
        }, c.Tile.prototype = {
            containsPoint: function(a, b) {
                return !(a < this.worldX || b < this.worldY || a > this.right || b > this.bottom)
            },
            intersects: function(a, b, c, d) {
                return !(c <= this.worldX || d <= this.worldY || a >= this.worldX + this.width || b >= this.worldY + this.height)
            },
            setCollisionCallback: function(a, b) {
                this.collisionCallback = a, this.collisionCallbackContext = b
            },
            destroy: function() {
                this.collisionCallback = null, this.collisionCallbackContext = null, this.properties = null
            },
            setCollision: function(a, b, c, d) {
                this.collideLeft = a, this.collideRight = b, this.collideUp = c, this.collideDown = d, this.faceLeft = a, this.faceRight = b, this.faceTop = c, this.faceBottom = d
            },
            resetCollision: function() {
                this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1
            },
            isInteresting: function(a, b) {
                return a && b ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : a ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : !!b && (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight)
            },
            copy: function(a) {
                this.index = a.index, this.alpha = a.alpha, this.properties = a.properties, this.collideUp = a.collideUp, this.collideDown = a.collideDown, this.collideLeft = a.collideLeft, this.collideRight = a.collideRight, this.collisionCallback = a.collisionCallback, this.collisionCallbackContext = a.collisionCallbackContext
            }
        }, c.Tile.prototype.constructor = c.Tile, Object.defineProperty(c.Tile.prototype, "collides", {
            get: function() {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
            }
        }), Object.defineProperty(c.Tile.prototype, "canCollide", {
            get: function() {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback
            }
        }), Object.defineProperty(c.Tile.prototype, "left", {
            get: function() {
                return this.worldX
            }
        }), Object.defineProperty(c.Tile.prototype, "right", {
            get: function() {
                return this.worldX + this.width
            }
        }), Object.defineProperty(c.Tile.prototype, "top", {
            get: function() {
                return this.worldY
            }
        }), Object.defineProperty(c.Tile.prototype, "bottom", {
            get: function() {
                return this.worldY + this.height
            }
        }), c.Tilemap = function(a, b, d, e, f, g) {
            this.game = a, this.key = b;
            var h = c.TilemapParser.parse(this.game, b, d, e, f, g);
            null !== h && (this.width = h.width, this.height = h.height, this.tileWidth = h.tileWidth, this.tileHeight = h.tileHeight, this.orientation = h.orientation, this.format = h.format, this.version = h.version, this.properties = h.properties, this.widthInPixels = h.widthInPixels, this.heightInPixels = h.heightInPixels, this.layers = h.layers, this.tilesets = h.tilesets, this.imagecollections = h.imagecollections, this.tiles = h.tiles, this.objects = h.objects, this.collideIndexes = [], this.collision = h.collision, this.images = h.images, this.enableDebug = !1, this.currentLayer = 0, this.debugMap = [], this._results = [], this._tempA = 0, this._tempB = 0)
        }, c.Tilemap.CSV = 0, c.Tilemap.TILED_JSON = 1, c.Tilemap.NORTH = 0, c.Tilemap.EAST = 1, c.Tilemap.SOUTH = 2, c.Tilemap.WEST = 3, c.Tilemap.prototype = {
            create: function(a, b, c, d, e, f) {
                return void 0 === f && (f = this.game.world), this.width = b, this.height = c, this.setTileSize(d, e), this.layers.length = 0, this.createBlankLayer(a, b, c, d, e, f)
            },
            setTileSize: function(a, b) {
                this.tileWidth = a, this.tileHeight = b, this.widthInPixels = this.width * a, this.heightInPixels = this.height * b
            },
            addTilesetImage: function(a, b, d, e, f, g, h) {
                if (void 0 === a) return null;
                void 0 === d && (d = this.tileWidth), void 0 === e && (e = this.tileHeight), void 0 === f && (f = 0), void 0 === g && (g = 0), void 0 === h && (h = 0), 0 === d && (d = 32), 0 === e && (e = 32);
                var i = null;
                if (void 0 !== b && null !== b || (b = a), b instanceof c.BitmapData) i = b.canvas;
                else {
                    if (!this.game.cache.checkImageKey(b)) return null;
                    i = this.game.cache.getImage(b)
                }
                var j = this.getTilesetIndex(a);
                if (null === j && this.format === c.Tilemap.TILED_JSON) return null;
                if (this.tilesets[j]) return this.tilesets[j].setImage(i), this.tilesets[j];
                var k = new c.Tileset(a, h, d, e, f, g, {});
                k.setImage(i), this.tilesets.push(k);
                for (var l = this.tilesets.length - 1, m = f, n = f, o = 0, p = 0, q = 0, r = h; r < h + k.total && (this.tiles[r] = [m, n, l], m += d + g, o++, o !== k.total) && (p++, p !== k.columns || (m = f, n += e + g, p = 0, q++, q !== k.rows)); r++);
                return k
            },
            createFromObjects: function(a, b, d, e, f, g, h, i, j) {
                if (void 0 === f && (f = !0), void 0 === g && (g = !1), void 0 === h && (h = this.game.world), void 0 === i && (i = c.Sprite), void 0 === j && (j = !0), this.objects[a])
                    for (var k = 0; k < this.objects[a].length; k++) {
                        var l = !1,
                            m = this.objects[a][k];
                        if (void 0 !== m.gid && "number" == typeof b && m.gid === b ? l = !0 : void 0 !== m.id && "number" == typeof b && m.id === b ? l = !0 : void 0 !== m.name && "string" == typeof b && m.name === b && (l = !0), l) {
                            var n = new i(this.game, parseFloat(m.x, 10), parseFloat(m.y, 10), d, e);
                            n.name = m.name, n.visible = m.visible, n.autoCull = g, n.exists = f, m.width && (n.width = m.width), m.height && (n.height = m.height), m.rotation && (n.angle = m.rotation), j && (n.y -= n.height), h.add(n);
                            for (var o in m.properties) h.set(n, o, m.properties[o], !1, !1, 0, !0)
                        }
                    }
            },
            createFromTiles: function(a, b, d, e, f, g) {
                "number" == typeof a && (a = [a]), void 0 === b || null === b ? b = [] : "number" == typeof b && (b = [b]), e = this.getLayer(e), void 0 === f && (f = this.game.world), void 0 === g && (g = {}), void 0 === g.customClass && (g.customClass = c.Sprite), void 0 === g.adjustY && (g.adjustY = !0);
                var h = this.layers[e].width,
                    i = this.layers[e].height;
                if (this.copy(0, 0, h, i, e), this._results.length < 2) return 0;
                for (var j, k = 0, l = 1, m = this._results.length; l < m; l++)
                    if (a.indexOf(this._results[l].index) !== -1) {
                        j = new g.customClass(this.game, this._results[l].worldX, this._results[l].worldY, d);
                        for (var n in g) j[n] = g[n];
                        f.add(j), k++
                    }
                if (1 === b.length)
                    for (l = 0; l < a.length; l++) this.replace(a[l], b[0], 0, 0, h, i, e);
                else if (b.length > 1)
                    for (l = 0; l < a.length; l++) this.replace(a[l], b[l], 0, 0, h, i, e);
                return k
            },
            createLayer: function(a, b, d, e) {
                void 0 === b && (b = this.game.width), void 0 === d && (d = this.game.height), void 0 === e && (e = this.game.world);
                var f = a;
                if ("string" == typeof a && (f = this.getLayerIndex(a)), !(null === f || f > this.layers.length)) {
                    void 0 === b || b <= 0 ? b = Math.min(this.game.width, this.layers[f].widthInPixels) : b > this.game.width && (b = this.game.width), void 0 === d || d <= 0 ? d = Math.min(this.game.height, this.layers[f].heightInPixels) : d > this.game.height && (d = this.game.height), this.enableDebug && void 0;
                    var g = e.add(new c.TilemapLayer(this.game, this, f, b, d));
                    return this.enableDebug && void 0, g
                }
            },
            createBlankLayer: function(a, b, d, e, f, g) {
                if (void 0 === g && (g = this.game.world), null === this.getLayerIndex(a)) {
                    for (var h, i = {
                        name: a,
                        x: 0,
                        y: 0,
                        width: b,
                        height: d,
                        widthInPixels: b * e,
                        heightInPixels: d * f,
                        alpha: 1,
                        visible: !0,
                        properties: {},
                        indexes: [],
                        callbacks: [],
                        bodies: [],
                        data: null
                    }, j = [], k = 0; k < d; k++) {
                        h = [];
                        for (var l = 0; l < b; l++) h.push(new c.Tile(i, (-1), l, k, e, f));
                        j.push(h)
                    }
                    i.data = j, this.layers.push(i), this.currentLayer = this.layers.length - 1;
                    var m = i.widthInPixels,
                        n = i.heightInPixels;
                    m > this.game.width && (m = this.game.width), n > this.game.height && (n = this.game.height);
                    var j = new c.TilemapLayer(this.game, this, this.layers.length - 1, m, n);
                    return j.name = a, g.add(j)
                }
            },
            getIndex: function(a, b) {
                for (var c = 0; c < a.length; c++)
                    if (a[c].name === b) return c;
                return null
            },
            getLayerIndex: function(a) {
                return this.getIndex(this.layers, a)
            },
            getTilesetIndex: function(a) {
                return this.getIndex(this.tilesets, a)
            },
            getImageIndex: function(a) {
                return this.getIndex(this.images, a)
            },
            setTileIndexCallback: function(a, b, c, d) {
                if (d = this.getLayer(d), "number" == typeof a) this.layers[d].callbacks[a] = {
                    callback: b,
                    callbackContext: c
                };
                else
                    for (var e = 0, f = a.length; e < f; e++) this.layers[d].callbacks[a[e]] = {
                        callback: b,
                        callbackContext: c
                    }
            },
            setTileLocationCallback: function(a, b, c, d, e, f, g) {
                if (g = this.getLayer(g), this.copy(a, b, c, d, g), !(this._results.length < 2))
                    for (var h = 1; h < this._results.length; h++) this._results[h].setCollisionCallback(e, f)
            },
            setCollision: function(a, b, c, d) {
                if (void 0 === b && (b = !0), void 0 === d && (d = !0), c = this.getLayer(c), "number" == typeof a) return this.setCollisionByIndex(a, b, c, !0);
                if (Array.isArray(a)) {
                    for (var e = 0; e < a.length; e++) this.setCollisionByIndex(a[e], b, c, !1);
                    d && this.calculateFaces(c)
                }
            },
            setCollisionBetween: function(a, b, c, d, e) {
                if (void 0 === c && (c = !0), void 0 === e && (e = !0), d = this.getLayer(d), !(a > b)) {
                    for (var f = a; f <= b; f++) this.setCollisionByIndex(f, c, d, !1);
                    e && this.calculateFaces(d)
                }
            },
            setCollisionByExclusion: function(a, b, c, d) {
                void 0 === b && (b = !0), void 0 === d && (d = !0), c = this.getLayer(c);
                for (var e = 0, f = this.tiles.length; e < f; e++) a.indexOf(e) === -1 && this.setCollisionByIndex(e, b, c, !1);
                d && this.calculateFaces(c)
            },
            setCollisionByIndex: function(a, b, c, d) {
                if (void 0 === b && (b = !0), void 0 === c && (c = this.currentLayer), void 0 === d && (d = !0), b) this.collideIndexes.push(a);
                else {
                    var e = this.collideIndexes.indexOf(a);
                    e > -1 && this.collideIndexes.splice(e, 1)
                }
                for (var f = 0; f < this.layers[c].height; f++)
                    for (var g = 0; g < this.layers[c].width; g++) {
                        var h = this.layers[c].data[f][g];
                        h && h.index === a && (b ? h.setCollision(!0, !0, !0, !0) : h.resetCollision(), h.faceTop = b, h.faceBottom = b, h.faceLeft = b, h.faceRight = b)
                    }
                return d && this.calculateFaces(c), c
            },
            getLayer: function(a) {
                return void 0 === a ? a = this.currentLayer : "string" == typeof a ? a = this.getLayerIndex(a) : a instanceof c.TilemapLayer && (a = a.index), a
            },
            setPreventRecalculate: function(a) {
                if (a === !0 && this.preventingRecalculate !== !0 && (this.preventingRecalculate = !0, this.needToRecalculate = {}), a === !1 && this.preventingRecalculate === !0) {
                    this.preventingRecalculate = !1;
                    for (var b in this.needToRecalculate) this.calculateFaces(b);
                    this.needToRecalculate = !1
                }
            },
            calculateFaces: function(a) {
                if (this.preventingRecalculate) return void(this.needToRecalculate[a] = !0);
                for (var b = null, c = null, d = null, e = null, f = 0, g = this.layers[a].height; f < g; f++)
                    for (var h = 0, i = this.layers[a].width; h < i; h++) {
                        var j = this.layers[a].data[f][h];
                        j && (b = this.getTileAbove(a, h, f), c = this.getTileBelow(a, h, f), d = this.getTileLeft(a, h, f), e = this.getTileRight(a, h, f), j.collides && (j.faceTop = !0, j.faceBottom = !0, j.faceLeft = !0, j.faceRight = !0), b && b.collides && (j.faceTop = !1), c && c.collides && (j.faceBottom = !1), d && d.collides && (j.faceLeft = !1), e && e.collides && (j.faceRight = !1))
                    }
            },
            getTileAbove: function(a, b, c) {
                return c > 0 ? this.layers[a].data[c - 1][b] : null
            },
            getTileBelow: function(a, b, c) {
                return c < this.layers[a].height - 1 ? this.layers[a].data[c + 1][b] : null
            },
            getTileLeft: function(a, b, c) {
                return b > 0 ? this.layers[a].data[c][b - 1] : null
            },
            getTileRight: function(a, b, c) {
                return b < this.layers[a].width - 1 ? this.layers[a].data[c][b + 1] : null
            },
            setLayer: function(a) {
                a = this.getLayer(a), this.layers[a] && (this.currentLayer = a)
            },
            hasTile: function(a, b, c) {
                return c = this.getLayer(c), void 0 !== this.layers[c].data[b] && void 0 !== this.layers[c].data[b][a] && this.layers[c].data[b][a].index > -1
            },
            removeTile: function(a, b, d) {
                if (d = this.getLayer(d), a >= 0 && a < this.layers[d].width && b >= 0 && b < this.layers[d].height && this.hasTile(a, b, d)) {
                    var e = this.layers[d].data[b][a];
                    return this.layers[d].data[b][a] = new c.Tile(this.layers[d], (-1), a, b, this.tileWidth, this.tileHeight), this.layers[d].dirty = !0, this.calculateFaces(d), e
                }
            },
            removeTileWorldXY: function(a, b, c, d, e) {
                return e = this.getLayer(e), a = this.game.math.snapToFloor(a, c) / c, b = this.game.math.snapToFloor(b, d) / d, this.removeTile(a, b, e)
            },
            putTile: function(a, b, d, e) {
                if (null === a) return this.removeTile(b, d, e);
                if (e = this.getLayer(e), b >= 0 && b < this.layers[e].width && d >= 0 && d < this.layers[e].height) {
                    var f;
                    return a instanceof c.Tile ? (f = a.index, this.hasTile(b, d, e) ? this.layers[e].data[d][b].copy(a) : this.layers[e].data[d][b] = new c.Tile(e, f, b, d, a.width, a.height)) : (f = a, this.hasTile(b, d, e) ? this.layers[e].data[d][b].index = f : this.layers[e].data[d][b] = new c.Tile(this.layers[e], f, b, d, this.tileWidth, this.tileHeight)), this.collideIndexes.indexOf(f) > -1 ? this.layers[e].data[d][b].setCollision(!0, !0, !0, !0) : this.layers[e].data[d][b].resetCollision(), this.layers[e].dirty = !0, this.calculateFaces(e), this.layers[e].data[d][b]
                }
                return null
            },
            putTileWorldXY: function(a, b, c, d, e, f) {
                return f = this.getLayer(f), b = this.game.math.snapToFloor(b, d) / d, c = this.game.math.snapToFloor(c, e) / e, this.putTile(a, b, c, f)
            },
            searchTileIndex: function(a, b, c, d) {
                void 0 === b && (b = 0), void 0 === c && (c = !1), d = this.getLayer(d);
                var e = 0;
                if (c) {
                    for (var f = this.layers[d].height - 1; f >= 0; f--)
                        for (var g = this.layers[d].width - 1; g >= 0; g--)
                            if (this.layers[d].data[f][g].index === a) {
                                if (e === b) return this.layers[d].data[f][g];
                                e++
                            }
                } else
                    for (var f = 0; f < this.layers[d].height; f++)
                        for (var g = 0; g < this.layers[d].width; g++)
                            if (this.layers[d].data[f][g].index === a) {
                                if (e === b) return this.layers[d].data[f][g];
                                e++
                            } return null
            },
            getTile: function(a, b, c, d) {
                return void 0 === d && (d = !1), c = this.getLayer(c), a >= 0 && a < this.layers[c].width && b >= 0 && b < this.layers[c].height ? this.layers[c].data[b][a].index === -1 ? d ? this.layers[c].data[b][a] : null : this.layers[c].data[b][a] : null
            },
            getTileWorldXY: function(a, b, c, d, e, f) {
                return void 0 === c && (c = this.tileWidth), void 0 === d && (d = this.tileHeight), e = this.getLayer(e), a = this.game.math.snapToFloor(a, c) / c, b = this.game.math.snapToFloor(b, d) / d, this.getTile(a, b, e, f)
            },
            copy: function(a, b, c, d, e) {
                if (e = this.getLayer(e), !this.layers[e]) return void(this._results.length = 0);
                void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = this.layers[e].width), void 0 === d && (d = this.layers[e].height), a < 0 && (a = 0), b < 0 && (b = 0), c > this.layers[e].width && (c = this.layers[e].width), d > this.layers[e].height && (d = this.layers[e].height), this._results.length = 0, this._results.push({
                    x: a,
                    y: b,
                    width: c,
                    height: d,
                    layer: e
                });
                for (var f = b; f < b + d; f++)
                    for (var g = a; g < a + c; g++) this._results.push(this.layers[e].data[f][g]);
                return this._results
            },
            paste: function(a, b, c, d) {
                if (void 0 === a && (a = 0), void 0 === b && (b = 0), d = this.getLayer(d), c && !(c.length < 2)) {
                    for (var e = a - c[1].x, f = b - c[1].y, g = 1; g < c.length; g++) this.layers[d].data[f + c[g].y][e + c[g].x].copy(c[g]);
                    this.layers[d].dirty = !0, this.calculateFaces(d)
                }
            },
            swap: function(a, b, c, d, e, f, g) {
                g = this.getLayer(g), this.copy(c, d, e, f, g), this._results.length < 2 || (this._tempA = a, this._tempB = b, this._results.forEach(this.swapHandler, this), this.paste(c, d, this._results, g))
            },
            swapHandler: function(a) {
                a.index === this._tempA ? a.index = this._tempB : a.index === this._tempB && (a.index = this._tempA)
            },
            forEach: function(a, b, c, d, e, f, g) {
                g = this.getLayer(g), this.copy(c, d, e, f, g), this._results.length < 2 || (this._results.forEach(a, b), this.paste(c, d, this._results, g))
            },
            replace: function(a, b, c, d, e, f, g) {
                if (g = this.getLayer(g), this.copy(c, d, e, f, g), !(this._results.length < 2)) {
                    for (var h = 1; h < this._results.length; h++) this._results[h].index === a && (this._results[h].index = b);
                    this.paste(c, d, this._results, g)
                }
            },
            random: function(a, b, c, d, e) {
                if (e = this.getLayer(e), this.copy(a, b, c, d, e), !(this._results.length < 2)) {
                    for (var f = [], g = 1; g < this._results.length; g++)
                        if (this._results[g].index) {
                            var h = this._results[g].index;
                            f.indexOf(h) === -1 && f.push(h)
                        }
                    for (var i = 1; i < this._results.length; i++) this._results[i].index = this.game.rnd.pick(f);
                    this.paste(a, b, this._results, e)
                }
            },
            shuffle: function(a, b, d, e, f) {
                if (f = this.getLayer(f), this.copy(a, b, d, e, f), !(this._results.length < 2)) {
                    for (var g = [], h = 1; h < this._results.length; h++) this._results[h].index && g.push(this._results[h].index);
                    c.ArrayUtils.shuffle(g);
                    for (var i = 1; i < this._results.length; i++) this._results[i].index = g[i - 1];
                    this.paste(a, b, this._results, f)
                }
            },
            fill: function(a, b, c, d, e, f) {
                if (f = this.getLayer(f), this.copy(b, c, d, e, f), !(this._results.length < 2)) {
                    for (var g = 1; g < this._results.length; g++) this._results[g].index = a;
                    this.paste(b, c, this._results, f)
                }
            },
            removeAllLayers: function() {
                this.layers.length = 0, this.currentLayer = 0
            },
            dump: function() {
                for (var a = "", b = [""], c = 0; c < this.layers[this.currentLayer].height; c++) {
                    for (var d = 0; d < this.layers[this.currentLayer].width; d++) a += "%c  ", this.layers[this.currentLayer].data[c][d] > 1 ? this.debugMap[this.layers[this.currentLayer].data[c][d]] ? b.push("background: " + this.debugMap[this.layers[this.currentLayer].data[c][d]]) : b.push("background: #ffffff") : b.push("background: rgb(0, 0, 0)");
                    a += "\n"
                }
                void(b[0] = a)
            },
            destroy: function() {
                this.removeAllLayers(), this.data = [], this.game = null
            }
        }, c.Tilemap.prototype.constructor = c.Tilemap, Object.defineProperty(c.Tilemap.prototype, "layer", {
            get: function() {
                return this.layers[this.currentLayer]
            },
            set: function(a) {
                a !== this.currentLayer && this.setLayer(a)
            }
        }), c.TilemapLayer = function(a, b, d, e, f) {
            e |= 0, f |= 0, c.Sprite.call(this, a, 0, 0), this.map = b, this.index = d, this.layer = b.layers[d], this.canvas = PIXI.CanvasPool.create(this, e, f), this.context = this.canvas.getContext("2d"), this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas))), this.type = c.TILEMAPLAYER, this.physicsType = c.TILEMAPLAYER, this.renderSettings = {
                    enableScrollDelta: !1,
                    overdrawRatio: .2,
                    copyCanvas: null
                }, this.debug = !1, this.exists = !0, this.debugSettings = {
                    missingImageFill: "rgb(255,255,255)",
                    debuggedTileOverfill: "rgba(0,255,0,0.4)",
                    forceFullRedraw: !0,
                    debugAlpha: .5,
                    facingEdgeStroke: "rgba(0,255,0,1)",
                    collidingTileOverfill: "rgba(0,255,0,0.2)"
                }, this.scrollFactorX = 1, this.scrollFactorY = 1, this.dirty = !0, this.rayStepRate = 4, this._wrap = !1, this._mc = {
                    scrollX: 0,
                    scrollY: 0,
                    renderWidth: 0,
                    renderHeight: 0,
                    tileWidth: b.tileWidth,
                    tileHeight: b.tileHeight,
                    cw: b.tileWidth,
                    ch: b.tileHeight,
                    tilesets: []
                }, this._scrollX = 0,
                this._scrollY = 0, this._results = [], a.device.canvasBitBltShift || (this.renderSettings.copyCanvas = c.TilemapLayer.ensureSharedCopyCanvas()), this.fixedToCamera = !0
        }, c.TilemapLayer.prototype = Object.create(c.Sprite.prototype), c.TilemapLayer.prototype.constructor = c.TilemapLayer, c.TilemapLayer.prototype.preUpdateCore = c.Component.Core.preUpdate, c.TilemapLayer.sharedCopyCanvas = null, c.TilemapLayer.ensureSharedCopyCanvas = function() {
            return this.sharedCopyCanvas || (this.sharedCopyCanvas = PIXI.CanvasPool.create(this, 2, 2)), this.sharedCopyCanvas
        }, c.TilemapLayer.prototype.preUpdate = function() {
            return this.preUpdateCore()
        }, c.TilemapLayer.prototype.postUpdate = function() {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y
        }, c.TilemapLayer.prototype._renderCanvas = function(a) {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderCanvas.call(this, a)
        }, c.TilemapLayer.prototype._renderWebGL = function(a) {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderWebGL.call(this, a)
        }, c.TilemapLayer.prototype.destroy = function() {
            PIXI.CanvasPool.remove(this), c.Component.Destroy.prototype.destroy.call(this)
        }, c.TilemapLayer.prototype.resize = function(a, b) {
            this.canvas.width = a, this.canvas.height = b, this.texture.frame.resize(a, b), this.texture.width = a, this.texture.height = b, this.texture.crop.width = a, this.texture.crop.height = b, this.texture.baseTexture.width = a, this.texture.baseTexture.height = b, this.texture.baseTexture.dirty(), this.texture.requiresUpdate = !0, this.texture._updateUvs(), this.dirty = !0
        }, c.TilemapLayer.prototype.resizeWorld = function() {
            this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y)
        }, c.TilemapLayer.prototype._fixX = function(a) {
            return 1 === this.scrollFactorX || 0 === this.scrollFactorX && 0 === this.position.x ? a : 0 === this.scrollFactorX && 0 !== this.position.x ? a - this.position.x : this._scrollX + (a - this._scrollX / this.scrollFactorX)
        }, c.TilemapLayer.prototype._unfixX = function(a) {
            return 1 === this.scrollFactorX ? a : this._scrollX / this.scrollFactorX + (a - this._scrollX)
        }, c.TilemapLayer.prototype._fixY = function(a) {
            return 1 === this.scrollFactorY || 0 === this.scrollFactorY && 0 === this.position.y ? a : 0 === this.scrollFactorY && 0 !== this.position.y ? a - this.position.y : this._scrollY + (a - this._scrollY / this.scrollFactorY)
        }, c.TilemapLayer.prototype._unfixY = function(a) {
            return 1 === this.scrollFactorY ? a : this._scrollY / this.scrollFactorY + (a - this._scrollY)
        }, c.TilemapLayer.prototype.getTileX = function(a) {
            return Math.floor(this._fixX(a) / this._mc.tileWidth)
        }, c.TilemapLayer.prototype.getTileY = function(a) {
            return Math.floor(this._fixY(a) / this._mc.tileHeight)
        }, c.TilemapLayer.prototype.getTileXY = function(a, b, c) {
            return c.x = this.getTileX(a), c.y = this.getTileY(b), c
        }, c.TilemapLayer.prototype.getRayCastTiles = function(a, b, c, d) {
            b || (b = this.rayStepRate), void 0 === c && (c = !1), void 0 === d && (d = !1);
            var e = this.getTiles(a.x, a.y, a.width, a.height, c, d);
            if (0 === e.length) return [];
            for (var f = a.coordinatesOnLine(b), g = [], h = 0; h < e.length; h++)
                for (var i = 0; i < f.length; i++) {
                    var j = e[h],
                        k = f[i];
                    if (j.containsPoint(k[0], k[1])) {
                        g.push(j);
                        break
                    }
                }
            return g
        }, c.TilemapLayer.prototype.getTiles = function(a, b, c, d, e, f) {
            void 0 === e && (e = !1), void 0 === f && (f = !1);
            var g = !(e || f);
            a = this._fixX(a), b = this._fixY(b);
            for (var h = Math.floor(a / (this._mc.cw * this.scale.x)), i = Math.floor(b / (this._mc.ch * this.scale.y)), j = Math.ceil((a + c) / (this._mc.cw * this.scale.x)) - h, k = Math.ceil((b + d) / (this._mc.ch * this.scale.y)) - i; this._results.length;) this._results.pop();
            for (var l = i; l < i + k; l++)
                for (var m = h; m < h + j; m++) {
                    var n = this.layer.data[l];
                    n && n[m] && (g || n[m].isInteresting(e, f)) && this._results.push(n[m])
                }
            return this._results.slice()
        }, c.TilemapLayer.prototype.resolveTileset = function(a) {
            var b = this._mc.tilesets;
            if (a < 2e3)
                for (; b.length < a;) b.push(void 0);
            var c = this.map.tiles[a] && this.map.tiles[a][2];
            if (null !== c) {
                var d = this.map.tilesets[c];
                if (d && d.containsTileIndex(a)) return b[a] = d
            }
            return b[a] = null
        }, c.TilemapLayer.prototype.resetTilesetCache = function() {
            for (var a = this._mc.tilesets; a.length;) a.pop()
        }, c.TilemapLayer.prototype.setScale = function(a, b) {
            a = a || 1, b = b || a;
            for (var c = 0; c < this.layer.data.length; c++)
                for (var d = this.layer.data[c], e = 0; e < d.length; e++) {
                    var f = d[e];
                    f.width = this.map.tileWidth * a, f.height = this.map.tileHeight * b, f.worldX = f.x * f.width, f.worldY = f.y * f.height
                }
            this.scale.setTo(a, b)
        }, c.TilemapLayer.prototype.shiftCanvas = function(a, b, c) {
            var d = a.canvas,
                e = d.width - Math.abs(b),
                f = d.height - Math.abs(c),
                g = 0,
                h = 0,
                i = b,
                j = c;
            b < 0 && (g = -b, i = 0), c < 0 && (h = -c, j = 0);
            var k = this.renderSettings.copyCanvas;
            if (k) {
                (k.width < e || k.height < f) && (k.width = e, k.height = f);
                var l = k.getContext("2d");
                l.clearRect(0, 0, e, f), l.drawImage(d, g, h, e, f, 0, 0, e, f), a.clearRect(i, j, e, f), a.drawImage(k, 0, 0, e, f, i, j, e, f)
            } else a.save(), a.globalCompositeOperation = "copy", a.drawImage(d, g, h, e, f, i, j, e, f), a.restore()
        }, c.TilemapLayer.prototype.renderRegion = function(a, b, c, d, e, f) {
            var g = this.context,
                h = this.layer.width,
                i = this.layer.height,
                j = this._mc.tileWidth,
                k = this._mc.tileHeight,
                l = this._mc.tilesets,
                m = NaN;
            this._wrap || (c <= e && (c = Math.max(0, c), e = Math.min(h - 1, e)), d <= f && (d = Math.max(0, d), f = Math.min(i - 1, f)));
            var n, o, p, q, r, s, t = c * j - a,
                u = d * k - b,
                v = (c + (1 << 20) * h) % h,
                w = (d + (1 << 20) * i) % i;
            for (q = w, s = f - d, o = u; s >= 0; q++, s--, o += k) {
                q >= i && (q -= i);
                var x = this.layer.data[q];
                for (p = v, r = e - c, n = t; r >= 0; p++, r--, n += j) {
                    p >= h && (p -= h);
                    var y = x[p];
                    if (y && !(y.index < 0)) {
                        var z = y.index,
                            A = l[z];
                        void 0 === A && (A = this.resolveTileset(z)), y.alpha === m || this.debug || (g.globalAlpha = y.alpha, m = y.alpha), A ? y.rotation || y.flipped ? (g.save(), g.translate(n + y.centerX, o + y.centerY), g.rotate(y.rotation), y.flipped && g.scale(-1, 1), A.draw(g, -y.centerX, -y.centerY, z), g.restore()) : A.draw(g, n, o, z) : this.debugSettings.missingImageFill && (g.fillStyle = this.debugSettings.missingImageFill, g.fillRect(n, o, j, k)), y.debug && this.debugSettings.debuggedTileOverfill && (g.fillStyle = this.debugSettings.debuggedTileOverfill, g.fillRect(n, o, j, k))
                    }
                }
            }
        }, c.TilemapLayer.prototype.renderDeltaScroll = function(a, b) {
            var c = this._mc.scrollX,
                d = this._mc.scrollY,
                e = this.canvas.width,
                f = this.canvas.height,
                g = this._mc.tileWidth,
                h = this._mc.tileHeight,
                i = 0,
                j = -g,
                k = 0,
                l = -h;
            if (a < 0 ? (i = e + a, j = e - 1) : a > 0 && (j = a), b < 0 ? (k = f + b, l = f - 1) : b > 0 && (l = b), this.shiftCanvas(this.context, a, b), i = Math.floor((i + c) / g), j = Math.floor((j + c) / g), k = Math.floor((k + d) / h), l = Math.floor((l + d) / h), i <= j) {
                this.context.clearRect(i * g - c, 0, (j - i + 1) * g, f);
                var m = Math.floor((0 + d) / h),
                    n = Math.floor((f - 1 + d) / h);
                this.renderRegion(c, d, i, m, j, n)
            }
            if (k <= l) {
                this.context.clearRect(0, k * h - d, e, (l - k + 1) * h);
                var o = Math.floor((0 + c) / g),
                    p = Math.floor((e - 1 + c) / g);
                this.renderRegion(c, d, o, k, p, l)
            }
        }, c.TilemapLayer.prototype.renderFull = function() {
            var a = this._mc.scrollX,
                b = this._mc.scrollY,
                c = this.canvas.width,
                d = this.canvas.height,
                e = this._mc.tileWidth,
                f = this._mc.tileHeight,
                g = Math.floor(a / e),
                h = Math.floor((c - 1 + a) / e),
                i = Math.floor(b / f),
                j = Math.floor((d - 1 + b) / f);
            this.context.clearRect(0, 0, c, d), this.renderRegion(a, b, g, i, h, j)
        }, c.TilemapLayer.prototype.render = function() {
            var a = !1;
            if (this.visible) {
                (this.dirty || this.layer.dirty) && (this.layer.dirty = !1, a = !0);
                var b = this.canvas.width,
                    c = this.canvas.height,
                    d = 0 | this._scrollX,
                    e = 0 | this._scrollY,
                    f = this._mc,
                    g = f.scrollX - d,
                    h = f.scrollY - e;
                if (a || 0 !== g || 0 !== h || f.renderWidth !== b || f.renderHeight !== c) return this.context.save(), f.scrollX = d, f.scrollY = e, f.renderWidth === b && f.renderHeight === c || (f.renderWidth = b, f.renderHeight = c), this.debug && (this.context.globalAlpha = this.debugSettings.debugAlpha, this.debugSettings.forceFullRedraw && (a = !0)), !a && this.renderSettings.enableScrollDelta && Math.abs(g) + Math.abs(h) < Math.min(b, c) ? this.renderDeltaScroll(g, h) : this.renderFull(), this.debug && (this.context.globalAlpha = 1, this.renderDebug()), this.texture.baseTexture.dirty(), this.dirty = !1, this.context.restore(), !0
            }
        }, c.TilemapLayer.prototype.renderDebug = function() {
            var a, b, c, d, e, f, g = this._mc.scrollX,
                h = this._mc.scrollY,
                i = this.context,
                j = this.canvas.width,
                k = this.canvas.height,
                l = this.layer.width,
                m = this.layer.height,
                n = this._mc.tileWidth,
                o = this._mc.tileHeight,
                p = Math.floor(g / n),
                q = Math.floor((j - 1 + g) / n),
                r = Math.floor(h / o),
                s = Math.floor((k - 1 + h) / o),
                t = p * n - g,
                u = r * o - h,
                v = (p + (1 << 20) * l) % l,
                w = (r + (1 << 20) * m) % m;
            for (i.strokeStyle = this.debugSettings.facingEdgeStroke, d = w, f = s - r, b = u; f >= 0; d++, f--, b += o) {
                d >= m && (d -= m);
                var x = this.layer.data[d];
                for (c = v, e = q - p, a = t; e >= 0; c++, e--, a += n) {
                    c >= l && (c -= l);
                    var y = x[c];
                    !y || y.index < 0 || !y.collides || (this.debugSettings.collidingTileOverfill && (i.fillStyle = this.debugSettings.collidingTileOverfill, i.fillRect(a, b, this._mc.cw, this._mc.ch)), this.debugSettings.facingEdgeStroke && (i.beginPath(), y.faceTop && (i.moveTo(a, b), i.lineTo(a + this._mc.cw, b)), y.faceBottom && (i.moveTo(a, b + this._mc.ch), i.lineTo(a + this._mc.cw, b + this._mc.ch)), y.faceLeft && (i.moveTo(a, b), i.lineTo(a, b + this._mc.ch)), y.faceRight && (i.moveTo(a + this._mc.cw, b), i.lineTo(a + this._mc.cw, b + this._mc.ch)), i.closePath(), i.stroke()))
                }
            }
        }, Object.defineProperty(c.TilemapLayer.prototype, "wrap", {
            get: function() {
                return this._wrap
            },
            set: function(a) {
                this._wrap = a, this.dirty = !0
            }
        }), Object.defineProperty(c.TilemapLayer.prototype, "scrollX", {
            get: function() {
                return this._scrollX
            },
            set: function(a) {
                this._scrollX = a
            }
        }), Object.defineProperty(c.TilemapLayer.prototype, "scrollY", {
            get: function() {
                return this._scrollY
            },
            set: function(a) {
                this._scrollY = a
            }
        }), Object.defineProperty(c.TilemapLayer.prototype, "collisionWidth", {
            get: function() {
                return this._mc.cw
            },
            set: function(a) {
                this._mc.cw = 0 | a, this.dirty = !0
            }
        }), Object.defineProperty(c.TilemapLayer.prototype, "collisionHeight", {
            get: function() {
                return this._mc.ch
            },
            set: function(a) {
                this._mc.ch = 0 | a, this.dirty = !0
            }
        }), c.TilemapParser = {
            INSERT_NULL: !1,
            parse: function(a, b, d, e, f, g) {
                if (void 0 === d && (d = 32), void 0 === e && (e = 32), void 0 === f && (f = 10), void 0 === g && (g = 10), void 0 === b) return this.getEmptyData();
                if (null === b) return this.getEmptyData(d, e, f, g);
                var h = a.cache.getTilemapData(b);
                if (h) {
                    if (h.format === c.Tilemap.CSV) return this.parseCSV(b, h.data, d, e);
                    if (!h.format || h.format === c.Tilemap.TILED_JSON) return this.parseTiledJSON(h.data)
                }
            },
            parseCSV: function(a, b, d, e) {
                var f = this.getEmptyData();
                b = b.trim();
                for (var g = [], h = b.split("\n"), i = h.length, j = 0, k = 0; k < h.length; k++) {
                    g[k] = [];
                    for (var l = h[k].split(","), m = 0; m < l.length; m++) g[k][m] = new c.Tile(f.layers[0], parseInt(l[m], 10), m, k, d, e);
                    0 === j && (j = l.length)
                }
                return f.format = c.Tilemap.CSV, f.name = a, f.width = j, f.height = i, f.tileWidth = d, f.tileHeight = e, f.widthInPixels = j * d, f.heightInPixels = i * e, f.layers[0].width = j, f.layers[0].height = i, f.layers[0].widthInPixels = f.widthInPixels, f.layers[0].heightInPixels = f.heightInPixels, f.layers[0].data = g, f
            },
            getEmptyData: function(a, b, c, d) {
                return {
                    width: void 0 !== c && null !== c ? c : 0,
                    height: void 0 !== d && null !== d ? d : 0,
                    tileWidth: void 0 !== a && null !== a ? a : 0,
                    tileHeight: void 0 !== b && null !== b ? b : 0,
                    orientation: "orthogonal",
                    version: "1",
                    properties: {},
                    widthInPixels: 0,
                    heightInPixels: 0,
                    layers: [{
                        name: "layer",
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0,
                        widthInPixels: 0,
                        heightInPixels: 0,
                        alpha: 1,
                        visible: !0,
                        properties: {},
                        indexes: [],
                        callbacks: [],
                        bodies: [],
                        data: []
                    }],
                    images: [],
                    objects: {},
                    collision: {},
                    tilesets: [],
                    tiles: []
                }
            },
            parseTiledJSON: function(a) {
                function b(a, b) {
                    var c = {};
                    for (var d in b) {
                        var e = b[d];
                        "undefined" != typeof a[e] && (c[e] = a[e])
                    }
                    return c
                }
                if ("orthogonal" !== a.orientation) return null;
                for (var d = {
                    width: a.width,
                    height: a.height,
                    tileWidth: a.tilewidth,
                    tileHeight: a.tileheight,
                    orientation: a.orientation,
                    format: c.Tilemap.TILED_JSON,
                    version: a.version,
                    properties: a.properties,
                    widthInPixels: a.width * a.tilewidth,
                    heightInPixels: a.height * a.tileheight
                }, e = [], f = 0; f < a.layers.length; f++)
                    if ("tilelayer" === a.layers[f].type) {
                        var g = a.layers[f];
                        if (!g.compression && g.encoding && "base64" === g.encoding) {
                            for (var h = window.atob(g.data), i = h.length, j = new Array(i), k = 0; k < i; k += 4) j[k / 4] = (h.charCodeAt(k) | h.charCodeAt(k + 1) << 8 | h.charCodeAt(k + 2) << 16 | h.charCodeAt(k + 3) << 24) >>> 0;
                            g.data = j, delete g.encoding
                        } else if (g.compression) continue;
                        var l = {
                            name: g.name,
                            x: g.x,
                            y: g.y,
                            width: g.width,
                            height: g.height,
                            widthInPixels: g.width * a.tilewidth,
                            heightInPixels: g.height * a.tileheight,
                            alpha: g.opacity,
                            visible: g.visible,
                            properties: {},
                            indexes: [],
                            callbacks: [],
                            bodies: []
                        };
                        g.properties && (l.properties = g.properties);
                        for (var m, n, o, p, q = 0, r = [], s = [], t = 0, i = g.data.length; t < i; t++) {
                            if (m = 0, n = !1, p = g.data[t], o = 0, p > 536870912) switch (p > 2147483648 && (p -= 2147483648, o += 4), p > 1073741824 && (p -= 1073741824, o += 2), p > 536870912 && (p -= 536870912, o += 1), o) {
                                case 5:
                                    m = Math.PI / 2;
                                    break;
                                case 6:
                                    m = Math.PI;
                                    break;
                                case 3:
                                    m = 3 * Math.PI / 2;
                                    break;
                                case 4:
                                    m = 0, n = !0;
                                    break;
                                case 7:
                                    m = Math.PI / 2, n = !0;
                                    break;
                                case 2:
                                    m = Math.PI, n = !0;
                                    break;
                                case 1:
                                    m = 3 * Math.PI / 2, n = !0
                            }
                            if (p > 0) {
                                var u = new c.Tile(l, p, q, s.length, a.tilewidth, a.tileheight);
                                u.rotation = m, u.flipped = n, 0 !== o && (u.flippedVal = o), r.push(u)
                            } else c.TilemapParser.INSERT_NULL ? r.push(null) : r.push(new c.Tile(l, (-1), q, s.length, a.tilewidth, a.tileheight));
                            q++, q === g.width && (s.push(r), q = 0, r = [])
                        }
                        l.data = s, e.push(l)
                    }
                d.layers = e;
                for (var v = [], f = 0; f < a.layers.length; f++)
                    if ("imagelayer" === a.layers[f].type) {
                        var w = a.layers[f],
                            x = {
                                name: w.name,
                                image: w.image,
                                x: w.x,
                                y: w.y,
                                alpha: w.opacity,
                                visible: w.visible,
                                properties: {}
                            };
                        w.properties && (x.properties = w.properties), v.push(x)
                    }
                d.images = v;
                for (var y = [], z = [], A = null, f = 0; f < a.tilesets.length; f++) {
                    var B = a.tilesets[f];
                    if (B.image) {
                        var C = new c.Tileset(B.name, B.firstgid, B.tilewidth, B.tileheight, B.margin, B.spacing, B.properties);
                        B.tileproperties && (C.tileProperties = B.tileproperties), C.updateTileData(B.imagewidth, B.imageheight), y.push(C)
                    } else {
                        var D = new c.ImageCollection(B.name, B.firstgid, B.tilewidth, B.tileheight, B.margin, B.spacing, B.properties);
                        for (var E in B.tiles) {
                            var x = B.tiles[E].image,
                                p = B.firstgid + parseInt(E, 10);
                            D.addImage(p, x)
                        }
                        z.push(D)
                    }
                    A && (A.lastgid = B.firstgid - 1), A = B
                }
                d.tilesets = y, d.imagecollections = z;
                for (var F = {}, G = {}, f = 0; f < a.layers.length; f++)
                    if ("objectgroup" === a.layers[f].type) {
                        var H = a.layers[f];
                        F[H.name] = [], G[H.name] = [];
                        for (var I = 0, i = H.objects.length; I < i; I++)
                            if (H.objects[I].gid) {
                                var J = {
                                    gid: H.objects[I].gid,
                                    name: H.objects[I].name,
                                    type: H.objects[I].hasOwnProperty("type") ? H.objects[I].type : "",
                                    x: H.objects[I].x,
                                    y: H.objects[I].y,
                                    visible: H.objects[I].visible,
                                    properties: H.objects[I].properties
                                };
                                H.objects[I].rotation && (J.rotation = H.objects[I].rotation), F[H.name].push(J)
                            } else if (H.objects[I].polyline) {
                            var J = {
                                name: H.objects[I].name,
                                type: H.objects[I].type,
                                x: H.objects[I].x,
                                y: H.objects[I].y,
                                width: H.objects[I].width,
                                height: H.objects[I].height,
                                visible: H.objects[I].visible,
                                properties: H.objects[I].properties
                            };
                            H.objects[I].rotation && (J.rotation = H.objects[I].rotation), J.polyline = [];
                            for (var K = 0; K < H.objects[I].polyline.length; K++) J.polyline.push([H.objects[I].polyline[K].x, H.objects[I].polyline[K].y]);
                            G[H.name].push(J), F[H.name].push(J)
                        } else if (H.objects[I].polygon) {
                            var J = b(H.objects[I], ["name", "type", "x", "y", "visible", "rotation", "properties"]);
                            J.polygon = [];
                            for (var K = 0; K < H.objects[I].polygon.length; K++) J.polygon.push([H.objects[I].polygon[K].x, H.objects[I].polygon[K].y]);
                            F[H.name].push(J)
                        } else if (H.objects[I].ellipse) {
                            var J = b(H.objects[I], ["name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                            F[H.name].push(J)
                        } else {
                            var J = b(H.objects[I], ["name", "type", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                            J.rectangle = !0, F[H.name].push(J)
                        }
                    }
                d.objects = F, d.collision = G, d.tiles = [];
                for (var f = 0; f < d.tilesets.length; f++)
                    for (var B = d.tilesets[f], q = B.tileMargin, L = B.tileMargin, M = 0, N = 0, O = 0, t = B.firstgid; t < B.firstgid + B.total && (d.tiles[t] = [q, L, f], q += B.tileWidth + B.tileSpacing, M++, M !== B.total) && (N++, N !== B.columns || (q = B.tileMargin, L += B.tileHeight + B.tileSpacing, N = 0, O++, O !== B.rows)); t++);
                for (var l, u, P, B, f = 0; f < d.layers.length; f++) {
                    l = d.layers[f], B = null;
                    for (var k = 0; k < l.data.length; k++) {
                        r = l.data[k];
                        for (var Q = 0; Q < r.length; Q++) u = r[Q], null === u || u.index < 0 || (P = d.tiles[u.index][2], B = d.tilesets[P], B.tileProperties && B.tileProperties[u.index - B.firstgid] && (u.properties = c.Utils.mixin(B.tileProperties[u.index - B.firstgid], u.properties)))
                    }
                }
                return d
            }
        }, c.Tileset = function(a, b, c, d, e, f, g) {
            (void 0 === c || c <= 0) && (c = 32), (void 0 === d || d <= 0) && (d = 32), void 0 === e && (e = 0), void 0 === f && (f = 0), this.name = a, this.firstgid = 0 | b, this.tileWidth = 0 | c, this.tileHeight = 0 | d, this.tileMargin = 0 | e, this.tileSpacing = 0 | f, this.properties = g || {}, this.image = null, this.rows = 0, this.columns = 0, this.total = 0, this.drawCoords = []
        }, c.Tileset.prototype = {
            draw: function(a, b, c, d) {
                var e = d - this.firstgid << 1;
                e >= 0 && e + 1 < this.drawCoords.length && a.drawImage(this.image, this.drawCoords[e], this.drawCoords[e + 1], this.tileWidth, this.tileHeight, b, c, this.tileWidth, this.tileHeight)
            },
            containsTileIndex: function(a) {
                return a >= this.firstgid && a < this.firstgid + this.total
            },
            setImage: function(a) {
                this.image = a, this.updateTileData(a.width, a.height)
            },
            setSpacing: function(a, b) {
                this.tileMargin = 0 | a, this.tileSpacing = 0 | b, this.image && this.updateTileData(this.image.width, this.image.height)
            },
            updateTileData: function(a, b) {
                var c = (b - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing),
                    d = (a - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
                c = Math.floor(c), d = Math.floor(d), (this.rows && this.rows !== c || this.columns && this.columns !== d) && void 0, this.rows = c, this.columns = d, this.total = c * d, this.drawCoords.length = 0;
                for (var e = this.tileMargin, f = this.tileMargin, g = 0; g < this.rows; g++) {
                    for (var h = 0; h < this.columns; h++) this.drawCoords.push(e), this.drawCoords.push(f), e += this.tileWidth + this.tileSpacing;
                    e = this.tileMargin, f += this.tileHeight + this.tileSpacing
                }
            }
        }, c.Tileset.prototype.constructor = c.Tileset, c.Particle = function(a, b, d, e, f) {
            c.Sprite.call(this, a, b, d, e, f), this.autoScale = !1, this.scaleData = null, this._s = 0, this.autoAlpha = !1, this.alphaData = null, this._a = 0
        }, c.Particle.prototype = Object.create(c.Sprite.prototype), c.Particle.prototype.constructor = c.Particle, c.Particle.prototype.update = function() {
            this.autoScale && (this._s--, this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1), this.autoAlpha && (this._a--, this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1)
        }, c.Particle.prototype.onEmit = function() {}, c.Particle.prototype.setAlphaData = function(a) {
            this.alphaData = a, this._a = a.length - 1, this.alpha = this.alphaData[this._a].v, this.autoAlpha = !0
        }, c.Particle.prototype.setScaleData = function(a) {
            this.scaleData = a, this._s = a.length - 1, this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y), this.autoScale = !0
        }, c.Particle.prototype.reset = function(a, b, d) {
            return c.Component.Reset.prototype.reset.call(this, a, b, d), this.alpha = 1, this.scale.set(1), this.autoScale = !1, this.autoAlpha = !1, this
        }, c.Particles = function(a) {
            this.game = a, this.emitters = {}, this.ID = 0
        }, c.Particles.prototype = {
            add: function(a) {
                return this.emitters[a.name] = a, a
            },
            remove: function(a) {
                delete this.emitters[a.name]
            },
            update: function() {
                for (var a in this.emitters) this.emitters[a].exists && this.emitters[a].update()
            }
        }, c.Particles.prototype.constructor = c.Particles, c.Particles.Arcade = {}, c.Particles.Arcade.Emitter = function(a, b, d, e) {
            this.maxParticles = e || 50, c.Group.call(this, a), this.name = "emitter" + this.game.particles.ID++, this.type = c.EMITTER, this.physicsType = c.GROUP, this.area = new c.Rectangle(b, d, 1, 1), this.minParticleSpeed = new c.Point((-100), (-100)), this.maxParticleSpeed = new c.Point(100, 100), this.minParticleScale = 1, this.maxParticleScale = 1, this.scaleData = null, this.minRotation = -360, this.maxRotation = 360, this.minParticleAlpha = 1, this.maxParticleAlpha = 1, this.alphaData = null, this.gravity = 100, this.particleClass = c.Particle, this.particleDrag = new c.Point, this.angularDrag = 0, this.frequency = 100, this.lifespan = 2e3, this.bounce = new c.Point, this.on = !1, this.particleAnchor = new c.Point(.5, .5), this.blendMode = c.blendModes.NORMAL, this.emitX = b, this.emitY = d, this.autoScale = !1, this.autoAlpha = !1, this.particleBringToTop = !1, this.particleSendToBack = !1, this._minParticleScale = new c.Point(1, 1), this._maxParticleScale = new c.Point(1, 1), this._quantity = 0, this._timer = 0, this._counter = 0, this._flowQuantity = 0, this._flowTotal = 0, this._explode = !0, this._frames = null
        }, c.Particles.Arcade.Emitter.prototype = Object.create(c.Group.prototype), c.Particles.Arcade.Emitter.prototype.constructor = c.Particles.Arcade.Emitter, c.Particles.Arcade.Emitter.prototype.update = function() {
            if (this.on && this.game.time.time >= this._timer)
                if (this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion, 0 !== this._flowTotal)
                    if (this._flowQuantity > 0) {
                        for (var a = 0; a < this._flowQuantity; a++)
                            if (this.emitParticle() && (this._counter++, this._flowTotal !== -1 && this._counter >= this._flowTotal)) {
                                this.on = !1;
                                break
                            }
                    } else this.emitParticle() && (this._counter++, this._flowTotal !== -1 && this._counter >= this._flowTotal && (this.on = !1));
            else this.emitParticle() && (this._counter++, this._quantity > 0 && this._counter >= this._quantity && (this.on = !1));
            for (var a = this.children.length; a--;) this.children[a].exists && this.children[a].update()
        }, c.Particles.Arcade.Emitter.prototype.makeParticles = function(a, b, c, d, e) {
            void 0 === b && (b = 0), void 0 === c && (c = this.maxParticles), void 0 === d && (d = !1), void 0 === e && (e = !1);
            var f, g = 0,
                h = a,
                i = b;
            for (this._frames = b, c > this.maxParticles && (this.maxParticles = c); g < c;) Array.isArray(a) && (h = this.game.rnd.pick(a)), Array.isArray(b) && (i = this.game.rnd.pick(b)), f = new this.particleClass(this.game, 0, 0, h, i), this.game.physics.arcade.enable(f, !1), d ? (f.body.checkCollision.any = !0, f.body.checkCollision.none = !1) : f.body.checkCollision.none = !0, f.body.collideWorldBounds = e, f.body.skipQuadTree = !0, f.exists = !1, f.visible = !1, f.anchor.copyFrom(this.particleAnchor), this.add(f), g++;
            return this
        }, c.Particles.Arcade.Emitter.prototype.kill = function() {
            return this.on = !1, this.alive = !1, this.exists = !1, this
        }, c.Particles.Arcade.Emitter.prototype.revive = function() {
            return this.alive = !0, this.exists = !0, this
        }, c.Particles.Arcade.Emitter.prototype.explode = function(a, b) {
            return this._flowTotal = 0, this.start(!0, a, 0, b, !1), this
        }, c.Particles.Arcade.Emitter.prototype.flow = function(a, b, c, d, e) {
            return void 0 !== c && 0 !== c || (c = 1), void 0 === d && (d = -1), void 0 === e && (e = !0), c > this.maxParticles && (c = this.maxParticles), this._counter = 0, this._flowQuantity = c, this._flowTotal = d, e ? (this.start(!0, a, b, c), this._counter += c, this.on = !0, this._timer = this.game.time.time + b * this.game.time.slowMotion) : this.start(!1, a, b, c), this
        }, c.Particles.Arcade.Emitter.prototype.start = function(a, b, c, d, e) {
            if (void 0 === a && (a = !0), void 0 === b && (b = 0), void 0 !== c && null !== c || (c = 250), void 0 === d && (d = 0), void 0 === e && (e = !1), d > this.maxParticles && (d = this.maxParticles), this.revive(), this.visible = !0, this.lifespan = b, this.frequency = c, a || e)
                for (var f = 0; f < d; f++) this.emitParticle();
            else this.on = !0, this._quantity = d, this._counter = 0, this._timer = this.game.time.time + c * this.game.time.slowMotion;
            return this
        }, c.Particles.Arcade.Emitter.prototype.emitParticle = function(a, b, c, d) {
            void 0 === a && (a = null), void 0 === b && (b = null);
            var e = this.getFirstExists(!1);
            if (null === e) return !1;
            var f = this.game.rnd;
            void 0 !== c && void 0 !== d ? e.loadTexture(c, d) : void 0 !== c && e.loadTexture(c);
            var g = this.emitX,
                h = this.emitY;
            null !== a ? g = a : this.width > 1 && (g = f.between(this.left, this.right)), null !== b ? h = b : this.height > 1 && (h = f.between(this.top, this.bottom)), e.reset(g, h), e.angle = 0, e.lifespan = this.lifespan, this.particleBringToTop ? this.bringToTop(e) : this.particleSendToBack && this.sendToBack(e), this.autoScale ? e.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? e.scale.set(f.realInRange(this.minParticleScale, this.maxParticleScale)) : this._minParticleScale.x === this._maxParticleScale.x && this._minParticleScale.y === this._maxParticleScale.y || e.scale.set(f.realInRange(this._minParticleScale.x, this._maxParticleScale.x), f.realInRange(this._minParticleScale.y, this._maxParticleScale.y)), void 0 === d && (Array.isArray(this._frames) ? e.frame = this.game.rnd.pick(this._frames) : e.frame = this._frames), this.autoAlpha ? e.setAlphaData(this.alphaData) : e.alpha = f.realInRange(this.minParticleAlpha, this.maxParticleAlpha), e.blendMode = this.blendMode;
            var i = e.body;
            return i.updateBounds(), i.bounce.copyFrom(this.bounce), i.drag.copyFrom(this.particleDrag), i.velocity.x = f.between(this.minParticleSpeed.x, this.maxParticleSpeed.x), i.velocity.y = f.between(this.minParticleSpeed.y, this.maxParticleSpeed.y), i.angularVelocity = f.between(this.minRotation, this.maxRotation), i.gravity.y = this.gravity, i.angularDrag = this.angularDrag, e.onEmit(), !0
        }, c.Particles.Arcade.Emitter.prototype.destroy = function() {
            this.game.particles.remove(this), c.Group.prototype.destroy.call(this, !0, !1)
        }, c.Particles.Arcade.Emitter.prototype.setSize = function(a, b) {
            return this.area.width = a, this.area.height = b, this
        }, c.Particles.Arcade.Emitter.prototype.setXSpeed = function(a, b) {
            return a = a || 0, b = b || 0, this.minParticleSpeed.x = a, this.maxParticleSpeed.x = b, this
        }, c.Particles.Arcade.Emitter.prototype.setYSpeed = function(a, b) {
            return a = a || 0, b = b || 0, this.minParticleSpeed.y = a, this.maxParticleSpeed.y = b, this
        }, c.Particles.Arcade.Emitter.prototype.setRotation = function(a, b) {
            return a = a || 0, b = b || 0, this.minRotation = a, this.maxRotation = b, this
        }, c.Particles.Arcade.Emitter.prototype.setAlpha = function(a, b, d, e, f) {
            if (void 0 === a && (a = 1), void 0 === b && (b = 1), void 0 === d && (d = 0), void 0 === e && (e = c.Easing.Linear.None), void 0 === f && (f = !1), this.minParticleAlpha = a, this.maxParticleAlpha = b, this.autoAlpha = !1, d > 0 && a !== b) {
                var g = {
                        v: a
                    },
                    h = this.game.make.tween(g).to({
                        v: b
                    }, d, e);
                h.yoyo(f), this.alphaData = h.generateData(60), this.alphaData.reverse(), this.autoAlpha = !0
            }
            return this
        }, c.Particles.Arcade.Emitter.prototype.setScale = function(a, b, d, e, f, g, h) {
            if (void 0 === a && (a = 1), void 0 === b && (b = 1), void 0 === d && (d = 1), void 0 === e && (e = 1), void 0 === f && (f = 0), void 0 === g && (g = c.Easing.Linear.None), void 0 === h && (h = !1), this.minParticleScale = 1, this.maxParticleScale = 1, this._minParticleScale.set(a, d), this._maxParticleScale.set(b, e), this.autoScale = !1, f > 0 && (a !== b || d !== e)) {
                var i = {
                        x: a,
                        y: d
                    },
                    j = this.game.make.tween(i).to({
                        x: b,
                        y: e
                    }, f, g);
                j.yoyo(h), this.scaleData = j.generateData(60), this.scaleData.reverse(), this.autoScale = !0
            }
            return this
        }, c.Particles.Arcade.Emitter.prototype.at = function(a) {
            return a.center ? (this.emitX = a.center.x, this.emitY = a.center.y) : (this.emitX = a.world.x + a.anchor.x * a.width, this.emitY = a.world.y + a.anchor.y * a.height), this
        }, Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "width", {
            get: function() {
                return this.area.width
            },
            set: function(a) {
                this.area.width = a
            }
        }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "height", {
            get: function() {
                return this.area.height
            },
            set: function(a) {
                this.area.height = a
            }
        }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "x", {
            get: function() {
                return this.emitX
            },
            set: function(a) {
                this.emitX = a
            }
        }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "y", {
            get: function() {
                return this.emitY
            },
            set: function(a) {
                this.emitY = a
            }
        }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "left", {
            get: function() {
                return Math.floor(this.x - this.area.width / 2)
            }
        }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "right", {
            get: function() {
                return Math.floor(this.x + this.area.width / 2)
            }
        }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "top", {
            get: function() {
                return Math.floor(this.y - this.area.height / 2)
            }
        }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "bottom", {
            get: function() {
                return Math.floor(this.y + this.area.height / 2)
            }
        }), c.Weapon = function(a, b) {
            c.Plugin.call(this, a, b), this.bullets = null, this.autoExpandBulletsGroup = !1, this.autofire = !1, this.shots = 0, this.fireLimit = 0, this.fireRate = 100, this.fireRateVariance = 0, this.fireFrom = new c.Rectangle(0, 0, 1, 1), this.fireAngle = c.ANGLE_UP, this.bulletInheritSpriteSpeed = !1, this.bulletAnimation = "", this.bulletFrameRandom = !1, this.bulletFrameCycle = !1, this.bulletWorldWrap = !1, this.bulletWorldWrapPadding = 0, this.bulletAngleOffset = 0, this.bulletAngleVariance = 0, this.bulletSpeed = 200, this.bulletSpeedVariance = 0, this.bulletLifespan = 0, this.bulletKillDistance = 0, this.bulletGravity = new c.Point(0, 0), this.bulletRotateToVelocity = !1, this.bulletKey = "", this.bulletFrame = "", this._bulletClass = c.Bullet, this._bulletCollideWorldBounds = !1, this._bulletKillType = c.Weapon.KILL_WORLD_BOUNDS, this._data = {
                customBody: !1,
                width: 0,
                height: 0,
                offsetX: 0,
                offsetY: 0
            }, this.bounds = new c.Rectangle, this.bulletBounds = a.world.bounds, this.bulletFrames = [], this.bulletFrameIndex = 0, this.anims = {}, this.onFire = new c.Signal, this.onKill = new c.Signal, this.onFireLimit = new c.Signal, this.trackedSprite = null, this.trackedPointer = null, this.trackRotation = !1, this.trackOffset = new c.Point, this._nextFire = 0, this._rotatedPoint = new c.Point
        }, c.Weapon.prototype = Object.create(c.Plugin.prototype), c.Weapon.prototype.constructor = c.Weapon, c.Weapon.KILL_NEVER = 0, c.Weapon.KILL_LIFESPAN = 1, c.Weapon.KILL_DISTANCE = 2, c.Weapon.KILL_WEAPON_BOUNDS = 3, c.Weapon.KILL_CAMERA_BOUNDS = 4, c.Weapon.KILL_WORLD_BOUNDS = 5, c.Weapon.KILL_STATIC_BOUNDS = 6, c.Weapon.prototype.createBullets = function(a, b, d, e) {
            return void 0 === a && (a = 1), void 0 === e && (e = this.game.world), this.bullets || (this.bullets = this.game.add.physicsGroup(c.Physics.ARCADE, e), this.bullets.classType = this._bulletClass), 0 !== a && (a === -1 && (this.autoExpandBulletsGroup = !0, a = 1), this.bullets.createMultiple(a, b, d), this.bullets.setAll("data.bulletManager", this), this.bulletKey = b, this.bulletFrame = d), this
        }, c.Weapon.prototype.forEach = function(a, b) {
            return this.bullets.forEachExists(a, b, arguments), this
        }, c.Weapon.prototype.pauseAll = function() {
            return this.bullets.setAll("body.enable", !1), this
        }, c.Weapon.prototype.resumeAll = function() {
            return this.bullets.setAll("body.enable", !0), this
        }, c.Weapon.prototype.killAll = function() {
            return this.bullets.callAllExists("kill", !0), this.bullets.setAll("body.enable", !0), this
        }, c.Weapon.prototype.resetShots = function(a) {
            return this.shots = 0, void 0 !== a && (this.fireLimit = a), this
        }, c.Weapon.prototype.destroy = function() {
            this.parent.remove(this, !1), this.bullets.destroy(), this.game = null, this.parent = null, this.active = !1, this.visible = !1
        }, c.Weapon.prototype.update = function() {
            this._bulletKillType === c.Weapon.KILL_WEAPON_BOUNDS && (this.trackedSprite ? (this.trackedSprite.updateTransform(), this.bounds.centerOn(this.trackedSprite.worldPosition.x, this.trackedSprite.worldPosition.y)) : this.trackedPointer && this.bounds.centerOn(this.trackedPointer.worldX, this.trackedPointer.worldY)), this.autofire && this.fire()
        }, c.Weapon.prototype.trackSprite = function(a, b, c, d) {
            return void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = !1), this.trackedPointer = null, this.trackedSprite = a, this.trackRotation = d, this.trackOffset.set(b, c), this
        }, c.Weapon.prototype.trackPointer = function(a, b, c) {
            return void 0 === a && (a = this.game.input.activePointer), void 0 === b && (b = 0), void 0 === c && (c = 0), this.trackedPointer = a, this.trackedSprite = null, this.trackRotation = !1, this.trackOffset.set(b, c), this
        }, c.Weapon.prototype.fire = function(a, b, d) {
            if (this.game.time.now < this._nextFire || this.fireLimit > 0 && this.shots === this.fireLimit) return !1;
            var e = this.bulletSpeed;
            0 !== this.bulletSpeedVariance && (e += c.Math.between(-this.bulletSpeedVariance, this.bulletSpeedVariance)), a ? this.fireFrom.width > 1 ? this.fireFrom.centerOn(a.x, a.y) : (this.fireFrom.x = a.x, this.fireFrom.y = a.y) : this.trackedSprite ? (this.trackRotation ? (this._rotatedPoint.set(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y), this._rotatedPoint.rotate(this.trackedSprite.world.x, this.trackedSprite.world.y, this.trackedSprite.rotation), this.fireFrom.width > 1 ? this.fireFrom.centerOn(this._rotatedPoint.x, this._rotatedPoint.y) : (this.fireFrom.x = this._rotatedPoint.x, this.fireFrom.y = this._rotatedPoint.y)) : this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedSprite.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedSprite.world.y + this.trackOffset.y), this.bulletInheritSpriteSpeed && (e += this.trackedSprite.body.speed)) : this.trackedPointer && (this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedPointer.world.x + this.trackOffset.x, this.trackedPointer.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedPointer.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedPointer.world.y + this.trackOffset.y));
            var f = this.fireFrom.width > 1 ? this.fireFrom.randomX : this.fireFrom.x,
                g = this.fireFrom.height > 1 ? this.fireFrom.randomY : this.fireFrom.y,
                h = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;
            void 0 !== b && void 0 !== d && (h = this.game.math.radToDeg(Math.atan2(d - g, b - f))), 0 !== this.bulletAngleVariance && (h += c.Math.between(-this.bulletAngleVariance, this.bulletAngleVariance));
            var i = 0,
                j = 0;
            0 === h || 180 === h ? i = Math.cos(this.game.math.degToRad(h)) * e : 90 === h || 270 === h ? j = Math.sin(this.game.math.degToRad(h)) * e : (i = Math.cos(this.game.math.degToRad(h)) * e, j = Math.sin(this.game.math.degToRad(h)) * e);
            var k = null;
            if (this.autoExpandBulletsGroup ? (k = this.bullets.getFirstExists(!1, !0, f, g, this.bulletKey, this.bulletFrame), k.data.bulletManager = this) : k = this.bullets.getFirstExists(!1), k) {
                if (k.reset(f, g), k.data.fromX = f, k.data.fromY = g, k.data.killType = this.bulletKillType, k.data.killDistance = this.bulletKillDistance, k.data.rotateToVelocity = this.bulletRotateToVelocity, this.bulletKillType === c.Weapon.KILL_LIFESPAN && (k.lifespan = this.bulletLifespan), k.angle = h + this.bulletAngleOffset, "" !== this.bulletAnimation) {
                    if (null === k.animations.getAnimation(this.bulletAnimation)) {
                        var l = this.anims[this.bulletAnimation];
                        k.animations.add(l.name, l.frames, l.frameRate, l.loop, l.useNumericIndex)
                    }
                    k.animations.play(this.bulletAnimation)
                } else this.bulletFrameCycle ? (k.frame = this.bulletFrames[this.bulletFrameIndex], this.bulletFrameIndex++, this.bulletFrameIndex >= this.bulletFrames.length && (this.bulletFrameIndex = 0)) : this.bulletFrameRandom && (k.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)]); if (k.data.bodyDirty && (this._data.customBody && k.body.setSize(this._data.width, this._data.height, this._data.offsetX, this._data.offsetY), k.body.collideWorldBounds = this.bulletCollideWorldBounds, k.data.bodyDirty = !1), k.body.velocity.set(i, j), k.body.gravity.set(this.bulletGravity.x, this.bulletGravity.y), 0 !== this.bulletSpeedVariance) {
                    var m = this.fireRate;
                    m += c.Math.between(-this.fireRateVariance, this.fireRateVariance), m < 0 && (m = 0), this._nextFire = this.game.time.now + m
                } else this._nextFire = this.game.time.now + this.fireRate;
                this.shots++, this.onFire.dispatch(k, this, e), this.fireLimit > 0 && this.shots === this.fireLimit && this.onFireLimit.dispatch(this, this.fireLimit)
            }
            return k
        }, c.Weapon.prototype.fireAtPointer = function(a) {
            return void 0 === a && (a = this.game.input.activePointer), this.fire(null, a.worldX, a.worldY)
        }, c.Weapon.prototype.fireAtSprite = function(a) {
            return this.fire(null, a.world.x, a.world.y)
        }, c.Weapon.prototype.fireAtXY = function(a, b) {
            return this.fire(null, a, b)
        }, c.Weapon.prototype.setBulletBodyOffset = function(a, b, c, d) {
            return void 0 === c && (c = 0), void 0 === d && (d = 0), this._data.customBody = !0, this._data.width = a, this._data.height = b, this._data.offsetX = c, this._data.offsetY = d, this.bullets.callAll("body.setSize", "body", a, b, c, d), this.bullets.setAll("data.bodyDirty", !1), this
        }, c.Weapon.prototype.setBulletFrames = function(a, b, d, e) {
            return void 0 === d && (d = !0), void 0 === e && (e = !1), this.bulletFrames = c.ArrayUtils.numberArray(a, b), this.bulletFrameIndex = 0, this.bulletFrameCycle = d, this.bulletFrameRandom = e, this
        }, c.Weapon.prototype.addBulletAnimation = function(a, b, c, d, e) {
            return this.anims[a] = {
                name: a,
                frames: b,
                frameRate: c,
                loop: d,
                useNumericIndex: e
            }, this.bullets.callAll("animations.add", "animations", a, b, c, d, e), this.bulletAnimation = a, this
        }, c.Weapon.prototype.debug = function(a, b, c) {
            void 0 === a && (a = 16), void 0 === b && (b = 32), void 0 === c && (c = !1), this.game.debug.text("Weapon Plugin", a, b), this.game.debug.text("Bullets Alive: " + this.bullets.total + " - Total: " + this.bullets.length, a, b + 24), c && this.bullets.forEachExists(this.game.debug.body, this.game.debug, "rgba(255, 0, 255, 0.8)")
        }, Object.defineProperty(c.Weapon.prototype, "bulletClass", {
            get: function() {
                return this._bulletClass
            },
            set: function(a) {
                this._bulletClass = a, this.bullets.classType = this._bulletClass
            }
        }), Object.defineProperty(c.Weapon.prototype, "bulletKillType", {
            get: function() {
                return this._bulletKillType
            },
            set: function(a) {
                switch (a) {
                    case c.Weapon.KILL_STATIC_BOUNDS:
                    case c.Weapon.KILL_WEAPON_BOUNDS:
                        this.bulletBounds = this.bounds;
                        break;
                    case c.Weapon.KILL_CAMERA_BOUNDS:
                        this.bulletBounds = this.game.camera.view;
                        break;
                    case c.Weapon.KILL_WORLD_BOUNDS:
                        this.bulletBounds = this.game.world.bounds
                }
                this._bulletKillType = a
            }
        }), Object.defineProperty(c.Weapon.prototype, "bulletCollideWorldBounds", {
            get: function() {
                return this._bulletCollideWorldBounds
            },
            set: function(a) {
                this._bulletCollideWorldBounds = a, this.bullets.setAll("body.collideWorldBounds", a), this.bullets.setAll("data.bodyDirty", !1)
            }
        }), Object.defineProperty(c.Weapon.prototype, "x", {
            get: function() {
                return this.fireFrom.x
            },
            set: function(a) {
                this.fireFrom.x = a
            }
        }), Object.defineProperty(c.Weapon.prototype, "y", {
            get: function() {
                return this.fireFrom.y
            },
            set: function(a) {
                this.fireFrom.y = a
            }
        }), c.Bullet = function(a, b, d, e, f) {
            c.Sprite.call(this, a, b, d, e, f), this.anchor.set(.5), this.data = {
                bulletManager: null,
                fromX: 0,
                fromY: 0,
                bodyDirty: !0,
                rotateToVelocity: !1,
                killType: 0,
                killDistance: 0
            }
        }, c.Bullet.prototype = Object.create(c.Sprite.prototype), c.Bullet.prototype.constructor = c.Bullet, c.Bullet.prototype.kill = function() {
            return this.alive = !1, this.exists = !1, this.visible = !1, this.data.bulletManager.onKill.dispatch(this), this
        }, c.Bullet.prototype.update = function() {
            this.exists && (this.data.killType > c.Weapon.KILL_LIFESPAN && (this.data.killType === c.Weapon.KILL_DISTANCE ? this.game.physics.arcade.distanceToXY(this, this.data.fromX, this.data.fromY, !0) > this.data.killDistance && this.kill() : this.data.bulletManager.bulletBounds.intersects(this) || this.kill()), this.data.rotateToVelocity && (this.rotation = Math.atan2(this.body.velocity.y, this.body.velocity.x)), this.data.bulletManager.bulletWorldWrap && this.game.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding))
        }, c.Video = function(a, b, d) {
            if (void 0 === b && (b = null), void 0 === d && (d = null), this.game = a, this.key = b, this.width = 0, this.height = 0, this.type = c.VIDEO, this.disableTextureUpload = !1, this.touchLocked = !1, this.onPlay = new c.Signal, this.onChangeSource = new c.Signal, this.onComplete = new c.Signal, this.onAccess = new c.Signal, this.onError = new c.Signal, this.onTimeout = new c.Signal, this.timeout = 15e3, this._timeOutID = null, this.video = null, this.videoStream = null, this.isStreaming = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._codeMuted = !1, this._muted = !1, this._codePaused = !1, this._paused = !1, this._pending = !1, this._autoplay = !1, this._endCallback = null, this._playCallback = null, b && this.game.cache.checkVideoKey(b)) {
                var e = this.game.cache.getVideo(b);
                e.isBlob ? this.createVideoFromBlob(e.data) : this.video = e.data, this.width = this.video.videoWidth, this.height = this.video.videoHeight
            } else d && this.createVideoFromURL(d, !1);
            this.video && !d ? (this.baseTexture = new PIXI.BaseTexture(this.video), this.baseTexture.forceLoaded(this.width, this.height)) : (this.baseTexture = new PIXI.BaseTexture(c.Cache.DEFAULT.baseTexture.source), this.baseTexture.forceLoaded(this.width, this.height)), this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new c.Frame(0, 0, 0, this.width, this.height, "video"), this.texture.setFrame(this.textureFrame), this.texture.valid = !1, null !== b && this.video && (this.texture.valid = this.video.canplay), this.snapshot = null, c.BitmapData && (this.snapshot = new c.BitmapData(this.game, "", this.width, this.height)), !this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? this.setTouchLock() : e && (e.locked = !1)
        }, c.Video.prototype = {
            connectToMediaStream: function(a, b) {
                return a && b && (this.video = a, this.videoStream = b, this.isStreaming = !0, this.baseTexture.source = this.video, this.updateTexture(null, this.video.videoWidth, this.video.videoHeight), this.onAccess.dispatch(this)), this
            },
            startMediaStream: function(a, b, c) {
                if (void 0 === a && (a = !1), void 0 === b && (b = null), void 0 === c && (c = null), !this.game.device.getUserMedia) return this.onError.dispatch(this, "No getUserMedia"), !1;
                null !== this.videoStream && (this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()), this.removeVideoElement(), this.video = document.createElement("video"), this.video.setAttribute("autoplay", "autoplay"), null !== b && (this.video.width = b), null !== c && (this.video.height = c), this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
                try {
                    navigator.getUserMedia({
                        audio: a,
                        video: !0
                    }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this))
                } catch (a) {
                    this.getUserMediaError(a)
                }
                return this
            },
            getUserMediaTimeout: function() {
                clearTimeout(this._timeOutID), this.onTimeout.dispatch(this)
            },
            getUserMediaError: function(a) {
                clearTimeout(this._timeOutID), this.onError.dispatch(this, a)
            },
            getUserMediaSuccess: function(a) {
                clearTimeout(this._timeOutID), this.videoStream = a, void 0 !== this.video.mozSrcObject ? this.video.mozSrcObject = a : this.video.src = window.URL && window.URL.createObjectURL(a) || a;
                var b = this;
                this.video.onloadeddata = function() {
                    function a() {
                        if (c > 0)
                            if (b.video.videoWidth > 0) {
                                var d = b.video.videoWidth,
                                    e = b.video.videoHeight;
                                isNaN(b.video.videoHeight) && (e = d / (4 / 3)), b.video.play(), b.isStreaming = !0, b.baseTexture.source = b.video, b.updateTexture(null, d, e), b.onAccess.dispatch(b)
                            } else window.setTimeout(a, 500);
                        c--
                    }
                    var c = 10;
                    a()
                }
            },
            createVideoFromBlob: function(a) {
                var b = this;
                return this.video = document.createElement("video"), this.video.controls = !1, this.video.setAttribute("autoplay", "autoplay"), this.video.addEventListener("loadeddata", function(a) {
                    b.updateTexture(a)
                }, !0), this.video.src = window.URL.createObjectURL(a), this.video.canplay = !0, this
            },
            createVideoFromURL: function(a, b) {
                return void 0 === b && (b = !1), this.texture && (this.texture.valid = !1), this.video = document.createElement("video"), this.video.controls = !1, b && this.video.setAttribute("autoplay", "autoplay"), this.video.src = a, this.video.canplay = !0, this.video.load(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.key = a, this
            },
            updateTexture: function(a, b, c) {
                var d = !1;
                void 0 !== b && null !== b || (b = this.video.videoWidth, d = !0), void 0 !== c && null !== c || (c = this.video.videoHeight), this.width = b, this.height = c, this.baseTexture.source !== this.video && (this.baseTexture.source = this.video), this.baseTexture.forceLoaded(b, c), this.texture.frame.resize(b, c), this.texture.width = b, this.texture.height = c, this.texture.valid = !0, this.snapshot && this.snapshot.resize(b, c), d && null !== this.key && (this.onChangeSource.dispatch(this, b, c), this._autoplay && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)))
            },
            complete: function() {
                this.onComplete.dispatch(this)
            },
            play: function(a, b) {
                return void 0 === a && (a = !1), void 0 === b && (b = 1), this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this), this.game.sound.onUnMute.add(this.unsetMute, this), this.game.sound.mute && this.setMute()), this.game.onPause.add(this.setPause, this), this.game.onResume.add(this.setResume, this), this._endCallback = this.complete.bind(this), this.video.addEventListener("ended", this._endCallback, !0), this.video.addEventListener("webkitendfullscreen", this._endCallback, !0), a ? this.video.loop = "loop" : this.video.loop = "", this.video.playbackRate = b, this.touchLocked ? this._pending = !0 : (this._pending = !1, null !== this.key && (4 !== this.video.readyState ? (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : (this._playCallback = this.playHandler.bind(this), this.video.addEventListener("playing", this._playCallback, !0))), this.video.play(), this.onPlay.dispatch(this, a, b)), this
            },
            playHandler: function() {
                this.video.removeEventListener("playing", this._playCallback, !0), this.updateTexture()
            },
            stop: function() {
                return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this), this.game.sound.onUnMute.remove(this.unsetMute, this)), this.game.onPause.remove(this.setPause, this), this.game.onResume.remove(this.setResume, this), this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(), this.video.src = null) : (this.video.src = "", this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.getTracks ? this.videoStream.getTracks().forEach(function(a) {
                    a.stop()
                }) : this.videoStream.stop()), this.videoStream = null, this.isStreaming = !1) : (this.video.removeEventListener("ended", this._endCallback, !0), this.video.removeEventListener("webkitendfullscreen", this._endCallback, !0), this.video.removeEventListener("playing", this._playCallback, !0), this.touchLocked ? this._pending = !1 : this.video.pause()), this
            },
            add: function(a) {
                if (Array.isArray(a))
                    for (var b = 0; b < a.length; b++) a[b].loadTexture && a[b].loadTexture(this);
                else a.loadTexture(this);
                return this
            },
            addToWorld: function(a, b, c, d, e, f) {
                e = e || 1, f = f || 1;
                var g = this.game.add.image(a, b, this);
                return g.anchor.set(c, d), g.scale.set(e, f), g
            },
            render: function() {
                !this.disableTextureUpload && this.playing && this.baseTexture.dirty()
            },
            setMute: function() {
                this._muted || (this._muted = !0, this.video.muted = !0)
            },
            unsetMute: function() {
                this._muted && !this._codeMuted && (this._muted = !1, this.video.muted = !1)
            },
            setPause: function() {
                this._paused || this.touchLocked || (this._paused = !0, this.video.pause())
            },
            setResume: function() {
                !this._paused || this._codePaused || this.touchLocked || (this._paused = !1, this.video.ended || this.video.play())
            },
            changeSource: function(a, b) {
                return void 0 === b && (b = !0), this.texture.valid = !1, this.video.pause(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.video.src = a, this.video.load(), this._autoplay = b, b || (this.paused = !0), this
            },
            checkVideoProgress: function() {
                4 === this.video.readyState ? this.updateTexture() : (this.retry--, this.retry > 0 ? this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval) : void 0)
            },
            setTouchLock: function() {
                this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0
            },
            unlock: function() {
                if (this.touchLocked = !1, this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate), this.key) {
                    var a = this.game.cache.getVideo(this.key);
                    a && !a.isBlob && (a.locked = !1)
                }
                return !0
            },
            grab: function(a, b, c) {
                return void 0 === a && (a = !1), void 0 === b && (b = 1), void 0 === c && (c = null), null === this.snapshot ? void 0 : (a && this.snapshot.cls(), this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, b, c), this.snapshot)
            },
            removeVideoElement: function() {
                if (this.video) {
                    for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes();) this.video.removeChild(this.video.firstChild);
                    this.video.removeAttribute("autoplay"), this.video.removeAttribute("src"), this.video = null
                }
            },
            destroy: function() {
                this.stop(), this.removeVideoElement(), this.touchLocked && this.game.input.touch.removeTouchLockCallback(this.unlock, this), this._retryID && window.clearTimeout(this._retryID)
            }
        }, Object.defineProperty(c.Video.prototype, "currentTime", {
            get: function() {
                return this.video ? this.video.currentTime : 0
            },
            set: function(a) {
                this.video.currentTime = a
            }
        }), Object.defineProperty(c.Video.prototype, "duration", {
            get: function() {
                return this.video ? this.video.duration : 0
            }
        }), Object.defineProperty(c.Video.prototype, "progress", {
            get: function() {
                return this.video ? this.video.currentTime / this.video.duration : 0
            }
        }), Object.defineProperty(c.Video.prototype, "mute", {
            get: function() {
                return this._muted
            },
            set: function(a) {
                if (a = a || null) {
                    if (this._muted) return;
                    this._codeMuted = !0, this.setMute()
                } else {
                    if (!this._muted) return;
                    this._codeMuted = !1, this.unsetMute()
                }
            }
        }), Object.defineProperty(c.Video.prototype, "paused", {
            get: function() {
                return this._paused
            },
            set: function(a) {
                if (a = a || null, !this.touchLocked)
                    if (a) {
                        if (this._paused) return;
                        this._codePaused = !0, this.setPause()
                    } else {
                        if (!this._paused) return;
                        this._codePaused = !1, this.setResume()
                    }
            }
        }), Object.defineProperty(c.Video.prototype, "volume", {
            get: function() {
                return this.video ? this.video.volume : 1
            },
            set: function(a) {
                a < 0 ? a = 0 : a > 1 && (a = 1), this.video && (this.video.volume = a)
            }
        }), Object.defineProperty(c.Video.prototype, "playbackRate", {
            get: function() {
                return this.video ? this.video.playbackRate : 1
            },
            set: function(a) {
                this.video && (this.video.playbackRate = a)
            }
        }), Object.defineProperty(c.Video.prototype, "loop", {
            get: function() {
                return !!this.video && this.video.loop
            },
            set: function(a) {
                a && this.video ? this.video.loop = "loop" : this.video && (this.video.loop = "")
            }
        }), Object.defineProperty(c.Video.prototype, "playing", {
            get: function() {
                return !(this.video.paused && this.video.ended)
            }
        }), c.Video.prototype.constructor = c.Video, void 0 === PIXI.blendModes && (PIXI.blendModes = c.blendModes), void 0 === PIXI.scaleModes && (PIXI.scaleModes = c.scaleModes), void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)), void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new PIXI.Matrix), void 0 === PIXI.RenderTexture.tempMatrix && (PIXI.RenderTexture.tempMatrix = new PIXI.Matrix), PIXI.Graphics && void 0 === PIXI.Graphics.POLY && (PIXI.Graphics.POLY = c.POLYGON, PIXI.Graphics.RECT = c.RECTANGLE, PIXI.Graphics.CIRC = c.CIRCLE, PIXI.Graphics.ELIP = c.ELLIPSE, PIXI.Graphics.RREC = c.ROUNDEDRECTANGLE), PIXI.TextureSilentFail = !0, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = c), exports.Phaser = c) : "undefined" != typeof define && define.amd ? define("Phaser", function() {
            return b.Phaser = c
        }()) : b.Phaser = c, c
    }.call(this);
var __extends = this && this.__extends || function() {
        var a = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(a, b) {
            a.__proto__ = b
        } || function(a, b) {
            for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c])
        };
        return function(b, c) {
            function d() {
                this.constructor = b
            }
            a(b, c), b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d)
        }
    }(),
    PhaserAds;
! function(a) {
    var b;
    ! function(a) {
        a[a.start = 0] = "start", a[a.firstQuartile = 1] = "firstQuartile", a[a.midPoint = 2] = "midPoint", a[a.thirdQuartile = 3] = "thirdQuartile", a[a.complete = 4] = "complete"
    }(b = a.AdEvent || (a.AdEvent = {}));
    var c = function(b) {
        function c(a, c) {
            var d = b.call(this, a, c) || this;
            return d.onContentPaused = new Phaser.Signal, d.onContentResumed = new Phaser.Signal, d.onAdProgression = new Phaser.Signal, d.onAdsDisabled = new Phaser.Signal, d.onAdClicked = new Phaser.Signal, d.onAdRewardGranted = new Phaser.Signal, d.onBannerShown = new Phaser.Signal, d.onBannerHidden = new Phaser.Signal, d.bannerActive = !1, d.provider = null, d.wasMuted = !1, Object.defineProperty(a, "ads", {
                value: d
            }), d
        }
        return __extends(c, b), c.prototype.setAdProvider = function(a) {
            this.provider = a, this.provider.setManager(this)
        }, c.prototype.showAd = function() {
            for (var b = [], c = 0; c < arguments.length; c++) b[c] = arguments[c];
            if (null === this.provider) throw new Error("Can not request an ad without an provider, please attach an ad provider!");
            b[0] && b[0] !== a.AdProvider.CocoonAdType.banner && (this.wasMuted = this.game.sound.mute, this.game.sound.mute = !0), this.provider.showAd.apply(this.provider, b)
        }, c.prototype.preloadAd = function() {
            for (var a = [], b = 0; b < arguments.length; b++) a[b] = arguments[b];
            if (null === this.provider) throw new Error("Can not preload an ad without an provider, please attach an ad provider!");
            this.provider.preloadAd.apply(this.provider, a)
        }, c.prototype.destroyAd = function() {
            for (var a = [], b = 0; b < arguments.length; b++) a[b] = arguments[b];
            if (null === this.provider) throw new Error("Can not destroy an ad without an provider, please attach an ad provider!");
            this.provider.destroyAd.apply(this.provider, a)
        }, c.prototype.hideAd = function() {
            for (var a = [], b = 0; b < arguments.length; b++) a[b] = arguments[b];
            if (null === this.provider) throw new Error("Can not hide an ad without an provider, please attach an ad provider!");
            this.unMuteAfterAd(), this.provider.hideAd.apply(this.provider, a)
        }, c.prototype.adsEnabled = function() {
            return this.provider.adsEnabled
        }, c.prototype.unMuteAfterAd = function() {
            this.wasMuted || (this.game.sound.mute = !1)
        }, c
    }(Phaser.Plugin);
    a.AdManager = c
}(PhaserAds || (PhaserAds = {}));
var PhaserAds;
! function(a) {
    var b;
    ! function(a) {
        var b;
        ! function(a) {
            a[a.AdMob = 0] = "AdMob", a[a.MoPub = 1] = "MoPub", a[a.Chartboost = 2] = "Chartboost", a[a.Heyzap = 3] = "Heyzap"
        }(b = a.CocoonProvider || (a.CocoonProvider = {}));
        var c;
        ! function(a) {
            a[a.banner = 0] = "banner", a[a.interstitial = 1] = "interstitial", a[a.insentive = 2] = "insentive"
        }(c = a.CocoonAdType || (a.CocoonAdType = {}));
        var d = function() {
            function a(a, c, d) {
                if (this.adsEnabled = !1, this.banner = null, this.bannerShowable = !1, this.interstitial = null, this.interstitialShowable = !1, this.insentive = null, this.insentiveShowable = !1, (a.device.cordova || a.device.crosswalk) && Cocoon && Cocoon.Ad) {
                    switch (this.adsEnabled = !0, c) {
                        default:
                            case b.AdMob:
                            this.cocoonProvider = Cocoon.Ad.AdMob;
                        break;
                        case b.Chartboost:
                            this.cocoonProvider = Cocoon.Ad.Chartboost;
                            break;
                        case b.Heyzap:
                            this.cocoonProvider = Cocoon.Ad.Heyzap;
                            break;
                        case b.MoPub:
                            this.cocoonProvider = Cocoon.Ad.MoPub
                    }
                    this.cocoonProvider.configure(d)
                }
            }
            return a.prototype.setManager = function(a) {
                this.adManager = a
            }, a.prototype.showAd = function(a) {
                if (!this.adsEnabled) return this.adManager.unMuteAfterAd(), void(a !== c.banner && this.adManager.onContentResumed.dispatch());
                if (a === c.banner) {
                    if (!this.bannerShowable || null === this.banner) return void this.adManager.unMuteAfterAd();
                    this.adManager.onBannerShown.dispatch(this.banner.width, this.banner.height), this.adManager.bannerActive = !0, this.banner.show()
                }
                if (a === c.interstitial) {
                    if (!this.interstitialShowable || null === this.interstitial) return this.adManager.unMuteAfterAd(), void this.adManager.onContentResumed.dispatch(c.interstitial);
                    this.interstitial.show()
                }
                if (a === c.insentive) {
                    if (!this.insentiveShowable || null === this.insentive) return this.adManager.unMuteAfterAd(), void this.adManager.onContentResumed.dispatch(c.insentive);
                    this.insentive.show()
                }
            }, a.prototype.preloadAd = function(a, b, d) {
                var e = this;
                this.adsEnabled && (this.destroyAd(a), a === c.banner && (this.banner = this.cocoonProvider.createBanner(b), d && this.banner.setLayout(d), this.banner.on("load", function() {
                    e.bannerShowable = !0
                }), this.banner.on("fail", function() {
                    e.bannerShowable = !1, e.banner = null
                }), this.banner.on("click", function() {
                    e.adManager.onAdClicked.dispatch(c.banner)
                }), this.banner.on("show", function() {}), this.banner.on("dismiss", function() {}), this.banner.load()), a === c.interstitial && (this.interstitial = this.cocoonProvider.createInterstitial(b), this.interstitial.on("load", function() {
                    e.interstitialShowable = !0
                }), this.interstitial.on("fail", function() {
                    e.interstitialShowable = !1, e.interstitial = null
                }), this.interstitial.on("click", function() {
                    e.adManager.onAdClicked.dispatch(c.interstitial)
                }), this.interstitial.on("show", function() {
                    e.adManager.onContentPaused.dispatch(c.interstitial)
                }), this.interstitial.on("dismiss", function() {
                    e.adManager.unMuteAfterAd(), e.adManager.onContentResumed.dispatch(c.interstitial), e.interstitialShowable = !1, e.interstitial = null
                }), this.interstitial.load()), a === c.insentive && (this.insentive = this.cocoonProvider.createRewardedVideo(b), this.insentive.on("load", function() {
                    e.insentiveShowable = !0
                }), this.insentive.on("fail", function() {
                    e.insentiveShowable = !1, e.insentive = null
                }), this.insentive.on("click", function() {
                    e.adManager.onAdClicked.dispatch(c.insentive)
                }), this.insentive.on("show", function() {
                    e.adManager.onContentPaused.dispatch(c.insentive)
                }), this.insentive.on("dismiss", function() {
                    e.adManager.unMuteAfterAd(), e.adManager.onContentResumed.dispatch(c.insentive), e.insentiveShowable = !1, e.insentive = null
                }), this.insentive.on("reward", function() {
                    e.adManager.unMuteAfterAd(), e.adManager.onAdRewardGranted.dispatch(c.insentive), e.insentiveShowable = !1, e.insentive = null
                }), this.insentive.load()))
            }, a.prototype.destroyAd = function(a) {
                if (this.adsEnabled) {
                    if (a === c.banner && null !== this.banner) {
                        try {
                            this.cocoonProvider.releaseBanner(this.banner)
                        } catch (a) {}
                        this.banner = null, this.bannerShowable = !1
                    }
                    a === c.interstitial && null !== this.interstitial && (this.cocoonProvider.releaseInterstitial(this.interstitial), this.interstitial = null, this.interstitialShowable = !1)
                }
            }, a.prototype.hideAd = function(a) {
                this.adsEnabled && (a === c.interstitial && null !== this.interstitial && this.interstitial.hide(), a === c.banner && null !== this.banner && (this.adManager.bannerActive && (this.adManager.bannerActive = !1, this.adManager.onBannerHidden.dispatch(this.banner.width, this.banner.height)), this.banner.hide()), a === c.insentive && null !== this.insentive && this.insentive.hide())
            }, a
        }();
        a.CocoonAds = d
    }(b = a.AdProvider || (a.AdProvider = {}))
}(PhaserAds || (PhaserAds = {}));
var PhaserAds;
! function(a) {
    var b;
    ! function(a) {
        var b;
        ! function(a) {
            a[a.Interstitial = 0] = "Interstitial", a[a.Video = 1] = "Video", a[a.Rewarded = 2] = "Rewarded", a[a.Banner = 3] = "Banner"
        }(b = a.HeyzapAdTypes || (a.HeyzapAdTypes = {}));
        var c = function() {
            function a(a, b) {
                var c = this;
                this.adsEnabled = !1, (a.device.cordova || a.device.crosswalk) && (this.adsEnabled = !0, HeyzapAds.start(b).then(function() {}, function(a) {
                    c.adsEnabled = !1
                }))
            }
            return a.prototype.setManager = function(a) {
                this.adManager = a
            }, a.prototype.showAd = function(a, c) {
                var d = this;
                switch (this.adsEnabled || (this.adManager.unMuteAfterAd(), this.adManager.onContentResumed.dispatch()), a) {
                    case b.Interstitial:
                        HeyzapAds.InterstitialAd.addEventListener(HeyzapAds.InterstitialAd.Events.HIDE, function() {
                            d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch(HeyzapAds.InterstitialAd.Events.HIDE)
                        }), HeyzapAds.InterstitialAd.addEventListener(HeyzapAds.InterstitialAd.Events.SHOW_FAILED, function() {
                            d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch(HeyzapAds.InterstitialAd.Events.SHOW_FAILED)
                        }), HeyzapAds.InterstitialAd.addEventListener(HeyzapAds.InterstitialAd.Events.CLICKED, function() {
                            d.adManager.onAdClicked.dispatch(HeyzapAds.InterstitialAd.Events.CLICKED)
                        }), HeyzapAds.InterstitialAd.show().then(function() {
                            d.adManager.onContentPaused.dispatch()
                        }, function(a) {
                            d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch()
                        });
                        break;
                    case b.Video:
                        HeyzapAds.VideoAd.addEventListener(HeyzapAds.VideoAd.Events.HIDE, function() {
                            d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch(HeyzapAds.VideoAd.Events.HIDE)
                        }), HeyzapAds.VideoAd.addEventListener(HeyzapAds.VideoAd.Events.SHOW_FAILED, function() {
                            d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch(HeyzapAds.VideoAd.Events.SHOW_FAILED)
                        }), HeyzapAds.VideoAd.addEventListener(HeyzapAds.VideoAd.Events.CLICKED, function() {
                            d.adManager.onAdClicked.dispatch(HeyzapAds.VideoAd.Events.CLICKED)
                        }), HeyzapAds.VideoAd.show().then(function() {
                            d.adManager.onContentPaused.dispatch()
                        }, function(a) {
                            d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch()
                        });
                        break;
                    case b.Rewarded:
                        HeyzapAds.IncentivizedAd.addEventListener(HeyzapAds.IncentivizedAd.Events.HIDE, function() {
                            d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch(HeyzapAds.IncentivizedAd.Events.HIDE)
                        }), HeyzapAds.IncentivizedAd.addEventListener(HeyzapAds.IncentivizedAd.Events.SHOW_FAILED, function() {
                            d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch(HeyzapAds.IncentivizedAd.Events.SHOW_FAILED)
                        }), HeyzapAds.IncentivizedAd.addEventListener(HeyzapAds.IncentivizedAd.Events.CLICKED, function() {
                            d.adManager.onAdClicked.dispatch(HeyzapAds.IncentivizedAd.Events.CLICKED)
                        }), HeyzapAds.IncentivizedAd.show().then(function() {
                            d.adManager.onContentPaused.dispatch()
                        }, function(a) {
                            d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch()
                        });
                        break;
                    case b.Banner:
                        HeyzapAds.BannerAd.show(c).then(function() {}, function(a) {})
                }
            }, a.prototype.preloadAd = function(a) {
                this.adsEnabled && a === b.Rewarded && HeyzapAds.IncentivizedAd.fetch().then(function() {}, function(a) {})
            }, a.prototype.destroyAd = function(a) {
                this.adsEnabled && a === b.Banner && HeyzapAds.BannerAd.destroy().then(function() {}, function(a) {})
            }, a.prototype.hideAd = function(a) {
                this.adsEnabled && a === b.Banner && HeyzapAds.BannerAd.hide().then(function() {}, function(a) {})
            }, a
        }();
        a.CordovaHeyzap = c
    }(b = a.AdProvider || (a.AdProvider = {}))
}(PhaserAds || (PhaserAds = {}));
var PhaserAds;
! function(a) {
    var b;
    ! function(a) {
        var b;
        ! function(a) {
            a[a.preroll = 0] = "preroll", a[a.midroll = 1] = "midroll"
        }(b = a.GameDistributionAdType || (a.GameDistributionAdType = {}));
        var c = function() {
            function a(a, b, c) {
                var d = this;
                this.adsEnabled = !0, this.areAdsEnabled(), this.settings = {
                    gameId: b,
                    userId: c,
                    resumeGame: function() {
                        d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch()
                    },
                    pauseGame: function() {
                        d.adManager.onContentPaused.dispatch()
                    },
                    onInit: function(a) {},
                    onError: function(a) {
                        d.adsEnabled = !1
                    }
                }, window.GameDistribution = "gdApi", window.gdApi = window.gdApi || function() {
                    (window.gdApi.q = window.gdApi.q || []).push(arguments)
                }, window.gdApi.l = Date.now(), gdApi(this.settings)
            }
            return a.prototype.setManager = function(a) {
                this.adManager = a
            }, a.prototype.showAd = function(a) {
                a === b.preroll ? ! function(a, b, c, d) {
                    var e = b.createElement(c),
                        f = b.getElementsByTagName(c)[0];
                    e.async = !0, e.src = d, f.parentNode.insertBefore(e, f)
                }(window, document, "script", "./api.js") : this.adsEnabled && gdApi.showBanner(), this.adsEnabled || (this.adManager.unMuteAfterAd(), this.adManager.onContentResumed.dispatch())
            }, a.prototype.preloadAd = function() {}, a.prototype.destroyAd = function() {}, a.prototype.hideAd = function() {}, a.prototype.areAdsEnabled = function() {
                var a = this,
                    b = document.createElement("div");
                b.innerHTML = "&nbsp;", b.className = "adsbox", document.body.appendChild(b);
                var c = function() {
                    var a = !0;
                    return 0 === b.offsetHeight && (a = !1), b.parentNode.removeChild(b), a
                };
                window.setTimeout(function() {
                    a.adsEnabled = c()
                }, 100)
            }, a
        }();
        a.GameDistributionAds = c
    }(b = a.AdProvider || (a.AdProvider = {}))
}(PhaserAds || (PhaserAds = {}));
var PhaserAds;
! function(a) {
    var b;
    ! function(b) {
        var c = function() {
            function b(a, b) {
                this.adsManager = null, this.googleEnabled = !1, this.adsEnabled = !0, this.adTagUrl = "", this.adRequested = !1, this.adManager = null, this.resizeListener = null, this.areAdsEnabled(), "undefined" != typeof google && (this.googleEnabled = !0, this.gameContent = "string" == typeof a.parent ? document.getElementById(a.parent) : a.parent, this.gameContent.style.position = "absolute", this.gameContent.style.width = "100%", this.adContent = this.gameContent.parentNode.appendChild(document.createElement("div")), this.adContent.id = "phaser-ad-container", this.adContent.style.position = "absolute", this.adContent.style.zIndex = "9999", this.adContent.style.display = "none", this.adContent.style.top = "0", this.adContent.style.left = "0", this.adContent.style.width = "100%", this.adContent.style.height = "100%", this.adContent.style.overflow = "hidden", this.adTagUrl = b, this.game = a, this.adDisplay = new google.ima.AdDisplayContainer(this.adContent), google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED), google.ima.settings.setLocale("nl"), this.adLoader = new google.ima.AdsLoader(this.adDisplay), this.adLoader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, this.onAdManagerLoader, !1, this), this.adLoader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, this.onAdError, !1, this))
            }
            return b.prototype.setManager = function(a) {
                this.adManager = a
            }, b.prototype.showAd = function(a) {
                if (!this.adRequested) {
                    if (this.adsEnabled || this.adManager.onAdsDisabled.dispatch(!0), !this.googleEnabled) return void this.onContentResumeRequested();
                    this.adDisplay.initialize();
                    var b = new google.ima.AdsRequest;
                    b.adTagUrl = this.adTagUrl + this.parseCustomParams(a);
                    var c = window.innerWidth,
                        d = window.innerHeight;
                    this.game.scale.isFullScreen && document.body.clientHeight < window.innerHeight && (d = document.body.clientHeight, c = document.body.clientWidth), b.linearAdSlotWidth = c, b.linearAdSlotHeight = d, b.nonLinearAdSlotWidth = c, b.nonLinearAdSlotHeight = d, b.forceNonLinearFullSlot = !0;
                    try {
                        this.adRequested = !0, this.adLoader.requestAds(b)
                    } catch (a) {
                        this.onContentResumeRequested()
                    }
                }
            }, b.prototype.preloadAd = function() {}, b.prototype.destroyAd = function() {}, b.prototype.hideAd = function() {}, b.prototype.onAdManagerLoader = function(a) {
                var b = this,
                    c = new google.ima.AdsRenderingSettings;
                c.restoreCustomPlaybackStateOnAdBreakComplete = !0;
                var d = a.getAdsManager(this.gameContent, c);
                this.adsManager = d, d.addEventListener(google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED, this.onContentPauseRequested, !1, this), d.addEventListener(google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED, this.onContentResumeRequested, !1, this), d.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, this.onAdError, !1, this), [google.ima.AdEvent.Type.ALL_ADS_COMPLETED, google.ima.AdEvent.Type.CLICK, google.ima.AdEvent.Type.COMPLETE, google.ima.AdEvent.Type.FIRST_QUARTILE, google.ima.AdEvent.Type.LOADED, google.ima.AdEvent.Type.MIDPOINT, google.ima.AdEvent.Type.PAUSED, google.ima.AdEvent.Type.STARTED, google.ima.AdEvent.Type.THIRD_QUARTILE].forEach(function(a) {
                    d.addEventListener(a, b.onAdEvent, !1, b)
                });
                try {
                    this.adContent.style.display = "block";
                    var e = window.innerWidth,
                        f = window.innerHeight;
                    this.adsManager.init(e, f, google.ima.ViewMode.NORMAL), this.adsManager.start(), this.resizeListener = function() {
                        null !== b.adsManager && b.adsManager.resize(window.innerWidth, window.innerHeight, google.ima.ViewMode.NORMAL);
                    }, window.addEventListener("resize", this.resizeListener)
                } catch (a) {
                    this.onAdError(a)
                }
            }, b.prototype.onAdEvent = function(b) {
                switch (b.type) {
                    case google.ima.AdEvent.Type.CLICK:
                        this.adManager.onAdClicked.dispatch();
                        break;
                    case google.ima.AdEvent.Type.LOADED:
                        this.adRequested = !1;
                        var c = b.getAd();
                        c.isLinear() || this.onContentResumeRequested();
                        break;
                    case google.ima.AdEvent.Type.STARTED:
                        this.adManager.onAdProgression.dispatch(a.AdEvent.start);
                        break;
                    case google.ima.AdEvent.Type.FIRST_QUARTILE:
                        this.adManager.onAdProgression.dispatch(a.AdEvent.firstQuartile);
                        break;
                    case google.ima.AdEvent.Type.MIDPOINT:
                        this.adManager.onAdProgression.dispatch(a.AdEvent.midPoint);
                        break;
                    case google.ima.AdEvent.Type.THIRD_QUARTILE:
                        this.adManager.onAdProgression.dispatch(a.AdEvent.thirdQuartile);
                        break;
                    case google.ima.AdEvent.Type.COMPLETE:
                        this.adManager.onAdProgression.dispatch(a.AdEvent.complete);
                        break;
                    case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:
                        this.onContentResumeRequested()
                }
            }, b.prototype.onAdError = function(a) {
                null !== this.adsManager && (this.adsManager.destroy(), this.adsManager = null, null !== this.resizeListener && (window.removeEventListener("resize", this.resizeListener), this.resizeListener = null)), this.adRequested && (this.adRequested = !1), this.onContentResumeRequested()
            }, b.prototype.onContentPauseRequested = function() {
                this.adManager.onContentPaused.dispatch()
            }, b.prototype.onContentResumeRequested = function() {
                return "undefined" == typeof google ? (this.adManager.unMuteAfterAd(), void this.adManager.onContentResumed.dispatch()) : (this.adContent.style.display = "none", this.adManager.unMuteAfterAd(), void this.adManager.onContentResumed.dispatch())
            }, b.prototype.parseCustomParams = function(a) {
                if (void 0 !== a) {
                    var b = "";
                    for (var c in a)
                        if (a.hasOwnProperty(c)) {
                            b.length > 0 && (b += "&");
                            var d = Array.isArray(a[c]) ? a[c].join(",") : a[c];
                            b += c + "=" + d
                        }
                    return "&cust_params=" + encodeURIComponent(b)
                }
                return ""
            }, b.prototype.areAdsEnabled = function() {
                var a = this,
                    b = document.createElement("div");
                b.innerHTML = "&nbsp;", b.className = "adsbox", document.body.appendChild(b);
                var c = function() {
                    var a = !0;
                    return 0 === b.offsetHeight && (a = !1), b.parentNode.removeChild(b), a
                };
                window.setTimeout(function() {
                    a.adsEnabled = c()
                }, 100)
            }, b
        }();
        b.Ima3 = c
    }(b = a.AdProvider || (a.AdProvider = {}))
}(PhaserAds || (PhaserAds = {}));
var spine = {
    radDeg: 180 / Math.PI,
    degRad: Math.PI / 180,
    Float32Array: "undefined" == typeof Float32Array ? Array : Float32Array,
    Uint32Array: "undefined" == typeof Uint32Array ? Array : Uint32Array,
    Uint16Array: "undefined" == typeof Uint16Array ? Array : Uint16Array
};
spine.temp = new spine.Float32Array(2), spine.BoneData = function(a, b) {
    this.name = a, this.parent = b
}, spine.BoneData.prototype = {
    length: 0,
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    inheritScale: !0,
    inheritRotation: !0
}, spine.BlendMode = {
    normal: 0,
    additive: 1,
    multiply: 2,
    screen: 3
}, spine.SlotData = function(a, b) {
    this.name = a, this.boneData = b
}, spine.SlotData.prototype = {
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    attachmentName: null,
    blendMode: spine.BlendMode.normal
}, spine.IkConstraintData = function(a) {
    this.name = a, this.bones = []
}, spine.IkConstraintData.prototype = {
    target: null,
    bendDirection: 1,
    mix: 1
}, spine.TransformConstraintData = function(a) {
    this.name = a
}, spine.TransformConstraintData.prototype = {
    bone: null,
    target: null,
    translateMix: 1,
    x: 0,
    y: 0
}, spine.Bone = function(a, b, c) {
    this.data = a, this.skeleton = b, this.parent = c, this.setToSetupPose()
}, spine.Bone.yDown = !1, spine.Bone.prototype = {
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    a: 0,
    b: 0,
    worldX: 0,
    c: 0,
    d: 0,
    worldY: 0,
    worldSignX: 1,
    worldSignY: 1,
    update: function() {
        this.updateWorldTransform(this.x, this.y, this.rotation, this.scaleX, this.scaleY)
    },
    updateWorldTransformWith: function() {
        this.updateWorldTransform(this.x, this.y, this.rotation, this.scaleX, this.scaleY)
    },
    updateWorldTransform: function(a, b, c, d, e) {
        this.appliedRotation = c, this.appliedScaleX = d, this.appliedScaleY = e, c *= spine.degRad;
        var f = Math.cos(c),
            g = Math.sin(c),
            h = f * d,
            i = -g * e,
            j = g * d,
            k = f * e,
            l = this.parent;
        if (!l) {
            var m = this.skeleton;
            return m.flipX && (a = -a, h = -h, i = -i), m.flipY != spine.Bone.yDown && (b = -b, j = -j, k = -k), this.a = h, this.b = i, this.c = j, this.d = k, this.worldX = a, this.worldY = b, this.worldSignX = d < 0 ? -1 : 1, void(this.worldSignY = e < 0 ? -1 : 1)
        }
        var n = l.a,
            o = l.b,
            p = l.c,
            q = l.d;
        if (this.worldX = n * a + o * b + l.worldX, this.worldY = p * a + q * b + l.worldY, this.worldSignX = l.worldSignX * (d < 0 ? -1 : 1), this.worldSignY = l.worldSignY * (e < 0 ? -1 : 1), this.data.inheritRotation && this.data.inheritScale) this.a = n * h + o * j, this.b = n * i + o * k, this.c = p * h + q * j, this.d = p * i + q * k;
        else {
            if (this.data.inheritRotation) {
                n = 1, o = 0, p = 0, q = 1;
                do {
                    c = l.appliedRotation * spine.degRad, f = Math.cos(c), g = Math.sin(c);
                    var r = n * f + o * g;
                    if (o = n * -g + o * f, n = r, r = p * f + q * g, q = p * -g + q * f, p = r, !l.data.inheritRotation) break;
                    l = l.parent
                } while (l);
                this.a = n * h + o * j, this.b = n * i + o * k, this.c = p * h + q * j, this.d = p * i + q * k
            } else if (this.data.inheritScale) {
                n = 1, o = 0, p = 0, q = 1;
                do {
                    c = l.appliedRotation * spine.degRad, f = Math.cos(c), g = Math.sin(c);
                    var s = l.appliedScaleX,
                        t = l.appliedScaleY,
                        u = f * s,
                        v = -g * t,
                        w = g * s,
                        x = f * t,
                        r = n * u + o * w;
                    if (o = n * v + o * x, n = r, r = p * u + q * w, q = p * v + q * x, p = r, s < 0 && (c = -c), f = Math.cos(-c), g = Math.sin(-c), r = n * f + o * g, o = n * -g + o * f, n = r, r = p * f + q * g, q = p * -g + q * f, p = r, !l.data.inheritScale) break;
                    l = l.parent
                } while (l);
                this.a = n * h + o * j, this.b = n * i + o * k, this.c = p * h + q * j, this.d = p * i + q * k
            } else this.a = h, this.b = i, this.c = j, this.d = k;
            this.skeleton.flipX && (this.a = -this.a, this.b = -this.b), this.skeleton.flipY != spine.Bone.yDown && (this.c = -this.c, this.d = -this.d)
        }
    },
    setToSetupPose: function() {
        var a = this.data;
        this.x = a.x, this.y = a.y, this.rotation = a.rotation, this.scaleX = a.scaleX, this.scaleY = a.scaleY
    },
    getWorldRotationX: function() {
        return Math.atan2(this.c, this.a) * spine.radDeg
    },
    getWorldRotationY: function() {
        return Math.atan2(this.d, this.b) * spine.radDeg
    },
    getWorldScaleX: function() {
        return Math.sqrt(this.a * this.a + this.b * this.b) * this.worldSignX
    },
    getWorldScaleY: function() {
        return Math.sqrt(this.c * this.c + this.d * this.d) * this.worldSignY
    },
    worldToLocal: function(a) {
        var b = a[0] - this.worldX,
            c = a[1] - this.worldY,
            d = this.a,
            e = this.b,
            f = this.c,
            g = this.d,
            h = 1 / (d * g - e * f);
        return a[0] = b * g * h - c * e * h, a[1] = c * d * h - b * f * h, a
    },
    localToWorld: function(a) {
        var b = a[0],
            c = a[1];
        return a[0] = b * this.a + c * this.b + this.worldX, a[1] = b * this.c + c * this.d + this.worldY, a
    }
}, spine.Slot = function(a, b) {
    this.data = a, this.bone = b, this.attachmentVertices = new spine.Float32Array, this.setToSetupPose()
}, spine.Slot.prototype = {
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    _attachmentTime: 0,
    attachment: null,
    setAttachment: function(a) {
        this.attachment != a && (this.attachment = a, this._attachmentTime = this.bone.skeleton.time, this.attachmentVertices.length = 0)
    },
    setAttachmentTime: function(a) {
        this._attachmentTime = this.bone.skeleton.time - a
    },
    getAttachmentTime: function() {
        return this.bone.skeleton.time - this._attachmentTime
    },
    setToSetupPose: function() {
        var a = this.data;
        if (this.r = a.r, this.g = a.g, this.b = a.b, this.a = a.a, a.attachmentName) {
            for (var b = this.bone.skeleton.data.slots, c = 0, d = b.length; c < d; c++)
                if (b[c] == a) {
                    this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachmentBySlotIndex(c, a.attachmentName));
                    break
                }
        } else this.setAttachment(null)
    }
}, spine.IkConstraint = function(a, b) {
    this.data = a, this.mix = a.mix, this.bendDirection = a.bendDirection, this.bones = [];
    for (var c = 0, d = a.bones.length; c < d; c++) this.bones[c] = b.findBone(a.bones[c].name);
    this.target = b.findBone(a.target.name)
}, spine.IkConstraint.prototype = {
    apply: function() {
        this.update()
    },
    update: function() {
        var a = this.target,
            b = this.bones;
        switch (b.length) {
            case 1:
                spine.IkConstraint.apply1(b[0], a.worldX, a.worldY, this.mix);
                break;
            case 2:
                spine.IkConstraint.apply2(b[0], b[1], a.worldX, a.worldY, this.bendDirection, this.mix)
        }
    }
}, spine.IkConstraint.apply1 = function(a, b, c, d) {
    var e = a.parent ? a.parent.getWorldRotationX() : 0,
        f = a.rotation,
        g = Math.atan2(c - a.worldY, b - a.worldX) * spine.radDeg - e;
    a.worldSignX != a.worldSignY != (a.skeleton.flipX != (a.skeleton.flipY != spine.Bone.yDown)) && (g = 360 - g), g > 180 ? g -= 360 : g < -180 && (g += 360), a.updateWorldTransform(a.x, a.y, f + (g - f) * d, a.appliedScaleX, a.appliedScaleY)
}, spine.IkConstraint.apply2 = function(a, b, c, d, e, f) {
    if (0 != f) {
        var g, h, i, j = a.x,
            k = a.y,
            l = a.appliedScaleX,
            m = a.appliedScaleY;
        l < 0 ? (l = -l, g = 180, i = -1) : (g = 0, i = 1), m < 0 && (m = -m, i = -i);
        var n = b.x,
            o = b.y,
            p = b.appliedScaleX,
            q = Math.abs(l - m) <= 1e-4;
        q || 0 == o || (b.worldX = a.a * n + a.worldX, b.worldY = a.c * n + a.worldY, o = 0), p < 0 ? (p = -p, h = 180) : h = 0;
        var r, s, t, u, v = a.parent;
        if (v) {
            var w = v.a,
                x = v.b,
                y = v.c,
                z = v.d,
                A = 1 / (w * z - x * y),
                B = v.worldX,
                C = v.worldY,
                D = c - B,
                E = d - C;
            r = (D * z - E * x) * A - j, s = (E * w - D * y) * A - k, D = b.worldX - B, E = b.worldY - C, t = (D * z - E * x) * A - j, u = (E * w - D * y) * A - k
        } else r = c - j, s = d - k, t = b.worldX - j, u = b.worldY - k;
        var F, G, H = Math.sqrt(t * t + u * u),
            I = b.data.length * p;
        a: if (q) {
            I *= l;
            var J = (r * r + s * s - H * H - I * I) / (2 * H * I);
            J < -1 ? J = -1 : J > 1 && (J = 1), G = Math.acos(J) * e;
            var w = H + I * J,
                K = I * Math.sin(G);
            F = Math.atan2(s * w - r * K, r * w + s * K)
        } else {
            var w = l * I,
                x = m * I,
                L = Math.atan2(s, r),
                M = w * w,
                N = x * x,
                O = H * H,
                P = r * r + s * s,
                Q = N * O + M * P - M * N,
                R = -2 * N * H,
                S = N - M,
                z = R * R - 4 * S * Q;
            if (z >= 0) {
                var T = Math.sqrt(z);
                R < 0 && (T = -T), T = -(R + T) / 2;
                var U = T / S,
                    V = Q / T,
                    W = Math.abs(U) < Math.abs(V) ? U : V;
                if (W * W <= P) {
                    var E = Math.sqrt(P - W * W) * e;
                    F = L - Math.atan2(E, W), G = Math.atan2(E / m, (W - H) / l);
                    break a
                }
            }
            var X = 0,
                Y = Number.MAX_VALUE,
                Z = 0,
                $ = 0,
                _ = 0,
                aa = 0,
                ba = 0,
                ca = 0,
                D = H + w,
                da = D * D;
            da > aa && (_ = 0, aa = da, ba = D), D = H - w, da = D * D, da < Y && (X = Math.PI, Y = da, Z = D);
            var ea = Math.acos(-w * H / (M - N));
            D = w * Math.cos(ea) + H;
            var E = x * Math.sin(ea);
            da = D * D + E * E, da < Y && (X = ea, Y = da, Z = D, $ = E), da > aa && (_ = ea, aa = da, ba = D, ca = E), P <= (Y + aa) / 2 ? (F = L - Math.atan2($ * e, Z), G = X * e) : (F = L - Math.atan2(ca * e, ba), G = _ * e)
        }
        var fa = Math.atan2(o, n) * i;
        F = (F - fa) * spine.radDeg + g, G = (G + fa) * spine.radDeg * i + h, F > 180 ? F -= 360 : F < -180 && (F += 360), G > 180 ? G -= 360 : G < -180 && (G += 360);
        var ga = a.rotation;
        a.updateWorldTransform(j, k, ga + (F - ga) * f, a.appliedScaleX, a.appliedScaleY), ga = b.rotation, b.updateWorldTransform(n, o, ga + (G - ga) * f, b.appliedScaleX, b.appliedScaleY)
    }
}, spine.TransformConstraint = function(a, b) {
    this.data = a, this.translateMix = a.translateMix, this.x = a.x, this.y = a.y, this.bone = b.findBone(a.bone.name), this.target = b.findBone(a.target.name)
}, spine.TransformConstraint.prototype = {
    apply: function() {
        this.update()
    },
    update: function() {
        var a = this.translateMix;
        if (a > 0) {
            var b = spine.temp;
            b[0] = x, b[1] = y, this.target.localToWorld(b);
            var c = this.bone;
            c.worldX += (b[0] - c.worldX) * a, c.worldY += (b[1] - c.worldY) * a
        }
    }
}, spine.Skin = function(a) {
    this.name = a, this.attachments = {}
}, spine.Skin.prototype = {
    addAttachment: function(a, b, c) {
        this.attachments[a + ":" + b] = c
    },
    getAttachment: function(a, b) {
        return this.attachments[a + ":" + b]
    },
    _attachAll: function(a, b) {
        for (var c in b.attachments) {
            var d = c.indexOf(":"),
                e = parseInt(c.substring(0, d)),
                f = c.substring(d + 1),
                g = a.slots[e];
            if (g.attachment && g.attachment.name == f) {
                var h = this.getAttachment(e, f);
                h && g.setAttachment(h)
            }
        }
    }
}, spine.Animation = function(a, b, c) {
    this.name = a, this.timelines = b, this.duration = c
}, spine.Animation.prototype = {
    apply: function(a, b, c, d, e) {
        d && 0 != this.duration && (c %= this.duration, b > 0 && (b %= this.duration));
        for (var f = this.timelines, g = 0, h = f.length; g < h; g++) f[g].apply(a, b, c, e, 1)
    },
    mix: function(a, b, c, d, e, f) {
        d && 0 != this.duration && (c %= this.duration, b > 0 && (b %= this.duration));
        for (var g = this.timelines, h = 0, i = g.length; h < i; h++) g[h].apply(a, b, c, e, f)
    }
}, spine.Animation.binarySearch = function(a, b, c) {
    var d = 0,
        e = Math.floor(a.length / c) - 2;
    if (!e) return c;
    for (var f = e >>> 1;;) {
        if (a[(f + 1) * c] <= b ? d = f + 1 : e = f, d == e) return (d + 1) * c;
        f = d + e >>> 1
    }
}, spine.Animation.binarySearch1 = function(a, b) {
    var c = 0,
        d = a.length - 2;
    if (!d) return 1;
    for (var e = d >>> 1;;) {
        if (a[e + 1] <= b ? c = e + 1 : d = e, c == d) return c + 1;
        e = c + d >>> 1
    }
}, spine.Animation.linearSearch = function(a, b, c) {
    for (var d = 0, e = a.length - c; d <= e; d += c)
        if (a[d] > b) return d;
    return -1
}, spine.Curves = function(a) {
    var b = 19 * (a - 1);
    this.curves = new spine.Float32Array(b), this.curves.length = b
}, spine.Curves.prototype = {
    setLinear: function(a) {
        this.curves[19 * a] = 0
    },
    setStepped: function(a) {
        this.curves[19 * a] = 1
    },
    setCurve: function(a, b, c, d, e) {
        var f = .1,
            g = f * f,
            h = g * f,
            i = 3 * f,
            j = 3 * g,
            k = 6 * g,
            l = 6 * h,
            m = 2 * -b + d,
            n = 2 * -c + e,
            o = 3 * (b - d) + 1,
            p = 3 * (c - e) + 1,
            q = b * i + m * j + o * h,
            r = c * i + n * j + p * h,
            s = m * k + o * l,
            t = n * k + p * l,
            u = o * l,
            v = p * l,
            w = 19 * a,
            x = this.curves;
        x[w++] = 2;
        for (var y = q, z = r, A = w + 19 - 1; w < A; w += 2) x[w] = y, x[w + 1] = z, q += s, r += t, s += u, t += v, y += q, z += r
    },
    getCurvePercent: function(a, b) {
        b = b < 0 ? 0 : b > 1 ? 1 : b;
        var c = this.curves,
            d = 19 * a,
            e = c[d];
        if (0 === e) return b;
        if (1 == e) return 0;
        d++;
        for (var f = 0, g = d, h = d + 19 - 1; d < h; d += 2)
            if (f = c[d], f >= b) {
                var i, j;
                return d == g ? (i = 0, j = 0) : (i = c[d - 2], j = c[d - 1]), j + (c[d + 1] - j) * (b - i) / (f - i)
            }
        var k = c[d - 1];
        return k + (1 - k) * (b - f) / (1 - f)
    }
}, spine.RotateTimeline = function(a) {
    this.curves = new spine.Curves(a), this.frames = new spine.Float32Array(2 * a), this.frames.length = 2 * a
}, spine.RotateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 2
    },
    setFrame: function(a, b, c) {
        a *= 2, this.frames[a] = b, this.frames[a + 1] = c
    },
    apply: function(a, b, c, d, e) {
        var f = this.frames;
        if (!(c < f[0])) {
            var g = a.bones[this.boneIndex];
            if (c >= f[f.length - 2]) {
                for (var h = g.data.rotation + f[f.length - 1] - g.rotation; h > 180;) h -= 360;
                for (; h < -180;) h += 360;
                return void(g.rotation += h * e)
            }
            var i = spine.Animation.binarySearch(f, c, 2),
                j = f[i - 1],
                k = f[i],
                l = 1 - (c - k) / (f[i - 2] - k);
            l = this.curves.getCurvePercent(i / 2 - 1, l);
            for (var h = f[i + 1] - j; h > 180;) h -= 360;
            for (; h < -180;) h += 360;
            for (h = g.data.rotation + (j + h * l) - g.rotation; h > 180;) h -= 360;
            for (; h < -180;) h += 360;
            g.rotation += h * e
        }
    }
}, spine.TranslateTimeline = function(a) {
    this.curves = new spine.Curves(a), this.frames = new spine.Float32Array(3 * a), this.frames.length = 3 * a
}, spine.TranslateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 3
    },
    setFrame: function(a, b, c, d) {
        a *= 3, this.frames[a] = b, this.frames[a + 1] = c, this.frames[a + 2] = d
    },
    apply: function(a, b, c, d, e) {
        var f = this.frames;
        if (!(c < f[0])) {
            var g = a.bones[this.boneIndex];
            if (c >= f[f.length - 3]) return g.x += (g.data.x + f[f.length - 2] - g.x) * e, void(g.y += (g.data.y + f[f.length - 1] - g.y) * e);
            var h = spine.Animation.binarySearch(f, c, 3),
                i = f[h - 2],
                j = f[h - 1],
                k = f[h],
                l = 1 - (c - k) / (f[h + -3] - k);
            l = this.curves.getCurvePercent(h / 3 - 1, l), g.x += (g.data.x + i + (f[h + 1] - i) * l - g.x) * e, g.y += (g.data.y + j + (f[h + 2] - j) * l - g.y) * e
        }
    }
}, spine.ScaleTimeline = function(a) {
    this.curves = new spine.Curves(a), this.frames = new spine.Float32Array(3 * a), this.frames.length = 3 * a
}, spine.ScaleTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 3
    },
    setFrame: function(a, b, c, d) {
        a *= 3, this.frames[a] = b, this.frames[a + 1] = c, this.frames[a + 2] = d
    },
    apply: function(a, b, c, d, e) {
        var f = this.frames;
        if (!(c < f[0])) {
            var g = a.bones[this.boneIndex];
            if (c >= f[f.length - 3]) return g.scaleX += (g.data.scaleX * f[f.length - 2] - g.scaleX) * e, void(g.scaleY += (g.data.scaleY * f[f.length - 1] - g.scaleY) * e);
            var h = spine.Animation.binarySearch(f, c, 3),
                i = f[h - 2],
                j = f[h - 1],
                k = f[h],
                l = 1 - (c - k) / (f[h + -3] - k);
            l = this.curves.getCurvePercent(h / 3 - 1, l), g.scaleX += (g.data.scaleX * (i + (f[h + 1] - i) * l) - g.scaleX) * e, g.scaleY += (g.data.scaleY * (j + (f[h + 2] - j) * l) - g.scaleY) * e
        }
    }
}, spine.ColorTimeline = function(a) {
    this.curves = new spine.Curves(a), this.frames = new spine.Float32Array(5 * a), this.frames.length = 5 * a
}, spine.ColorTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 5
    },
    setFrame: function(a, b, c, d, e, f) {
        a *= 5, this.frames[a] = b, this.frames[a + 1] = c, this.frames[a + 2] = d, this.frames[a + 3] = e, this.frames[a + 4] = f
    },
    apply: function(a, b, c, d, e) {
        var f = this.frames;
        if (!(c < f[0])) {
            var g, h, i, j;
            if (c >= f[f.length - 5]) {
                var k = f.length - 1;
                g = f[k - 3], h = f[k - 2], i = f[k - 1], j = f[k]
            } else {
                var l = spine.Animation.binarySearch(f, c, 5),
                    m = f[l - 4],
                    n = f[l - 3],
                    o = f[l - 2],
                    p = f[l - 1],
                    q = f[l],
                    r = 1 - (c - q) / (f[l - 5] - q);
                r = this.curves.getCurvePercent(l / 5 - 1, r), g = m + (f[l + 1] - m) * r, h = n + (f[l + 2] - n) * r, i = o + (f[l + 3] - o) * r, j = p + (f[l + 4] - p) * r
            }
            var s = a.slots[this.slotIndex];
            e < 1 ? (s.r += (g - s.r) * e, s.g += (h - s.g) * e, s.b += (i - s.b) * e, s.a += (j - s.a) * e) : (s.r = g, s.g = h, s.b = i, s.a = j)
        }
    }
}, spine.AttachmentTimeline = function(a) {
    this.curves = new spine.Curves(a), this.frames = new spine.Float32Array(a), this.frames.length = a, this.attachmentNames = [], this.attachmentNames.length = a
}, spine.AttachmentTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function() {
        return this.frames.length
    },
    setFrame: function(a, b, c) {
        this.frames[a] = b, this.attachmentNames[a] = c
    },
    apply: function(a, b, c, d, e) {
        var f = this.frames;
        if (c < f[0]) return void(b > c && this.apply(a, b, Number.MAX_VALUE, null, 0));
        b > c && (b = -1);
        var g = c >= f[f.length - 1] ? f.length - 1 : spine.Animation.binarySearch1(f, c) - 1;
        if (!(f[g] < b)) {
            var h = this.attachmentNames[g];
            a.slots[this.slotIndex].setAttachment(h ? a.getAttachmentBySlotIndex(this.slotIndex, h) : null)
        }
    }
}, spine.EventTimeline = function(a) {
    this.frames = new spine.Float32Array(a), this.frames.length = a, this.events = [], this.events.length = a
}, spine.EventTimeline.prototype = {
    getFrameCount: function() {
        return this.frames.length
    },
    setFrame: function(a, b) {
        this.frames[a] = b.time, this.events[a] = b
    },
    apply: function(a, b, c, d, e) {
        if (d) {
            var f = this.frames,
                g = f.length;
            if (b > c) this.apply(a, b, Number.MAX_VALUE, d, e), b = -1;
            else if (b >= f[g - 1]) return;
            if (!(c < f[0])) {
                var h;
                if (b < f[0]) h = 0;
                else {
                    h = spine.Animation.binarySearch1(f, b);
                    for (var i = f[h]; h > 0 && f[h - 1] == i;) h--
                }
                for (var j = this.events; h < g && c >= f[h]; h++) d[d.length] = j[h]
            }
        }
    }
}, spine.DrawOrderTimeline = function(a) {
    this.frames = new spine.Float32Array(a), this.frames.length = a, this.drawOrders = [], this.drawOrders.length = a
}, spine.DrawOrderTimeline.prototype = {
    getFrameCount: function() {
        return this.frames.length
    },
    setFrame: function(a, b, c) {
        this.frames[a] = b, this.drawOrders[a] = c
    },
    apply: function(a, b, c, d, e) {
        var f = this.frames;
        if (!(c < f[0])) {
            var g;
            g = c >= f[f.length - 1] ? f.length - 1 : spine.Animation.binarySearch1(f, c) - 1;
            var h = a.drawOrder,
                i = a.slots,
                j = this.drawOrders[g];
            if (j)
                for (var k = 0, l = j.length; k < l; k++) h[k] = a.slots[j[k]];
            else
                for (var k = 0, l = i.length; k < l; k++) h[k] = i[k]
        }
    }
}, spine.FfdTimeline = function(a) {
    this.curves = new spine.Curves(a), this.frames = new spine.Float32Array(a), this.frames.length = a, this.frameVertices = [], this.frameVertices.length = a
}, spine.FfdTimeline.prototype = {
    slotIndex: 0,
    attachment: 0,
    getFrameCount: function() {
        return this.frames.length
    },
    setFrame: function(a, b, c) {
        this.frames[a] = b, this.frameVertices[a] = c
    },
    apply: function(a, b, c, d, e) {
        var f = a.slots[this.slotIndex],
            g = f.attachment;
        if (g && (g == this.attachment || g.inheritFFD && g.parentMesh == this.attachment)) {
            var h = this.frames;
            if (!(c < h[0])) {
                var i = this.frameVertices,
                    j = i[0].length,
                    k = f.attachmentVertices;
                if (k.length != j && (f.attachmentVertices = k = new spine.Float32Array(j), e = 1), c >= h[h.length - 1]) {
                    var l = i[h.length - 1];
                    if (e < 1)
                        for (var m = 0; m < j; m++) k[m] += (l[m] - k[m]) * e;
                    else
                        for (var m = 0; m < j; m++) k[m] = l[m]
                } else {
                    var n = spine.Animation.binarySearch1(h, c),
                        o = h[n],
                        p = 1 - (c - o) / (h[n - 1] - o);
                    p = this.curves.getCurvePercent(n - 1, p < 0 ? 0 : p > 1 ? 1 : p);
                    var q = i[n - 1],
                        r = i[n];
                    if (e < 1)
                        for (var m = 0; m < j; m++) {
                            var s = q[m];
                            k[m] += (s + (r[m] - s) * p - k[m]) * e
                        } else
                            for (var m = 0; m < j; m++) {
                                var s = q[m];
                                k[m] = s + (r[m] - s) * p
                            }
                }
            }
        }
    }
}, spine.IkConstraintTimeline = function(a) {
    this.curves = new spine.Curves(a), this.frames = new spine.Float32Array(3 * a), this.frames.length = 3 * a
}, spine.IkConstraintTimeline.prototype = {
    ikConstraintIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 3
    },
    setFrame: function(a, b, c, d) {
        a *= 3, this.frames[a] = b, this.frames[a + 1] = c, this.frames[a + 2] = d
    },
    apply: function(a, b, c, d, e) {
        var f = this.frames;
        if (!(c < f[0])) {
            var g = a.ikConstraints[this.ikConstraintIndex];
            if (c >= f[f.length - 3]) return g.mix += (f[f.length - 2] - g.mix) * e, void(g.bendDirection = f[f.length - 1]);
            var h = spine.Animation.binarySearch(f, c, 3),
                i = f[h + -2],
                j = f[h],
                k = 1 - (c - j) / (f[h + -3] - j);
            k = this.curves.getCurvePercent(h / 3 - 1, k);
            var l = i + (f[h + 1] - i) * k;
            g.mix += (l - g.mix) * e, g.bendDirection = f[h + -1]
        }
    }
}, spine.SkeletonData = function() {
    this.bones = [], this.slots = [], this.skins = [], this.events = [], this.animations = [], this.ikConstraints = [], this.transformConstraints = []
}, spine.SkeletonData.prototype = {
    name: null,
    defaultSkin: null,
    width: 0,
    height: 0,
    version: null,
    hash: null,
    findBone: function(a) {
        for (var b = this.bones, c = 0, d = b.length; c < d; c++)
            if (b[c].name == a) return b[c];
        return null
    },
    findBoneIndex: function(a) {
        for (var b = this.bones, c = 0, d = b.length; c < d; c++)
            if (b[c].name == a) return c;
        return -1
    },
    findSlot: function(a) {
        for (var b = this.slots, c = 0, d = b.length; c < d; c++)
            if (b[c].name == a) return slot[c];
        return null
    },
    findSlotIndex: function(a) {
        for (var b = this.slots, c = 0, d = b.length; c < d; c++)
            if (b[c].name == a) return c;
        return -1
    },
    findSkin: function(a) {
        for (var b = this.skins, c = 0, d = b.length; c < d; c++)
            if (b[c].name == a) return b[c];
        return null
    },
    findEvent: function(a) {
        for (var b = this.events, c = 0, d = b.length; c < d; c++)
            if (b[c].name == a) return b[c];
        return null
    },
    findAnimation: function(a) {
        for (var b = this.animations, c = 0, d = b.length; c < d; c++)
            if (b[c].name == a) return b[c];
        return null
    },
    findIkConstraint: function(a) {
        for (var b = this.ikConstraints, c = 0, d = b.length; c < d; c++)
            if (b[c].name == a) return b[c];
        return null
    },
    findTransformConstraints: function(a) {
        for (var b = this.transformConstraints, c = 0, d = b.length; c < d; c++)
            if (b[c].name == a) return b[c];
        return null
    }
}, spine.Skeleton = function(a) {
    this.data = a, this.bones = [];
    for (var b = 0, c = a.bones.length; b < c; b++) {
        var d = a.bones[b],
            e = d.parent ? this.bones[a.bones.indexOf(d.parent)] : null;
        this.bones[b] = new spine.Bone(d, this, e)
    }
    this.slots = [], this.drawOrder = [];
    for (var b = 0, c = a.slots.length; b < c; b++) {
        var f = a.slots[b],
            g = this.bones[a.bones.indexOf(f.boneData)],
            h = new spine.Slot(f, g);
        this.slots[b] = h, this.drawOrder[b] = h
    }
    this.ikConstraints = [];
    for (var b = 0, c = a.ikConstraints.length; b < c; b++) this.ikConstraints[b] = new spine.IkConstraint(a.ikConstraints[b], this);
    this.transformConstraints = [];
    for (var b = 0, c = a.transformConstraints.length; b < c; b++) this.transformConstraints[b] = new spine.TransformConstraint(a.transformConstraints[b], this);
    this.cache = [], this.updateCache()
}, spine.Skeleton.prototype = {
    x: 0,
    y: 0,
    skin: null,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    time: 0,
    flipX: !1,
    flipY: !1,
    updateCache: function() {
        var a = this.bones,
            b = this.cache,
            c = this.ikConstraints,
            d = this.transformConstraints,
            e = c.length,
            f = d.length;
        b.length = 0;
        for (var g = 0, h = a.length; g < h; g++) {
            var i = a[g];
            b[b.length] = i;
            for (var j = 0; j < e; j++) {
                var k = c[j];
                if (i == k.bones[k.bones.length - 1]) {
                    b[b.length] = k;
                    break
                }
            }
        }
        for (var g = 0; g < f; g++)
            for (var l = d[g], j = b.length - 1; j >= 0; j--) {
                var m = b[j];
                if (m == l.bone || m == l.target) {
                    b.splice(j + 1, 0, l);
                    break
                }
            }
    },
    updateWorldTransform: function() {
        for (var a = this.cache, b = 0, c = a.length; b < c; b++) a[b].update()
    },
    setToSetupPose: function() {
        this.setBonesToSetupPose(), this.setSlotsToSetupPose()
    },
    setBonesToSetupPose: function() {
        for (var a = this.bones, b = 0, c = a.length; b < c; b++) a[b].setToSetupPose();
        for (var d = this.ikConstraints, b = 0, c = d.length; b < c; b++) {
            var e = d[b];
            e.bendDirection = e.data.bendDirection, e.mix = e.data.mix
        }
        for (var f = this.transformConstraints, b = 0, c = f.length; b < c; b++) {
            var e = f[b];
            e.translateMix = e.data.translateMix, e.x = e.data.x, e.y = e.data.y
        }
    },
    setSlotsToSetupPose: function() {
        for (var a = this.slots, b = this.drawOrder, c = 0, d = a.length; c < d; c++) b[c] = a[c], a[c].setToSetupPose(c)
    },
    getRootBone: function() {
        return this.bones.length ? this.bones[0] : null
    },
    findBone: function(a) {
        for (var b = this.bones, c = 0, d = b.length; c < d; c++)
            if (b[c].data.name == a) return b[c];
        return null
    },
    findBoneIndex: function(a) {
        for (var b = this.bones, c = 0, d = b.length; c < d; c++)
            if (b[c].data.name == a) return c;
        return -1
    },
    findSlot: function(a) {
        for (var b = this.slots, c = 0, d = b.length; c < d; c++)
            if (b[c].data.name == a) return b[c];
        return null
    },
    findSlotIndex: function(a) {
        for (var b = this.slots, c = 0, d = b.length; c < d; c++)
            if (b[c].data.name == a) return c;
        return -1
    },
    setSkinByName: function(a) {
        var b = this.data.findSkin(a);
        if (!b) throw "Skin not found: " + a;
        this.setSkin(b)
    },
    setSkin: function(a) {
        if (a)
            if (this.skin) a._attachAll(this, this.skin);
            else
                for (var b = this.slots, c = 0, d = b.length; c < d; c++) {
                    var e = b[c],
                        f = e.data.attachmentName;
                    if (f) {
                        var g = a.getAttachment(c, f);
                        g && e.setAttachment(g)
                    }
                }
            this.skin = a
    },
    getAttachmentBySlotName: function(a, b) {
        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(a), b)
    },
    getAttachmentBySlotIndex: function(a, b) {
        if (this.skin) {
            var c = this.skin.getAttachment(a, b);
            if (c) return c
        }
        return this.data.defaultSkin ? this.data.defaultSkin.getAttachment(a, b) : null
    },
    setAttachment: function(a, b) {
        for (var c = this.slots, d = 0, e = c.length; d < e; d++) {
            var f = c[d];
            if (f.data.name == a) {
                var g = null;
                if (b && (g = this.getAttachmentBySlotIndex(d, b), !g)) throw "Attachment not found: " + b + ", for slot: " + a;
                return void f.setAttachment(g)
            }
        }
        throw "Slot not found: " + a
    },
    findIkConstraint: function(a) {
        for (var b = this.ikConstraints, c = 0, d = b.length; c < d; c++)
            if (b[c].data.name == a) return b[c];
        return null
    },
    findTransformConstraint: function(a) {
        for (var b = this.transformConstraints, c = 0, d = b.length; c < d; c++)
            if (b[c].data.name == a) return b[c];
        return null
    },
    update: function(a) {
        this.time += a
    }
}, spine.EventData = function(a) {
    this.name = a
}, spine.EventData.prototype = {
    intValue: 0,
    floatValue: 0,
    stringValue: null
}, spine.Event = function(a, b) {
    this.time = a, this.data = b
}, spine.Event.prototype = {
    intValue: 0,
    floatValue: 0,
    stringValue: null
}, spine.AttachmentType = {
    region: 0,
    boundingbox: 1,
    mesh: 2,
    weightedmesh: 3,
    linkedmesh: 4,
    weightedlinkedmesh: 5
}, spine.RegionAttachment = function(a) {
    this.name = a, this.offset = new spine.Float32Array(8), this.offset.length = 8, this.uvs = new spine.Float32Array(8), this.uvs.length = 8
}, spine.RegionAttachment.prototype = {
    type: spine.AttachmentType.region,
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    width: 0,
    height: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    rendererObject: null,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    setUVs: function(a, b, c, d, e) {
        var f = this.uvs;
        e ? (f[2] = a, f[3] = d, f[4] = a, f[5] = b, f[6] = c, f[7] = b, f[0] = c, f[1] = d) : (f[0] = a, f[1] = d, f[2] = a, f[3] = b, f[4] = c, f[5] = b, f[6] = c, f[7] = d)
    },
    updateOffset: function() {
        var a = this.width / this.regionOriginalWidth * this.scaleX,
            b = this.height / this.regionOriginalHeight * this.scaleY,
            c = -this.width / 2 * this.scaleX + this.regionOffsetX * a,
            d = -this.height / 2 * this.scaleY + this.regionOffsetY * b,
            e = c + this.regionWidth * a,
            f = d + this.regionHeight * b,
            g = this.rotation * spine.degRad,
            h = Math.cos(g),
            i = Math.sin(g),
            j = c * h + this.x,
            k = c * i,
            l = d * h + this.y,
            m = d * i,
            n = e * h + this.x,
            o = e * i,
            p = f * h + this.y,
            q = f * i,
            r = this.offset;
        r[0] = j - m, r[1] = l + k, r[2] = j - q, r[3] = p + k, r[4] = n - q, r[5] = p + o, r[6] = n - m, r[7] = l + o
    },
    computeVertices: function(a, b, c, d) {
        a += c.worldX, b += c.worldY;
        var e = c.a,
            f = c.b,
            g = c.c,
            h = c.d,
            i = this.offset;
        d[0] = i[0] * e + i[1] * f + a, d[1] = i[0] * g + i[1] * h + b, d[2] = i[2] * e + i[3] * f + a, d[3] = i[2] * g + i[3] * h + b, d[4] = i[4] * e + i[5] * f + a, d[5] = i[4] * g + i[5] * h + b, d[6] = i[6] * e + i[7] * f + a, d[7] = i[6] * g + i[7] * h + b
    }
}, spine.MeshAttachment = function(a) {
    this.name = a
}, spine.MeshAttachment.prototype = {
    type: spine.AttachmentType.mesh,
    vertices: null,
    uvs: null,
    regionUVs: null,
    triangles: null,
    hullLength: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    inheritFFD: !0,
    parentMesh: null,
    rendererObject: null,
    regionU: 0,
    regionV: 0,
    regionU2: 0,
    regionV2: 0,
    regionRotate: !1,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    edges: null,
    width: 0,
    height: 0,
    updateUVs: function() {
        var a = this.regionU2 - this.regionU,
            b = this.regionV2 - this.regionV,
            c = this.regionUVs.length;
        if (this.uvs && this.uvs.length == c || (this.uvs = new spine.Float32Array(c)), this.regionRotate)
            for (var d = 0; d < c; d += 2) this.uvs[d] = this.regionU + this.regionUVs[d + 1] * a, this.uvs[d + 1] = this.regionV + b - this.regionUVs[d] * b;
        else
            for (var d = 0; d < c; d += 2) this.uvs[d] = this.regionU + this.regionUVs[d] * a, this.uvs[d + 1] = this.regionV + this.regionUVs[d + 1] * b
    },
    computeWorldVertices: function(a, b, c, d) {
        var e = c.bone;
        a += e.worldX, b += e.worldY;
        var f = e.a,
            g = e.b,
            h = e.c,
            i = e.d,
            j = this.vertices,
            k = j.length;
        c.attachmentVertices.length == k && (j = c.attachmentVertices);
        for (var l = 0; l < k; l += 2) {
            var m = j[l],
                n = j[l + 1];
            d[l] = m * f + n * g + a, d[l + 1] = m * h + n * i + b
        }
    },
    setParentMesh: function(a) {
        this.parentMesh = a, a && (this.vertices = a.vertices, this.regionUVs = a.regionUVs, this.triangles = a.triangles, this.hullLength = a.hullLength, this.edges = a.edges, this.width = a.width, this.height = a.height)
    }
}, spine.WeightedMeshAttachment = function(a) {
    this.name = a
}, spine.WeightedMeshAttachment.prototype = {
    type: spine.AttachmentType.weightedmesh,
    bones: null,
    weights: null,
    uvs: null,
    regionUVs: null,
    triangles: null,
    hullLength: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    inheritFFD: !0,
    parentMesh: null,
    rendererObject: null,
    regionU: 0,
    regionV: 0,
    regionU2: 0,
    regionV2: 0,
    regionRotate: !1,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    edges: null,
    width: 0,
    height: 0,
    updateUVs: function(a, b, c, d, e) {
        var f = this.regionU2 - this.regionU,
            g = this.regionV2 - this.regionV,
            h = this.regionUVs.length;
        if (this.uvs && this.uvs.length == h || (this.uvs = new spine.Float32Array(h)), this.regionRotate)
            for (var i = 0; i < h; i += 2) this.uvs[i] = this.regionU + this.regionUVs[i + 1] * f, this.uvs[i + 1] = this.regionV + g - this.regionUVs[i] * g;
        else
            for (var i = 0; i < h; i += 2) this.uvs[i] = this.regionU + this.regionUVs[i] * f, this.uvs[i + 1] = this.regionV + this.regionUVs[i + 1] * g
    },
    computeWorldVertices: function(a, b, c, d) {
        var e, f, g, h, i, j, k, l = c.bone.skeleton.bones,
            m = this.weights,
            n = this.bones,
            o = 0,
            p = 0,
            q = 0,
            r = 0,
            s = n.length;
        if (c.attachmentVertices.length)
            for (var t = c.attachmentVertices; p < s; o += 2) {
                for (f = 0, g = 0, e = n[p++] + p; p < e; p++, q += 3, r += 2) h = l[n[p]], i = m[q] + t[r], j = m[q + 1] + t[r + 1], k = m[q + 2], f += (i * h.a + j * h.b + h.worldX) * k, g += (i * h.c + j * h.d + h.worldY) * k;
                d[o] = f + a, d[o + 1] = g + b
            } else
                for (; p < s; o += 2) {
                    for (f = 0, g = 0, e = n[p++] + p; p < e; p++, q += 3) h = l[n[p]], i = m[q], j = m[q + 1], k = m[q + 2], f += (i * h.a + j * h.b + h.worldX) * k, g += (i * h.c + j * h.d + h.worldY) * k;
                    d[o] = f + a, d[o + 1] = g + b
                }
    },
    setParentMesh: function(a) {
        this.parentMesh = a, a && (this.bones = a.bones, this.weights = a.weights, this.regionUVs = a.regionUVs, this.triangles = a.triangles, this.hullLength = a.hullLength, this.edges = a.edges, this.width = a.width, this.height = a.height)
    }
}, spine.BoundingBoxAttachment = function(a) {
    this.name = a, this.vertices = new spine.Float32Array
}, spine.BoundingBoxAttachment.prototype = {
    type: spine.AttachmentType.boundingbox,
    computeWorldVertices: function(a, b, c, d) {
        a += c.worldX, b += c.worldY;
        for (var e = c.a, f = c.b, g = c.c, h = c.d, i = this.vertices, j = 0, k = i.length; j < k; j += 2) {
            var l = i[j],
                m = i[j + 1];
            d[j] = l * e + m * f + a, d[j + 1] = l * g + m * h + b
        }
    }
}, spine.AnimationStateData = function(a) {
    this.skeletonData = a, this.animationToMixTime = {}
}, spine.AnimationStateData.prototype = {
    defaultMix: 0,
    setMixByName: function(a, b, c) {
        var d = this.skeletonData.findAnimation(a);
        if (!d) throw "Animation not found: " + a;
        var e = this.skeletonData.findAnimation(b);
        if (!e) throw "Animation not found: " + b;
        this.setMix(d, e, c)
    },
    setMix: function(a, b, c) {
        this.animationToMixTime[a.name + ":" + b.name] = c
    },
    getMix: function(a, b) {
        var c = a.name + ":" + b.name;
        return this.animationToMixTime.hasOwnProperty(c) ? this.animationToMixTime[c] : this.defaultMix
    }
}, spine.TrackEntry = function() {}, spine.TrackEntry.prototype = {
    next: null,
    previous: null,
    animation: null,
    loop: !1,
    delay: 0,
    time: 0,
    lastTime: -1,
    endTime: 0,
    timeScale: 1,
    mixTime: 0,
    mixDuration: 0,
    mix: 1,
    onStart: null,
    onEnd: null,
    onComplete: null,
    onEvent: null
}, spine.AnimationState = function(a) {
    this.data = a, this.tracks = [], this.events = []
}, spine.AnimationState.prototype = {
    onStart: null,
    onEnd: null,
    onComplete: null,
    onEvent: null,
    timeScale: 1,
    update: function(a) {
        a *= this.timeScale;
        for (var b = 0; b < this.tracks.length; b++) {
            var c = this.tracks[b];
            if (c) {
                if (c.time += a * c.timeScale, c.previous) {
                    var d = a * c.previous.timeScale;
                    c.previous.time += d, c.mixTime += d
                }
                var e = c.next;
                e ? (e.time = c.lastTime - e.delay, e.time >= 0 && this.setCurrent(b, e)) : !c.loop && c.lastTime >= c.endTime && this.clearTrack(b)
            }
        }
    },
    apply: function(a) {
        for (var b = 0; b < this.tracks.length; b++) {
            var c = this.tracks[b];
            if (c) {
                this.events.length = 0;
                var d = c.time,
                    e = c.lastTime,
                    f = c.endTime,
                    g = c.loop;
                !g && d > f && (d = f);
                var h = c.previous;
                if (h) {
                    var i = h.time;
                    !h.loop && i > h.endTime && (i = h.endTime), h.animation.apply(a, i, i, h.loop, null);
                    var j = c.mixTime / c.mixDuration * c.mix;
                    j >= 1 && (j = 1, c.previous = null), c.animation.mix(a, c.lastTime, d, g, this.events, j)
                } else 1 == c.mix ? c.animation.apply(a, c.lastTime, d, g, this.events) : c.animation.mix(a, c.lastTime, d, g, this.events, c.mix);
                for (var k = 0, l = this.events.length; k < l; k++) {
                    var m = this.events[k];
                    c.onEvent && c.onEvent(b, m), this.onEvent && this.onEvent(b, m)
                }
                if (g ? e % f > d % f : e < f && d >= f) {
                    var n = Math.floor(d / f);
                    c.onComplete && c.onComplete(b, n), this.onComplete && this.onComplete(b, n)
                }
                c.lastTime = c.time
            }
        }
    },
    clearTracks: function() {
        for (var a = 0, b = this.tracks.length; a < b; a++) this.clearTrack(a);
        this.tracks.length = 0
    },
    clearTrack: function(a) {
        if (!(a >= this.tracks.length)) {
            var b = this.tracks[a];
            b && (b.onEnd && b.onEnd(a), this.onEnd && this.onEnd(a), this.tracks[a] = null)
        }
    },
    _expandToIndex: function(a) {
        if (a < this.tracks.length) return this.tracks[a];
        for (; a >= this.tracks.length;) this.tracks[this.tracks.length] = null;
        return null
    },
    setCurrent: function(a, b) {
        var c = this._expandToIndex(a);
        if (c) {
            var d = c.previous;
            c.previous = null, c.onEnd && c.onEnd(a), this.onEnd && this.onEnd(a), b.mixDuration = this.data.getMix(c.animation, b.animation), b.mixDuration > 0 && (b.mixTime = 0, d && c.mixTime / c.mixDuration < .5 ? b.previous = d : b.previous = c)
        }
        this.tracks[a] = b, b.onStart && b.onStart(a), this.onStart && this.onStart(a)
    },
    setAnimationByName: function(a, b, c) {
        var d = this.data.skeletonData.findAnimation(b);
        if (!d) throw "Animation not found: " + b;
        return this.setAnimation(a, d, c)
    },
    setAnimation: function(a, b, c) {
        var d = new spine.TrackEntry;
        return d.animation = b, d.loop = c, d.endTime = b.duration, this.setCurrent(a, d), d
    },
    addAnimationByName: function(a, b, c, d) {
        var e = this.data.skeletonData.findAnimation(b);
        if (!e) throw "Animation not found: " + b;
        return this.addAnimation(a, e, c, d)
    },
    addAnimation: function(a, b, c, d) {
        var e = new spine.TrackEntry;
        e.animation = b, e.loop = c, e.endTime = b.duration;
        var f = this._expandToIndex(a);
        if (f) {
            for (; f.next;) f = f.next;
            f.next = e
        } else this.tracks[a] = e;
        return d <= 0 && (f ? d += f.endTime - this.data.getMix(f.animation, b) : d = 0), e.delay = d, e
    },
    getCurrent: function(a) {
        return a >= this.tracks.length ? null : this.tracks[a];
    }
}, spine.SkeletonJson = function(a) {
    this.attachmentLoader = a, this.linkedMeshes = []
}, spine.SkeletonJson.prototype = {
    scale: 1,
    readSkeletonData: function(a, b) {
        var c = new spine.SkeletonData;
        c.name = b;
        var d = a.skeleton;
        d && (c.hash = d.hash, c.version = d.spine, c.width = d.width || 0, c.height = d.height || 0);
        for (var e = a.bones, f = 0, g = e.length; f < g; f++) {
            var h = e[f],
                i = null;
            if (h.parent && (i = c.findBone(h.parent), !i)) throw "Parent bone not found: " + h.parent;
            var j = new spine.BoneData(h.name, i);
            j.length = (h.length || 0) * this.scale, j.x = (h.x || 0) * this.scale, j.y = (h.y || 0) * this.scale, j.rotation = h.rotation || 0, j.scaleX = h.hasOwnProperty("scaleX") ? h.scaleX : 1, j.scaleY = h.hasOwnProperty("scaleY") ? h.scaleY : 1, j.inheritScale = !h.hasOwnProperty("inheritScale") || h.inheritScale, j.inheritRotation = !h.hasOwnProperty("inheritRotation") || h.inheritRotation, c.bones[f] = j
        }
        var k = a.ik;
        if (k)
            for (var f = 0, g = k.length; f < g; f++) {
                for (var l = k[f], m = new spine.IkConstraintData(l.name), e = l.bones, n = 0, o = e.length; n < o; n++) {
                    var p = c.findBone(e[n]);
                    if (!p) throw "IK bone not found: " + e[n];
                    m.bones[n] = p
                }
                if (m.target = c.findBone(l.target), !m.target) throw "Target bone not found: " + l.target;
                m.bendDirection = !l.hasOwnProperty("bendPositive") || l.bendPositive ? 1 : -1, m.mix = l.hasOwnProperty("mix") ? l.mix : 1, c.ikConstraints[f] = m
            }
        var q = a.transform;
        if (q)
            for (var f = 0, g = q.length; f < g; f++) {
                var r = q[f],
                    s = new spine.TransformConstraintData(r.name);
                if (s.bone = c.findBone(r.bone), !s.bone) throw "Bone not found: " + r.bone;
                if (s.target = c.findBone(r.target), !s.target) throw "Target bone not found: " + r.target;
                s.mix = r.hasOwnProperty("translateMix") ? l.translateMix : 1, s.x = (r.x || 0) * this.scale, s.y = (r.y || 0) * this.scale, c.transformConstraints[f] = s
            }
        for (var t = a.slots, f = 0, g = t.length; f < g; f++) {
            var u = t[f],
                j = c.findBone(u.bone);
            if (!j) throw "Slot bone not found: " + u.bone;
            var v = new spine.SlotData(u.name, j),
                w = u.color;
            w && (v.r = this.toColor(w, 0), v.g = this.toColor(w, 1), v.b = this.toColor(w, 2), v.a = this.toColor(w, 3)), v.attachmentName = u.attachment, v.blendMode = spine.BlendMode[u.blend || "normal"], c.slots[f] = v
        }
        var x = a.skins;
        for (var y in x)
            if (x.hasOwnProperty(y)) {
                var z = x[y],
                    A = new spine.Skin(y);
                for (var B in z)
                    if (z.hasOwnProperty(B)) {
                        var C = c.findSlotIndex(B),
                            D = z[B];
                        for (var E in D)
                            if (D.hasOwnProperty(E)) {
                                var F = this.readAttachment(A, C, E, D[E]);
                                F && A.addAttachment(C, E, F)
                            }
                    }
                c.skins[c.skins.length] = A, "default" == A.name && (c.defaultSkin = A)
            }
        for (var f = 0, g = this.linkedMeshes.length; f < g; f++) {
            var G = this.linkedMeshes[f],
                A = G.skin ? c.findSkin(G.skin) : c.defaultSkin;
            if (!A) throw "Skin not found: " + G.skin;
            var i = A.getAttachment(G.slotIndex, G.parent);
            if (!i) throw "Parent mesh not found: " + G.parent;
            G.mesh.setParentMesh(i), G.mesh.updateUVs()
        }
        this.linkedMeshes.length = 0;
        var H = a.events;
        for (var I in H)
            if (H.hasOwnProperty(I)) {
                var J = H[I],
                    K = new spine.EventData(I);
                K.intValue = J["int"] || 0, K.floatValue = J["float"] || 0, K.stringValue = J.string || null, c.events[c.events.length] = K
            }
        var L = a.animations;
        for (var M in L) L.hasOwnProperty(M) && this.readAnimation(M, L[M], c);
        return c
    },
    readAttachment: function(a, b, c, d) {
        c = d.name || c;
        var e = d.type || "region";
        "skinnedmesh" == e && (e = "weightedmesh"), e = spine.AttachmentType[e];
        var f = d.path || c,
            g = this.scale;
        switch (e) {
            case spine.AttachmentType.region:
                var h = this.attachmentLoader.newRegionAttachment(a, c, f);
                if (!h) return null;
                h.path = f, h.x = (d.x || 0) * g, h.y = (d.y || 0) * g, h.scaleX = d.hasOwnProperty("scaleX") ? d.scaleX : 1, h.scaleY = d.hasOwnProperty("scaleY") ? d.scaleY : 1, h.rotation = d.rotation || 0, h.width = (d.width || 0) * g, h.height = (d.height || 0) * g;
                var i = d.color;
                return i && (h.r = this.toColor(i, 0), h.g = this.toColor(i, 1), h.b = this.toColor(i, 2), h.a = this.toColor(i, 3)), h.updateOffset(), h;
            case spine.AttachmentType.mesh:
            case spine.AttachmentType.linkedmesh:
                var j = this.attachmentLoader.newMeshAttachment(a, c, f);
                return j ? (j.path = f, i = d.color, i && (j.r = this.toColor(i, 0), j.g = this.toColor(i, 1), j.b = this.toColor(i, 2), j.a = this.toColor(i, 3)), j.width = (d.width || 0) * g, j.height = (d.height || 0) * g, d.parent ? (j.inheritFFD = !d.hasOwnProperty("ffd") || d.ffd, this.linkedMeshes[this.linkedMeshes.length] = {
                    mesh: j,
                    skin: d.skin,
                    slotIndex: b,
                    parent: d.parent
                }) : (j.vertices = this.getFloatArray(d, "vertices", g), j.triangles = this.getUint32Array(d, "triangles"), j.regionUVs = this.getFloatArray(d, "uvs", 1), j.updateUVs(), j.hullLength = 2 * (d.hull || 0), d.edges && (j.edges = this.getUint16Array(d, "edges"))), j) : null;
            case spine.AttachmentType.weightedmesh:
            case spine.AttachmentType.weightedlinkedmesh:
                var j = this.attachmentLoader.newWeightedMeshAttachment(a, c, f);
                if (!j) return null;
                if (j.path = f, i = d.color, i && (j.r = this.toColor(i, 0), j.g = this.toColor(i, 1), j.b = this.toColor(i, 2), j.a = this.toColor(i, 3)), j.width = (d.width || 0) * g, j.height = (d.height || 0) * g, d.parent) j.inheritFFD = !d.hasOwnProperty("ffd") || d.ffd, this.linkedMeshes[this.linkedMeshes.length] = {
                    mesh: j,
                    skin: d.skin,
                    slotIndex: b,
                    parent: d.parent
                };
                else {
                    for (var k = this.getFloatArray(d, "uvs", 1), l = this.getFloatArray(d, "vertices", 1), m = new spine.Float32Array(3 * k.length * 3), n = new spine.Uint32Array(3 * k.length), o = 0, p = 0, q = 0, r = l.length; o < r;) {
                        var s = 0 | l[o++];
                        n[p++] = s;
                        for (var t = o + 4 * s; o < t;) n[p++] = l[o], m[q++] = l[o + 1] * g, m[q++] = l[o + 2] * g, m[q++] = l[o + 3], o += 4
                    }
                    j.bones = n, j.weights = m, j.triangles = this.getUint32Array(d, "triangles"), j.regionUVs = k, j.updateUVs(), j.hullLength = 2 * (d.hull || 0), d.edges && (j.edges = this.getUint16Array(d, "edges"))
                }
                return j;
            case spine.AttachmentType.boundingbox:
                var u = this.attachmentLoader.newBoundingBoxAttachment(a, c),
                    l = d.vertices;
                u.vertices = new spine.Float32Array(l.length);
                for (var o = 0, r = l.length; o < r; o++) u.vertices[o] = l[o] * g;
                return u
        }
        throw "Unknown attachment type: " + e
    },
    readAnimation: function(a, b, c) {
        var d = [],
            e = 0,
            f = b.slots;
        for (var g in f)
            if (f.hasOwnProperty(g)) {
                var h = f[g],
                    i = c.findSlotIndex(g);
                for (var j in h)
                    if (h.hasOwnProperty(j)) {
                        var k = h[j];
                        if ("color" == j) {
                            var l = new spine.ColorTimeline(k.length);
                            l.slotIndex = i;
                            for (var m = 0, n = 0, o = k.length; n < o; n++) {
                                var p = k[n],
                                    q = p.color,
                                    r = this.toColor(q, 0),
                                    s = this.toColor(q, 1),
                                    t = this.toColor(q, 2),
                                    u = this.toColor(q, 3);
                                l.setFrame(m, p.time, r, s, t, u), this.readCurve(l, m, p), m++
                            }
                            d[d.length] = l, e = Math.max(e, l.frames[5 * l.getFrameCount() - 5])
                        } else {
                            if ("attachment" != j) throw "Invalid timeline type for a slot: " + j + " (" + g + ")";
                            var l = new spine.AttachmentTimeline(k.length);
                            l.slotIndex = i;
                            for (var m = 0, n = 0, o = k.length; n < o; n++) {
                                var p = k[n];
                                l.setFrame(m++, p.time, p.name)
                            }
                            d[d.length] = l, e = Math.max(e, l.frames[l.getFrameCount() - 1])
                        }
                    }
            }
        var v = b.bones;
        for (var w in v)
            if (v.hasOwnProperty(w)) {
                var x = c.findBoneIndex(w);
                if (x == -1) throw "Bone not found: " + w;
                var y = v[w];
                for (var j in y)
                    if (y.hasOwnProperty(j)) {
                        var k = y[j];
                        if ("rotate" == j) {
                            var l = new spine.RotateTimeline(k.length);
                            l.boneIndex = x;
                            for (var m = 0, n = 0, o = k.length; n < o; n++) {
                                var p = k[n];
                                l.setFrame(m, p.time, p.angle), this.readCurve(l, m, p), m++
                            }
                            d[d.length] = l, e = Math.max(e, l.frames[2 * l.getFrameCount() - 2])
                        } else {
                            if ("translate" != j && "scale" != j) throw "Invalid timeline type for a bone: " + j + " (" + w + ")";
                            var l, z = 1;
                            "scale" == j ? l = new spine.ScaleTimeline(k.length) : (l = new spine.TranslateTimeline(k.length), z = this.scale), l.boneIndex = x;
                            for (var m = 0, n = 0, o = k.length; n < o; n++) {
                                var p = k[n],
                                    A = (p.x || 0) * z,
                                    B = (p.y || 0) * z;
                                l.setFrame(m, p.time, A, B), this.readCurve(l, m, p), m++
                            }
                            d[d.length] = l, e = Math.max(e, l.frames[3 * l.getFrameCount() - 3])
                        }
                    }
            }
        var C = b.ik;
        for (var D in C)
            if (C.hasOwnProperty(D)) {
                var E = c.findIkConstraint(D),
                    k = C[D],
                    l = new spine.IkConstraintTimeline(k.length);
                l.ikConstraintIndex = c.ikConstraints.indexOf(E);
                for (var m = 0, n = 0, o = k.length; n < o; n++) {
                    var p = k[n],
                        F = p.hasOwnProperty("mix") ? p.mix : 1,
                        G = !p.hasOwnProperty("bendPositive") || p.bendPositive ? 1 : -1;
                    l.setFrame(m, p.time, F, G), this.readCurve(l, m, p), m++
                }
                d[d.length] = l, e = Math.max(e, l.frames[3 * l.getFrameCount() - 3])
            }
        var H = b.ffd;
        for (var I in H) {
            var J = c.findSkin(I),
                h = H[I];
            for (g in h) {
                var i = c.findSlotIndex(g),
                    K = h[g];
                for (var L in K) {
                    var k = K[L],
                        l = new spine.FfdTimeline(k.length),
                        M = J.getAttachment(i, L);
                    if (!M) throw "FFD attachment not found: " + L;
                    l.slotIndex = i, l.attachment = M;
                    var N, O = M.type == spine.AttachmentType.mesh;
                    N = O ? M.vertices.length : M.weights.length / 3 * 2;
                    for (var m = 0, n = 0, o = k.length; n < o; n++) {
                        var P, p = k[n];
                        if (p.vertices) {
                            var Q = p.vertices,
                                P = new spine.Float32Array(N);
                            P.length = N;
                            var R = p.offset || 0,
                                S = Q.length;
                            if (1 == this.scale)
                                for (var T = 0; T < S; T++) P[T + R] = Q[T];
                            else
                                for (var T = 0; T < S; T++) P[T + R] = Q[T] * this.scale; if (O)
                                for (var U = M.vertices, T = 0, S = P.length; T < S; T++) P[T] += U[T]
                        } else O ? P = M.vertices : (P = new spine.Float32Array(N), P.length = N);
                        l.setFrame(m, p.time, P), this.readCurve(l, m, p), m++
                    }
                    d[d.length] = l, e = Math.max(e, l.frames[l.getFrameCount() - 1])
                }
            }
        }
        var V = b.drawOrder;
        if (V || (V = b.draworder), V) {
            for (var l = new spine.DrawOrderTimeline(V.length), W = c.slots.length, m = 0, n = 0, o = V.length; n < o; n++) {
                var X = V[n],
                    Y = null;
                if (X.offsets) {
                    Y = new spine.Uint32Array(W), Y.length = W;
                    for (var T = W - 1; T >= 0; T--) Y[T] = 4294967295;
                    var Z = X.offsets,
                        $ = new spine.Uint32Array(W - Z.length);
                    $.length = W - Z.length;
                    for (var _ = 0, aa = 0, T = 0, S = Z.length; T < S; T++) {
                        var ba = Z[T],
                            i = c.findSlotIndex(ba.slot);
                        if (i == -1) throw "Slot not found: " + ba.slot;
                        for (; _ != i;) $[aa++] = _++;
                        Y[_ + ba.offset] = _++
                    }
                    for (; _ < W;) $[aa++] = _++;
                    for (var T = W - 1; T >= 0; T--) 4294967295 == Y[T] && (Y[T] = $[--aa])
                }
                l.setFrame(m++, X.time, Y)
            }
            d[d.length] = l, e = Math.max(e, l.frames[l.getFrameCount() - 1])
        }
        var ca = b.events;
        if (ca) {
            for (var l = new spine.EventTimeline(ca.length), m = 0, n = 0, o = ca.length; n < o; n++) {
                var da = ca[n],
                    ea = c.findEvent(da.name);
                if (!ea) throw "Event not found: " + da.name;
                var fa = new spine.Event(da.time, ea);
                fa.intValue = da.hasOwnProperty("int") ? da["int"] : ea.intValue, fa.floatValue = da.hasOwnProperty("float") ? da["float"] : ea.floatValue, fa.stringValue = da.hasOwnProperty("string") ? da.string : ea.stringValue, l.setFrame(m++, fa)
            }
            d[d.length] = l, e = Math.max(e, l.frames[l.getFrameCount() - 1])
        }
        c.animations[c.animations.length] = new spine.Animation(a, d, e)
    },
    readCurve: function(a, b, c) {
        var d = c.curve;
        d ? "stepped" == d ? a.curves.setStepped(b) : d instanceof Array && a.curves.setCurve(b, d[0], d[1], d[2], d[3]) : a.curves.setLinear(b)
    },
    toColor: function(a, b) {
        if (8 != a.length) throw "Color hexidecimal length must be 8, recieved: " + a;
        return parseInt(a.substring(2 * b, 2 * b + 2), 16) / 255
    },
    getFloatArray: function(a, b, c) {
        var d = a[b],
            e = new spine.Float32Array(d.length),
            f = 0,
            g = d.length;
        if (1 == c)
            for (; f < g; f++) e[f] = d[f];
        else
            for (; f < g; f++) e[f] = d[f] * c;
        return e
    },
    getUint32Array: function(a, b) {
        for (var c = a[b], d = new spine.Uint32Array(c.length), e = 0, f = c.length; e < f; e++) d[e] = 0 | c[e];
        return d
    },
    getUint16Array: function(a, b) {
        for (var c = a[b], d = new spine.Uint16Array(c.length), e = 0, f = c.length; e < f; e++) d[e] = 0 | c[e];
        return d
    }
}, spine.Atlas = function(a, b) {
    this.textureLoader = b, this.pages = [], this.regions = [];
    var c = new spine.AtlasReader(a),
        d = [];
    d.length = 4;
    for (var e = null;;) {
        var f = c.readLine();
        if (null === f) break;
        if (f = c.trim(f), f.length)
            if (e) {
                var g = new spine.AtlasRegion;
                g.name = f, g.page = e, g.rotate = "true" == c.readValue(), c.readTuple(d);
                var h = parseInt(d[0]),
                    i = parseInt(d[1]);
                c.readTuple(d);
                var j = parseInt(d[0]),
                    k = parseInt(d[1]);
                g.u = h / e.width, g.v = i / e.height, g.rotate ? (g.u2 = (h + k) / e.width, g.v2 = (i + j) / e.height) : (g.u2 = (h + j) / e.width, g.v2 = (i + k) / e.height), g.x = h, g.y = i, g.width = Math.abs(j), g.height = Math.abs(k), 4 == c.readTuple(d) && (g.splits = [parseInt(d[0]), parseInt(d[1]), parseInt(d[2]), parseInt(d[3])], 4 == c.readTuple(d) && (g.pads = [parseInt(d[0]), parseInt(d[1]), parseInt(d[2]), parseInt(d[3])], c.readTuple(d))), g.originalWidth = parseInt(d[0]), g.originalHeight = parseInt(d[1]), c.readTuple(d), g.offsetX = parseInt(d[0]), g.offsetY = parseInt(d[1]), g.index = parseInt(c.readValue()), this.regions[this.regions.length] = g
            } else {
                e = new spine.AtlasPage, e.name = f, 2 == c.readTuple(d) && (e.width = parseInt(d[0]), e.height = parseInt(d[1]), c.readTuple(d)), e.format = spine.Atlas.Format[d[0]], c.readTuple(d), e.minFilter = spine.Atlas.TextureFilter[d[0]], e.magFilter = spine.Atlas.TextureFilter[d[1]];
                var l = c.readValue();
                e.uWrap = spine.Atlas.TextureWrap.clampToEdge, e.vWrap = spine.Atlas.TextureWrap.clampToEdge, "x" == l ? e.uWrap = spine.Atlas.TextureWrap.repeat : "y" == l ? e.vWrap = spine.Atlas.TextureWrap.repeat : "xy" == l && (e.uWrap = e.vWrap = spine.Atlas.TextureWrap.repeat), b.load(e, f, this), this.pages[this.pages.length] = e
            } else e = null
    }
}, spine.Atlas.prototype = {
    findRegion: function(a) {
        for (var b = this.regions, c = 0, d = b.length; c < d; c++)
            if (b[c].name == a) return b[c];
        return null
    },
    dispose: function() {
        for (var a = this.pages, b = 0, c = a.length; b < c; b++) this.textureLoader.unload(a[b].rendererObject)
    },
    updateUVs: function(a) {
        for (var b = this.regions, c = 0, d = b.length; c < d; c++) {
            var e = b[c];
            e.page == a && (e.u = e.x / a.width, e.v = e.y / a.height, e.rotate ? (e.u2 = (e.x + e.height) / a.width, e.v2 = (e.y + e.width) / a.height) : (e.u2 = (e.x + e.width) / a.width, e.v2 = (e.y + e.height) / a.height))
        }
    }
}, spine.Atlas.Format = {
    alpha: 0,
    intensity: 1,
    luminanceAlpha: 2,
    rgb565: 3,
    rgba4444: 4,
    rgb888: 5,
    rgba8888: 6
}, spine.Atlas.TextureFilter = {
    nearest: 0,
    linear: 1,
    mipMap: 2,
    mipMapNearestNearest: 3,
    mipMapLinearNearest: 4,
    mipMapNearestLinear: 5,
    mipMapLinearLinear: 6
}, spine.Atlas.TextureWrap = {
    mirroredRepeat: 0,
    clampToEdge: 1,
    repeat: 2
}, spine.AtlasPage = function() {}, spine.AtlasPage.prototype = {
    name: null,
    format: null,
    minFilter: null,
    magFilter: null,
    uWrap: null,
    vWrap: null,
    rendererObject: null,
    width: 0,
    height: 0
}, spine.AtlasRegion = function() {}, spine.AtlasRegion.prototype = {
    page: null,
    name: null,
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    u: 0,
    v: 0,
    u2: 0,
    v2: 0,
    offsetX: 0,
    offsetY: 0,
    originalWidth: 0,
    originalHeight: 0,
    index: 0,
    rotate: !1,
    splits: null,
    pads: null
}, spine.AtlasReader = function(a) {
    this.lines = a.split(/\r\n|\r|\n/)
}, spine.AtlasReader.prototype = {
    index: 0,
    trim: function(a) {
        return a.replace(/^\s+|\s+$/g, "")
    },
    readLine: function() {
        return this.index >= this.lines.length ? null : this.lines[this.index++]
    },
    readValue: function() {
        var a = this.readLine(),
            b = a.indexOf(":");
        if (b == -1) throw "Invalid line: " + a;
        return this.trim(a.substring(b + 1))
    },
    readTuple: function(a) {
        var b = this.readLine(),
            c = b.indexOf(":");
        if (c == -1) throw "Invalid line: " + b;
        for (var d = 0, e = c + 1; d < 3; d++) {
            var f = b.indexOf(",", e);
            if (f == -1) break;
            a[d] = this.trim(b.substr(e, f - e)), e = f + 1
        }
        return a[d] = this.trim(b.substring(e)), d + 1
    }
}, spine.AtlasAttachmentLoader = function(a) {
    this.atlas = a
}, spine.AtlasAttachmentLoader.prototype = {
    newRegionAttachment: function(a, b, c) {
        var d = this.atlas.findRegion(c);
        if (!d) throw "Region not found in atlas: " + c + " (region attachment: " + b + ")";
        var e = new spine.RegionAttachment(b);
        return e.rendererObject = d, e.setUVs(d.u, d.v, d.u2, d.v2, d.rotate), e.regionOffsetX = d.offsetX, e.regionOffsetY = d.offsetY, e.regionWidth = d.width, e.regionHeight = d.height, e.regionOriginalWidth = d.originalWidth, e.regionOriginalHeight = d.originalHeight, e
    },
    newMeshAttachment: function(a, b, c) {
        var d = this.atlas.findRegion(c);
        if (!d) throw "Region not found in atlas: " + c + " (mesh attachment: " + b + ")";
        var e = new spine.MeshAttachment(b);
        return e.rendererObject = d, e.regionU = d.u, e.regionV = d.v, e.regionU2 = d.u2, e.regionV2 = d.v2, e.regionRotate = d.rotate, e.regionOffsetX = d.offsetX, e.regionOffsetY = d.offsetY, e.regionWidth = d.width, e.regionHeight = d.height, e.regionOriginalWidth = d.originalWidth, e.regionOriginalHeight = d.originalHeight, e
    },
    newWeightedMeshAttachment: function(a, b, c) {
        var d = this.atlas.findRegion(c);
        if (!d) throw "Region not found in atlas: " + c + " (weighted mesh attachment: " + b + ")";
        var e = new spine.WeightedMeshAttachment(b);
        return e.rendererObject = d, e.regionU = d.u, e.regionV = d.v, e.regionU2 = d.u2, e.regionV2 = d.v2, e.regionRotate = d.rotate, e.regionOffsetX = d.offsetX, e.regionOffsetY = d.offsetY, e.regionWidth = d.width, e.regionHeight = d.height, e.regionOriginalWidth = d.originalWidth, e.regionOriginalHeight = d.originalHeight, e
    },
    newBoundingBoxAttachment: function(a, b) {
        return new spine.BoundingBoxAttachment(b)
    }
}, spine.SkeletonBounds = function() {
    this.polygonPool = [], this.polygons = [], this.boundingBoxes = []
}, spine.SkeletonBounds.prototype = {
    minX: 0,
    minY: 0,
    maxX: 0,
    maxY: 0,
    update: function(a, b) {
        var c = a.slots,
            d = c.length,
            e = a.x,
            f = a.y,
            g = this.boundingBoxes,
            h = this.polygonPool,
            i = this.polygons;
        g.length = 0;
        for (var j = 0, k = i.length; j < k; j++) h[h.length] = i[j];
        i.length = 0;
        for (var j = 0; j < d; j++) {
            var l = c[j],
                m = l.attachment;
            if (m.type == spine.AttachmentType.boundingbox) {
                g[g.length] = m;
                var n, o = h.length;
                o > 0 ? (n = h[o - 1], h.splice(o - 1, 1)) : n = new spine.Float32Array, i[i.length] = n, n.length = m.vertices.length, m.computeWorldVertices(e, f, l.bone, n)
            }
        }
        b && this.aabbCompute()
    },
    aabbCompute: function() {
        for (var a = this.polygons, b = Number.MAX_VALUE, c = Number.MAX_VALUE, d = -Number.MAX_VALUE, e = -Number.MAX_VALUE, f = 0, g = a.length; f < g; f++)
            for (var h = a[f], i = 0, j = h.length; i < j; i += 2) {
                var k = h[i],
                    l = h[i + 1];
                b = Math.min(b, k), c = Math.min(c, l), d = Math.max(d, k), e = Math.max(e, l)
            }
        this.minX = b, this.minY = c, this.maxX = d, this.maxY = e
    },
    aabbContainsPoint: function(a, b) {
        return a >= this.minX && a <= this.maxX && b >= this.minY && b <= this.maxY
    },
    aabbIntersectsSegment: function(a, b, c, d) {
        var e = this.minX,
            f = this.minY,
            g = this.maxX,
            h = this.maxY;
        if (a <= e && c <= e || b <= f && d <= f || a >= g && c >= g || b >= h && d >= h) return !1;
        var i = (d - b) / (c - a),
            j = i * (e - a) + b;
        if (j > f && j < h) return !0;
        if (j = i * (g - a) + b, j > f && j < h) return !0;
        var k = (f - b) / i + a;
        return k > e && k < g || (k = (h - b) / i + a, k > e && k < g)
    },
    aabbIntersectsSkeleton: function(a) {
        return this.minX < a.maxX && this.maxX > a.minX && this.minY < a.maxY && this.maxY > a.minY
    },
    containsPoint: function(a, b) {
        for (var c = this.polygons, d = 0, e = c.length; d < e; d++)
            if (this.polygonContainsPoint(c[d], a, b)) return this.boundingBoxes[d];
        return null
    },
    intersectsSegment: function(a, b, c, d) {
        for (var e = this.polygons, f = 0, g = e.length; f < g; f++)
            if (e[f].intersectsSegment(a, b, c, d)) return this.boundingBoxes[f];
        return null
    },
    polygonContainsPoint: function(a, b, c) {
        for (var d = a.length, e = d - 2, f = !1, g = 0; g < d; g += 2) {
            var h = a[g + 1],
                i = a[e + 1];
            if (h < c && i >= c || i < c && h >= c) {
                var j = a[g];
                j + (c - h) / (i - h) * (a[e] - j) < b && (f = !f)
            }
            e = g
        }
        return f
    },
    polygonIntersectsSegment: function(a, b, c, d, e) {
        for (var f = a.length, g = b - d, h = c - e, i = b * e - c * d, j = a[f - 2], k = a[f - 1], l = 0; l < f; l += 2) {
            var m = a[l],
                n = a[l + 1],
                o = j * n - k * m,
                p = j - m,
                q = k - n,
                r = g * q - h * p,
                s = (i * p - g * o) / r;
            if ((s >= j && s <= m || s >= m && s <= j) && (s >= b && s <= d || s >= d && s <= b)) {
                var t = (i * q - h * o) / r;
                if ((t >= k && t <= n || t >= n && t <= k) && (t >= c && t <= e || t >= e && t <= c)) return !0
            }
            j = m, k = n
        }
        return !1
    },
    getPolygon: function(a) {
        var b = this.boundingBoxes.indexOf(a);
        return b == -1 ? null : this.polygons[b]
    },
    getWidth: function() {
        return this.maxX - this.minX
    },
    getHeight: function() {
        return this.maxY - this.minY
    }
};
var __extends = this && this.__extends || function(a, b) {
        function c() {
            this.constructor = a
        }
        for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);
        a.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c)
    },
    PhaserSpine;
! function(a) {
    var b = function(b) {
        function c(a, c) {
            var d = b.call(this, a, c) || this;
            return d.addSpineCache(), d.addSpineFactory(), d.addSpineLoader(), d
        }
        return __extends(c, b), c.prototype.addSpineLoader = function() {
            Phaser.Loader.prototype.spine = function(a, b, c) {
                var d = this,
                    e = a + "Atlas",
                    f = {
                        atlas: e,
                        basePath: "" === b.substring(0, b.lastIndexOf("/")) ? "." : b.substring(0, b.lastIndexOf("/")),
                        variants: void 0
                    };
                void 0 === c ? c = [""] : f.variants = c, c.forEach(function(a) {
                    d.onFileComplete.add(function(b, c) {
                        c === e && new spine.Atlas(d.game.cache.getText(c), {
                            load: function(b, c, e) {
                                d.image(c, f.basePath + "/" + c.substr(0, c.lastIndexOf(".")) + a + ".png")
                            }
                        })
                    }), d.text(e, b.substr(0, b.lastIndexOf(".")) + a + ".atlas")
                }), this.json(a, b), this.game.cache.addSpine(a, f)
            }
        }, c.prototype.addSpineFactory = function() {
            Phaser.GameObjectFactory.prototype.spine = function(b, c, d, e, f) {
                void 0 === f && (f = this.world);
                var g = new a.Spine(this.game, d, e);
                return g.setToSetupPose(), g.position.x = b, g.position.y = c, f.add(g)
            }, Phaser.GameObjectCreator.prototype.spine = function(b, c, d, e, f) {
                return new a.Spine(this.game, d, e)
            }
        }, c.prototype.addSpineCache = function() {
            Phaser.Cache.prototype.spine = {}, Phaser.Cache.prototype.addSpine = function(a, b) {
                this.spine[a] = b
            }, Phaser.Cache.prototype.getSpine = function(a) {
                return !this.spine.hasOwnProperty(a), this.spine[a]
            }
        }, c
    }(Phaser.Plugin);
    b.RESOLUTION_REGEXP = /@(.+)x/, a.SpinePlugin = b
}(PhaserSpine || (PhaserSpine = {})), Phaser.Rope.prototype.postUpdate = function() {}, spine.Bone.yDown = !0;
var PhaserSpine;
! function(a) {
    var b = function(b) {
        function c(c, d, e) {
            var f = b.call(this, c) || this;
            f.imageScale = 1;
            var g = f.game.cache.getSpine(d);
            void 0 !== e && g.variants.indexOf(e) !== -1 ? f.imageScale = f.getScaleFromVariant(e) : g.variants && g.variants.length >= 1 && (f.imageScale = f.getScaleFromVariant(g.variants[0]));
            var h = new a.SpineTextureLoader(c),
                i = new spine.Atlas(c.cache.getText(g.atlas), h),
                j = new spine.AtlasAttachmentLoader(i),
                k = new spine.SkeletonJson(j);
            if (f.skeletonData = k.readSkeletonData(c.cache.getJSON(d)), !f.skeletonData) throw new Error("Spine data must be preloaded using Loader.spine");
            f.onEvent = new Phaser.Signal, f.onComplete = new Phaser.Signal, f.onEnd = new Phaser.Signal, f.skeleton = new spine.Skeleton(f.skeletonData), f.skeleton.updateWorldTransform(), f.stateData = new spine.AnimationStateData(f.skeletonData), f.state = new spine.AnimationState(f.stateData), f.state.onEvent = f.onEvent.dispatch.bind(f.onEvent), f.state.onComplete = f.onComplete.dispatch.bind(f.onComplete), f.state.onEnd = f.onEnd.dispatch.bind(f.onEnd), f.slotContainers = [];
            for (var l = 0, m = f.skeleton.slots.length; l < m; l++) {
                var n = f.skeleton.slots[l],
                    o = n.attachment,
                    p = new Phaser.Group(c);
                if (f.slotContainers.push(p), f.add(p), o instanceof spine.RegionAttachment) {
                    var q = o.rendererObject.name,
                        r = f.createSprite(n, o);
                    n.currentSprite = r, n.currentSpriteName = q, p.add(r)
                } else {
                    if (!(o instanceof spine.WeightedMeshAttachment)) continue;
                    var s = f.createMesh(n, o);
                    n.currentMesh = s, n.currentMeshName = o.name, p.add(s)
                }
            }
            return f.autoUpdate = !0, f
        }
        return __extends(c, b), Object.defineProperty(c.prototype, "autoUpdate", {
            get: function() {
                return this.updateTransform === a.Spine.prototype.autoUpdateTransform
            },
            set: function(b) {
                this.updateTransform = b ? a.Spine.prototype.autoUpdateTransform : PIXI.DisplayObjectContainer.prototype.updateTransform
            },
            enumerable: !0,
            configurable: !0
        }), c.prototype.getScaleFromVariant = function(b) {
            var c = a.SpinePlugin.RESOLUTION_REGEXP.exec(b);
            return c ? parseFloat(c[1]) : 1
        }, c.prototype.setTint = function(a) {
            this.globalTint = a;
            for (var b = this.skeleton.slots, c = 0; c < b.length; c++) {
                var d = b[c];
                d.currentSprite.tint = a
            }
        }, c.prototype.update = function(a) {
            if (void 0 !== a) {
                this.state.update(a), this.state.apply(this.skeleton), this.skeleton.updateWorldTransform();
                for (var b = this.skeleton.drawOrder, c = this.skeleton.slots, d = 0, e = b.length; d < e; d++) void 0 !== b[d].currentSprite && (this.children[d] = b[d].currentSprite.parent);
                for (var d = 0, e = c.length; d < e; d++) {
                    var f = c[d],
                        g = f.attachment,
                        h = this.slotContainers[d];
                    if (g) {
                        var i = g.type;
                        if (i === spine.AttachmentType.region) {
                            if (g.rendererObject && (!f.currentSpriteName || f.currentSpriteName !== g.name)) {
                                var j = g.rendererObject.name;
                                if (void 0 !== f.currentSprite && (f.currentSprite.visible = !1), f.sprites = f.sprites || {}, void 0 !== f.sprites[j]) f.sprites[j].visible = !0;
                                else {
                                    var k = this.createSprite(f, g);
                                    h.add(k)
                                }
                                f.currentSprite = f.sprites[j], f.currentSpriteName = j
                            }
                            var l = f.bone;
                            h.position.x = g.x * l.a + g.y * l.b + l.worldX, h.position.y = g.x * l.c + g.y * l.d + l.worldY, h.scale.x = l.getWorldScaleX(), h.scale.y = l.getWorldScaleY(), h.rotation = (l.getWorldRotationX() - g.rotation) * Math.PI / 180, l.getWorldScaleY() < 0 && (h.scale.y = -h.scale.y), l.getWorldScaleX() < 0 && (h.scale.x = -h.scale.x), (l.getWorldScaleY() < 0 || l.getWorldScaleX() < 0) && (h.rotation = -h.rotation), f.currentSprite.blendMode = f.blendMode, this.globalTint || (f.currentSprite.tint = f.currentSprite.tint = parseInt(Phaser.Color.componentToHex(255 * f.r).substring(0, 2) + Phaser.Color.componentToHex(255 * f.g).substring(0, 2) + Phaser.Color.componentToHex(255 * f.b).substring(0, 2), 16))
                        } else {
                            if (i !== spine.AttachmentType.weightedmesh && i !== spine.AttachmentType.weightedlinkedmesh) {
                                h.visible = !1;
                                continue
                            }
                            if (!f.currentMeshName || f.currentMeshName !== g.name) {
                                var m = g.name;
                                if (void 0 !== f.currentMesh && (f.currentMesh.visible = !1), f.meshes = f.meshes || {}, void 0 !== f.meshes[m]) f.meshes[m].visible = !0;
                                else {
                                    var n = this.createMesh(f, g);
                                    h.add(n)
                                }
                                f.currentMesh = f.meshes[m], f.currentMeshName = m
                            }
                            g.computeWorldVertices(f.bone.skeleton.x, f.bone.skeleton.y, f, f.currentMesh.vertices)
                        }
                        h.visible = !0, h.alpha = f.a
                    } else h.visible = !1
                }
            }
        }, c.prototype.destroy = function(a, c) {
            b.prototype.destroy.call(this, !0, c)
        }, c.prototype.autoUpdateTransform = function() {
            this.lastTime = this.lastTime || Date.now();
            var a = .001 * (Date.now() - this.lastTime);
            this.lastTime = Date.now(), this.update(a), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
        }, c.prototype.createSprite = function(a, b) {
            var c = b.rendererObject,
                d = c.page.rendererObject,
                e = new PIXI.Rectangle(c.x, c.y, c.rotate ? c.height : c.width, c.rotate ? c.width : c.height),
                f = new PIXI.Texture(d, e),
                g = new Phaser.Sprite(this.game, 0, 0, f),
                h = c.rotate ? .5 * Math.PI : 0;
            if (g.scale.x = c.width / c.originalWidth * b.scaleX / this.imageScale, g.scale.y = c.height / c.originalHeight * b.scaleY / this.imageScale, g.rotation = h, g.anchor.x = (.5 * c.originalWidth - c.offsetX) / c.width, g.anchor.y = 1 - (.5 * c.originalHeight - c.offsetY) / c.height, g.alpha = b.a, c.rotate) {
                var i = g.scale.x;
                g.scale.x = g.scale.y, g.scale.y = i
            }
            return a.sprites = a.sprites || {}, a.sprites[c.name] = g, g
        }, c.prototype.createMesh = function(a, b) {
            var c = b.rendererObject,
                d = c.page.rendererObject,
                e = new PIXI.Texture(d),
                f = new Phaser.Rope(this.game, 0, 0, e);
            return f.drawMode = 1, f.canvasPadding = 1.5, f.vertices = new spine.Float32Array(b.uvs.length), f.uvs = b.uvs, f.indices = b.triangles, f.alpha = b.a, a.meshes = a.meshes || {}, a.meshes[b.name] = f, f
        }, c.prototype.setMixByName = function(a, b, c) {
            this.stateData.setMixByName(a, b, c)
        }, c.prototype.setAnimationByName = function(a, b, c) {
            void 0 === c && (c = !1);
            var d = this.state.data.skeletonData.findAnimation(b);
            return d ? this.state.setAnimation(a, d, c) : null
        }, c.prototype.addAnimationByName = function(a, b, c, d) {
            void 0 === c && (c = !1), void 0 === d && (d = 0);
            var e = this.state.data.skeletonData.findAnimation(b);
            return e ? this.state.addAnimation(a, e, c, d) : null
        }, c.prototype.setSkinByName = function(a) {
            var b = this.skeleton.data.findSkin(a);
            b && this.skeleton.setSkin(b)
        }, c.prototype.setSkin = function(a) {
            this.skeleton.setSkin(a)
        }, c.prototype.setToSetupPose = function() {
            this.skeleton.setToSetupPose()
        }, c.prototype.createCombinedSkin = function(a) {
            for (var b = [], c = 1; c < arguments.length; c++) b[c - 1] = arguments[c];
            if (0 !== b.length) {
                for (var d = new spine.Skin(a), e = 0; e < b.length; e++) {
                    var f = b[e],
                        g = this.skeleton.data.findSkin(f);
                    if (!g) return;
                    for (var h in g.attachments) {
                        var i = h.split(":"),
                            j = i[0],
                            k = i[1],
                            l = g.attachments[h];
                        if (void 0 === j || void 0 === k) return;
                        void 0 === d.getAttachment(j, k) && d.addAttachment(j, k, l)
                    }
                }
                return this.skeleton.data.skins.push(d), d
            }
        }, c
    }(Phaser.Group);
    a.Spine = b
}(PhaserSpine || (PhaserSpine = {}));
var PhaserSpine;
! function(a) {
    var b = function() {
        function a(a) {
            this.load = function(a, b, c) {
                var d = this.game.make.image(0, 0, b);
                a.rendererObject = d.texture.baseTexture
            }, this.unload = function(a) {
                a.destroy()
            }, this.game = a
        }
        return a
    }();
    a.SpineTextureLoader = b
}(PhaserSpine || (PhaserSpine = {}));
var __extends = this && this.__extends || function(a, b) {
        function c() {
            this.constructor = a
        }
        for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);
        a.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c)
    },
    PhaserCachebuster;
! function(a) {
    var b = function(a) {
        function b(b, c) {
            var d = a.call(this, b, c) || this;
            return d.patchLoader(), d
        }
        return __extends(b, a), b.prototype.patchLoader = function() {
            Object.defineProperty(Phaser.Loader, "cacheBuster", {
                value: null
            }), Phaser.Loader.prototype.transformUrl = function(a, b) {
                return a ? (null !== this.cacheBuster && null === a.match(/^(data:)/) && (a += "?v=" + this.cacheBuster), a.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? a : this.baseURL + b.path + a) : ""
            }
        }, b
    }(Phaser.Plugin);
    a.CacheBuster = b
}(PhaserCachebuster || (PhaserCachebuster = {}));
var __extends = this && this.__extends || function() {
        var a = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(a, b) {
            a.__proto__ = b
        } || function(a, b) {
            for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c])
        };
        return function(b, c) {
            function d() {
                this.constructor = b
            }
            a(b, c), b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d)
        }
    }(),
    Fabrique;
! function(a) {
    var b;
    ! function(a) {
        var b = function(a) {
            function b(b, c) {
                var d = a.call(this, b, null, "splash-background") || this;
                return d.back = d.game.make.graphics(0, 0), d.add(d.back), d.resize(c), d
            }
            return __extends(b, a), b.prototype.resize = function(a) {
                this.back.clear().beginFill(14548992).drawRect(0, 0, this.game.width, this.game.height)
            }, b.prototype.update = function() {}, b.prototype.destroy = function(b) {
                a.prototype.destroy.call(this, b), this.back.destroy(!0), this.back = null
            }, b
        }(Phaser.Group);
        a.Bild = b
    }(b = a.SplashScreenBackgrounds || (a.SplashScreenBackgrounds = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(a) {
        var b = function(a) {
            function b(b, c) {
                var d = a.call(this, b, null, "splash-background") || this;
                return d.triangles = [], d.triangleSizes = [350, 650, 950, 1250], d.back = d.game.make.graphics(0, 0), d.t = d.game.make.graphics(0, 0), d.gradientBitmap = d.game.make.bitmapData(d.game.width, d.game.height), d.gradient = d.game.make.sprite(0, 0, d.gradientBitmap), d.add(d.back), d.add(d.t), d.add(d.gradient), d.resize(c), d
            }
            return __extends(b, a), b.prototype.resize = function(a) {
                var b = this;
                this.back.clear().beginFill(3387647).drawRect(0, 0, this.game.width, this.game.height), this.updateTrinagles(a), this.t.x = this.game.width / 2, this.t.y = this.game.height / 2, this.t.clear(), this.t.lineStyle(80 * a, 16777215, .3), this.triangles.forEach(function(a) {
                    b.t.drawPolygon(a)
                }), this.t.angle = 30, this.gradientBitmap.resize(this.game.width, this.game.height);
                var c = this.gradientBitmap.context.createLinearGradient(0, 0, 0, this.game.height - 200);
                c.addColorStop(0, "rgba(51, 176, 255, 0)"), c.addColorStop(1, "rgba(51, 176, 255, 1)"), this.gradientBitmap.context.fillStyle = c, this.gradientBitmap.context.clearRect(0, 0, this.game.width, this.game.height), this.gradientBitmap.context.fillRect(0, 0, this.game.width, this.game.height)
            }, b.prototype.updateTrinagles = function(a) {
                var b = this;
                new Phaser.Point(this.game.width / 2, this.game.height / 2), this.triangles = [], this.triangleSizes.forEach(function(c, d) {
                    c *= a, b.triangles.push(new Phaser.Polygon([new Phaser.Point(c * Math.cos(0), c * Math.sin(0)), new Phaser.Point(c * Math.cos(1 / 3 * (2 * Math.PI)), c * Math.sin(1 / 3 * (2 * Math.PI))), new Phaser.Point(c * Math.cos(2 / 3 * (2 * Math.PI)), c * Math.sin(2 / 3 * (2 * Math.PI))), new Phaser.Point(c * Math.cos(0), c * Math.sin(0))]))
                })
            }, b.prototype.update = function() {
                this.t.angle += .3
            }, b.prototype.destroy = function(b) {
                a.prototype.destroy.call(this, b), this.back.destroy(!0), this.gradientBitmap.destroy(), this.gradient.destroy(!0), this.t.destroy(!0), this.back = null, this.gradientBitmap = null, this.gradient = null, this.t = null, this.triangles = null, this.triangleSizes = null
            }, b
        }(Phaser.Group);
        a.FunnyGames = b
    }(b = a.SplashScreenBackgrounds || (a.SplashScreenBackgrounds = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(a) {
        var b = function(a) {
            function b(b, c) {
                var d = a.call(this, b, null, "splash-background") || this;
                return d.gradientBitmap = d.game.make.bitmapData(d.game.width, d.game.height), d.gradient = d.game.make.sprite(0, 0, d.gradientBitmap), d.add(d.gradient), d.resize(c), d
            }
            return __extends(b, a), b.prototype.resize = function(a) {
                this.gradientBitmap.resize(this.game.width, this.game.height);
                var b = this.gradientBitmap.context.createLinearGradient(0, 0, 0, this.game.height);
                b.addColorStop(0, "rgba(26, 135, 182, 1)"), b.addColorStop(.5, "rgba(25, 174, 232, 1)"), b.addColorStop(.5, "rgba(3, 114, 165, 1)"), b.addColorStop(1, "rgba(8, 147, 203, 1)"), this.gradientBitmap.context.fillStyle = b, this.gradientBitmap.context.clearRect(0, 0, this.game.width, this.game.height), void this.gradientBitmap.context.fillRect(0, 0, this.game.width, this.game.height)
            }, b.prototype.update = function() {}, b.prototype.destroy = function(b) {
                a.prototype.destroy.call(this, b), this.gradientBitmap.destroy(), this.gradient.destroy(!0), this.gradientBitmap = null, this.gradient = null
            }, b
        }(Phaser.Group);
        a.Kizi = b
    }(b = a.SplashScreenBackgrounds || (a.SplashScreenBackgrounds = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(a) {
        var b = function(a) {
            function b(b, c) {
                var d = a.call(this, b, null, "splash-background") || this;
                return d.back = d.game.make.graphics(0, 0), d.gradientBitmap = d.game.make.bitmapData(d.game.width, d.game.height), d.gradient = d.game.make.sprite(0, 0, d.gradientBitmap), d.add(d.back), d.add(d.gradient), d.resize(c), d
            }
            return __extends(b, a), b.prototype.resize = function(a) {
                this.back.clear().beginFill(4879021).drawRect(0, 0, this.game.width, this.game.height)
            }, b.prototype.update = function() {}, b.prototype.destroy = function(b) {
                a.prototype.destroy.call(this, b), this.back.destroy(!0), this.gradientBitmap.destroy(), this.gradient.destroy(!0), this.back = null, this.gradientBitmap = null, this.gradient = null
            }, b
        }(Phaser.Group);
        a.Spele = b
    }(b = a.SplashScreenBackgrounds || (a.SplashScreenBackgrounds = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(a) {
        var b = function(a) {
            function b(b, c) {
                var d = a.call(this, b, null, "splash-background") || this;
                return d.back = d.game.make.graphics(0, 0), d.gradientBitmap = d.game.make.bitmapData(d.game.width, d.game.height), d.gradient = d.game.make.sprite(0, 0, d.gradientBitmap), d.add(d.back), d.add(d.gradient), d.resize(c), d
            }
            return __extends(b, a), b.prototype.resize = function(a) {
                this.back.clear().beginFill(357287).drawRect(0, 0, this.game.width, this.game.height), this.gradientBitmap.resize(this.game.width, this.game.height), this.gradientBitmap.context.clearRect(0, 0, this.game.width, this.game.height);
                var b = this.gradientBitmap.context.createRadialGradient(this.game.width / 2, this.game.height / 2, 0, this.game.width / 2, this.game.height / 2, this.game.height / 2);
                b.addColorStop(0, "rgba(0, 81, 125, 0)"), b.addColorStop(1, "rgba(0, 81, 125, 1)"), this.gradientBitmap.context.fillStyle = b, this.gradientBitmap.context.fillRect(0, 0, this.game.width, this.game.height);
                var c = this.gradientBitmap.context.createRadialGradient(this.game.width / 2, this.game.height / 2, 0, this.game.width / 2, this.game.height / 2, this.game.height / 2);
                c.addColorStop(0, "rgba(4, 176, 240, 1)"), c.addColorStop(1, "rgba(4, 176, 240, 0)"), this.gradientBitmap.context.fillStyle = c, this.gradientBitmap.context.fillRect(0, 0, this.game.width, this.game.height)
            }, b.prototype.update = function() {}, b.prototype.destroy = function(b) {
                a.prototype.destroy.call(this, b), this.back.destroy(!0), this.gradientBitmap.destroy(), this.gradient.destroy(!0), this.back = null, this.gradientBitmap = null, this.gradient = null
            }, b
        }(Phaser.Group);
        a.Yepi = b
    }(b = a.SplashScreenBackgrounds || (a.SplashScreenBackgrounds = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(a) {
        a[a.splashscreen = 0] = "splashscreen", a[a.logo = 1] = "logo", a[a.facebook = 2] = "facebook", a[a.twitter = 3] = "twitter", a[a.playstore = 4] = "playstore", a[a.appstore = 5] = "appstore", a[a.more_games = 6] = "more_games", a[a.download_game = 7] = "download_game", a[a.walkthrough = 8] = "walkthrough", a[a.disclaimer = 9] = "disclaimer", a[a.highscores = 10] = "highscores"
    }(b = a.UtmTargets || (a.UtmTargets = {}));
    var c = function() {
        function c() {}
        return c.preloadImages = function(b) {
            var d;
            switch (a.Utils.isOnDevice(b) || c.isAirfi() ? a.Utils.ASSET_LOCATION = "assets/" : a.Utils.isTc() ? a.Utils.ASSET_LOCATION = "./assets/" : "fbrq.io" === a.Utils.getSourceSite(!0) && (a.Utils.ASSET_LOCATION =  "./assets/"), a.Utils.getBrandingDomain()) {
                case a.BrandingDomain.Spele:
                    d = "spele";
                    break;
                case a.BrandingDomain.Yepi:
                    d = "yepi";
                    break;
                case a.BrandingDomain.Bild:
                    d = "bild";
                    break;
                default:
                case a.BrandingDomain.Funnygames:
                    d = "funnygames"
            }
            a.Utils.isTc() || (b.load.crossOrigin = "anonymous"), b.load.image(c.LOGO_KEY, a.Utils.ASSET_LOCATION + "images/branding_logo_" + d + "_small.png")
        }, c.openCampaignLink = function(d, e, f) {
            if (a.Utils.isOnDevice(d) || c.isContracted(d) || c.isSpecial(d)) return null;
            var g, h = a.Utils.getSourceSite(),
                i = (a.SplashScreen.Preloader.SPLASH_OVERRIDE !== !1 ? a.BrandingDomain[a.SplashScreen.Preloader.SPLASH_OVERRIDE] : a.Utils.getSourceSite(), a.Utils.isOnDevice(d) ? "https://" : "//");
            switch (a.Utils.getBrandingDomain()) {
                case a.BrandingDomain.Spele:
                    g = i + "www.spele.nl";
                    break;
                case a.BrandingDomain.Yepi:
                    g = i + "www.yepi.com";
                    break;
                case a.BrandingDomain.Bild:
                    var j = window.open(i + "www.bildspielt.de", "_blank");
                    return void j.focus();
                default:
                case a.BrandingDomain.Funnygames:
                    g = i + "www.funnygames.nu"
            }
            var k = "string" == typeof f ? f : b[f],
                l = window.open(g + "/?utm_source=" + h + "&utm_medium=html5&utm_term=" + e + "&utm_content=" + k + "&utm_campaign=sponsored_games", "_blank");
            l.focus()
        }, c.getLogoWithLink = function(b, d) {
            var e = new Phaser.Image(b, 0, 0, c.LOGO_KEY);
            return a.Utils.isOnDevice(b) || c.isContracted(b) || c.isSpecial(b) || c.isAirfi() || (e.inputEnabled = !0, e.input.useHandCursor = !0, e.events.onInputUp.add(function() {
                a.Branding.openCampaignLink(b, d, a.UtmTargets.logo)
            }, this)), e
        }, c.isInternal = function(a) {
            return c.hostMatchesList(a.cache.getJSON(c.INTERNAL_PORTALS_KEY))
        }, c.isContracted = function(a) {
            return c.hostMatchesList(a.cache.getJSON(c.CONTRACTED_PORTALS_KEY))
        }, c.isSpecial = function(a) {
            return c.hostMatchesList(a.cache.getJSON(c.SPECIAL_PORTALS_KEY))
        }, c.isBild = function() {
            return "bild.fbrq.io" === window.location.host || window.location.host.indexOf("contentfleet.com") !== -1
        }, c.isBip = function() {
            return "bip.fbrq.io" === window.location.host
        }, c.isSpil = function() {
            return document.referrer.indexOf("gameplayer.io") !== -1
        }, c.isAirfi = function() {
            return !!window.hasOwnProperty("airfi") && window.airfi
        }, c.hostMatchesList = function(b) {
            b = b || [];
            for (var c = a.Utils.getSourceSite(), d = 0; d < b.length; d++)
                if (c === b[d]) return !0;
            return !1
        }, c
    }();
    c.LOGO_KEY = "branding_logo", c.INTERNAL_PORTALS_KEY = "branding_portals", c.CONTRACTED_PORTALS_KEY = "branding_contracted", c.SPECIAL_PORTALS_KEY = "branding_special", c.SITELOCK_PORTALS = "sitelock_portals", c.GAME_ICONS_KEY = "more_games", a.Branding = c
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b = function() {
        function b() {}
        return b.loadPortalScript = function(b) {
            b && b.hasOwnProperty("minijuegos") && b.minijuegos.indexOf(a.Utils.getSourceSite()) !== -1 && (void 0 !== window.mpConfig ? window.mpConfig.partner = "orange-games" : window.mpConfig = {
                partner: "orange-games"
            }, "function" == typeof addScript && addScript("https://ext.minijuegosgratis.com/external-host/main.js", Date.now() / 1e3))
        }, b
    }();
    a.PortalScripts = b
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b = function() {
        function a() {}
        return a.initialize = function(b, c, d, e) {
            var f = "string" == typeof b.parent ? document.getElementById(b.parent) : b.parent;
            a.container = f.parentNode.appendChild(document.createElement("div")), a.container.id = "phaser-vooxe-container", a.container.style.position = "absolute", a.container.style.zIndex = "9999", a.container.style.display = "none", a.container.style.top = "0", a.container.style.left = "0", a.container.style.width = "100%", a.container.style.height = "100%", a.container.style.overflow = "hidden";
            var g = a.container.appendChild(document.createElement("div"));
            g.style.width = "100%", g.style.height = "50px", g.style.backgroundColor = "#000000";
            var h = g.appendChild(document.createElement("div"));
            h.innerHTML = "&#x274c;", h.style.color = "#ffffff", h.style.cssFloat = "right", h.style.fontSize = "40px", h.style.marginRight = "5px", h.style.cursor = "pointer", h.addEventListener("click", function() {
                return a.hide()
            });
            var i = {
                container: "phaser-vooxe-container",
                gameId: c,
                publisherId: "dc63a91fa184423482808bed4d782320",
                width: window.innerWidth + "px",
                height: window.innerHeight - 50 + "px",
                title: d,
                category: e,
                langCode: "en-us",
                autoplay: "no",
                onFound: function(a) {},
                onError: function(a) {},
                onReady: function(b) {
                    a.playerInstance = b
                }
            };
            ! function(a, b, c, d, e, f, g) {
                a.VooxeVideo = e, a[e] = a[e] || function() {
                    (a[e].q = a[e].q || []).push(arguments)
                }, a[e].l = Date.now(), f = b.createElement(c), g = b.getElementsByTagName(c)[0], f.async = 1, f.src = d, g.parentNode.insertBefore(f, g)
            }(window, document, "script", "//video-static.vooxe.com/libs/gd/gd.js", "gdPlayer", void 0, void 0), gdPlayer(i)
        }, a.play = function(b) {
            null !== a.playerInstance && a.playerInstance.play(b)
        }, a.pause = function() {
            null !== a.playerInstance && a.playerInstance.pause()
        }, a.show = function() {
            a.container.style.display = "block"
        }, a.hide = function() {
            a.pause(), a.container.style.display = "none", a.onClose.dispatch()
        }, a.setVolume = function(b) {
            null !== a.playerInstance && (b > 1 || b < 0 || a.playerInstance.setVolume(b))
        }, a
    }();
    b.playerInstance = null, b.onClose = new Phaser.Signal, a.Vooxe = b
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(a) {
        a[a.Neutral = 0] = "Neutral", a[a.Yepi = 1] = "Yepi", a[a.Spele = 2] = "Spele", a[a.Funnygames = 3] = "Funnygames", a[a.Kizi = 4] = "Kizi", a[a.Bild = 5] = "Bild"
    }(b = a.BrandingDomain || (a.BrandingDomain = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(a) {
        var b = function(a) {
            function b(b, c, d, e, f, g, h) {
                var i = a.call(this, b, d, e, "", null, null) || this;
                i.onInputUp.add(i.openGame, i), i.id = c.data.key, i.url = c.data.url, i.icon = i.game.add.image(0, 0, c.data.key), i.icon.width = f, i.icon.height = f, i.input.priorityID = 680, i.addChild(i.icon);
                var j = i.game.make.graphics(0, 0);
                j.beginFill(h).drawRect(0, 0, f, g - f).endFill(), i.titleBg = i.game.add.image(0, f, j.generateTexture()), i.addChild(i.titleBg);
                var k = c.data.title;
                return k.length > 16 && (k = k.replace(k.substring(14, k.length), "...")), i.title = i.game.add.text(f / 2, i.titleBg.y + (g - f) / 2 + 4, k.toUpperCase(), {
                    font: "bold " + .35 * (g - f) + "px Arial",
                    fill: "#FFF",
                    align: "center",
                    wordWrap: !0,
                    wordWrapWidth: f - 10
                }), i.title.anchor.set(.5, .5), i.addChild(i.title), j = i.game.make.graphics(0, 0), j.beginFill(16777215).drawCircle(0, 0, 80).beginFill(h).lineTo(-15, -25).lineTo(25, 0).lineTo(-15, 25).lineTo(-15, -25).endFill(), i.playImg = i.game.add.image(f / 2, f / 3 * 2.7, j.generateTexture()), i.playImg.anchor.set(.5, .5), i.addChild(i.playImg), i
            }
            return __extends(b, a), b.prototype.openGame = function() {
                // this.game.analytics && this.game.analytics.google.sendGenericEvent("MoreGames", "Click", this.id), this.url.indexOf("http://") !== -1 && this.url.replace("http:", "");
                // var a = window.open(this.url, "_self");
                // a.focus()
            }, b.prototype.destroy = function() {
                this.onInputUp.remove(this.openGame, this), a.prototype.destroy.call(this), this.removedFromWorld()
            }, b
        }(Phaser.Button);
        a.Item = b
    }(b = a.MoreGames || (a.MoreGames = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(b) {
        var c = function(c) {
            function d(b, d) {
                var e = c.call(this, b, null, "moreGames-background") || this;
                e.size = 800, e.items = [], e.offset = 14, e.isDestroyed = !1, e.gameName = d, e.deviceRatio = b.width / e.size, e.overlay = b.add.graphics(0, 0), e.overlay.beginFill(0, .4).drawRect(0, 0, b.width, b.height).endFill(), e.overlay.pivot.set(b.width / 2, b.height / 2), e.overlay.inputEnabled = !0, e.overlay.input.priorityID = 660, e.onClose = new Phaser.Signal, e.overlay.events.onInputUp.add(function() {
                    e.hide()
                }), e.add(e.overlay), e.menuGrp = new Phaser.Group(b, e, "menuGrp"), e.add(e.menuGrp);
                var f = b.make.graphics(0, 0);
                f.beginFill(2507370).drawRoundedRect(0, 0, e.size, e.size + 20, 15).endFill(), e.background = e.game.add.image(0, 0, f.generateTexture()), e.background.anchor.set(.5), e.background.inputEnabled = !0, e.background.input.priorityID = 670, e.background.input.useHandCursor = !1, e.menuGrp.add(e.background), e.logoBtn = e.game.add.button(0, -(e.background.height / 2) + e.offset, a.Branding.LOGO_KEY, function() {
                    a.Branding.openCampaignLink(e.game, e.gameName, a.UtmTargets.more_games)
                }, e), e.logoBtn.scale.setTo(1), e.logoBtn.anchor.set(.5, 0), e.menuGrp.add(e.logoBtn), e.closeBtn = b.add.button(e.size / 2 - 10, -(e.size / 2) + 25, "close_btn", e.hide, e), e.closeBtn.anchor.set(1), e.closeBtn.input.priorityID = 680, e.menuGrp.add(e.closeBtn), e.createItems();
                var g = b.make.graphics(0, 0);
                g.beginFill(2507370).drawRect(0, 0, 270, 40).endFill(), e.moreGamesBtn = b.add.button(0, e.background.y + e.background.height / 2 - g.height - e.offset, "", function() {
                    a.Branding.openCampaignLink(e.game, e.gameName, a.UtmTargets.more_games)
                }, e), e.moreGamesBtn.texture = g.generateTexture(), e.moreGamesBtn.input.priorityID = 680, e.moreGamesBtn.anchor.set(.5, 0), e.menuGrp.add(e.moreGamesBtn);
                var h = {
                    font: "bold 26px Tahoma",
                    fill: "#ffffff"
                };
                return e.moreGamesText = b.add.text(0, e.moreGamesBtn.height / 2 + 2, "PLAY MORE GAMES", h), e.moreGamesText.anchor.set(.5), e.moreGamesBtn.addChild(e.moreGamesText), e.visible = !1, e.resize(), e.resizeListener = function() {
                    setTimeout(function() {
                        e.isDestroyed || e.resize()
                    }, 100)
                }, e.game.scale.onSizeChange.add(e.resizeListener, e), e
            }
            return __extends(d, c), d.prototype.createItems = function() {
                this.itemGrp = this.game.make.group(this, "items"), this.itemGrp.x = 0, this.itemGrp.y = this.size / 2 + this.logoBtn.y + this.logoBtn.height, this.menuGrp.add(this.itemGrp);
                var c, e, f, g, h = this.game.cache.getJSON(a.Branding.GAME_ICONS_KEY),
                    i = 3,
                    j = Math.floor(this.size / i - 1.25 * this.offset),
                    k = Math.floor(j + .25 * j),
                    l = 0;
                for (var m in h) h.hasOwnProperty(m) && l < 6 && !this.isCurrentGame(m) && (e = l % i * j + this.offset + l % i * this.offset, f = Math.floor(l / i) * k + this.offset + Math.floor(l / i) * this.offset, g = l % d.BG_COLORS.length, c = new b.Item(this.game, h[m], e - this.size / 2, f - this.size / 2, j, k, d.BG_COLORS[g]), this.itemGrp.add(c), this.items.push(c), l++)
            }, d.prototype.isCurrentGame = function(a) {
                var b = window.location.href.replace(/-/g, "");
                return a = a.replace(/-/g, ""), b.indexOf(a) >= 0
            }, d.prototype.show = function() {
                this.visible || (this.game.analytics && (this.game.analytics.google.sendScreenView("moregames"), this.game.analytics.google.sendGenericEvent("MoreGames", "Open")), this.visible = !0)
            }, d.prototype.hide = function() {
                this.visible && (this.visible = !1, this.game.analytics && this.game.analytics.google.sendGenericEvent("MoreGames", "Close"), this.onClose && this.onClose.dispatch())
            }, d.preloadImages = function(b) {
                a.Utils.getSourceSite(), a.Utils.isOnDevice(b) || a.Branding.isAirfi() ? a.Utils.ASSET_LOCATION = "assets/" : a.Utils.isTc() ? a.Utils.ASSET_LOCATION = "./assets/" : "fbrq.io" === a.Utils.getSourceSite(!0) && (a.Utils.ASSET_LOCATION = "./assets/"), a.Utils.isTc() || (b.load.crossOrigin = "anonymous"), b.load.image("close_btn", a.Utils.ASSET_LOCATION + "images/close_btn.png");
                var c = b.cache.getJSON(a.Branding.GAME_ICONS_KEY);
                for (var d in c) c.hasOwnProperty(d) && (c[d].data.key = d, b.load.image(d, a.Utils.ASSET_LOCATION + "icons/" + d + ".png"))
            }, d.prototype.getScale = function() {
                return this.game.height > this.game.width && this.game.width < this.size ? (this.game.width - 20) / this.size : this.game.width > this.game.height && this.game.height < this.size ? (this.game.height - 40) / this.size : 1
            }, d.prototype.resize = function() {
                this.scaleFactor = this.getScale(), this.overlay.clear().beginFill(0, .4).drawRect(0, 0, this.game.width, this.game.height).endFill(), this.overlay.pivot.set(this.game.width / 2, this.game.height / 2), this.menuGrp.scale.set(this.scaleFactor)
            }, d.prototype.destroy = function() {
                this.game.scale.onSizeChange.remove(this.resizeListener, this), this.isDestroyed || (this.overlay.destroy(!0), this.overlay = null, this.itemGrp.destroy(!0), this.itemGrp = null, this.menuGrp.destroy(!0), this.menuGrp = null, this.background.destroy(), this.background = null, this.closeBtn.destroy(), this.closeBtn = null, this.moreGamesBtn.destroy(), this.moreGamesBtn = null, this.moreGamesText.destroy(), this.moreGamesText = null, this.logoBtn.destroy(), this.logoBtn = null, this.onClose.removeAll(), this.onClose = null, this.items.forEach(function(a) {
                    a.destroy()
                })), this.isDestroyed = !0, this.removeAll(!0), c.prototype.destroy.call(this)
            }, d
        }(Phaser.Group);
        c.BG_COLORS = [2201331, 10233776, 15936542, 15690752, 16361509, 5025616], b.Menu = c
    }(b = a.MoreGames || (a.MoreGames = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(a) {
        var b = function(a) {
            function b(b, c) {
                var d = a.call(this, b, c) || this;
                return d.ga = GA.getInstance(), b.hasOwnProperty("analytics") ? Object.defineProperty(b.analytics, "game", {
                    value: d
                }) : b.analytics = {
                    game: d
                }, d
            }
            return __extends(b, a), b.prototype.setup = function(a, b, c, d, e) {
                void 0 === e && (e = !0), this.ga.init(a, b, c, d).addEvent(new GA.Events.User), e && this.setupErrorTracking()
            }, b.prototype.createUser = function(a, b, c, d) {
                return new GA.User(a, b, c, d)
            }, b.prototype.addEvent = function(a) {
                this.ga.addEvent(a)
            }, b.prototype.sendEvents = function() {
                this.ga.sendData()
            }, b.prototype.setupErrorTracking = function() {
                var a = this,
                    b = [];
                window.addEventListener("error", function(c) {
                    if (b.indexOf(c.message) === -1) {
                        b.push(c.message);
                        var d = "Error: " + c.message;
                        c.filename && (d += "\nurl: " + c.filename), c.lineno && (d += "\nline: " + c.lineno), c.colno && (d += "\ncolumn: " + c.colno), c.error && (d += "\nDetails: " + c.error), a.ga.addEvent(new GA.Events.Exception(GA.Events.ErrorSeverity.critical, d)).sendData()
                    }
                }), window.addEventListener("error", function(b) {
                    var c = b.message;
                    b.hasOwnProperty("error") && b.error.hasOwnProperty("stack") && (c = b.error.stack), a.ga.addEvent(new GA.Events.Exception(GA.Events.ErrorSeverity.critical, c)).sendData()
                })
            }, b
        }(Phaser.Plugin);
        a.GameAnalytics = b
    }(b = a.Plugins || (a.Plugins = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(b) {
        var c = function(b) {
            function c(c, d) {
                var e = b.call(this, c, d) || this;
                c.hasOwnProperty("analytics") ? Object.defineProperty(c.analytics, "google", {
                    value: e
                }) : c.analytics = {
                    google: e
                };
                var f = a.Utils.isOnDevice(c) ? "https://" : "//";
                return function(a, b, c, d, e, f, g) {
                    a.GoogleAnalyticsObject = e, a[e] = a[e] ? a[e] : function() {
                        (a[e].q = a[e].q || []).push(arguments)
                    }, a[e].l = Date.now(), f = b.createElement(c), g = b.getElementsByTagName(c)[0], f.async = 1, f.src = d, g.parentNode.insertBefore(f, g)
                }(window, document, "script", f + "./analytics.js", "ga"), e
            }
            return __extends(c, b), c.prototype.setup = function(b, c, d, e) {
                if (void 0 === e && (e = "auto"), ga("create", b, e), a.Utils.isOnDevice(this.game) && ga("set", "checkProtocolTask", null), void 0 !== c && ga("set", "appName", c), void 0 !== c && ga("set", "appVersion", d), ga("send", "pageview"), "auto" !== e) {
                    var f = {
                        name: "fbrq"
                    };
                    for (var g in e) e.hasOwnProperty(g) && (f[g] = e[g]);
                    ga("create", "UA-78960661-1", f)
                } else ga("create", "UA-78960661-1", e, "fbrq"); if (a.Branding.isSpil()) {
                    var h = a.Utils.getReferrer(decodeURIComponent(document.referrer));
                    ga("fbrq.set", "referrer", h), ga("set", "referrer", h)
                }
                return a.Utils.isOnDevice(this.game) && ga("fbrq.set", "checkProtocolTask", null), ga("fbrq.send", "pageview"), ga("fbrq.set", "appName", "All"), ga
            }, c.prototype.sendScreenView = function(a) {
                ga("fbrq.send", "screenview", {
                    screenName: a
                }), ga("send", "screenview", {
                    screenName: a
                })
            }, c.prototype.sendGenericEvent = function(a, b, c) {
                ga("fbrq.send", "event", a, b, c)
            }, c
        }(Phaser.Plugin);
        b.GoogleAnalytics = c
    }(b = a.Plugins || (a.Plugins = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(a) {
        var b = function(a) {
            function b(b, c) {
                var d = a.call(this, b, c) || this;
                return b.hasOwnProperty("events") ? void 0 : b.events = {
                    onGameStart: new Phaser.Signal,
                    onGameEnd: new Phaser.Signal,
                    onLevelStart: new Phaser.Signal,
                    onLevelEnd: new Phaser.Signal,
                    onPause: new Phaser.Signal,
                    onResume: new Phaser.Signal
                }, d
            }
            return __extends(b, a), b
        }(Phaser.Plugin);
        a.GameEvents = b
    }(b = a.Plugins || (a.Plugins = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(b) {
        var c = function(c) {
            function d() {
                var a = c.call(this) || this;
                return a.name = d.Name, a.scaleFactor = 1, a.created = !1, a
            }
            return __extends(d, c), d.prototype.init = function(b) {
                if (this.config = b, d.SPLASH_OVERRIDE = "number" == typeof b.splashOverride && b.splashOverride, this.game.scale.onSizeChange.add(this.resize, this), void 0 === !this.game.load.spine) throw new Error("You tried to play the Splash screen without spine support enabled!");
                a.Utils.isOnDevice(this.game) || a.Branding.isAirfi() ? a.Utils.ASSET_LOCATION = "assets/" : a.Utils.isTc() ? a.Utils.ASSET_LOCATION = "./assets/" : "fbrq.io" === a.Utils.getSourceSite(!0) && (a.Utils.ASSET_LOCATION =  "./assets/")
            }, d.prototype.preload = function() {
                this.scaleFactor = this.getScale(), a.Utils.isTc() || (this.game.load.crossOrigin = "anonymous");
                var b = Date.now() / 1e3 | 0;
                switch (a.Utils.isOnDevice(this.game) || (this.game.load.json(a.Branding.INTERNAL_PORTALS_KEY, a.Utils.ASSET_LOCATION + "json/internal.json?v=" + b), this.game.load.json(a.Branding.CONTRACTED_PORTALS_KEY, a.Utils.ASSET_LOCATION + "json/contracted.json?v=" + b), this.game.load.json(a.Branding.SPECIAL_PORTALS_KEY, a.Utils.ASSET_LOCATION + "json/special.json?v=" + b), this.game.load.json(a.Branding.SITELOCK_PORTALS, a.Utils.ASSET_LOCATION + "json/sitelock.json?v=" + b), this.game.load.json(a.Branding.GAME_ICONS_KEY, a.Utils.ASSET_LOCATION + "json/games.json?v=" + b), this.game.load.json(a.Domain.KEY, a.Utils.ASSET_LOCATION + "json/domains.json")), a.Utils.getBrandingDomain()) {
                    case a.BrandingDomain.Spele:
                        this.background = new a.SplashScreenBackgrounds.Spele(this.game, this.scaleFactor), this.game.add.existing(this.background);
                        break;
                    case a.BrandingDomain.Yepi:
                        this.background = new a.SplashScreenBackgrounds.Yepi(this.game, this.scaleFactor), this.game.add.existing(this.background);
                        break;
                    case a.BrandingDomain.Kizi:
                        this.background = new a.SplashScreenBackgrounds.Kizi(this.game, this.scaleFactor), this.game.add.existing(this.background);
                        break;
                    case a.BrandingDomain.Bild:
                        this.background = new a.SplashScreenBackgrounds.Bild(this.game, this.scaleFactor), this.game.add.existing(this.background);
                        break;
                    default:
                    case a.BrandingDomain.Funnygames:
                        this.background = new a.SplashScreenBackgrounds.FunnyGames(this.game, this.scaleFactor), this.game.add.existing(this.background)
                }
            }, d.prototype.getScale = function() {
                return this.game.device.desktop ? this.game.width < 1.5 * b.FunnyGames.IdealWidth ? this.game.width / 6 * 4 / b.FunnyGames.IdealWidth : 1 : this.game.width < this.game.height ? this.game.width / 6 * 4 / b.FunnyGames.IdealWidth : this.game.width / 6 * 3 / b.FunnyGames.IdealWidth
            }, d.prototype.loadUpdate = function() {
                this.background.update()
            }, d.prototype.update = function() {
                this.background.update()
            }, d.prototype.resize = function() {
                this.scaleFactor = this.getScale(), this.background.resize(this.scaleFactor)
            }, d.prototype.shutdown = function() {
                this.game.scale.onSizeChange.remove(this.resize, this), this.world.remove(this.background)
            }, d.prototype.create = function() {
                a.Domain.setList(this.cache.getJSON(a.Domain.KEY, !0)), a.PortalScripts.loadPortalScript(this.cache.getJSON(a.Branding.SITELOCK_PORTALS)), this.game.state.add(b.SplashPreloader.Name, b.SplashPreloader), this.game.state.start(b.SplashPreloader.Name, !0, !1, this.config, this.background)
            }, d
        }(Phaser.State);
        c.Name = "preloader", c.SPLASH_OVERRIDE = !1, b.Preloader = c
    }(b = a.SplashScreen || (a.SplashScreen = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(b) {
        var c = function(c) {
            function d() {
                var a = c.call(this) || this;
                return a.name = d.Name, a.scaleFactor = 1, a
            }
            return __extends(d, c), d.prototype.init = function(a, b) {
                this.config = a, this.game.scale.onSizeChange.add(this.resize, this), this.background = b, this.game.add.existing(this.background)
            }, d.prototype.preload = function() {
                if (this.scaleFactor = this.getScale(), a.Utils.isTc() || (this.game.load.crossOrigin = "anonymous"), a.Branding.isSpecial(this.game)) this.game.add.existing(this.background), this.game.load.spritesheet("fgs_play", a.Utils.ASSET_LOCATION + "images/fgs_btn_play.png", 130, 130), this.game.load.image("loader", a.Utils.ASSET_LOCATION + "images/loader_back.png");
                else switch (a.Utils.getBrandingDomain()) {
                    case a.BrandingDomain.Spele:
                        this.game.load.image("ss_play", a.Utils.ASSET_LOCATION + "images/ss_btn_play.png"), this.game.load.spine("ss_splash", a.Utils.ASSET_LOCATION + "spine/ss_splash.json"), this.game.device.iOS ? this.game.load.audio("cheer", [a.Utils.ASSET_LOCATION + "sound/ss_intro.m4a"]) : this.game.load.audio("cheer", [a.Utils.ASSET_LOCATION + "sound/ss_intro.ogg", a.Utils.ASSET_LOCATION + "sound/ss_intro.mp3"]);
                        break;
                    case a.BrandingDomain.Yepi:
                        this.game.load.spine("yp_splash", a.Utils.ASSET_LOCATION + "spine/yp_splash.json"), this.game.load.atlas("yp_atlas", a.Utils.ASSET_LOCATION + "atlas/yp_atlas.png", a.Utils.ASSET_LOCATION + "atlas/yp_atlas.json");
                        break;
                    case a.BrandingDomain.Kizi:
                        this.game.load.image("kizi_button", a.Utils.ASSET_LOCATION + "images/kizi_splash_button.png"), this.game.load.image("kizi_button_push", a.Utils.ASSET_LOCATION + "images/kizi_splash_button_onpush.png"), this.game.load.image("kizi_splash_clouds", a.Utils.ASSET_LOCATION + "images/kizi_splash_bg_cloud.png"), this.game.load.spritesheet("kizi_splash_spritesheet", a.Utils.ASSET_LOCATION + "images/kizi_splash_spritesheet.png", 250, 250, 4);
                        break;
                    case a.BrandingDomain.Bild:
                        this.game.load.image("bild_play", a.Utils.ASSET_LOCATION + "images/bild_btn_play.png"), this.game.load.image("bild_logo", a.Utils.ASSET_LOCATION + "images/branding_logo_bild.png"), this.game.add.existing(this.background);
                        break;
                    default:
                    case a.BrandingDomain.Funnygames:
                        this.game.load.image("fgs_logo", a.Utils.ASSET_LOCATION + "images/fgs_logo.png"), this.game.load.spritesheet("fgs_play", a.Utils.ASSET_LOCATION + "images/fgs_btn_play.png", 130, 130), this.game.load.spine("fgs_monster_1", a.Utils.ASSET_LOCATION + "spine/fgs_monster_1.json"), this.game.load.spine("fgs_monster_2", a.Utils.ASSET_LOCATION + "spine/fgs_monster_2.json"), this.game.load.spine("fgs_monster_3", a.Utils.ASSET_LOCATION + "spine/fgs_monster_3.json"), this.game.device.iOS ? this.game.load.audio("fg", [a.Utils.ASSET_LOCATION + "sound/fgs_intro.m4a"]) : this.game.load.audio("fg", [a.Utils.ASSET_LOCATION + "sound/fgs_intro.ogg", a.Utils.ASSET_LOCATION + "sound/fgs_intro.mp3"])
                }
            }, d.prototype.getScale = function() {
                return this.game.device.desktop ? this.game.width < 1.5 * b.FunnyGames.IdealWidth ? this.game.width / 6 * 4 / b.FunnyGames.IdealWidth : 1 : this.game.width < this.game.height ? this.game.width / 6 * 4 / b.FunnyGames.IdealWidth : this.game.width / 6 * 3 / b.FunnyGames.IdealWidth
            }, d.prototype.loadUpdate = function() {
                this.background.update()
            }, d.prototype.update = function() {
                this.background.update()
            }, d.prototype.resize = function() {
                this.scaleFactor = this.getScale(), this.background.resize(this.scaleFactor)
            }, d.prototype.shutdown = function() {
                this.game.scale.onSizeChange.remove(this.resize, this), this.world.remove(this.background)
            }, d.prototype.create = function() {
                if (a.Branding.isSpecial(this.game)) this.game.state.add(b.Neutral.Name, b.Neutral), this.game.state.start(b.Neutral.Name, !0, !1, this.config, this.background);
                else switch (a.Utils.getBrandingDomain()) {
                    case a.BrandingDomain.Spele:
                        this.game.state.add(b.Spele.Name, b.Spele), this.game.state.start(b.Spele.Name, !0, !1, this.config, this.background);
                        break;
                    case a.BrandingDomain.Yepi:
                        this.game.state.add(b.Yepi.Name, b.Yepi), this.game.state.start(b.Yepi.Name, !0, !1, this.config, this.background);
                        break;
                    case a.BrandingDomain.Kizi:
                        this.game.state.add(b.Kizi.Name, b.Kizi), this.game.state.start(b.Kizi.Name, !0, !1, this.config, this.background);
                        break;
                    case a.BrandingDomain.Bild:
                        this.game.state.add(b.Bild.Name, b.Bild), this.game.state.start(b.Bild.Name, !0, !1, this.config, this.background);
                        break;
                    default:
                    case a.BrandingDomain.Funnygames:
                        this.game.state.add(b.FunnyGames.Name, b.FunnyGames), this.game.state.start(b.FunnyGames.Name, !0, !1, this.config, this.background)
                }
            }, d
        }(Phaser.State);
        c.Name = "splashloader", b.SplashPreloader = c
    }(b = a.SplashScreen || (a.SplashScreen = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(b) {
        var c = function(c) {
            function d() {
                var a = c.call(this) || this;
                return a.name = d.Name, a.scaleFactor = 1, a.created = !1, a.preloadReady = !1, a.clicked = !1, a.preloadTexts = [], a.tId = 0, a
            }
            return __extends(d, c), d.prototype.init = function(a, b) {
                this.config = a, this.background = b, this.game.scale.onSizeChange.add(this.resize, this)
            }, d.prototype.preload = function() {
                this.game.add.existing(this.background), this.createObjects(), this.scaleFactor = this.getScale(), this.resizeObjects(), this.startAnimation(), this.game.load.onLoadStart.add(this.onPreloadStart, this), this.game.load.onFileComplete.add(this.onPreloadedFile, this), this.game.load.onLoadComplete.add(this.onPreloadEnd, this), this.config.preloadHandler(), 0 === this.game.load.totalQueuedFiles() && this.onPreloadEnd()
            }, d.prototype.onPreloadStart = function() {}, d.prototype.onPreloadedFile = function() {}, d.prototype.onPreloadEnd = function() {
                var b = this;
                this.preloadReady = !0, this.loadBack.visible = !1, this.loadBar.visible = !1, a.Utils.isOnDevice(this.game) || this.game.device.desktop ? this.game.time.events.add(Phaser.Timer.SECOND, function() {
                    void 0 !== b.config.mobilePlayClickhandler ? b.config.mobilePlayClickhandler() : b.game.state.start(b.config.nextState)
                }) : (this.game.input.onDown.add(function(a) {
                    b.clicked || (b.clicked = !0, void 0 !== b.config.mobilePlayClickhandler ? b.config.mobilePlayClickhandler() : b.playClick(), b.game.input.onDown.remove(b.playClick, b))
                }, this), this.animateButton())
            }, d.prototype.createObjects = function() {
                var a = this;
                this.logo = this.game.add.sprite(this.game.width / 2, this.game.height / 2 - 100, "bild_logo"), this.logo.anchor.set(.5), this.logo.scale.set(.8);
                var b = this.game.make.graphics(0, 0);
                b.beginFill(16777215, .5).drawRect(0, 0, 350, 20).endFill(), this.loadBack = this.game.add.sprite(this.game.width / 2, this.game.height / 2 + 100, b.generateTexture()), this.loadBack.anchor.set(.5);
                var c = this.game.make.graphics(0, 0);
                c.beginFill(16777215, 1).drawRect(0, 0, 350, 20).endFill(), this.loadBar = this.game.add.sprite(this.game.width / 2 - 175, this.game.height / 2 + 100, c.generateTexture()), this.loadBar.anchor.set(0, .5), this.load.setPreloadSprite(this.loadBar), this.playButton = this.game.add.button(this.game.width / 2, this.game.height / 2 + 200, "bild_play", function() {
                    a.clicked || (a.clicked = !0, void 0 !== a.config.mobilePlayClickhandler ? a.config.mobilePlayClickhandler() : a.playClick(), a.game.input.onDown.remove(a.playClick, a))
                }, this), this.playButton.anchor.set(.5), this.playButton.scale.set(this.scaleFactor), this.playButton.visible = !1, this.created = !0
            }, d.prototype.resizeObjects = function() {
                this.created && (a.Utils.isOnDevice(this.game) || (this.playButton.x = this.game.width / 2, this.playButton.y = this.game.height / 2 + 200, this.logo.x = this.game.width / 2, this.logo.y = this.game.height / 2 - 100))
            }, d.prototype.playClick = function() {
                var a = this;
                this.game.tweens.remove(this.buttonTween);
                var b = this.game.add.tween(this.playButton.scale);
                b.to({
                    x: 0,
                    y: 0
                }, 350, Phaser.Easing.Back.In).onComplete.add(function() {
                    a.game.state.start(a.config.nextState)
                }), b.start()
            }, d.prototype.getScale = function() {
                return a.Utils.isOnDevice(this.game) ? this.game.width < 1.5 * b.FunnyGames.IdealWidth ? this.game.width / 6 * 4 / b.FunnyGames.IdealWidth : 1 : this.game.width < this.game.height ? this.game.width / 6 * 4 / b.FunnyGames.IdealWidth : this.game.width / 6 * 3 / b.FunnyGames.IdealWidth
            }, d.prototype.startAnimation = function() {}, d.prototype.animateButton = function() {
                a.Utils.isOnDevice(this.game) || (this.game.tweens.remove(this.buttonTween), this.playButton.scale.set(this.scaleFactor), this.playButton.visible = !0, this.buttonTween = this.game.add.tween(this.playButton.scale), this.buttonTween.to({
                    x: 1.14 * this.scaleFactor,
                    y: 1.14 * this.scaleFactor
                }, 420, Phaser.Easing.Quadratic.InOut, !0, 500), this.buttonTween.yoyo(!0).onComplete.add(this.animateButton, this), this.buttonTween.start())
            }, d.prototype.update = function() {
                this.background.update()
            }, d.prototype.loadUpdate = function() {
                this.background.update()
            }, d.prototype.resize = function() {
                this.scaleFactor = this.getScale(), this.background.resize(this.scaleFactor), this.resizeObjects(), this.created && this.preloadReady && this.animateButton()
            }, d.prototype.shutdown = function() {
                c.prototype.shutdown.call(this), this.logo.destroy(!0), this.loadBack.destroy(!0), this.loadBar.destroy(!0), this.playButton.destroy(!0), this.background.destroy(!0), this.logo = null, this.loadBack = null, this.loadBar = null, this.playButton = null, this.background = null, this.config = null, this.game.scale.onSizeChange.remove(this.resize, this), this.game.load.onLoadStart.remove(this.onPreloadStart, this), this.game.load.onFileComplete.remove(this.onPreloadedFile, this), this.game.load.onLoadComplete.remove(this.onPreloadEnd, this), this.game.state.remove(b.Preloader.Name), this.game.state.remove(b.SplashPreloader.Name), this.game.state.remove(this.name)
            }, d
        }(Phaser.State);
        c.Name = "bildSplashScreen", c.IdealWidth = 463, c.MaxDots = 3, b.Bild = c
    }(b = a.SplashScreen || (a.SplashScreen = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(b) {
        var c = function(c) {
            function d() {
                var a = c.call(this) || this;
                return a.name = d.Name, a.scaleFactor = 1, a.created = !1, a.preloadReady = !1, a.clicked = !1, a.preloadTexts = ["Loading images", "Loading music", "Loading sound effects", "Calculating Pi"], a.dots = 1, a.dotText = ".", a.tId = 0, a
            }
            return __extends(d, c), d.prototype.init = function(a, b) {
                this.config = a, this.background = b, this.config.preloadTexts && (this.preloadTexts = this.config.preloadTexts), this.game.scale.onSizeChange.add(this.resize, this)
            }, d.prototype.preload = function() {
                this.game.add.existing(this.background), this.createObjects(), this.scaleFactor = this.getScale(), this.resizeObjects(), this.startAnimation(), this.game.load.onLoadStart.add(this.onPreloadStart, this), this.game.load.onFileComplete.add(this.onPreloadedFile, this), this.game.load.onLoadComplete.add(this.onPreloadEnd, this), this.config.preloadHandler(), 0 === this.game.load.totalQueuedFiles() && this.onPreloadEnd()
            }, d.prototype.onPreloadStart = function() {
                this.t = Date.now(), this.preloadText.setText(this.preloadTexts[this.tId])
            }, d.prototype.onPreloadedFile = function() {
                Date.now() - this.t > 1e3 && (this.t = Date.now(), this.tId++, this.tId >= this.preloadTexts.length && (this.tId = 0)), this.dotText.length >= 3 ? this.dotText = "." : this.dotText += ".", this.preloadText.setText(this.preloadTexts[this.tId] + this.dotText)
            }, d.prototype.onPreloadEnd = function() {
                var b = this;
                this.preloadReady = !0, this.preloadText.visible = !1, a.Utils.isOnDevice(this.game) || this.game.device.desktop ? this.game.time.events.add(Phaser.Timer.SECOND, function() {
                    void 0 !== b.config.mobilePlayClickhandler ? b.config.mobilePlayClickhandler() : b.game.state.start(b.config.nextState)
                }) : (this.game.input.onDown.add(function(a) {
                    b.clicked || (b.clicked = !0, void 0 !== b.config.mobilePlayClickhandler ? b.config.mobilePlayClickhandler() : b.playClick(), b.game.input.onDown.remove(b.playClick, b))
                }, this), this.animateButton())
            }, d.prototype.createObjects = function() {
                var a = this;
                this.monster1 = this.game.add.spine(0, 0, "fgs_monster_1"), this.monster1.setAnimationByName(0, "idle", !0), this.monster2 = this.game.add.spine(0, 0, "fgs_monster_2"), this.monster2.setAnimationByName(0, "idle", !0), this.monster3 = this.game.add.spine(0, 0, "fgs_monster_3"), this.monster3.setAnimationByName(0, "idle", !0), this.preloadText = this.game.add.text(this.game.width / 2, this.game.height / 2 + 230, "", {
                    font: "Arial",
                    fontSize: 40,
                    fill: "#ffffff",
                    fontWeight: "bold"
                }), this.preloadText.anchor.set(.5), this.logo = this.game.add.image(0, 0, "fgs_logo"), this.logo.anchor.set(.5), d.IdealWidth = 1.5 * this.logo.getBounds().width, this.playButton = this.game.add.button(this.game.width / 2, this.game.height / 2 + 230 * this.scaleFactor, "fgs_play", function() {
                    a.clicked || (a.clicked = !0, void 0 !== a.config.mobilePlayClickhandler ? a.config.mobilePlayClickhandler() : a.playClick(), a.game.input.onDown.remove(a.playClick, a))
                }, this, 0, 0, 1, 0), this.playButton.anchor.set(.5), this.playButton.scale.set(this.scaleFactor), this.playButton.visible = !1, this.created = !0
            }, d.prototype.resizeObjects = function() {
                this.created && (this.logo.scale.set(1.5 * this.scaleFactor), this.logo.y = this.game.height / 2 + 70 * this.scaleFactor, this.logo.x = this.game.width / 2, this.monster1.x = this.game.width / 2 + 40 * this.scaleFactor, this.monster1.y = this.game.height / 2 - 10 * this.scaleFactor, this.monster1.scale.set(.4 * this.scaleFactor), this.monster2.x = this.game.width / 2 + 190 * this.scaleFactor, this.monster2.y = this.game.height / 2 - 10 * this.scaleFactor, this.monster2.scale.set(.4 * this.scaleFactor), this.monster3.x = this.game.width / 2 - 140 * this.scaleFactor, this.monster3.y = this.game.height / 2 - 10 * this.scaleFactor, this.monster3.scale.set(.4 * this.scaleFactor), this.preloadText.x = this.game.width / 2, this.preloadText.y = this.game.height / 2 + 230 * this.scaleFactor, this.preloadText.scale.set(this.scaleFactor), a.Utils.isOnDevice(this.game) || (this.playButton.x = this.game.width / 2, this.playButton.y = this.game.height / 2 + 230 * this.scaleFactor))
            }, d.prototype.playClick = function() {
                var a = this;
                this.game.tweens.remove(this.buttonTween);
                var b = this.game.add.tween(this.playButton.scale);
                b.to({
                    x: 0,
                    y: 0
                }, 350, Phaser.Easing.Back.In).onComplete.add(function() {
                    a.game.state.start(a.config.nextState)
                }), b.start()
            }, d.prototype.getScale = function() {
                return a.Utils.isOnDevice(this.game) ? this.game.width < 1.5 * d.IdealWidth ? this.game.width / 6 * 4 / d.IdealWidth : 1 : this.game.width < this.game.height ? this.game.width / 6 * 4 / d.IdealWidth : this.game.width / 6 * 3 / d.IdealWidth
            }, d.prototype.startAnimation = function() {
                this.game.sound.touchLocked || this.game.sound.play("fg");
                var a = this.game.add.tween(this.logo.scale);
                a.to({
                    x: 1.2 * this.scaleFactor,
                    y: 1.2 * this.scaleFactor
                }, 100), a.to({
                    x: 1.5 * this.scaleFactor,
                    y: 1.5 * this.scaleFactor
                }, 450, Phaser.Easing.Back.InOut), a.start()
            }, d.prototype.animateButton = function() {
                a.Utils.isOnDevice(this.game) || (this.game.tweens.remove(this.buttonTween), this.playButton.scale.set(this.scaleFactor), this.playButton.visible = !0, this.buttonTween = this.game.add.tween(this.playButton.scale), this.buttonTween.to({
                    x: 1.14 * this.scaleFactor,
                    y: 1.14 * this.scaleFactor
                }, 420, Phaser.Easing.Quadratic.InOut, !0, 500), this.buttonTween.yoyo(!0).onComplete.add(this.animateButton, this), this.buttonTween.start())
            }, d.prototype.update = function() {
                this.background.update()
            }, d.prototype.loadUpdate = function() {
                this.background.update()
            }, d.prototype.resize = function() {
                this.scaleFactor = this.getScale(), this.background.resize(this.scaleFactor), this.resizeObjects(), this.created && this.preloadReady && this.animateButton()
            }, d.prototype.shutdown = function() {
                c.prototype.shutdown.call(this), this.logo.destroy(!0), this.monster1.destroy(!0), this.monster2.destroy(!0), this.monster3.destroy(!0), this.playButton.destroy(!0), this.background.destroy(!0), this.preloadText.destroy(!0), this.logo = null, this.monster1 = null, this.monster2 = null, this.monster3 = null, this.playButton = null, this.background = null, this.preloadText = null, this.config = null, this.game.scale.onSizeChange.remove(this.resize, this), this.game.load.onLoadStart.remove(this.onPreloadStart, this), this.game.load.onFileComplete.remove(this.onPreloadedFile, this), this.game.load.onLoadComplete.remove(this.onPreloadEnd, this), this.game.state.remove(b.Preloader.Name), this.game.state.remove(b.SplashPreloader.Name), this.game.state.remove(this.name)
            }, d
        }(Phaser.State);
        c.Name = "funnySplashScreen", c.IdealWidth = 463, c.MaxDots = 3, b.FunnyGames = c
    }(b = a.SplashScreen || (a.SplashScreen = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(b) {
        var c = function(c) {
            function d() {
                var a = c.call(this) || this;
                return a.name = d.Name, a.scaleFactor = 1, a.created = !1, a.preloadReady = !1, a.clicked = !1, a.dots = 1, a.dotText = ".", a.tId = 0, a
            }
            return __extends(d, c), d.prototype.init = function(a, b) {
                this.config = a, this.background = b, this.game.scale.onSizeChange.add(this.resize, this), this.game.add.existing(this.background)
            }, d.prototype.preload = function() {
                this.createObjects(), this.scaleFactor = this.getScale(), this.resizeObjects(), this.startAnimation(), this.game.load.onLoadStart.add(this.onPreloadStart, this), this.game.load.onFileComplete.add(this.onPreloadedFile, this), this.game.load.onLoadComplete.add(this.onPreloadEnd, this), this.config.preloadHandler(), 0 === this.game.load.totalQueuedFiles() && this.onPreloadEnd()
            }, d.prototype.onPreloadStart = function() {}, d.prototype.onPreloadedFile = function() {}, d.prototype.onPreloadEnd = function() {
                var b = this;
                this.preloadReady = !0, a.Utils.isOnDevice(this.game) || this.game.device.desktop ? this.game.time.events.add(Phaser.Timer.SECOND, function() {
                    void 0 !== b.config.mobilePlayClickhandler ? b.config.mobilePlayClickhandler() : b.game.state.start(b.config.nextState)
                }) : (this.game.input.onDown.add(function(a) {
                    b.clicked || (b.clicked = !0, void 0 !== b.config.mobilePlayClickhandler ? b.config.mobilePlayClickhandler() : b.playClick(), b.game.input.onDown.remove(b.playClick, b))
                }, this), this.animateButton())
            }, d.prototype.createObjects = function() {
                var a = this;
                this.clouds = this.game.add.sprite(0, 50, "kizi_splash_clouds"), this.clouds.scale.set(this.game.width / this.clouds.width), this.clouds.alpha = .5, this.monster = this.game.add.sprite(this.game.width / 2, this.game.height / 2, "kizi_splash_spritesheet"), this.monster.animations.add("load"), this.monster.animations.play("load", 6, !0), this.monster.scale.set(1.5), this.monster.anchor.set(.5), this.playButton = this.game.add.button(this.game.width / 2, .75 * this.game.height, "kizi_button", function() {
                    a.clicked || (a.clicked = !0, void 0 !== a.config.mobilePlayClickhandler ? a.config.mobilePlayClickhandler() : a.playClick(), a.game.input.onDown.remove(a.playClick, a))
                }, this, 0, 0, 1, 0), this.playButton.anchor.set(.5), this.playButton.scale.set(this.scaleFactor), this.playButton.visible = !1, this.created = !0
            }, d.prototype.resizeObjects = function() {
                this.created && (a.Utils.isOnDevice(this.game) || (this.playButton.x = this.game.width / 2, this.playButton.y = .75 * this.game.height))
            }, d.prototype.playClick = function() {
                var a = this;
                this.game.tweens.remove(this.buttonTween);
                var b = this.game.add.tween(this.playButton.scale);
                b.to({
                    x: 0,
                    y: 0
                }, 350, Phaser.Easing.Back.In).onComplete.add(function() {
                    a.game.state.start(a.config.nextState)
                }), b.start()
            }, d.prototype.getScale = function() {
                return a.Utils.isOnDevice(this.game) ? this.game.width < 1.5 * b.FunnyGames.IdealWidth ? this.game.width / 6 * 4 / b.FunnyGames.IdealWidth : 1 : this.game.width < this.game.height ? this.game.width / 6 * 4 / b.FunnyGames.IdealWidth : this.game.width / 6 * 3 / b.FunnyGames.IdealWidth
            }, d.prototype.startAnimation = function() {}, d.prototype.animateButton = function() {
                a.Utils.isOnDevice(this.game) || (this.game.tweens.remove(this.buttonTween), this.playButton.scale.set(this.scaleFactor), this.playButton.visible = !0, this.buttonTween = this.game.add.tween(this.playButton.scale), this.buttonTween.to({
                    x: 1.14 * this.scaleFactor,
                    y: 1.14 * this.scaleFactor
                }, 420, Phaser.Easing.Quadratic.InOut, !0, 500), this.buttonTween.yoyo(!0).onComplete.add(this.animateButton, this), this.buttonTween.start())
            }, d.prototype.update = function() {}, d.prototype.loadUpdate = function() {}, d.prototype.resize = function() {
                this.scaleFactor = this.getScale(), this.background.resize(this.scaleFactor), this.resizeObjects(), this.created && this.preloadReady && this.animateButton()
            }, d.prototype.shutdown = function() {
                this.game.scale.onSizeChange.remove(this.resize, this), this.game.load.onLoadStart.remove(this.onPreloadStart, this), this.game.load.onFileComplete.remove(this.onPreloadedFile, this), this.game.load.onLoadComplete.remove(this.onPreloadEnd, this)
            }, d
        }(Phaser.State);
        c.Name = "kiziSplashScreen", c.IdealWidth = 463, c.MaxDots = 3, b.Kizi = c
    }(b = a.SplashScreen || (a.SplashScreen = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(b) {
        var c = function(c) {
            function d() {
                var a = c.call(this) || this;
                return a.name = d.Name, a.scaleFactor = 1, a.created = !1, a.preloadReady = !1, a.clicked = !1, a.dots = 1, a.dotText = ".", a.tId = 0, a
            }
            return __extends(d, c), d.prototype.init = function(a, b) {
                this.config = a, this.background = b, this.game.scale.onSizeChange.add(this.resize, this)
            }, d.prototype.preload = function() {
                this.game.add.existing(this.background), this.createObjects(), this.scaleFactor = this.getScale(), this.resizeObjects(), this.startAnimation(), this.game.load.onLoadStart.add(this.onPreloadStart, this), this.game.load.onFileComplete.add(this.onPreloadedFile, this), this.game.load.onLoadComplete.add(this.onPreloadEnd, this), this.config.preloadHandler(), 0 === this.game.load.totalQueuedFiles() && this.onPreloadEnd()
            }, d.prototype.onPreloadStart = function() {}, d.prototype.onPreloadedFile = function() {}, d.prototype.onPreloadEnd = function() {
                var b = this;
                this.preloadReady = !0, this.loadBack.visible = !1, this.loadBar.visible = !1, a.Utils.isOnDevice(this.game) || this.game.device.desktop ? this.game.time.events.add(Phaser.Timer.SECOND, function() {
                    void 0 !== b.config.mobilePlayClickhandler ? b.config.mobilePlayClickhandler() : b.game.state.start(b.config.nextState)
                }) : (this.game.input.onDown.add(function(a) {
                    b.clicked || (b.clicked = !0, void 0 !== b.config.mobilePlayClickhandler ? b.config.mobilePlayClickhandler() : b.playClick(), b.game.input.onDown.remove(b.playClick, b))
                }, this), this.animateButton())
            }, d.prototype.createObjects = function() {
                var a = this;
                this.loadBack = this.game.add.sprite(this.game.width / 2, this.game.height / 2, "loader"), this.loadBack.anchor.set(.5);
                var b = this.game.make.graphics(0, 0);
                b.beginFill(16777215, 1).drawRoundedRect(0, 0, 350, 20, 5).endFill(), this.loadBar = this.game.add.sprite(this.game.width / 2 - 175, this.game.height / 2 - 5, b.generateTexture()), this.loadBar.anchor.set(0, .5), this.load.setPreloadSprite(this.loadBar), this.playButton = this.game.add.button(this.game.width / 2, this.game.height / 2, "fgs_play", function() {
                    a.clicked || (a.clicked = !0, void 0 !== a.config.mobilePlayClickhandler ? a.config.mobilePlayClickhandler() : a.playClick(), a.game.input.onDown.remove(a.playClick, a))
                }, this, 0, 0, 1, 0), this.playButton.anchor.set(.5), this.playButton.scale.set(this.scaleFactor), this.playButton.visible = !1, this.created = !0
            }, d.prototype.resizeObjects = function() {
                this.created && (a.Utils.isOnDevice(this.game) || (this.playButton.x = this.game.width / 2, this.playButton.y = this.game.height / 2))
            }, d.prototype.playClick = function() {
                var a = this;
                this.game.tweens.remove(this.buttonTween);
                var b = this.game.add.tween(this.playButton.scale);
                b.to({
                    x: 0,
                    y: 0
                }, 350, Phaser.Easing.Back.In).onComplete.add(function() {
                    a.game.state.start(a.config.nextState)
                }), b.start()
            }, d.prototype.getScale = function() {
                return a.Utils.isOnDevice(this.game) ? this.game.width < 1.5 * b.FunnyGames.IdealWidth ? this.game.width / 6 * 4 / b.FunnyGames.IdealWidth : 1 : this.game.width < this.game.height ? this.game.width / 6 * 4 / b.FunnyGames.IdealWidth : this.game.width / 6 * 3 / b.FunnyGames.IdealWidth
            }, d.prototype.startAnimation = function() {}, d.prototype.animateButton = function() {
                a.Utils.isOnDevice(this.game) || (this.game.tweens.remove(this.buttonTween), this.playButton.scale.set(this.scaleFactor), this.playButton.visible = !0, this.buttonTween = this.game.add.tween(this.playButton.scale), this.buttonTween.to({
                    x: 1.14 * this.scaleFactor,
                    y: 1.14 * this.scaleFactor
                }, 420, Phaser.Easing.Quadratic.InOut, !0, 500), this.buttonTween.yoyo(!0).onComplete.add(this.animateButton, this), this.buttonTween.start())
            }, d.prototype.update = function() {
                this.background.update()
            }, d.prototype.loadUpdate = function() {
                this.background.update()
            }, d.prototype.resize = function() {
                this.scaleFactor = this.getScale(), this.background.resize(this.scaleFactor), this.resizeObjects(), this.created && this.preloadReady && this.animateButton()
            }, d.prototype.shutdown = function() {
                this.game.scale.onSizeChange.remove(this.resize, this), this.game.load.onLoadStart.remove(this.onPreloadStart, this), this.game.load.onFileComplete.remove(this.onPreloadedFile, this), this.game.load.onLoadComplete.remove(this.onPreloadEnd, this), this.loadBack.destroy(!0), this.loadBar.destroy(!0), this.playButton.destroy(!0), this.background.destroy(!0), this.loadBack = null, this.loadBar = null, this.playButton = null, this.background = null, this.game.state.remove(b.Preloader.Name), this.game.state.remove(b.SplashPreloader.Name), this.game.state.remove(this.name)
            }, d
        }(Phaser.State);
        c.Name = "neutralSplashScreen", c.IdealWidth = 463, c.MaxDots = 3, b.Neutral = c
    }(b = a.SplashScreen || (a.SplashScreen = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(a) {
        var b = function(b) {
            function c() {
                var a = b.call(this) || this;
                return a.name = c.Name, a.scaleFactor = 1, a.created = !1, a.preloadTexts = [], a.preloadReady = !1, a.dots = 1, a.dotText = ".", a.clicked = !1, a.tId = 0, a
            }
            return __extends(c, b), c.prototype.init = function(a, b) {
                this.config = a, this.background = b, this.config.preloadTexts && (this.preloadTexts = this.config.preloadTexts), this.game.scale.onSizeChange.add(this.resize, this)
            }, c.prototype.preload = function() {
                this.game.add.existing(this.background), this.createObjects(), this.scaleFactor = this.getScale(), this.resizeObjects(), this.startAnimation(), this.game.load.onLoadStart.add(this.onPreloadStart, this), this.game.load.onFileComplete.add(this.onPreloadedFile, this), this.game.load.onLoadComplete.add(this.onPreloadEnd, this), this.config.preloadHandler(), 0 === this.game.load.totalQueuedFiles() && this.onPreloadEnd()
            }, c.prototype.onPreloadStart = function() {
                this.t = Date.now(), this.preloadText.setText("Spelletje wordt geladen")
            }, c.prototype.onPreloadedFile = function() {
                Date.now() - this.t > 2e3 && (this.t = Date.now(), this.tId++, this.tId >= this.preloadTexts.length && (this.tId = 0)), this.dotText.length >= 3 ? this.dotText = "." : this.dotText += ".", this.preloadText.setText("Spelletje wordt geladen")
            }, c.prototype.onPreloadEnd = function() {
                var a = this;
                this.preloadReady = !0, this.preloadText.visible = !1, this.game.device.desktop ? this.game.time.events.add(Phaser.Timer.SECOND, function() {
                    void 0 !== a.config.mobilePlayClickhandler ? a.config.mobilePlayClickhandler() : a.game.state.start(a.config.nextState)
                }) : (this.game.input.onDown.add(function() {
                    a.clicked || (a.clicked = !0, void 0 !== a.config.mobilePlayClickhandler ? a.config.mobilePlayClickhandler() : a.playClick(), a.game.input.onDown.remove(a.playClick, a))
                }, this), this.animateButton())
            }, c.prototype.createObjects = function() {
                var a = this;
                this.spine = this.game.add.spine(0, 0, "ss_splash"), this.preloadText = this.game.add.text(this.game.width / 2, this.game.height / 2 + 150, "", {
                    font: "Arial",
                    fontSize: 40,
                    fill: "#ffffff",
                    fontWeight: "bold"
                }), this.preloadText.anchor.set(.5), this.playButton = this.game.add.image(this.game.width / 2, this.game.height / 2 + 55 * this.scaleFactor, "ss_play"), this.playButton.anchor.set(.5), this.playButton.scale.set(this.scaleFactor), this.playButton.visible = !1, this.playButton.inputEnabled = !0, this.playButton.events.onInputUp.add(function() {
                    a.clicked || (a.clicked = !0, void 0 !== a.config.mobilePlayClickhandler ? a.config.mobilePlayClickhandler() : a.playClick(), a.game.input.onDown.remove(a.playClick, a))
                }), this.created = !0
            }, c.prototype.resizeObjects = function() {
                this.created && (this.spine.x = this.game.width / 2, this.spine.y = this.game.height / 2, this.spine.scale.set(this.scaleFactor), this.preloadText.x = this.game.width / 2, this.preloadText.y = this.game.height / 2 + 150 * this.scaleFactor, this.preloadText.scale.set(this.scaleFactor), this.game.device.desktop || (this.playButton.x = this.game.width / 2, this.playButton.y = this.game.height / 2 + 55 * this.scaleFactor))
            }, c.prototype.playClick = function() {
                var a = this;
                this.game.tweens.remove(this.buttonTween);
                var b = this.game.add.tween(this.playButton.scale);
                b.to({
                    x: 0,
                    y: 0
                }, 350, Phaser.Easing.Back.In).onComplete.add(function() {
                    a.game.state.start(a.config.nextState)
                }), b.start(), this.game.input.onDown.remove(this.playClick, this)
            }, c.prototype.getScale = function() {
                return this.game.device.desktop ? this.game.width < 1.5 * a.FunnyGames.IdealWidth ? this.game.width / 6 * 4 / a.FunnyGames.IdealWidth : 1 : this.game.width < this.game.height ? this.game.width / 6 * 4 / a.FunnyGames.IdealWidth : this.game.width / 6 * 3 / a.FunnyGames.IdealWidth
            }, c.prototype.startAnimation = function() {
                this.game.sound.touchLocked || this.game.sound.play("cheer"), this.spine.setAnimationByName(0, "animation", !1)
            }, c.prototype.animateButton = function() {
                this.game.device.desktop || (this.game.tweens.remove(this.buttonTween), this.playButton.scale.set(this.scaleFactor), this.playButton.visible = !0, this.buttonTween = this.game.add.tween(this.playButton.scale), this.buttonTween.to({
                    x: 1.14 * this.scaleFactor,
                    y: 1.14 * this.scaleFactor
                }, 420, Phaser.Easing.Quadratic.InOut, !0, 500), this.buttonTween.yoyo(!0).onComplete.add(this.animateButton, this), this.buttonTween.start())
            }, c.prototype.update = function() {
                this.background.update()
            }, c.prototype.loadUpdate = function() {
                this.background.update()
            }, c.prototype.resize = function() {
                this.scaleFactor = this.getScale(), this.background.resize(this.scaleFactor), this.resizeObjects(), this.created && this.preloadReady && this.animateButton()
            }, c.prototype.shutdown = function() {
                b.prototype.shutdown.call(this), this.spine.destroy(!0), this.playButton.destroy(!0), this.background.destroy(!0), this.preloadText.destroy(!0), this.spine = null, this.playButton = null, this.background = null, this.preloadText = null, this.game.scale.onSizeChange.remove(this.resize, this), this.game.load.onLoadStart.remove(this.onPreloadStart, this), this.game.load.onFileComplete.remove(this.onPreloadedFile, this), this.game.load.onLoadComplete.remove(this.onPreloadEnd, this), this.game.state.remove(a.Preloader.Name), this.game.state.remove(a.SplashPreloader.Name), this.game.state.remove(this.name)
            }, c
        }(Phaser.State);
        b.Name = "speleSplashScreen", b.IdealWidth = 463, b.MaxDots = 3, a.Spele = b
    }(b = a.SplashScreen || (a.SplashScreen = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b;
    ! function(a) {
        var b = function(b) {
            function c() {
                var a = b.call(this) || this;
                return a.name = c.Name, a.scaleFactor = 1, a.created = !1, a.tiles = [], a.preloadReady = !1, a.balls = [], a.clicked = !1, a.tId = 0, a.dt = Date.now(), a.ddt = Date.now(), a
            }
            return __extends(c, b), c.prototype.init = function(a, b) {
                this.config = a, this.background = b, this.game.scale.onSizeChange.add(this.resize, this), this.gradientBitmap = this.game.make.bitmapData(this.game.width, this.game.height)
            }, c.prototype.preload = function() {
                this.game.add.existing(this.background), this.createObjects(), this.scaleFactor = this.getScale(), this.resizeObjects(), this.startAnimation(), this.game.load.onLoadStart.add(this.onPreloadStart, this), this.game.load.onFileComplete.add(this.onPreloadedFile, this), this.game.load.onLoadComplete.add(this.onPreloadEnd, this), this.config.preloadHandler(), 0 === this.game.load.totalQueuedFiles() && this.onPreloadEnd()
            }, c.prototype.onPreloadStart = function() {
                this.t = Date.now()
            }, c.prototype.onPreloadedFile = function() {}, c.prototype.onPreloadEnd = function() {
                this.preloadReady = !0, this.animateButton()
            }, c.prototype.createObjects = function() {
                for (var a = 0; a < 70; a++) {
                    var b = Math.random() < .5 ? "square_empty" : "square_game_" + ("0" + (32 * Math.random() + 1 | 0)).slice(-2),
                        c = this.game.add.image(this.game.width / 2 + (80 * (a % 10) - 400), this.game.height / 2 + (80 * Math.floor(a / 10) - 280), "yp_atlas", b + ".png");
                    c.alpha = .4, this.tiles.push(c)
                }
                this.gradient = this.game.add.sprite(0, 0, this.gradientBitmap), this.spine = this.game.add.spine(0, 0, "yp_splash"), this.spine.setMixByName("flyin", "idle", .2), this.spine.visible = !1, this.logo = this.game.add.sprite(0, 0, "yp_atlas", "yepi_logo.png"), this.logo.alignIn(this.world.bounds, Phaser.TOP_CENTER, 0, -20), this.created = !0;
                var d = this.game.make.graphics(0, 0);
                d.beginFill(16631558, 1).drawCircle(0, 0, 20).endFill();
                for (var a = 0; a < 3; a++) {
                    var e = this.game.add.sprite(0, 0, d.generateTexture());
                    e.alignIn(this.game.world.bounds, Phaser.BOTTOM_CENTER, -50 + 50 * a, -20), e.scale.set(0), e.anchor.set(.5), this.balls.push(e), this.game.add.tween(e.scale).to({
                        x: 1,
                        y: 1
                    }, 900, "Linear", !0, 300 * a, -1).yoyo(!0).delay(300)
                }
            }, c.prototype.resizeObjects = function() {
                var a = this;
                if (this.created) {
                    this.gradientBitmap.resize(this.game.width, this.game.height), this.gradientBitmap.context.clearRect(0, 0, this.game.width, this.game.height);
                    var b = this.gradientBitmap.context.createRadialGradient(this.game.width / 2, this.game.height / 2, 0, this.game.width / 2, this.game.height / 2, this.game.height / 1.8);
                    b.addColorStop(0, "rgba(0, 81, 125, 0)"), b.addColorStop(1, "rgba(0, 81, 125, 1)"), this.gradientBitmap.context.fillStyle = b, this.gradientBitmap.context.fillRect(0, 0, this.game.width, this.game.height), this.spine.x = this.game.width / 2, this.spine.y = this.game.height / 2, this.spine.scale.set(this.scaleFactor), this.logo.scale.set(this.scaleFactor), this.logo.alignIn(this.world.bounds, Phaser.TOP_CENTER, 0, -20), this.tiles.forEach(function(b, c) {
                        b.x = a.game.width / 2 + (80 * (c % 10) - 400), b.y = a.game.height / 2 + (80 * Math.floor(c / 10) - 280)
                    })
                }
            }, c.prototype.playClick = function() {
                this.game.state.start(this.config.nextState)
            }, c.prototype.getScale = function() {
                return this.game.width < this.game.height ? this.game.width / 6 * 4 / a.FunnyGames.IdealWidth : this.game.width / 6 * 3 / a.FunnyGames.IdealWidth
            }, c.prototype.startAnimation = function() {}, c.prototype.animateButton = function() {
                var a = this;
                this.spine.visible = !0, this.spine.setAnimationByName(0, "flyin", !1), this.spine.addAnimationByName(0, "idle", !0, 0), this.game.tweens.removeAll(), this.balls.forEach(function(a) {
                    a.parent.removeChild(a), a.destroy(!0)
                }), this.game.input.onUp.add(function() {
                    a.clicked || (a.clicked = !0, void 0 !== a.config.mobilePlayClickhandler ? a.config.mobilePlayClickhandler() : a.playClick(), a.game.input.onDown.remove(a.playClick, a))
                })
            }, c.prototype.update = function() {
                var a = Date.now() - this.dt;
                a > 200 && (this.tweenRandomItem(), this.dt = Date.now())
            }, c.prototype.loadUpdate = function() {
                var a = Date.now() - this.ddt;
                a > 200 && (this.ddt = Date.now(), this.tweenRandomItem())
            }, c.prototype.tweenRandomItem = function() {
                var a = this.tiles[Math.random() * this.tiles.length | 0];
                this.game.add.tween(a).to({
                    alpha: 1
                }, 1e3, Phaser.Easing.Linear.None, !0, 0, 0, !0)
            }, c.prototype.resize = function() {
                this.scaleFactor = this.getScale(), this.background.resize(this.scaleFactor), this.resizeObjects()
            }, c.prototype.shutdown = function() {
                b.prototype.shutdown.call(this), this.spine.destroy(!0), this.background.destroy(!0), this.tiles.forEach(function(a) {
                    a.destroy(!0)
                }), this.gradientBitmap.destroy(), this.gradient.destroy(!0), this.logo.destroy(!0), this.balls.forEach(function(a) {
                    a.destroy(!0)
                }), this.spine = null, this.playButton = null, this.background = null, this.gradientBitmap = null, this.gradient = null, this.logo = null, this.tiles = null, this.balls = null, this.game.scale.onSizeChange.remove(this.resize, this), this.game.load.onLoadStart.remove(this.onPreloadStart, this), this.game.load.onFileComplete.remove(this.onPreloadedFile, this), this.game.load.onLoadComplete.remove(this.onPreloadEnd, this), this.game.state.remove(a.Preloader.Name), this.game.state.remove(a.SplashPreloader.Name), this.game.state.remove(this.name)
            }, c
        }(Phaser.State);
        b.Name = "yepiSplashScreen", b.IdealWidth = 463, b.MaxDots = 3, a.Yepi = b
    }(b = a.SplashScreen || (a.SplashScreen = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b = null,
        c = function() {
            function a() {}
            return a.has = function(a) {
                var c = a.lastIndexOf(".");
                if (c <= 0 || c >= a.length - 1) return !1;
                var d = a.lastIndexOf(".", c - 1);
                if (d <= 0 || d >= c - 1) return !1;
                var e = b[a.slice(c + 1)];
                return !!e && e.indexOf(" " + a.slice(d + 1, c) + " ") >= 0
            }, a.is = function(a) {
                var c = a.lastIndexOf(".");
                if (c <= 0 || c >= a.length - 1) return !1;
                var d = a.lastIndexOf(".", c - 1);
                if (d >= 0) return !1;
                var e = b[a.slice(c + 1)];
                return !!e && e.indexOf(" " + a.slice(0, c) + " ") >= 0
            }, a.get = function(a) {
                var c = a.lastIndexOf(".");
                if (c <= 0 || c >= a.length - 1) return null;
                var d = a.lastIndexOf(".", c - 1);
                if (d <= 0 || d >= c - 1) return null;
                var e = b[a.slice(c + 1)];
                return e ? e.indexOf(" " + a.slice(d + 1, c) + " ") < 0 ? null : a.slice(d + 1) : null
            }, a
        }(),
        d = function() {
            function a() {}
            return a.setList = function(a) {
                b = a || {}
            }, a.getDomain = function(a) {
                if (null === b) return null;
                var c = a.match(/\./g);
                if (c && c.length < 2) return a;
                var d = a.length - this.getTld(a).length - 1;
                return d = a.lastIndexOf(".", d - 1) + 1, a.substring(d) || ""
            }, a.getTld = function(a) {
                if (null === b) return null;
                var d = a.lastIndexOf("."),
                    e = a.substring(d + 1);
                return b[e.toLowerCase()] ? c.get(a) || e : e
            }, a
        }();
    d.KEY = "Domains", a.Domain = d
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b = function() {
        function b() {}
        return b.getSourceSite = function(c) {
            void 0 === c && (c = !1);
            var d = document.referrer || window.location.host;
            if (c && (d = window.location.host), d = decodeURIComponent(d), a.Branding.isBild()) return "bildspielt.de";
            if (a.Branding.isBip()) return "bipgaming.com";
            a.Branding.isSpil() && (d = b.getReferrer(d)), d = d.indexOf("://") > -1 ? d.split("/")[2] : d.split("/")[0], d = d.split(":")[0];
            var e = a.Domain.getDomain(d);
            return null !== e ? e : (3 === d.split(".").length && (d = d.substr(d.indexOf(".") + 1)), d)
        }, b.getBrandingDomain = function() {
            if (a.SplashScreen.Preloader.SPLASH_OVERRIDE !== !1) return a.SplashScreen.Preloader.SPLASH_OVERRIDE;
            var c = b.getSourceSite();
            switch (c) {
                case "spele.nl":
                    return a.BrandingDomain.Spele;
                case "yepi.com":
                    return a.BrandingDomain.Yepi;
                case "kizi.com":
                    return a.BrandingDomain.Kizi;
                case "bildspielt.de":
                    return a.BrandingDomain.Bild;
                default:
                    return a.BrandingDomain.Funnygames
            }
        }, b.getReferrer = function(a) {
            return a.indexOf("?ref=") !== -1 ? a.substr(a.indexOf("?ref=") + 5) : a
        }, b.inIframe = function() {
           
        }, b.getDomain = function(a) {
            var b = document.createElement("a");
            return b.href = a, b.origin
        }, b.isOnDevice = function(a) {
            return !(!a.device.cordova && !a.device.crosswalk  )
        }, b.isTc = function() {
            return 1
        }, b.getRandomRange = function(a, b) {
            return Math.random() * (b - a) + a | 0
        }, b.intTimeToString = function(a) {
            var b = Math.floor(a / 3600),
                c = Math.floor(a % 3600 / 60),
                d = a % 60,
                e = b < 10 ? "0" + b : b.toString(),
                f = c < 10 ? "0" + c : c.toString(),
                g = d < 10 ? "0" + d : d.toString();
            return e + ":" + f + ":" + g
        }, b
    }();
    b.ASSET_LOCATION = "./assets/", a.Utils = b
}(Fabrique || (Fabrique = {}));
var CryptoJS = CryptoJS || function(a, b) {
    var c = {},
        d = c.lib = {},
        e = function() {},
        f = d.Base = {
            extend: function(a) {
                e.prototype = this;
                var b = new e;
                return a && b.mixIn(a), b.hasOwnProperty("init") || (b.init = function() {
                    b.$super.init.apply(this, arguments)
                }), b.init.prototype = b, b.$super = this, b
            },
            create: function() {
                var a = this.extend();
                return a.init.apply(a, arguments), a
            },
            init: function() {},
            mixIn: function(a) {
                for (var b in a) a.hasOwnProperty(b) && (this[b] = a[b]);
                a.hasOwnProperty("toString") && (this.toString = a.toString)
            },
            clone: function() {
                return this.init.prototype.extend(this)
            }
        },
        g = d.WordArray = f.extend({
            init: function(a, c) {
                a = this.words = a || [], this.sigBytes = c != b ? c : 4 * a.length
            },
            toString: function(a) {
                return (a || i).stringify(this)
            },
            concat: function(a) {
                var b = this.words,
                    c = a.words,
                    d = this.sigBytes;
                if (a = a.sigBytes, this.clamp(), d % 4)
                    for (var e = 0; a > e; e++) b[d + e >>> 2] |= (c[e >>> 2] >>> 24 - 8 * (e % 4) & 255) << 24 - 8 * ((d + e) % 4);
                else if (65535 < c.length)
                    for (e = 0; a > e; e += 4) b[d + e >>> 2] = c[e >>> 2];
                else b.push.apply(b, c);
                return this.sigBytes += a, this
            },
            clamp: function() {
                var b = this.words,
                    c = this.sigBytes;
                b[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4), b.length = a.ceil(c / 4)
            },
            clone: function() {
                var a = f.clone.call(this);
                return a.words = this.words.slice(0), a
            },
            random: function(b) {
                for (var c = [], d = 0; b > d; d += 4) c.push(4294967296 * a.random() | 0);
                return new g.init(c, b)
            }
        }),
        h = c.enc = {},
        i = h.Hex = {
            stringify: function(a) {
                var b = a.words;
                a = a.sigBytes;
                for (var c = [], d = 0; a > d; d++) {
                    var e = b[d >>> 2] >>> 24 - 8 * (d % 4) & 255;
                    c.push((e >>> 4).toString(16)), c.push((15 & e).toString(16))
                }
                return c.join("")
            },
            parse: function(a) {
                for (var b = a.length, c = [], d = 0; b > d; d += 2) c[d >>> 3] |= parseInt(a.substr(d, 2), 16) << 24 - 4 * (d % 8);
                return new g.init(c, b / 2)
            }
        },
        j = h.Latin1 = {
            stringify: function(a) {
                var b = a.words;
                a = a.sigBytes;
                for (var c = [], d = 0; a > d; d++) c.push(String.fromCharCode(b[d >>> 2] >>> 24 - 8 * (d % 4) & 255));
                return c.join("")
            },
            parse: function(a) {
                for (var b = a.length, c = [], d = 0; b > d; d++) c[d >>> 2] |= (255 & a.charCodeAt(d)) << 24 - 8 * (d % 4);
                return new g.init(c, b)
            }
        },
        k = h.Utf8 = {
            stringify: function(a) {
                try {
                    return decodeURIComponent(escape(j.stringify(a)))
                } catch (a) {
                    throw Error("Malformed UTF-8 data")
                }
            },
            parse: function(a) {
                return j.parse(unescape(encodeURIComponent(a)))
            }
        },
        l = d.BufferedBlockAlgorithm = f.extend({
            reset: function() {
                this._data = new g.init, this._nDataBytes = 0
            },
            _append: function(a) {
                "string" == typeof a && (a = k.parse(a)), this._data.concat(a), this._nDataBytes += a.sigBytes
            },
            _process: function(b) {
                var c = this._data,
                    d = c.words,
                    e = c.sigBytes,
                    f = this.blockSize,
                    h = e / (4 * f),
                    h = b ? a.ceil(h) : a.max((0 | h) - this._minBufferSize, 0);
                if (b = h * f, e = a.min(4 * b, e), b) {
                    for (var i = 0; b > i; i += f) this._doProcessBlock(d, i);
                    i = d.splice(0, b), c.sigBytes -= e
                }
                return new g.init(i, e)
            },
            clone: function() {
                var a = f.clone.call(this);
                return a._data = this._data.clone(), a
            },
            _minBufferSize: 0
        });
    d.Hasher = l.extend({
        cfg: f.extend(),
        init: function(a) {
            this.cfg = this.cfg.extend(a), this.reset()
        },
        reset: function() {
            l.reset.call(this), this._doReset()
        },
        update: function(a) {
            return this._append(a), this._process(), this
        },
        finalize: function(a) {
            return a && this._append(a), this._doFinalize()
        },
        blockSize: 16,
        _createHelper: function(a) {
            return function(b, c) {
                return new a.init(c).finalize(b)
            }
        },
        _createHmacHelper: function(a) {
            return function(b, c) {
                return new m.HMAC.init(a, c).finalize(b)
            }
        }
    });
    var m = c.algo = {};
    return c
}(Math);
! function(a) {
    for (var b = CryptoJS, c = b.lib, d = c.WordArray, e = c.Hasher, c = b.algo, f = [], g = [], h = function(a) {
        return 4294967296 * (a - (0 | a)) | 0
    }, i = 2, j = 0; 64 > j;) {
        var k;
        a: {
            k = i;
            for (var l = a.sqrt(k), m = 2; l >= m; m++)
                if (!(k % m)) {
                    k = !1;
                    break a
                }
            k = !0
        }
        k && (8 > j && (f[j] = h(a.pow(i, .5))), g[j] = h(a.pow(i, 1 / 3)), j++), i++
    }
    var n = [],
        c = c.SHA256 = e.extend({
            _doReset: function() {
                this._hash = new d.init(f.slice(0))
            },
            _doProcessBlock: function(a, b) {
                for (var c = this._hash.words, d = c[0], e = c[1], f = c[2], h = c[3], i = c[4], j = c[5], k = c[6], l = c[7], m = 0; 64 > m; m++) {
                    if (16 > m) n[m] = 0 | a[b + m];
                    else {
                        var o = n[m - 15],
                            p = n[m - 2];
                        n[m] = ((o << 25 | o >>> 7) ^ (o << 14 | o >>> 18) ^ o >>> 3) + n[m - 7] + ((p << 15 | p >>> 17) ^ (p << 13 | p >>> 19) ^ p >>> 10) + n[m - 16]
                    }
                    o = l + ((i << 26 | i >>> 6) ^ (i << 21 | i >>> 11) ^ (i << 7 | i >>> 25)) + (i & j ^ ~i & k) + g[m] + n[m], p = ((d << 30 | d >>> 2) ^ (d << 19 | d >>> 13) ^ (d << 10 | d >>> 22)) + (d & e ^ d & f ^ e & f), l = k, k = j, j = i, i = h + o | 0, h = f, f = e, e = d, d = o + p | 0
                }
                c[0] = c[0] + d | 0, c[1] = c[1] + e | 0, c[2] = c[2] + f | 0, c[3] = c[3] + h | 0, c[4] = c[4] + i | 0, c[5] = c[5] + j | 0, c[6] = c[6] + k | 0, c[7] = c[7] + l | 0
            },
            _doFinalize: function() {
                var b = this._data,
                    c = b.words,
                    d = 8 * this._nDataBytes,
                    e = 8 * b.sigBytes;
                return c[e >>> 5] |= 128 << 24 - e % 32, c[(e + 64 >>> 9 << 4) + 14] = a.floor(d / 4294967296), c[(e + 64 >>> 9 << 4) + 15] = d, b.sigBytes = 4 * c.length, this._process(), this._hash
            },
            clone: function() {
                var a = e.clone.call(this);
                return a._hash = this._hash.clone(), a
            }
        });
    b.SHA256 = e._createHelper(c), b.HmacSHA256 = e._createHmacHelper(c)
}(Math),
function() {
    var a = CryptoJS,
        b = a.enc.Utf8;
    a.algo.HMAC = a.lib.Base.extend({
        init: function(a, c) {
            a = this._hasher = new a.init, "string" == typeof c && (c = b.parse(c));
            var d = a.blockSize,
                e = 4 * d;
            c.sigBytes > e && (c = a.finalize(c)), c.clamp();
            for (var f = this._oKey = c.clone(), g = this._iKey = c.clone(), h = f.words, i = g.words, j = 0; d > j; j++) h[j] ^= 1549556828, i[j] ^= 909522486;
            f.sigBytes = g.sigBytes = e, this.reset()
        },
        reset: function() {
            var a = this._hasher;
            a.reset(), a.update(this._iKey)
        },
        update: function(a) {
            return this._hasher.update(a), this
        },
        finalize: function(a) {
            var b = this._hasher;
            return a = b.finalize(a), b.reset(), b.finalize(this._oKey.clone().concat(a))
        }
    })
}(),
function() {
    var a = CryptoJS,
        b = a.lib.WordArray;
    a.enc.Base64 = {
        stringify: function(a) {
            var b = a.words,
                c = a.sigBytes,
                d = this._map;
            a.clamp(), a = [];
            for (var e = 0; c > e; e += 3)
                for (var f = (b[e >>> 2] >>> 24 - 8 * (e % 4) & 255) << 16 | (b[e + 1 >>> 2] >>> 24 - 8 * ((e + 1) % 4) & 255) << 8 | b[e + 2 >>> 2] >>> 24 - 8 * ((e + 2) % 4) & 255, g = 0; 4 > g && c > e + .75 * g; g++) a.push(d.charAt(f >>> 6 * (3 - g) & 63));
            if (b = d.charAt(64))
                for (; a.length % 4;) a.push(b);
            return a.join("")
        },
        parse: function(a) {
            var c = a.length,
                d = this._map,
                e = d.charAt(64);
            e && (e = a.indexOf(e), -1 != e && (c = e));
            for (var e = [], f = 0, g = 0; c > g; g++)
                if (g % 4) {
                    var h = d.indexOf(a.charAt(g - 1)) << 2 * (g % 4),
                        i = d.indexOf(a.charAt(g)) >>> 6 - 2 * (g % 4);
                    e[f >>> 2] |= (h | i) << 24 - 8 * (f % 4), f++
                }
            return b.create(e, f)
        },
        _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
    }
}();
var GA;
! function(a) {
    ! function(a) {
        a[a.ios = 0] = "ios", a[a.android = 1] = "android", a[a.windows = 2] = "windows", a[a.windows_phone = 3] = "windows_phone", a[a.blackberry = 4] = "blackberry", a[a.roku = 5] = "roku", a[a.tizen = 6] = "tizen", a[a.nacl = 7] = "nacl", a[a.mac_osx = 8] = "mac_osx", a[a.webplayer = 9] = "webplayer"
    }(a.Platform || (a.Platform = {})), a.Platform, ! function(a) {
        a[a.male = 0] = "male", a[a.female = 1] = "female"
    }(a.Gender || (a.Gender = {})), a.Gender
}(GA || (GA = {}));
var GA;
! function(a) {
    var b;
    ! function(a) {
        var b = /^[A-Za-z0-9\\s\\-_\\.\\(\\)\\!\\?]{1,64}:[A-Za-z0-9\\s\\-_\\.\\(\\)\\!\\?]{1,64}$/,
            c = function() {
                function a(a, c, d, e, f, g) {
                    if (this.category = 1, this.transaction_num = 0, !a || null === a.match(b)) throw new Error("Invalid event_id supplied for BusinessEvent");
                    if (this.event_id = a, this.amount = c, !d || null === d.match(/^[A-Z]{3}$/)) throw new Error("Invalid currency supplied for BusinessEvent");
                    if (this.currency = d, this.transaction_num = e, f) {
                        if (f.length > 32) throw new Error("A too long cart_type was supplied, should be max 32 characters");
                        this.cart_type = f
                    }
                    void 0 !== g && (this.receipt_info = g)
                }
                return a
            }();
        a.Business = c
    }(b = a.Events || (a.Events = {}))
}(GA || (GA = {}));
var GA;
! function(a) {
    var b;
    ! function(a) {
        var b = /^[A-Za-z0-9\\s\\-_\\.\\(\\)\\!\\?]{1,64}(:[A-Za-z0-9\\s\\-_\\.\\(\\)\\!\\?]{1,64}){0,4}$/,
            c = function() {
                function a(a, c) {
                    if (this.category = 0, null === a.match(b)) throw new Error("Invalid event_id supplied for DesignEvent");
                    this.event_id = a, void 0 !== c && (this.value = c)
                }
                return a
            }();
        a.Design = c
    }(b = a.Events || (a.Events = {}))
}(GA || (GA = {}));
var GA;
! function(a) {
    var b;
    ! function(a) {
        ! function(a) {
            a[a.design = 0] = "design", a[a.business = 1] = "business", a[a.error = 2] = "error", a[a.user = 3] = "user", a[a.session_end = 4] = "session_end", a[a.progression = 5] = "progression", a[a.resource = 6] = "resource"
        }(a.Category || (a.Category = {})), a.Category
    }(b = a.Events || (a.Events = {}))
}(GA || (GA = {}));
var GA;
! function(a) {
    var b;
    ! function(a) {
        ! function(a) {
            a[a.debug = 0] = "debug", a[a.info = 1] = "info", a[a.warning = 2] = "warning", a[a.error = 3] = "error", a[a.critical = 4] = "critical"
        }(a.ErrorSeverity || (a.ErrorSeverity = {}));
        var b = a.ErrorSeverity,
            c = function() {
                function a(a, c) {
                    this.category = 2, this.message = "", this.severity = b[a], void 0 !== c && (this.message = c.substr(0, 8192))
                }
                return a
            }();
        a.Exception = c
    }(b = a.Events || (a.Events = {}))
}(GA || (GA = {}));
var GA;
! function(a) {
    var b;
    ! function(a) {
        var b = function() {
            function a() {}
            return a
        }();
        a.InitResponse = b;
        var c = function() {
            function a(a) {
                this.data = a
            }
            return a.prototype.toString = function() {
                return JSON.stringify(this.data)
            }, a
        }();
        a.Init = c
    }(b = a.Events || (a.Events = {}))
}(GA || (GA = {}));
var GA;
! function(a) {
    var b;
    ! function(a) {
        var b = /^(Start|Fail|Complete):[A-Za-z0-9\\s\\-_\\.\\(\\)\\!\\?]{1,64}(:[A-Za-z0-9\\s\\-_\\.\\(\\)\\!\\?]{1,64}){0,2}$/,
            c = function() {
                function a(a, c, d) {
                    if (this.category = 5, null === a.match(b)) throw new Error("Invalid event_id supplied for ProgressionEvent");
                    this.event_id = a, void 0 !== c && (this.attempt_num = c), void 0 !== d && (this.score = d)
                }
                return a
            }();
        a.Progression = c
    }(b = a.Events || (a.Events = {}))
}(GA || (GA = {}));
var GA;
! function(a) {
    var b;
    ! function(a) {
        var b = /^(Sink|Source):[A-Za-z]{1,64}:[A-Za-z0-9\\s\\-_\\.\\(\\)\\!\\?]{1,64}:[A-Za-z0-9\\s\\-_\\.\\(\\)\\!\\?]{1,64}/,
            c = function() {
                function a(a, c) {
                    if (this.category = 6, null === a.match(b)) throw new Error("Invalid event_id supplied for ResourceEvent");
                    this.event_id = a, this.amount = c
                }
                return a
            }();
        a.Resource = c
    }(b = a.Events || (a.Events = {}))
}(GA || (GA = {}));
var GA;
! function(a) {
    var b;
    ! function(a) {
        var b = function() {
            function a(a) {
                this.category = 4, this.length = 0, this.length = a
            }
            return a
        }();
        a.SessionEnd = b
    }(b = a.Events || (a.Events = {}))
}(GA || (GA = {}));
var GA;
! function(a) {
    var b;
    ! function(a) {
        var b = function() {
            function a() {
                this.category = 3
            }
            return a
        }();
        a.User = b
    }(b = a.Events || (a.Events = {}))
}(GA || (GA = {}));
var GA;
! function(a) {
    function b() {
        return null === c.instance && (c.instance = new c), c.instance
    }
    a.getInstance = b;
    var c = function() {
        function b() {
            this.sessionId = a.Utils.createUniqueId(), this.messageQueue = new a.Utils.MessageQueue, this.enabled = !1, this.initProcessed = !1, this.timeoutId = 0, this.timeOffset = 0
        }
        return b.prototype.init = function(c, d, e, f) {
            var g = this;
            if (null === b.instance) throw new Error("No instance Available!");
            this.gameKey = c, this.secretKey = d, this.build = e, this.user = f, this.incrementSessionNum(f);
            var h = new a.Events.Init(a.Utils.getBaseAnnotations());
            return this.sendEvent(h.toString(), "init", function(a) {
                g.initProcessed = !0, a.enabled === !0 && (g.enabled = !0, g.timeOffset = (Date.now() / 1e3 | 0) - a.server_ts)
            }), this.scheduleSendData(b.SCHEDULE_TIME), window.addEventListener("beforeunload", function() {
                g.sendData()
            }), this
        }, b.prototype.incrementSessionNum = function(b) {
            var c = a.Utils.LocalStorage.getItem(b.user_id);
            c ? a.Utils.LocalStorage.setItem(b.user_id, (parseInt(c) + 1).toString()) : (c = "1", a.Utils.LocalStorage.setItem(b.user_id, c))
        }, b.prototype.addEvent = function(c) {
            if (null === b.instance) throw new Error("No instance Available!");
            var d = new a.Utils.Message(c, a.Utils.getDefaultAnnotations(this.user, this.sessionId, this.build, this.timeOffset));
            return this.messageQueue.push(d), this
        }, b.prototype.sendData = function() {
            if (this.initProcessed === !1) return this.scheduleSendData(1e3), this;
            if (this.enabled === !1) return this;
            if (null === b.instance) throw new Error("No instance Available!");
            for (var a = [], c = ""; this.messageQueue.length > 0;) {
                var d = this.messageQueue.pop();
                a.push(d.data)
            }
            if (0 === a.length) return this.scheduleSendData(b.SCHEDULE_TIME), this;
            try {
                c = JSON.stringify(a)
            } catch (a) {}
            return this.sendEvent(c, "events"), this.scheduleSendData(b.SCHEDULE_TIME), this
        }, b.prototype.scheduleSendData = function(a) {
            var b = this;
            clearTimeout(this.timeoutId), this.timeoutId = setTimeout(function() {
                b.sendData()
            }, a)
        }, b.prototype.sendEvent = function(c, d, e) {
            if (void 0 === e && (e = null), null === b.instance && null === this.gameKey) throw new Error("No instance Available!");
            if (!(c.length < 1)) {
                var f = CryptoJS.HmacSHA256(c, this.secretKey),
                    g = CryptoJS.enc.Base64.stringify(f),
                    h = b.API_URL + this.gameKey + "/" + d;
                a.Utils.postRequest(h, c, g, function(a) {
                    if (a.success === !1 && window.console && void 0, null != e) {
                        var b = "";
                        try {
                            b = JSON.parse(a.message)
                        } catch (a) {}
                        e(b)
                    }
                })
            }
        }, b.SCHEDULE_TIME = 15e3, b.SDK_VERSION = "rest api v2", b.API_URL = ("https:" === document.location.protocol ? "." : ".") + "/v2/", b.instance = null, b
    }();
    a.GameAnalytics = c
}(GA || (GA = {}));
var GA;
! function(a) {
    var b = function() {
        function b(b, c, d, e) {
            if (this.user_id = "", b) this.user_id = b;
            else {
                var f = a.Utils.LocalStorage.getItem("user");
                this.user_id = f || a.Utils.createUniqueUserId()
            }
            c && c.length > 0 && (this.facebook_id = c, this.user_id = c), a.Utils.LocalStorage.setItem("user", this.user_id), 1 !== d && 0 !== d || (this.gender = d), e && e.toString().match(/^[0-9]{4}$/gi) && (this.birth_year = e)
        }
        return b
    }();
    a.User = b
}(GA || (GA = {}));
var GA;
! function(a) {
    var b;
    ! function(b) {
        function c(b, c, d, f) {
            var g = {
                sdk_version: a.GameAnalytics.SDK_VERSION,
                platform: a.Platform[2],
                os_version: a.Platform[2] + " 8",
                device: "unknown",
                v: 2,
                user_id: b.user_id,
                client_ts: (Date.now() / 1e3 | 0) + f,
                manufacturer: "unknown",
                session_id: c,
                session_num: e(b.user_id),
                build: d
            };
            b.facebook_id && (g.facebook_id = b.facebook_id), 0 !== b.gender && 1 !== b.gender || (g.gender = a.Gender[b.gender]), b.birth_year && (g.birth_year = b.birth_year);
            var h = navigator.userAgent;
            return h.match(/iPad|iPod|iPhone/i) ? (g.platform = a.Platform[0], g.device = h.match(/iPad|iPod|iPhone/i)[0], g.manufacturer = "Apple", g.os_version = a.Platform[0] + " " + h.match(/OS (\b[0-9]+_[0-9]+(?:_[0-9]+)?\b)/)[1].replace(/_/gi, ".")) : h.match(/Android/i) ? (g.platform = a.Platform[1], g.device = h.match(/Mobile/i) ? "Phone" : "Tablet", g.os_version = a.Platform[1] + " " + h.match(/Android (\d+(?:\.\d+)+);/)[1]) : h.match(/Windows Phone/i) && (g.platform = a.Platform[2], g.device = "Windows Phone", g.os_version = a.Platform[2] + " " + h.match(/Phone (\d+(?:\.\d+)+);/)[1]), g
        }

        function d() {
            var b = {
                    sdk_version: a.GameAnalytics.SDK_VERSION,
                    platform: "unknown",
                    os_version: "unknown"
                },
                c = navigator.userAgent;
            return c.match(/iPad|iPod|iPhone/i) ? (b.platform = a.Platform[0], b.os_version = a.Platform[0] + " " + c.match(/OS (\b[0-9]+_[0-9]+(?:_[0-9]+)?\b)/)[1].replace(/_/gi, ".")) : c.match(/Android/i) ? (b.platform = a.Platform[1], b.os_version = a.Platform[1] + " " + c.match(/Android (\d+(?:\.\d+)+);/)[1]) : c.match(/Windows Phone/i) && (b.platform = a.Platform[2], b.os_version = a.Platform[2] + " " + c.match(/Phone (\d+(?:\.\d+)+);/)[1]), b
        }

        function e(a) {
            var c = b.LocalStorage.getItem(a);
            return c ? parseInt(c) : 1
        }
        b.getDefaultAnnotations = c, b.getBaseAnnotations = d
    }(b = a.Utils || (a.Utils = {}))
}(GA || (GA = {}));
var GA;
! function(a) {
    var b;
    ! function(a) {
        var b = function() {
            function a() {}
            return a.getItem = function(b) {
                return a.Available ? localStorage.getItem(a.CacheKey + b) : void 0
            }, a.setItem = function(b, c) {
                a.Available && localStorage.setItem(a.CacheKey + b, c)
            }, a.Available = !1, a.CacheKey = "GA:", a
        }();
        a.LocalStorage = b;
        try {
            "object" == typeof localStorage && (localStorage.setItem("testingLocalStorage", "yes"), localStorage.removeItem("testingLocalStorage"), b.Available = !0)
        } catch (a) {}
    }(b = a.Utils || (a.Utils = {}))
}(GA || (GA = {}));
var GA;
! function(a) {
    var b;
    ! function(b) {
        var c = function() {
            function b(a, b) {
                this.event = a, this.annotations = b
            }
            return Object.defineProperty(b.prototype, "data", {
                get: function() {
                    for (var b in this.event) this.event.hasOwnProperty(b) && ("category" === b ? this.annotations[b] = a.Events.Category[this.event[b]] : this.annotations[b] = this.event[b]);
                    return this.annotations
                },
                enumerable: !0,
                configurable: !0
            }), b
        }();
        b.Message = c
    }(b = a.Utils || (a.Utils = {}))
}(GA || (GA = {}));
var GA;
! function(a) {
    var b;
    ! function(a) {
        var b = function() {
            function a() {
                this.queue = [], this.load()
            }
            return a.prototype.push = function(a) {
                this.queue.push(a)
            }, a.prototype.pop = function() {
                return this.queue.pop()
            }, Object.defineProperty(a.prototype, "length", {
                get: function() {
                    return this.queue.length
                },
                enumerable: !0,
                configurable: !0
            }), a.prototype.save = function() {}, a.prototype.load = function() {}, a
        }();
        a.MessageQueue = b
    }(b = a.Utils || (a.Utils = {}))
}(GA || (GA = {}));
var GA;
! function(a) {
    var b;
    ! function(a) {
        function b(a, b, c, d) {
            var e;
            if (!window.XMLHttpRequest) return void d({
                success: !1,
                message: "Error: Unable to send request, XMLHttpRequest not supported"
            });
            e = new XMLHttpRequest, e.onreadystatechange = function() {
                4 == e.readyState && (200 === e.status ? d({
                    success: !0,
                    message: e.responseText
                }) : e.status > 0 && d({
                    success: !1,
                    message: "Error: There was a problem with the request: status " + e.status
                }))
            };
            try {
                e.open("POST", a, !0), e.setRequestHeader("Authorization", c), e.setRequestHeader("Content-Type", "application/json"), e.send(b)
            } catch (a) {
                d({
                    success: !1,
                    message: "Error: Unable to send request, CORS not allowed."
                })
            }
        }
        var c = function() {
            function a() {
                this.success = !1, this.message = ""
            }
            return a
        }();
        a.Response = c, a.postRequest = b
    }(b = a.Utils || (a.Utils = {}))
}(GA || (GA = {}));
var GA;
! function(a) {
    var b;
    ! function(a) {
        function b() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(a) {
                var b = 16 * Math.random() | 0,
                    c = "x" == a ? b : 3 & b | 8;
                return c.toString(16)
            })
        }

        function c() {
            return b()
        }
        a.createUniqueId = b, a.createUniqueUserId = c
    }(b = a.Utils || (a.Utils = {}))
}(GA || (GA = {})),
function() {
    function a(a, b, c) {
        return a.call.apply(a.bind, arguments)
    }

    function b(a, b, c) {
        if (!a) throw Error();
        if (2 < arguments.length) {
            var d = Array.prototype.slice.call(arguments, 2);
            return function() {
                var c = Array.prototype.slice.call(arguments);
                return Array.prototype.unshift.apply(c, d), a.apply(b, c)
            }
        }
        return function() {
            return a.apply(b, arguments)
        }
    }

    function c(d, e, f) {
        return c = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? a : b, c.apply(null, arguments)
    }

    function d(a, b) {
        this.a = a, this.o = b || a, this.c = this.o.document
    }

    function e(a, b, c, d) {
        if (b = a.c.createElement(b), c)
            for (var e in c) c.hasOwnProperty(e) && ("style" == e ? b.style.cssText = c[e] : b.setAttribute(e, c[e]));
        return d && b.appendChild(a.c.createTextNode(d)), b
    }

    function f(a, b, c) {
        a = a.c.getElementsByTagName(b)[0], a || (a = document.documentElement), a.insertBefore(c, a.lastChild)
    }

    function g(a) {
        a.parentNode && a.parentNode.removeChild(a)
    }

    function h(a, b, c) {
        b = b || [], c = c || [];
        for (var d = a.className.split(/\s+/), e = 0; e < b.length; e += 1) {
            for (var f = !1, g = 0; g < d.length; g += 1)
                if (b[e] === d[g]) {
                    f = !0;
                    break
                }
            f || d.push(b[e])
        }
        for (b = [], e = 0; e < d.length; e += 1) {
            for (f = !1, g = 0; g < c.length; g += 1)
                if (d[e] === c[g]) {
                    f = !0;
                    break
                }
            f || b.push(d[e])
        }
        a.className = b.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "")
    }

    function i(a, b) {
        for (var c = a.className.split(/\s+/), d = 0, e = c.length; d < e; d++)
            if (c[d] == b) return !0;
        return !1
    }

    function j(a) {
        return a.o.location.hostname || a.a.location.hostname
    }

    function k(a, b, c) {
        function d() {
            j && g && h && (j(i), j = null)
        }
        b = e(a, "link", {
            rel: "stylesheet",
            href: b,
            media: "all"
        });
        var g = !1,
            h = !0,
            i = null,
            j = c || null;
        ba ? (b.onload = function() {
            g = !0, d()
        }, b.onerror = function() {
            g = !0, i = Error("Stylesheet failed to load"), d()
        }) : setTimeout(function() {
            g = !0, d()
        }, 0), f(a, "head", b)
    }

    function l(a, b, c, d) {
        var f = a.c.getElementsByTagName("head")[0];
        if (f) {
            var g = e(a, "script", {
                    src: b
                }),
                h = !1;
            return g.onload = g.onreadystatechange = function() {
                h || this.readyState && "loaded" != this.readyState && "complete" != this.readyState || (h = !0, c && c(null), g.onload = g.onreadystatechange = null, "HEAD" == g.parentNode.tagName && f.removeChild(g))
            }, f.appendChild(g), setTimeout(function() {
                h || (h = !0, c && c(Error("Script load timeout")))
            }, d || 5e3), g
        }
        return null
    }

    function m() {
        this.a = 0, this.c = null
    }

    function n(a) {
        return a.a++,
            function() {
                a.a--, p(a)
            }
    }

    function o(a, b) {
        a.c = b, p(a)
    }

    function p(a) {
        0 == a.a && a.c && (a.c(), a.c = null)
    }

    function q(a) {
        this.a = a || "-"
    }

    function r(a, b) {
        this.c = a, this.f = 4, this.a = "n";
        var c = (b || "n4").match(/^([nio])([1-9])$/i);
        c && (this.a = c[1], this.f = parseInt(c[2], 10))
    }

    function s(a) {
        return v(a) + " " + (a.f + "00") + " 300px " + t(a.c)
    }

    function t(a) {
        var b = [];
        a = a.split(/,\s*/);
        for (var c = 0; c < a.length; c++) {
            var d = a[c].replace(/['"]/g, ""); - 1 != d.indexOf(" ") || /^\d/.test(d) ? b.push("'" + d + "'") : b.push(d)
        }
        return b.join(",")
    }

    function u(a) {
        return a.a + a.f
    }

    function v(a) {
        var b = "normal";
        return "o" === a.a ? b = "oblique" : "i" === a.a && (b = "italic"), b
    }

    function w(a) {
        var b = 4,
            c = "n",
            d = null;
        return a && ((d = a.match(/(normal|oblique|italic)/i)) && d[1] && (c = d[1].substr(0, 1).toLowerCase()), (d = a.match(/([1-9]00|normal|bold)/i)) && d[1] && (/bold/i.test(d[1]) ? b = 7 : /[1-9]00/.test(d[1]) && (b = parseInt(d[1].substr(0, 1), 10)))), c + b
    }

    function x(a, b) {
        this.c = a, this.f = a.o.document.documentElement, this.h = b, this.a = new q("-"), this.j = !1 !== b.events, this.g = !1 !== b.classes
    }

    function y(a) {
        a.g && h(a.f, [a.a.c("wf", "loading")]), A(a, "loading")
    }

    function z(a) {
        if (a.g) {
            var b = i(a.f, a.a.c("wf", "active")),
                c = [],
                d = [a.a.c("wf", "loading")];
            b || c.push(a.a.c("wf", "inactive")), h(a.f, c, d)
        }
        A(a, "inactive")
    }

    function A(a, b, c) {
        a.j && a.h[b] && (c ? a.h[b](c.c, u(c)) : a.h[b]())
    }

    function B() {
        this.c = {}
    }

    function C(a, b, c) {
        var d, e = [];
        for (d in b)
            if (b.hasOwnProperty(d)) {
                var f = a.c[d];
                f && e.push(f(b[d], c))
            }
        return e
    }

    function D(a, b) {
        this.c = a, this.f = b, this.a = e(this.c, "span", {
            "aria-hidden": "true"
        }, this.f)
    }

    function E(a) {
        f(a.c, "body", a.a)
    }

    function F(a) {
        return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + t(a.c) + ";" + ("font-style:" + v(a) + ";font-weight:" + (a.f + "00") + ";")
    }

    function G(a, b, c, d, e, f) {
        this.g = a, this.j = b, this.a = d, this.c = c, this.f = e || 3e3, this.h = f || void 0
    }

    function H(a, b, c, d, e, f, g) {
        this.v = a, this.B = b, this.c = c, this.a = d, this.s = g || "BESbswy", this.f = {}, this.w = e || 3e3, this.u = f || null, this.m = this.j = this.h = this.g = null, this.g = new D(this.c, this.s), this.h = new D(this.c, this.s), this.j = new D(this.c, this.s), this.m = new D(this.c, this.s), a = new r(this.a.c + ",serif", u(this.a)), a = F(a), this.g.a.style.cssText = a, a = new r(this.a.c + ",sans-serif", u(this.a)), a = F(a), this.h.a.style.cssText = a, a = new r("serif", u(this.a)), a = F(a), this.j.a.style.cssText = a, a = new r("sans-serif", u(this.a)), a = F(a), this.m.a.style.cssText = a, E(this.g), E(this.h), E(this.j), E(this.m)
    }

    function I() {
        if (null === da) {
            var a = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
            da = !!a && (536 > parseInt(a[1], 10) || 536 === parseInt(a[1], 10) && 11 >= parseInt(a[2], 10))
        }
        return da
    }

    function J(a, b, c) {
        for (var d in ca)
            if (ca.hasOwnProperty(d) && b === a.f[ca[d]] && c === a.f[ca[d]]) return !0;
        return !1
    }

    function K(a) {
        var b, c = a.g.a.offsetWidth,
            d = a.h.a.offsetWidth;
        (b = c === a.f.serif && d === a.f["sans-serif"]) || (b = I() && J(a, c, d)), b ? aa() - a.A >= a.w ? I() && J(a, c, d) && (null === a.u || a.u.hasOwnProperty(a.a.c)) ? M(a, a.v) : M(a, a.B) : L(a) : M(a, a.v)
    }

    function L(a) {
        setTimeout(c(function() {
            K(this)
        }, a), 50)
    }

    function M(a, b) {
        setTimeout(c(function() {
            g(this.g.a), g(this.h.a), g(this.j.a), g(this.m.a), b(this.a)
        }, a), 0)
    }

    function N(a, b, c) {
        this.c = a, this.a = b, this.f = 0, this.m = this.j = !1, this.s = c
    }

    function O(a) {
        0 == --a.f && a.j && (a.m ? (a = a.a, a.g && h(a.f, [a.a.c("wf", "active")], [a.a.c("wf", "loading"), a.a.c("wf", "inactive")]), A(a, "active")) : z(a.a))
    }

    function P(a) {
        this.j = a, this.a = new B, this.h = 0, this.f = this.g = !0
    }

    function Q(a, b, d, e, f) {
        var g = 0 == --a.h;
        (a.f || a.g) && setTimeout(function() {
            var a = f || null,
                i = e || null || {};
            if (0 === d.length && g) z(b.a);
            else {
                b.f += d.length, g && (b.j = g);
                var j, k = [];
                for (j = 0; j < d.length; j++) {
                    var l = d[j],
                        m = i[l.c],
                        n = b.a,
                        o = l;
                    if (n.g && h(n.f, [n.a.c("wf", o.c, u(o).toString(), "loading")]), A(n, "fontloading", o), n = null, null === ea)
                        if (window.FontFace) {
                            var o = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),
                                p = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
                            ea = o ? 42 < parseInt(o[1], 10) : !p
                        } else ea = !1;
                    n = ea ? new G(c(b.g, b), c(b.h, b), b.c, l, b.s, m) : new H(c(b.g, b), c(b.h, b), b.c, l, b.s, a, m), k.push(n)
                }
                for (j = 0; j < k.length; j++) k[j].start()
            }
        }, 0)
    }

    function R(a, b, c) {
        var d = [],
            e = c.timeout;
        y(b);
        var d = C(a.a, c, a.c),
            f = new N(a.c, b, e);
        for (a.h = d.length, b = 0, c = d.length; b < c; b++) d[b].load(function(b, c, d) {
            Q(a, f, b, c, d)
        })
    }

    function S(a, b) {
        this.c = a, this.a = b
    }

    function T(a, b) {
        this.c = a, this.a = b
    }

    function U(a, b) {
        a ? this.c = a : this.c = fa, this.a = [], this.f = [], this.g = b || ""
    }

    function V(a, b) {
        for (var c = b.length, d = 0; d < c; d++) {
            var e = b[d].split(":");
            3 == e.length && a.f.push(e.pop());
            var f = "";
            2 == e.length && "" != e[1] && (f = ":"), a.a.push(e.join(f))
        }
    }

    function W(a) {
        if (0 == a.a.length) throw Error("No fonts to load!");
        if (-1 != a.c.indexOf("kit=")) return a.c;
        for (var b = a.a.length, c = [], d = 0; d < b; d++) c.push(a.a[d].replace(/ /g, "+"));
        return b = a.c + "?family=" + c.join("%7C"), 0 < a.f.length && (b += "&subset=" + a.f.join(",")), 0 < a.g.length && (b += "&text=" + encodeURIComponent(a.g)), b
    }

    function X(a) {
        this.f = a, this.a = [], this.c = {}
    }

    function Y(a) {
        for (var b = a.f.length, c = 0; c < b; c++) {
            var d = a.f[c].split(":"),
                e = d[0].replace(/\+/g, " "),
                f = ["n4"];
            if (2 <= d.length) {
                var g, h = d[1];
                if (g = [], h)
                    for (var h = h.split(","), i = h.length, j = 0; j < i; j++) {
                        var k;
                        if (k = h[j], k.match(/^[\w-]+$/)) {
                            var l = ja.exec(k.toLowerCase());
                            if (null == l) k = "";
                            else {
                                if (k = l[2], k = null == k || "" == k ? "n" : ia[k], l = l[1], null == l || "" == l) l = "4";
                                else var m = ha[l],
                                    l = m ? m : isNaN(l) ? "4" : l.substr(0, 1);
                                k = [k, l].join("")
                            }
                        } else k = "";
                        k && g.push(k)
                    }
                0 < g.length && (f = g), 3 == d.length && (d = d[2], g = [], d = d ? d.split(",") : g, 0 < d.length && (d = ga[d[0]]) && (a.c[e] = d))
            }
            for (a.c[e] || (d = ga[e]) && (a.c[e] = d), d = 0; d < f.length; d += 1) a.a.push(new r(e, f[d]))
        }
    }

    function Z(a, b) {
        this.c = a, this.a = b
    }

    function $(a, b) {
        this.c = a, this.a = b
    }

    function _(a, b) {
        this.c = a, this.f = b, this.a = []
    }
    var aa = Date.now || function() {
            return +new Date
        },
        ba = !!window.FontFace;
    q.prototype.c = function(a) {
        for (var b = [], c = 0; c < arguments.length; c++) b.push(arguments[c].replace(/[\W_]+/g, "").toLowerCase());
        return b.join(this.a)
    }, G.prototype.start = function() {
        var a = this.c.o.document,
            b = this,
            c = aa(),
            d = new Promise(function(d, e) {
                function f() {
                    aa() - c >= b.f ? e() : a.fonts.load(s(b.a), b.h).then(function(a) {
                        1 <= a.length ? d() : setTimeout(f, 25)
                    }, function() {
                        e()
                    })
                }
                f()
            }),
            e = null,
            f = new Promise(function(a, c) {
                e = setTimeout(c, b.f)
            });
        Promise.race([f, d]).then(function() {
            e && (clearTimeout(e), e = null), b.g(b.a)
        }, function() {
            b.j(b.a)
        })
    };
    var ca = {
            D: "serif",
            C: "sans-serif"
        },
        da = null;
    H.prototype.start = function() {
        this.f.serif = this.j.a.offsetWidth, this.f["sans-serif"] = this.m.a.offsetWidth, this.A = aa(), K(this)
    };
    var ea = null;
    N.prototype.g = function(a) {
        var b = this.a;
        b.g && h(b.f, [b.a.c("wf", a.c, u(a).toString(), "active")], [b.a.c("wf", a.c, u(a).toString(), "loading"), b.a.c("wf", a.c, u(a).toString(), "inactive")]), A(b, "fontactive", a), this.m = !0, O(this)
    }, N.prototype.h = function(a) {
        var b = this.a;
        if (b.g) {
            var c = i(b.f, b.a.c("wf", a.c, u(a).toString(), "active")),
                d = [],
                e = [b.a.c("wf", a.c, u(a).toString(), "loading")];
            c || d.push(b.a.c("wf", a.c, u(a).toString(), "inactive")), h(b.f, d, e)
        }
        A(b, "fontinactive", a), O(this)
    }, P.prototype.load = function(a) {
        this.c = new d(this.j, a.context || this.j), this.g = !1 !== a.events, this.f = !1 !== a.classes, R(this, new x(this.c, a), a)
    }, S.prototype.load = function(a) {
        function b() {
            if (f["__mti_fntLst" + d]) {
                var c, e = f["__mti_fntLst" + d](),
                    g = [];
                if (e)
                    for (var h = 0; h < e.length; h++) {
                        var i = e[h].fontfamily;
                        void 0 != e[h].fontStyle && void 0 != e[h].fontWeight ? (c = e[h].fontStyle + e[h].fontWeight, g.push(new r(i, c))) : g.push(new r(i))
                    }
                a(g)
            } else setTimeout(function() {
                b()
            }, 50)
        }
        var c = this,
            d = c.a.projectId,
            e = c.a.version;
        if (d) {
            var f = c.c.o;
            l(this.c, (c.a.api || "https://fast.fonts.net/jsapi") + "/" + d + ".js" + (e ? "?v=" + e : ""), function(e) {
                e ? a([]) : (f["__MonotypeConfiguration__" + d] = function() {
                    return c.a
                }, b())
            }).id = "__MonotypeAPIScript__" + d
        } else a([])
    }, T.prototype.load = function(a) {
        var b, c, d = this.a.urls || [],
            e = this.a.families || [],
            f = this.a.testStrings || {},
            g = new m;
        for (b = 0, c = d.length; b < c; b++) k(this.c, d[b], n(g));
        var h = [];
        for (b = 0, c = e.length; b < c; b++)
            if (d = e[b].split(":"), d[1])
                for (var i = d[1].split(","), j = 0; j < i.length; j += 1) h.push(new r(d[0], i[j]));
            else h.push(new r(d[0]));
        o(g, function() {
            a(h, f)
        })
    };
    var fa = "https://fonts.googleapis.com/css",
        ga = {
            latin: "BESbswy",
            "latin-ext": "çöüğş",
            cyrillic: "йяЖ",
            greek: "αβΣ",
            khmer: "កខគ",
            Hanuman: "កខគ"
        },
        ha = {
            thin: "1",
            extralight: "2",
            "extra-light": "2",
            ultralight: "2",
            "ultra-light": "2",
            light: "3",
            regular: "4",
            book: "4",
            medium: "5",
            "semi-bold": "6",
            semibold: "6",
            "demi-bold": "6",
            demibold: "6",
            bold: "7",
            "extra-bold": "8",
            extrabold: "8",
            "ultra-bold": "8",
            ultrabold: "8",
            black: "9",
            heavy: "9",
            l: "3",
            r: "4",
            b: "7"
        },
        ia = {
            i: "i",
            italic: "i",
            n: "n",
            normal: "n"
        },
        ja = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/,
        ka = {
            Arimo: !0,
            Cousine: !0,
            Tinos: !0
        };
    Z.prototype.load = function(a) {
        var b = new m,
            c = this.c,
            d = new U(this.a.api, this.a.text),
            e = this.a.families;
        V(d, e);
        var f = new X(e);
        Y(f), k(c, W(d), n(b)), o(b, function() {
            a(f.a, f.c, ka)
        })
    }, $.prototype.load = function(a) {
        var b = this.a.id,
            c = this.c.o;
        b ? l(this.c, (this.a.api || "https://use.typekit.net") + "/" + b + ".js", function(b) {
            if (b) a([]);
            else if (c.Typekit && c.Typekit.config && c.Typekit.config.fn) {
                b = c.Typekit.config.fn;
                for (var d = [], e = 0; e < b.length; e += 2)
                    for (var f = b[e], g = b[e + 1], h = 0; h < g.length; h++) d.push(new r(f, g[h]));
                try {
                    c.Typekit.load({
                        events: !1,
                        classes: !1,
                        async: !0
                    })
                } catch (i) {}
                a(d)
            }
        }, 2e3) : a([])
    }, _.prototype.load = function(a) {
        var b = this.f.id,
            c = this.c.o,
            d = this;
        b ? (c.__webfontfontdeckmodule__ || (c.__webfontfontdeckmodule__ = {}), c.__webfontfontdeckmodule__[b] = function(b, c) {
            for (var e = 0, f = c.fonts.length; e < f; ++e) {
                var g = c.fonts[e];
                d.a.push(new r(g.name, w("font-weight:" + g.weight + ";font-style:" + g.style)))
            }
            a(d.a)
        }, l(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + j(this.c) + "/" + b + ".js", function(b) {
            b && a([])
        })) : a([])
    };
    var la = new P(window);
    la.a.c.custom = function(a, b) {
        return new T(b, a)
    }, la.a.c.fontdeck = function(a, b) {
        return new _(b, a)
    }, la.a.c.monotype = function(a, b) {
        return new S(b, a)
    }, la.a.c.typekit = function(a, b) {
        return new $(b, a)
    }, la.a.c.google = function(a, b) {
        return new Z(b, a)
    };
    var ma = {
        load: c(la.load, la)
    };
    "function" == typeof define && define.amd ? define(function() {
        return ma
    }) : "undefined" != typeof module && module.exports ? module.exports = ma : (window.WebFont = ma, window.WebFontConfig && la.load(window.WebFontConfig))
}();
var $global = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this,
    $hxClasses = $hxClasses || {},
    $estr = function() {
        return js.Boot.__string_rec(this, "")
    },
    EReg = $hxClasses.EReg = function(a, b) {
        this.r = new RegExp(a, b.split("u").join(""))
    };
EReg.__name__ = ["EReg"], EReg.prototype = {
    r: null,
    match: function(a) {
        return this.r.global && (this.r.lastIndex = 0), this.r.m = this.r.exec(a), this.r.s = a, null != this.r.m
    },
    matched: function(a) {
        if (null != this.r.m && a >= 0 && a < this.r.m.length) return this.r.m[a];
        throw new js._Boot.HaxeError("EReg::matched")
    },
    __class__: EReg
};
var HxOverrides = $hxClasses.HxOverrides = function() {};
HxOverrides.__name__ = ["HxOverrides"], HxOverrides.cca = function(a, b) {
    var c = a.charCodeAt(b);
    if (c == c) return c
}, HxOverrides.substr = function(a, b, c) {
    if (null == c) c = a.length;
    else if (c < 0) {
        if (0 != b) return "";
        c = a.length + c
    }
    return a.substr(b, c)
}, HxOverrides.remove = function(a, b) {
    var c = a.indexOf(b);
    return c != -1 && (a.splice(c, 1), !0)
}, HxOverrides.iter = function(a) {
    return {
        cur: 0,
        arr: a,
        hasNext: function() {
            return this.cur < this.arr.length
        },
        next: function() {
            return this.arr[this.cur++]
        }
    }
}, Math.__name__ = ["Math"];
var Reflect = $hxClasses.Reflect = function() {};
Reflect.__name__ = ["Reflect"], Reflect.field = function(a, b) {
    try {
        return a[b]
    } catch (c) {
        return null
    }
}, Reflect.setField = function(a, b, c) {
    a[b] = c
}, Reflect.getProperty = function(a, b) {
    var c;
    if (null == a) return null;
    var d;
    return a.__properties__ ? (c = a.__properties__["get_" + b], d = c) : d = !1, d ? a[c]() : a[b]
}, Reflect.setProperty = function(a, b, c) {
    var d, e;
    a.__properties__ ? (d = a.__properties__["set_" + b], e = d) : e = !1, e ? a[d](c) : a[b] = c
}, Reflect.fields = function(a) {
    var b = [];
    if (null != a) {
        var c = Object.prototype.hasOwnProperty;
        for (var d in a) "__id__" != d && "hx__closures__" != d && c.call(a, d) && b.push(d)
    }
    return b
}, Reflect.isFunction = function(a) {
    return "function" == typeof a && !(a.__name__ || a.__ename__)
};
var Std = $hxClasses.Std = function() {};
Std.__name__ = ["Std"], Std.is = function(a, b) {
    return js.Boot.__instanceof(a, b)
}, Std.string = function(a) {
    return js.Boot.__string_rec(a, "")
}, Std.parseInt = function(a) {
    var b = parseInt(a, 10);
    return 0 != b || 120 != HxOverrides.cca(a, 1) && 88 != HxOverrides.cca(a, 1) || (b = parseInt(a)), isNaN(b) ? null : b
}, Std.parseFloat = function(a) {
    return parseFloat(a)
};
var StringTools = $hxClasses.StringTools = function() {};
StringTools.__name__ = ["StringTools"], StringTools.isSpace = function(a, b) {
    var c = HxOverrides.cca(a, b);
    return c > 8 && c < 14 || 32 == c
}, StringTools.ltrim = function(a) {
    for (var b = a.length, c = 0; c < b && StringTools.isSpace(a, c);)++c;
    return c > 0 ? HxOverrides.substr(a, c, b - c) : a
}, StringTools.rtrim = function(a) {
    for (var b = a.length, c = 0; c < b && StringTools.isSpace(a, b - c - 1);)++c;
    return c > 0 ? HxOverrides.substr(a, 0, b - c) : a
}, StringTools.trim = function(a) {
    return StringTools.ltrim(StringTools.rtrim(a))
}, StringTools.replace = function(a, b, c) {
    return a.split(b).join(c)
};
var ValueType = $hxClasses.ValueType = {
    __ename__: ["ValueType"],
    __constructs__: ["TNull", "TInt", "TFloat", "TBool", "TObject", "TFunction", "TClass", "TEnum", "TUnknown"]
};
ValueType.TNull = ["TNull", 0], ValueType.TNull.toString = $estr, ValueType.TNull.__enum__ = ValueType, ValueType.TInt = ["TInt", 1], ValueType.TInt.toString = $estr, ValueType.TInt.__enum__ = ValueType, ValueType.TFloat = ["TFloat", 2], ValueType.TFloat.toString = $estr, ValueType.TFloat.__enum__ = ValueType, ValueType.TBool = ["TBool", 3], ValueType.TBool.toString = $estr, ValueType.TBool.__enum__ = ValueType, ValueType.TObject = ["TObject", 4], ValueType.TObject.toString = $estr, ValueType.TObject.__enum__ = ValueType, ValueType.TFunction = ["TFunction", 5], ValueType.TFunction.toString = $estr, ValueType.TFunction.__enum__ = ValueType, ValueType.TClass = function(a) {
    var b = ["TClass", 6, a];
    return b.__enum__ = ValueType, b.toString = $estr, b
}, ValueType.TEnum = function(a) {
    var b = ["TEnum", 7, a];
    return b.__enum__ = ValueType, b.toString = $estr, b
}, ValueType.TUnknown = ["TUnknown", 8], ValueType.TUnknown.toString = $estr, ValueType.TUnknown.__enum__ = ValueType;
var Type = $hxClasses.Type = function() {};
Type.__name__ = ["Type"], Type.getEnum = function(a) {
    return null == a ? null : a.__enum__
}, Type.getClassName = function(a) {
    var b = a.__name__;
    return null == b ? null : b.join(".")
}, Type.getEnumName = function(a) {
    var b = a.__ename__;
    return b.join(".")
}, Type.resolveClass = function(a) {
    var b = $hxClasses[a];
    return null != b && b.__name__ ? b : null
}, Type.resolveEnum = function(a) {
    var b = $hxClasses[a];
    return null != b && b.__ename__ ? b : null
}, Type.createInstance = function(a, b) {
    var c = b.length;
    switch (c) {
        case 0:
            return new a;
        case 1:
            return new a(b[0]);
        case 2:
            return new a(b[0], b[1]);
        case 3:
            return new a(b[0], b[1], b[2]);
        case 4:
            return new a(b[0], b[1], b[2], b[3]);
        case 5:
            return new a(b[0], b[1], b[2], b[3], b[4]);
        case 6:
            return new a(b[0], b[1], b[2], b[3], b[4], b[5]);
        case 7:
            return new a(b[0], b[1], b[2], b[3], b[4], b[5], b[6]);
        case 8:
            return new a(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
        case 9:
            return new a(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8]);
        case 10:
            return new a(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8], b[9]);
        case 11:
            return new a(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8], b[9], b[10]);
        case 12:
            return new a(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8], b[9], b[10], b[11]);
        case 13:
            return new a(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8], b[9], b[10], b[11], b[12]);
        case 14:
            return new a(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8], b[9], b[10], b[11], b[12], b[13]);
        default:
            throw new js._Boot.HaxeError("Too many arguments")
    }
}, Type.createEnum = function(a, b, c) {
    var d = Reflect.field(a, b);
    if (null == d) throw new js._Boot.HaxeError("No such constructor " + b);
    if (Reflect.isFunction(d)) {
        if (null == c) throw new js._Boot.HaxeError("Constructor " + b + " need parameters");
        return d.apply(a, c)
    }
    if (null != c && 0 != c.length) throw new js._Boot.HaxeError("Constructor " + b + " does not need parameters");
    return d
}, Type.getInstanceFields = function(a) {
    var b = [];
    for (var c in a.prototype) b.push(c);
    return HxOverrides.remove(b, "__class__"), HxOverrides.remove(b, "__properties__"), b
}, Type["typeof"] = function(a) {
    var b = typeof a;
    switch (b) {
        case "boolean":
            return ValueType.TBool;
        case "function":
            return a.__name__ || a.__ename__ ? ValueType.TObject : ValueType.TFunction;
        case "number":
            return Math.ceil(a) == a % 2147483648 ? ValueType.TInt : ValueType.TFloat;
        case "object":
            if (null == a) return ValueType.TNull;
            var c = a.__enum__;
            if (null != c) return ValueType.TEnum(c);
            var d = js.Boot.getClass(a);
            return null != d ? ValueType.TClass(d) : ValueType.TObject;
        case "string":
            return ValueType.TClass(String);
        case "undefined":
            return ValueType.TNull;
        default:
            return ValueType.TUnknown
    }
};
var _UInt = _UInt || {};
_UInt.UInt_Impl_ = $hxClasses["_UInt.UInt_Impl_"] = {}, _UInt.UInt_Impl_.__name__ = ["_UInt", "UInt_Impl_"], _UInt.UInt_Impl_.toFloat = function(a) {
    var b = a;
    return b < 0 ? 4294967296 + b : b + 0
};
var bikas = bikas || {};
bikas.ExportHaxetypes = $hxClasses["bikas.ExportHaxetypes"] = function() {}, bikas.ExportHaxetypes.__name__ = ["bikas", "ExportHaxetypes"], bikas.ExportHaxetypes.exportHaxeStuff = function() {}, bikas.algorithms || (bikas.algorithms = {}), bikas.algorithms.ProceduralNumberGenerator = $hxClasses["bikas.algorithms.ProceduralNumberGenerator"] = function(a) {
    this.seed = Math.round(2147483647 * a)
}, bikas.algorithms.ProceduralNumberGenerator.__name__ = ["bikas", "algorithms", "ProceduralNumberGenerator"], bikas.algorithms.ProceduralNumberGenerator.prng = function(a) {
    return _UInt.UInt_Impl_.toFloat(16807 * a) % _UInt.UInt_Impl_.toFloat(2147483647) | 0
}, bikas.algorithms.ProceduralNumberGenerator.prototype = {
    seed: null,
    getRandom: function() {
        return this.seed = bikas.algorithms.ProceduralNumberGenerator.prng(this.seed), _UInt.UInt_Impl_.toFloat(this.seed) / _UInt.UInt_Impl_.toFloat(2147483647)
    },
    getRandomBetween: function(a, b) {
        return this.seed = bikas.algorithms.ProceduralNumberGenerator.prng(this.seed), a + (b - a) * (_UInt.UInt_Impl_.toFloat(this.seed) / _UInt.UInt_Impl_.toFloat(2147483647))
    },
    getRandomBetweenInt: function(a, b) {
        return this.seed = bikas.algorithms.ProceduralNumberGenerator.prng(this.seed), a + Math.floor(_UInt.UInt_Impl_.toFloat(this.seed) / _UInt.UInt_Impl_.toFloat(2147483647) * (b - a + 1))
    },
    __class__: bikas.algorithms.ProceduralNumberGenerator
}, bikas.algorithms.QuarticSolver = $hxClasses["bikas.algorithms.QuarticSolver"] = function() {}, bikas.algorithms.QuarticSolver.__name__ = ["bikas", "algorithms", "QuarticSolver"], bikas.algorithms.QuarticSolver.solveQuartic = function(a, b, c, d, e) {
    var f, g = 1 / a,
        h = b * g,
        i = c * g,
        j = d * g,
        k = e * g,
        l = h * h,
        m = -.375 * l + i,
        n = .125 * l * h - .5 * h * i + j,
        o = -.01171875 * l * l + .0625 * l * i - .25 * h * j + k,
        p = -.5 * m,
        q = -o,
        r = p * p,
        s = (r - 3 * q) / 9,
        t = (p * (r - 4.5 * q) + 13.5 * (.5 * o * m - .125 * n * n)) / 27,
        u = s * s * s,
        v = t * t,
        w = u - v,
        x = p / 3;
    if (w >= 0) {
        w = t / Math.sqrt(u);
        var y = Math.acos(w) / 3,
            z = -2 * Math.sqrt(s);
        f = z * Math.cos(y) - x
    } else {
        var A = Math.pow(Math.sqrt(v - u) + Math.abs(t), .3333333333333333);
        f = t < 0 ? A + s / A - x : -(A + s / A) - x
    }
    var B = 2 * f - m;
    if (B < 0) {
        if (!(B > -1e-10)) return null;
        B = 0
    }
    var C;
    if (B < 1e-10) {
        if (C = f * f - o, C < 0) return null;
        C = Math.sqrt(C)
    } else B = Math.sqrt(B), C = .5 * n / B;
    var D = B * B,
        E = -.25 * h,
        F = D - 4 * (f - C),
        G = D - 4 * (f + C);
    if (F >= 0 && G >= 0) {
        F = Math.sqrt(F), G = Math.sqrt(G);
        var H = [];
        H[0] = -.5 * (B + F) + E, H[1] = -.5 * (B - F) + E, H[2] = .5 * (B + G) + E, H[3] = .5 * (B - G) + E;
        for (var I = 1; I < 4;)
            for (var J = I++, K = J; K > 0 && H[K - 1] > H[K];) {
                var L = H[K];
                H[K] = H[K - 1], H[K - 1] = L, --K
            }
        return H
    }
    if (F >= 0) {
        F = Math.sqrt(F);
        var M = [];
        return M[0] = -.5 * (B + F) + E, M[1] = -.5 * (B - F) + E, M
    }
    if (G >= 0) {
        G = Math.sqrt(G);
        var N = [];
        return N[0] = .5 * (B - G) + E, N[1] = .5 * (B + G) + E, N
    }
    return null
}, bikas.algorithms.NotBikas_ButWhatever_RootSolver = $hxClasses["bikas.algorithms.NotBikas_ButWhatever_RootSolver"] = function() {
    this.roots = [], this._scratchArray = []
}, bikas.algorithms.NotBikas_ButWhatever_RootSolver.__name__ = ["bikas", "algorithms", "NotBikas_ButWhatever_RootSolver"], bikas.algorithms.NotBikas_ButWhatever_RootSolver.cbrt = function(a) {
    return (a < 0 ? -1 : 1) * Math.pow(Math.abs(a), .3333333333333333)
}, bikas.algorithms.NotBikas_ButWhatever_RootSolver.isZero = function(a) {
    return a > -1e-10 && a < 1e-10
}, bikas.algorithms.NotBikas_ButWhatever_RootSolver.prototype = {
    roots: null,
    _scratchArray: null,
    free: function() {
        this.roots = null, this._scratchArray = null
    },
    solveQuadric: function(a, b, c) {
        var d = b / (2 * c),
            e = a / c,
            f = d * d - e;
        if (f > -1e-10 && f < 1e-10) return this.roots[0] = -d, 1;
        if (f < 0) return 0;
        var g = Math.sqrt(f);
        return this.roots[0] = g - d, this.roots[1] = -g - d, 2
    },
    solveCubic: function(a, b, c, d) {
        var e = 0,
            f = c / d,
            g = b / d,
            h = a / d,
            i = f * f,
            j = .3333333333333333 * (-.3333333333333333 * i + g),
            k = .5 * (.07407407407407407 * f * i - .3333333333333333 * f * g + h),
            l = j * j * j,
            m = k * k + l;
        if (m > -1e-10 && m < 1e-10)
            if (k > -1e-10 && k < 1e-10) this.roots[0] = 0, e = 1;
            else {
                var n = -k,
                    o = (n < 0 ? -1 : 1) * Math.pow(Math.abs(n), .3333333333333333);
                this.roots[0] = 2 * o, this.roots[1] = -o, e = 2
            } else if (m < 0) {
            var p = Math,
                q = .3333333333333333 * p.acos(-k / p.sqrt(-l)),
                r = 2 * p.sqrt(-j);
            this.roots[0] = r * p.cos(q), this.roots[1] = -r * p.cos(q + 1.0471975511965976), this.roots[2] = -r * p.cos(q - 1.0471975511965976), e = 3
        } else {
            var s = Math,
                t = (s.sqrt(m), s.sqrt(m) - k),
                u = (t < 0 ? -1 : 1) * Math.pow(Math.abs(t), .3333333333333333),
                v = s.sqrt(m) + k,
                w = -((v < 0 ? -1 : 1) * Math.pow(Math.abs(v), .3333333333333333));
            this.roots[0] = u + w, e = 1
        }
        for (var x = .3333333333333333 * f, y = 0, z = e; y < z;) {
            var A = y++;
            this.roots[A] -= x
        }
        return e
    },
    solveQuartic: function(a, b, c, d, e) {
        var f, g, h, i, j, k = d / e,
            l = c / e,
            m = b / e,
            n = a / e,
            o = k * k,
            p = -.375 * o + l,
            q = .125 * o * k - .5 * k * l + m,
            r = -.01171875 * o * o + .0625 * o * l - .25 * k * m + n;
        if (r > -1e-10 && r < 1e-10) f = q, g = p, h = 0, i = 1, j = this.solveCubic(f, g, h, i), this.roots[j++] = 0;
        else {
            f = .5 * r * p - .125 * q * q, g = -r, h = -.5 * p, i = 1, this.solveCubic(f, g, h, i);
            var s = this.roots[0],
                t = s * s - r,
                u = 2 * s - p;
            if (t > -1e-10 && t < 1e-10) t = 0;
            else {
                if (!(t > 0)) return 0;
                t = Math.sqrt(t)
            } if (u > -1e-10 && u < 1e-10) u = 0;
            else {
                if (!(u > 0)) return 0;
                u = Math.sqrt(u)
            }
            f = s - t, g = q < 0 ? -u : u, h = 1, j = this.solveQuadric(f, g, h), f = s + t, g = q < 0 ? u : -u, h = 1;
            for (var v = this._scratchArray, w = 0, x = j; w < x;) {
                var y = w++;
                v[y] = this.roots[y]
            }
            for (var z = this.solveQuadric(f, g, h), A = 0, B = z; A < B;) {
                var C = A++;
                this.roots[C + z] = this.roots[C], this.roots[C] = v[C]
            }
            j += z
        }
        for (var D = .25 * k, E = 0, F = j; E < F;) {
            var G = E++;
            this.roots[G] -= D
        }
        return j
    },
    __class__: bikas.algorithms.NotBikas_ButWhatever_RootSolver
}, bikas.animation || (bikas.animation = {}), bikas.animation.SpriteState = $hxClasses["bikas.animation.SpriteState"] = function() {
    this.scale_y = 1, this.scale_x = 1, this.rotation = 0, this.position_y = 0, this.position_x = 0
}, bikas.animation.SpriteState.__name__ = ["bikas", "animation", "SpriteState"], bikas.animation.SpriteState.prototype = {
    position_x: null,
    position_y: null,
    rotation: null,
    scale_x: null,
    scale_y: null,
    __class__: bikas.animation.SpriteState
}, bikas.animation.AnimationKeyframe = $hxClasses["bikas.animation.AnimationKeyframe"] = function() {
    this.states = []
}, bikas.animation.AnimationKeyframe.__name__ = ["bikas", "animation", "AnimationKeyframe"], bikas.animation.AnimationKeyframe.prototype = {
    states: null,
    __class__: bikas.animation.AnimationKeyframe
}, bikas.animation.SpriteDescription = $hxClasses["bikas.animation.SpriteDescription"] = function() {}, bikas.animation.SpriteDescription.__name__ = ["bikas", "animation", "SpriteDescription"], bikas.animation.SpriteDescription.prototype = {
    name: null,
    registration_x: null,
    registration_y: null,
    __class__: bikas.animation.SpriteDescription
}, bikas.animation.StaticSprite = $hxClasses["bikas.animation.StaticSprite"] = function() {}, bikas.animation.StaticSprite.__name__ = ["bikas", "animation", "StaticSprite"], bikas.animation.StaticSprite.prototype = {
    description: null,
    state: null,
    __class__: bikas.animation.StaticSprite
}, bikas.animation.Animation = $hxClasses["bikas.animation.Animation"] = function() {
    this.keyframes = [], this.animated_sprites = [], this.static_sprites = []
}, bikas.animation.Animation.__name__ = ["bikas", "animation", "Animation"], bikas.animation.Animation.prototype = {
    static_sprites: null,
    animated_sprites: null,
    keyframe_indexes: null,
    keyframes: null,
    __class__: bikas.animation.Animation
}, bikas.animation.AnimationSerializer = $hxClasses["bikas.animation.AnimationSerializer"] = function() {}, bikas.animation.AnimationSerializer.__name__ = ["bikas", "animation", "AnimationSerializer"], bikas.animation.AnimationSerializer.describeData = function() {
    var a, b = (bikas.serialization.BefDo.pushClass, bikas.serialization.BefDo.pushBool, bikas.serialization.BefDo.pushInt, bikas.serialization.BefDo.pushDouble, bikas.serialization.BefDo.pushDouble),
        c = bikas.serialization.BefDo.pushString,
        d = (bikas.serialization.BefDo.pushEnum, bikas.serialization.BefDo.pushArray),
        e = bikas.serialization.BefDo.pushInstance,
        f = (bikas.serialization.BefDo.pushIgnore, bikas.serialization.BefDo.createSerialData()),
        g = bikas.animation.SpriteState,
        h = new bikas.serialization.SerialClass;
    h.full_class_name = Type.getClassName(g), h.serial_type = g, h.unserial_type = g, h.fields = [], h.ignore_fields = [], h.init_func = null, f.classes.push(h), a = h, b(a, "position_x"), b(a, "position_y"), b(a, "rotation"), b(a, "scale_x"), b(a, "scale_y");
    var i = bikas.animation.AnimationKeyframe,
        j = new bikas.serialization.SerialClass;
    j.full_class_name = Type.getClassName(i), j.serial_type = i, j.unserial_type = i, j.fields = [], j.ignore_fields = [], j.init_func = null, f.classes.push(j), a = j, d(a, "states", [12]);
    var k = bikas.animation.SpriteDescription,
        l = new bikas.serialization.SerialClass;
    l.full_class_name = Type.getClassName(k), l.serial_type = k, l.unserial_type = k, l.fields = [], l.ignore_fields = [], l.init_func = null, f.classes.push(l), a = l, c(a, "name"), b(a, "registration_x"), b(a, "registration_y");
    var m = bikas.animation.StaticSprite,
        n = new bikas.serialization.SerialClass;
    n.full_class_name = Type.getClassName(m), n.serial_type = m, n.unserial_type = m, n.fields = [], n.ignore_fields = [], n.init_func = null, f.classes.push(n), a = n, e(a, "description"), e(a, "state");
    var o = bikas.animation.Animation,
        p = new bikas.serialization.SerialClass;
    return p.full_class_name = Type.getClassName(o), p.serial_type = o, p.unserial_type = o, p.fields = [], p.ignore_fields = [], p.init_func = null, f.classes.push(p), a = p, d(a, "static_sprites", [12]), d(a, "animated_sprites", [12]), d(a, "keyframe_indexes", [3]), d(a, "keyframes", [12]), bikas.serialization.BefDo.validateSerialData(f), bikas.serialization.BefDo.createTypeTableForSerialData(f), f
}, bikas.animation.AnimationSerializer.serialize = function(a, b) {
    var c = bikas.serialization.BefDo.serialize(a, b, [12]);
    return c
}, bikas.animation.AnimationSerializer.unserialize = function(a, b) {
    var c = bikas.serialization.BefDo.unserialize(a, b);
    return null == c ? null : js.Boot.__cast(c, bikas.animation.Animation)
}, bikas.global || (bikas.global = {}), bikas.global.MathConstants = $hxClasses["bikas.global.MathConstants"] = function() {}, bikas.global.MathConstants.__name__ = ["bikas", "global", "MathConstants"], bikas.global.Point = $hxClasses["bikas.global.Point"] = function(a, b) {
    null == b && (b = 0), null == a && (a = 0), this.x = a, this.y = b
}, bikas.global.Point.__name__ = ["bikas", "global", "Point"], bikas.global.Point.prototype = {
    x: null,
    y: null,
    toString: function() {
        return "{x:" + Math.round(1e3 * this.x) / 1e3 + ",y:" + Math.round(1e3 * this.y) / 1e3 + "}"
    },
    __class__: bikas.global.Point
}, bikas.global.PointTime = $hxClasses["bikas.global.PointTime"] = function(a, b) {
    this.time = a, this.point = b
}, bikas.global.PointTime.__name__ = ["bikas", "global", "PointTime"], bikas.global.PointTime.prototype = {
    time: null,
    point: null,
    __class__: bikas.global.PointTime
}, bikas.global.Rectangle = $hxClasses["bikas.global.Rectangle"] = function(a, b, c, d) {
    null == d && (d = 0), null == c && (c = 0), null == b && (b = 0), null == a && (a = 0), this.x = a, this.y = b, this.width = c, this.height = d
}, bikas.global.Rectangle.__name__ = ["bikas", "global", "Rectangle"], bikas.global.Rectangle.prototype = {
    x: null,
    y: null,
    width: null,
    height: null,
    toString: function() {
        return "{x:" + Math.round(1e3 * this.x) / 1e3 + ",y:" + Math.round(1e3 * this.y) / 1e3 + ",width:" + Math.round(1e3 * this.width) / 1e3 + ",height:" + Math.round(1e3 * this.height) / 1e3 + "}"
    },
    __class__: bikas.global.Rectangle
}, bikas.global.Size = $hxClasses["bikas.global.Size"] = function(a, b) {
    null == b && (b = 0), null == a && (a = 0), this.width = a, this.height = b
}, bikas.global.Size.__name__ = ["bikas", "global", "Size"], bikas.global.Size.prototype = {
    width: null,
    height: null,
    toString: function() {
        return "{width:" + Math.round(1e3 * this.width) / 1e3 + ",height:" + Math.round(1e3 * this.height) / 1e3 + "}"
    },
    __class__: bikas.global.Size
}, bikas.global.Transform = $hxClasses["bikas.global.Transform"] = function() {
    this.rotation = 0, this.scale_y = 1, this.scale_x = 1
}, bikas.global.Transform.__name__ = ["bikas", "global", "Transform"], bikas.global.Transform.prototype = {
    scale_x: null,
    scale_y: null,
    rotation: null,
    toString: function() {
        return "{scale_x:" + Math.round(1e3 * this.scale_x) / 1e3 + ",scale_y:" + Math.round(1e3 * this.scale_y) / 1e3 + ",rotation:" + Math.round(1e3 * this.rotation) / 1e3 + "}"
    },
    __class__: bikas.global.Transform
}, bikas.global.Intersection = $hxClasses["bikas.global.Intersection"] = function(a, b) {
    this.point = a, this.time = b
}, bikas.global.Intersection.__name__ = ["bikas", "global", "Intersection"], bikas.global.Intersection.prototype = {
    point: null,
    time: null,
    __class__: bikas.global.Intersection
}, bikas.global.Range = $hxClasses["bikas.global.Range"] = function(a, b) {
    this.start = a, this.end = b
}, bikas.global.Range.__name__ = ["bikas", "global", "Range"], bikas.global.Range.prototype = {
    start: null,
    end: null,
    __class__: bikas.global.Range
}, bikas.global.MinMax = $hxClasses["bikas.global.MinMax"] = function(a, b) {
    this.min = a, this.max = b
}, bikas.global.MinMax.__name__ = ["bikas", "global", "MinMax"], bikas.global.MinMax.prototype = {
    min: null,
    max: null,
    __class__: bikas.global.MinMax
}, bikas.global.MinMaxCurrent = $hxClasses["bikas.global.MinMaxCurrent"] = function(a, b, c) {
    this.min = a, this.max = b, this.current = c
}, bikas.global.MinMaxCurrent.__name__ = ["bikas", "global", "MinMaxCurrent"], bikas.global.MinMaxCurrent.prototype = {
    min: null,
    max: null,
    current: null,
    __class__: bikas.global.MinMaxCurrent
}, bikas.global.GlobalFunc = $hxClasses["bikas.global.GlobalFunc"] = function() {}, bikas.global.GlobalFunc.__name__ = ["bikas", "global", "GlobalFunc"], bikas.global.GlobalFunc.angleDifferenceRad = function(a, b) {
    return Math.atan2(Math.sin(a - b), Math.cos(a - b))
}, bikas.global.GlobalFunc.angleDifferenceDeg = function(a, b) {
    var c = (a - b) * Math.PI / 180;
    return Math.atan2(Math.sin(c), Math.cos(c)) / Math.PI * 180
}, bikas.global.GlobalFunc.normalizeAngle = function(a) {
    return a = (a % bikas.global.MathConstants.PI2 + bikas.global.MathConstants.PI2) % bikas.global.MathConstants.PI2, a > Math.PI && (a -= bikas.global.MathConstants.PI2), a
}, bikas.global.GlobalFunc.findGreatestCommonDivisor = function(a, b) {
    for (var c; 0 != a;) c = a, a = b % a, b = c;
    return b
}, bikas.global.GlobalFunc.clamp = function(a, b, c) {
    return a < b ? b : a > c ? c : a
}, bikas.global.GlobalFunc.clampInt = function(a, b, c) {
    return a < b ? b : a > c ? c : a
}, bikas.global.GlobalFunc.isValueBetween = function(a, b, c) {
    return a >= b && a <= c
}, bikas.global.GlobalFunc.didValuePass = function(a, b, c) {
    return c >= a && c <= b || c <= a && c >= b
}, bikas.global.GlobalFunc.isInRange = function(a, b, c, d) {
    return !(a < c && b < c) && !(a > d && b > d)
}, bikas.global.GlobalFunc.range = function(a, b, c) {
    return (a - b) / (c - b)
}, bikas.global.GlobalFunc.rangeCoeff = function(a, b, c) {
    return (a - b) / (c - b)
}, bikas.global.GlobalFunc.rangeCoeffClamped = function(a, b, c) {
    var d = (a - b) / (c - b);
    return d < 0 ? 0 : d > 1 ? 1 : d
}, bikas.global.GlobalFunc.distance = function(a, b, c, d) {
    var e = c - a,
        f = d - b;
    return Math.sqrt(e * e + f * f)
}, bikas.global.GlobalFunc.distanceBetweenPoints = function(a, b) {
    var c = b.x - a.x,
        d = b.y - a.y;
    return Math.sqrt(c * c + d * d)
}, bikas.global.GlobalFunc.dot = function(a, b, c, d) {
    return a * c + b * d
}, bikas.global.GlobalFunc.direction = function(a, b, c, d) {
    var e = c - a,
        f = d - b,
        g = Math.sqrt(e * e + f * f),
        h = (a * c + b * d) / (g * g);
    return h
}, bikas.global.GlobalFunc.rectanglesIntersect = function(a, b) {
    return !(a.x > b.x + b.width || a.x + a.width < b.x || a.y > b.y + b.height || a.y + a.height < b.y)
}, bikas.global.GlobalFunc.getTotalRectangle = function(a) {
    if (0 == a.length) return null;
    for (var b = a[0].x, c = a[0].y, d = a[0].x + a[0].width, e = a[0].y + a[0].height, f = 0; f < a.length;) {
        var g = a[f];
        ++f, g.x < b && (b = g.x), g.y < c && (c = g.y), g.x + g.width > d && (d = g.x + g.width), g.y + g.height > e && (e = g.y + g.height)
    }
    return new bikas.global.Rectangle(b, c, d - b, e - c)
}, bikas.global.GlobalFunc.getInvertedPoint = function(a) {
    return new bikas.global.Point((-a.x), (-a.y))
}, bikas.global.GlobalFunc.getTransformX = function(a, b, c, d, e) {
    return a * c * Math.cos(e) - b * d * Math.sin(e)
}, bikas.global.GlobalFunc.getTransformY = function(a, b, c, d, e) {
    return a * c * Math.sin(e) + b * d * Math.cos(e)
}, bikas.global.GlobalFunc.getInvertedTransform = function(a) {
    var b = new bikas.global.Transform;
    return b.scale_x = 1 / a.scale_x, b.scale_y = 1 / a.scale_y, b.rotation = -a.rotation, b
}, bikas.global.GlobalFunc.isPointBetween = function(a, b, c) {
    return !(c.x < a.x && c.x < b.x) && (!(c.x > a.x && c.x > b.x) && (!(c.y < a.y && c.y < b.y) && !(c.y > a.y && c.y > b.y)))
}, bikas.global.GlobalFunc.isPointInLineRange = function(a, b, c) {
    var d = b.x - a.x,
        e = b.y - a.y,
        f = (c.x - a.x) * d + (c.y - a.y) * e;
    return 0 <= f && f <= d * d + e * e
}, bikas.global.GlobalFunc.distanceBetweenLineAndPoint = function(a, b, c) {
    var d = c.x - a.x,
        e = c.y - a.y,
        f = b.x - a.x,
        g = b.y - a.y;
    return Math.abs(d * g - f * e) / Math.sqrt(f * f + g * g)
}, bikas.global.GlobalFunc.distanceBetweenPointAndRectangle = function(a, b) {
    var c = a.x,
        d = b.x,
        e = b.x + b.width,
        f = c < d ? d : c > e ? e : c,
        g = a.y,
        h = b.y,
        i = b.y + b.height,
        j = g < h ? h : g > i ? i : g,
        k = f - a.x,
        l = j - a.y;
    return Math.sqrt(k * k + l * l)
}, bikas.global.GlobalFunc.getPointPerpendicularToLine = function(a, b, c) {
    var d = c.x - a.x,
        e = c.y - a.y,
        f = b.x - a.x,
        g = b.y - a.y,
        h = (d * g - f * e) / (f * f + g * g);
    return new bikas.global.Point(c.x - h * g, c.y + h * f)
}, bikas.global.GlobalFunc.pointInRectangle = function(a, b) {
    return !(a.x < b.x) && (!(a.y < b.y) && (!(a.x > b.x + b.width) && !(a.y > b.y + b.height)))
}, bikas.global.GlobalFunc.rectangleInRectangle = function(a, b) {
    return !(a.x < b.x) && (!(a.y < b.y) && (!(a.x + a.width > b.x + b.width) && !(a.y + a.height > b.y + b.height)))
}, bikas.global.GlobalFunc.expandRectangle = function(a, b) {
    return new bikas.global.Rectangle(a.x - b, a.y - b, a.width + 2 * b, a.height + 2 * b)
}, bikas.global.GlobalFunc.getRectangleMiddle = function(a) {
    return new bikas.global.Point(a.x + a.width / 2, a.y + a.height / 2)
}, bikas.global.GlobalFunc.logX = function(a, b) {
    return null == b && (b = 10), Math.round(Math.log(a) / Math.log(b))
}, bikas.global.GlobalFunc.near = function(a, b, c) {
    return a >= b - c && a <= b + c
}, bikas.global.GlobalFunc.min = function(a, b) {
    return a < b ? a : b
}, bikas.global.GlobalFunc.minInt = function(a, b) {
    return a < b ? a : b
}, bikas.global.GlobalFunc.max = function(a, b) {
    return a > b ? a : b
}, bikas.global.GlobalFunc.maxInt = function(a, b) {
    return a > b ? a : b
}, bikas.global.GlobalFunc.rotatePoint = function(a, b, c) {
    var d = Math.cos(c) * (b.x - a.x) - Math.sin(c) * (b.y - a.y) + a.x,
        e = Math.sin(c) * (b.x - a.x) + Math.cos(c) * (b.y - a.y) + a.y;
    return new bikas.global.Point(d, e)
}, bikas.global.GlobalFunc.round = function(a, b) {
    return null == b && (b = .01), Math.round(a / b) * b
}, bikas.global.GlobalFunc.snap = function(a, b) {
    return b > 0 ? Math.round(Math.round(a / b) * b) : a
}, bikas.global.GlobalFunc.interpolateSmoothOutIn = function(a, b, c) {
    var d = .5 * (1 - Math.cos(c * Math.PI));
    return a * (1 - d) + b * d
}, bikas.global.GlobalFunc.interpolateSmoothIn = function(a, b, c) {
    return c = Math.sin(c * Math.PI * .5), (1 - c) * a + c * b
}, bikas.global.GlobalFunc.interpolateSmoothOut = function(a, b, c) {
    return c = Math.cos(c * Math.PI * .5), c * a + (1 - c) * b
}, bikas.global.GlobalFunc.interpolate = function(a, b, c) {
    return a + (b - a) * c
}, bikas.global.GlobalFunc.interpolateClamped = function(a, b, c) {
    return a + (b - a) * (c < 0 ? 0 : c > 1 ? 1 : c)
}, bikas.global.GlobalFunc.interpolateForwardAndBackward = function(a, b, c) {
    return c < .5 ? a + (b - a) * (2 * c) : b + (a - b) * (2 * c - 1)
}, bikas.global.GlobalFunc.findIndexOfNearestValue = function(a, b) {
    for (var c = b[0], d = Math.abs(c - a), e = 0, f = 0, g = b.length; f < g;) {
        var h = f++;
        c = b[h], Math.abs(c - a) < d && (d = Math.abs(c - a), e = h)
    }
    return e
}, bikas.global.GlobalFunc.sumFloatArray = function(a) {
    for (var b = 0, c = 0; c < a.length;) {
        var d = a[c];
        ++c, b += d
    }
    return b
}, bikas.global.GlobalFunc.sumIntArray = function(a) {
    for (var b = 0, c = 0; c < a.length;) {
        var d = a[c];
        ++c, b += d
    }
    return b
}, bikas.global.GlobalFunc.copyPoint = function(a) {
    return new bikas.global.Point(a.x, a.y)
}, bikas.global.GlobalFunc.copyRectangle = function(a) {
    return new bikas.global.Rectangle(a.x, a.y, a.width, a.height)
}, bikas.global.GlobalFunc.copyTransform = function(a) {
    var b = new bikas.global.Transform;
    return b.scale_x = a.scale_x, b.scale_y = a.scale_y, b.rotation = a.rotation, b
}, bikas.global.GlobalFunc.spaceText = function(a, b) {
    for (; a.length < b;) a += " ";
    return a
}, bikas.global.GlobalFunc.getRandomBetween = function(a, b) {
    return a + Math.random() * (b - a)
}, bikas.global.GlobalFunc.getRandomSign = function() {
    return Math.random() > .5 ? 1 : -1
}, bikas.global.GlobalFunc.getRandomBetweenInt = function(a, b) {
    return a + Math.floor(Math.random() * (b - a + 1))
}, bikas.global.GlobalFunc.getRandomPointInRectangle = function(a) {
    return new bikas.global.Point(a.x + a.width * Math.random(), a.y + a.height * Math.random())
}, bikas.global.GlobalFunc.pointsEqual = function(a, b) {
    return a.x == b.x && a.y == b.y
}, bikas.global.GlobalFunc.sizesEqual = function(a, b) {
    return a.width == b.width && a.height == b.height
}, bikas.global.GlobalFunc.createRectangleFrom2Points = function(a, b) {
    var c, d;
    return c = a.x < b.x ? a.x : b.x, d = a.y < b.y ? a.y : b.y, new bikas.global.Rectangle(c, d, Math.abs(a.x - b.x), Math.abs(a.y - b.y))
}, bikas.global.GlobalFunc.pointInPolygon = function(a, b) {
    if (b.length < 3) return !1;
    for (var c = a.x, d = a.y, e = b[b.length - 1], f = !1, g = 0; g < b.length;) {
        var h = b[g];
        ++g, (h.y < d && e.y >= d || e.y < d && h.y >= d) && (h.x <= c || e.x <= c) && h.x + (d - h.y) / (e.y - h.y) * (e.x - h.x) < c && (f = !f), e = h
    }
    return f
}, bikas.global.GlobalFunc.intersectPointX = function(a, b, c) {
    return new bikas.global.Point(a.x + (c - a.y) / (b.y - a.y) * (b.x - a.x), c)
}, bikas.global.GlobalFunc.intersectPointY = function(a, b, c) {
    return new bikas.global.Point(c, a.y + (c - a.x) / (b.x - a.x) * (b.y - a.y))
}, bikas.global.GlobalFunc.sortByIncreasingValue = function(a, b) {
    return a > b ? 1 : a < b ? -1 : 0
}, bikas.global.Interpolate = $hxClasses["bikas.global.Interpolate"] = function() {}, bikas.global.Interpolate.__name__ = ["bikas", "global", "Interpolate"], bikas.global.Interpolate.linear = function(a, b, c) {
    return a + (b - a) * c
}, bikas.global.Interpolate.smoothStart = function(a, b, c) {
    return c = Math.cos(c * Math.PI * .5), c * a + (1 - c) * b
}, bikas.global.Interpolate.smoothEnd = function(a, b, c) {
    return c = Math.sin(c * Math.PI * .5), (1 - c) * a + c * b
}, bikas.global.Interpolate.smoothStartEnd = function(a, b, c) {
    var d = .5 * (1 - Math.cos(c * Math.PI));
    return a * (1 - d) + b * d
}, bikas.global.Interpolate.linearClamped = function(a, b, c) {
    return a + (b - a) * (c < 0 ? 0 : c > 1 ? 1 : c)
}, bikas.global.Interpolate.linearForwardAndBackward = function(a, b, c) {
    return c < .5 ? a + (b - a) * (2 * c) : b + (a - b) * (2 * c - 1)
}, bikas.global.Interpolate.integrateSmoothEnd = function(a, b, c) {
    null == c && (c = 60);
    for (var d = (b - a) / c, e = a + d / 2, f = 0, g = 0, h = c; g < h;) {
        g++;
        f += Math.sin(.5 * Math.PI * e) * d, e += d
    }
    return f
}, bikas.global.Interpolate.integrateLinear = function(a, b, c) {
    null == c && (c = 60);
    for (var d = (b - a) / c, e = a + d / 2, f = 0, g = 0, h = c; g < h;) {
        g++;
        f += e * d, e += d
    }
    return f
}, bikas.global.Interpolate.clamp = function(a, b, c) {
    return a < b ? b : a > c ? c : a
}, bikas.global.GlobalParse = $hxClasses["bikas.global.GlobalParse"] = function() {}, bikas.global.GlobalParse.__name__ = ["bikas", "global", "GlobalParse"], bikas.global.GlobalParse.stringToFloatArray = function(a) {
    if ("[" != a.charAt(0) || "]" != a.charAt(a.length - 1)) return null;
    for (var b = HxOverrides.substr(a, 1, a.length - 2), c = b.split(","), d = c.map(Std.parseFloat), e = 0, f = d.length; e < f;) {
        var g = e++;
        isNaN(d[g]) && (d[g] = 0)
    }
    return d
}, bikas.global.GlobalParse.stringToIntArray = function(a) {
    if ("[" != a.charAt(0) || "]" != a.charAt(a.length - 1)) return null;
    for (var b = HxOverrides.substr(a, 1, a.length - 2), c = b.split(","), d = c.map(Std.parseInt), e = 0, f = d.length; e < f;) {
        var g = e++;
        null == d[g] && (d[g] = 0)
    }
    return d
}, bikas.global.GlobalParse.floatArrayToString = function(a) {
    for (var b = "[", c = 0, d = a.length - 1; c < d;) {
        var e = c++;
        b += a[e] + ","
    }
    return b += a[a.length - 1] + "]"
}, bikas.global.GlobalParse.intArrayToString = function(a) {
    for (var b = "[", c = 0, d = a.length - 1; c < d;) {
        var e = c++;
        b += a[e] + ","
    }
    return b += a[a.length - 1] + "]"
}, bikas.global.GlobalProc = $hxClasses["bikas.global.GlobalProc"] = function() {}, bikas.global.GlobalProc.__name__ = ["bikas", "global", "GlobalProc"], bikas.global.GlobalProc.applyTransform = function(a, b, c, d) {
    var e = .017453292519943 * d.rotation,
        f = a.x * d.scale_x * Math.cos(e) - a.y * d.scale_y * Math.sin(e),
        g = .017453292519943 * d.rotation,
        h = a.x * d.scale_x * Math.sin(g) + a.y * d.scale_y * Math.cos(g);
    a.x = c.x + f, a.y = c.y + h, b.scale_x *= d.scale_x, b.scale_y *= d.scale_y, b.rotation += d.rotation
}, bikas.global.GlobalProc.transformPoint = function(a, b) {
    var c = .017453292519943 * b.rotation,
        d = a.x * b.scale_x * Math.cos(c) - a.y * b.scale_y * Math.sin(c),
        e = .017453292519943 * b.rotation,
        f = a.x * b.scale_x * Math.sin(e) + a.y * b.scale_y * Math.cos(e);
    a.x = d, a.y = f
}, bikas.global.GlobalProc.applySeveralTransformsToPoint = function(a, b, c) {
    if (b.length != c.length);
    else
        for (var d = 0, e = b.length; d < e;) {
            var f = d++,
                g = b[f],
                h = c[f],
                i = .017453292519943 * h.rotation,
                j = a.x * h.scale_x * Math.cos(i) - a.y * h.scale_y * Math.sin(i),
                k = .017453292519943 * h.rotation,
                l = a.x * h.scale_x * Math.sin(k) + a.y * h.scale_y * Math.cos(k);
            a.x = g.x + j, a.y = g.y + l
        }
}, bikas.global.GlobalProc.applyTransformToPoint = function(a, b, c) {
    var d = .017453292519943 * c.rotation,
        e = a.x * c.scale_x * Math.cos(d) - a.y * c.scale_y * Math.sin(d),
        f = .017453292519943 * c.rotation,
        g = a.x * c.scale_x * Math.sin(f) + a.y * c.scale_y * Math.cos(f);
    a.x = b.x + e, a.y = b.y + g
}, bikas.global.GlobalProc.expandRectangle = function(a, b) {
    return a.x -= b, a.y -= b, a.width += 2 * b, a.height += 2 * b, a
}, bikas.global.GlobalProc.scaleRectangle = function(a, b) {
    a.x *= b, a.y *= b, a.width *= b, a.height *= b
}, bikas.global.GlobalProc.setRectanglePosition = function(a, b) {
    a.x = b.x, a.y = b.y
}, bikas.global.GlobalProc.setPoint = function(a, b) {
    a.x = b.x, a.y = b.y
}, bikas.global.GlobalProc.randomizeMinMaxCurrent = function(a) {
    var b = a.min,
        c = a.max;
    a.current = b + Math.random() * (c - b)
}, bikas.global.GlobalProc.roundFloatArray = function(a) {
    for (var b = 0, c = a.length; b < c;) {
        var d = b++;
        a[d] = Math.round(a[d])
    }
    return a
}, bikas.global.GlobalSolve = $hxClasses["bikas.global.GlobalSolve"] = function() {}, bikas.global.GlobalSolve.__name__ = ["bikas", "global", "GlobalSolve"], bikas.global.GlobalSolve.getQuadraticSolution = function(a, b, c) {
    var d = b * b - 4 * a * c;
    if (d < 0) return null;
    var e = Math.sqrt(d),
        f = (-b + e) / (2 * a),
        g = (-b - e) / (2 * a),
        h = Math.abs(f) < Math.abs(g) ? f : g;
    return h
}, bikas.global.GlobalSolve.getQuadraticOnlyPositiveSolution = function(a, b, c) {
    var d = b * b - 4 * a * c;
    if (d < 0) return null;
    var e = Math.sqrt(d),
        f = (-b + e) / (2 * a),
        g = (-b - e) / (2 * a);
    return f > 0 && g > 0 ? Math.abs(f) < Math.abs(g) ? f : g : f > 0 ? f : g > 0 ? g : null
}, bikas.global.GlobalSolve.getQuadraticSolutions = function(a, b, c) {
    var d = b * b - 4 * a * c;
    if (d < 0) return null;
    var e = Math.sqrt(d);
    if (0 == e) return [-b / (2 * a)];
    var f = (-b + e) / (2 * a),
        g = (-b - e) / (2 * a);
    return f < g ? [f, g] : [g, f]
}, bikas.global.GlobalSolve.getProjectileAndHorizontalLineIntersection = function(a, b, c, d) {
    var e = c.y / 2,
        f = b.y,
        g = a.y - d,
        h = null;
    if (0 == e) {
        if (0 == f) return null;
        h = -g / f
    } else h = bikas.global.GlobalSolve.getQuadraticOnlyPositiveSolution(e, f, g); if (null == h) return null;
    e = c.x / 2, f = b.x, g = a.x;
    var i = e * h * h + f * h + g;
    return new bikas.global.Intersection(new bikas.global.Point(i, d), h)
}, bikas.global.GlobalSolve.getProjectileAndVerticalLineIntersection = function(a, b, c, d) {
    var e = c.x / 2,
        f = b.x,
        g = a.x - d,
        h = null;
    if (0 == e) {
        if (0 == f) return null;
        h = -g / f
    } else h = bikas.global.GlobalSolve.getQuadraticOnlyPositiveSolution(e, f, g); if (null == h) return null;
    e = c.y / 2, f = b.y, g = a.y;
    var i = e * h * h + f * h + g;
    return new bikas.global.Intersection(new bikas.global.Point(d, i), h)
}, bikas.global.GlobalSolve.getProjectileAndHorizontalSegmentIntersection = function(a, b, c, d, e) {
    if (d.y != e.y) return null;
    var f = bikas.global.GlobalSolve.getProjectileAndHorizontalLineIntersection(a, b, c, d.y);
    if (null == f) return null;
    var g = f.point.x;
    return g >= d.x && g <= e.x ? f : null
}, bikas.global.GlobalSolve.getProjectileAndVerticalSegmentIntersection = function(a, b, c, d, e) {
    if (d.x != e.x) return null;
    var f = bikas.global.GlobalSolve.getProjectileAndVerticalLineIntersection(a, b, c, d.x);
    if (null == f) return null;
    var g = f.point.y;
    return g >= d.y && g <= e.y ? f : null
}, bikas.global.GlobalSolve.getProjectileAndMovingRectangleCollisionPoint = function(a, b, c, d, e, f) {
    var g = bikas.global.GlobalSolve.getProjectileAndRectangleCollisionPoint(a, b, c, d, f);
    return g
}, bikas.global.GlobalSolve.getProjectileAndRectangleCollisionPoint = function(a, b, c, d, e) {
    var f = e.y,
        g = f + e.height,
        h = e.x,
        i = h + e.width,
        j = null,
        k = a.y,
        l = b.y;
    if (f >= k && f <= l || f <= k && f >= l) {
        var m = a.x,
            n = b.x;
        if (!(m < h && n < h) && !(m > i && n > i)) {
            var o = bikas.global.GlobalSolve.getProjectileAndHorizontalSegmentIntersection(a, c, d, new bikas.global.Point(h, f), new bikas.global.Point(i, f));
            null != o && (null == j && (j = []), j.push(o))
        }
    }
    var p = a.x,
        q = b.x;
    if (h >= p && h <= q || h <= p && h >= q) {
        var r = a.y,
            s = b.y;
        if (!(r < f && s < f) && !(r > g && s > g)) {
            var t = bikas.global.GlobalSolve.getProjectileAndVerticalSegmentIntersection(a, c, d, new bikas.global.Point(h, f), new bikas.global.Point(h, g));
            null != t && (null == j && (j = []), j.push(t))
        }
    }
    var u = a.y,
        v = b.y;
    if (g >= u && g <= v || g <= u && g >= v) {
        var w = a.x,
            x = b.x;
        if (!(w < h && x < h) && !(w > i && x > i)) {
            var y = bikas.global.GlobalSolve.getProjectileAndHorizontalSegmentIntersection(a, c, d, new bikas.global.Point(h, g), new bikas.global.Point(i, g));
            null != y && (null == j && (j = []), j.push(y))
        }
    }
    var z = a.x,
        A = b.x;
    if (i >= z && i <= A || i <= z && i >= A) {
        var B = a.y,
            C = b.y;
        if (!(B < f && C < f) && !(B > g && C > g)) {
            var D = bikas.global.GlobalSolve.getProjectileAndVerticalSegmentIntersection(a, c, d, new bikas.global.Point(i, f), new bikas.global.Point(i, g));
            null != D && (null == j && (j = []), j.push(D))
        }
    }
    if (null != j) {
        for (var E = j[0], F = 0; F < j.length;) {
            var G = j[F];
            ++F, Math.abs(G.time) < Math.abs(E.time) && (E = G)
        }
        return E
    }
    return null
}, bikas.global.GlobalSolve.getQuadraticBezierToLineIntersection = function(a, b, c, d, e) {
    var f = c,
        g = b,
        h = a,
        i = d,
        j = e,
        k = new bikas.global.Point(i.y - j.y, j.x - i.x),
        l = new bikas.global.Point(f.x + g.x * -2 + h.x, f.y + g.y * -2 + h.y),
        m = new bikas.global.Point(f.x * -2 + 2 * g.x, f.y * -2 + 2 * g.y),
        n = new bikas.global.Point(f.x, f.y),
        o = i.x * j.y - j.x * i.y,
        p = k.x * l.x + k.y * l.y,
        q = (k.x * m.x + k.y * m.y) / p,
        r = (k.x * n.x + k.y * n.y + o) / p,
        s = [],
        t = q * q - 4 * r;
    if (t > 0) {
        var u = Math.sqrt(t),
            v = (-q + u) / 2,
            w = (-q - u) / 2;
        v < w ? (s.push(v), s.push(w)) : (s.push(w), s.push(v))
    } else 0 == t && s.push(-q / 2);
    for (var x = [], y = 0; y < s.length;) {
        var z = s[y];
        ++y;
        var A = i.x,
            B = j.x,
            C = A < B ? A : B,
            D = i.y,
            E = j.y,
            F = D < E ? D : E,
            G = i.x,
            H = j.x,
            I = G > H ? G : H,
            J = i.y,
            K = j.y,
            L = J > K ? J : K;
        if (z >= 0 && z <= 1) {
            var M = f.x,
                N = M + (g.x - M) * z,
                O = g.x,
                P = f.y,
                Q = P + (g.y - P) * z,
                R = g.y,
                S = new bikas.global.Point(N + (O + (h.x - O) * z - N) * z, Q + (R + (h.y - R) * z - Q) * z),
                T = S.x,
                U = S.y;
            i.x == j.x && U >= F && U <= L ? x.push(S) : i.y == j.y && T >= C && T <= I ? x.push(S) : T >= C && U >= F && T <= I && U <= L && x.push(S)
        }
    }
    return x
}, bikas.global.GlobalSolve.getTimeToReachTarget = function(a, b, c, d, e) {
    null == e && (e = !1);
    var f = d.x - c.x,
        g = d.y - c.y,
        h = a * a,
        i = b.y,
        j = i * i,
        k = i * g,
        l = Math.sqrt(f * f + g * g);
    if (h < l * i - k) return -1;
    var m = 0;
    m = e ? 2 / j * (h + k + Math.sqrt((h + k) * (h + k) - j * l * l)) : 2 / j * (h + k - Math.sqrt((h + k) * (h + k) - j * l * l));
    var n = Math.sqrt(m);
    return n
}, bikas.global.GlobalSolve.getVectorToReachTarget = function(a, b, c, d, e) {
    null == e && (e = !1);
    var f = bikas.global.GlobalSolve.getTimeToReachTarget(a, b, c, d, e);
    if (f < 0) return null;
    var g = new bikas.global.Point(d.x - c.x, d.y - c.y),
        h = 1 / f,
        i = new bikas.global.Point(g.x * h, g.y * h),
        j = f / 2,
        k = new bikas.global.Point(b.x * j, b.y * j),
        l = new bikas.global.Point(i.x - k.x, i.y - k.y);
    return l
}, bikas.global.GlobalSolve.getVectorsToReachMovingTarget = function(a, b, c, d, e, f) {
    null == f && (f = !1);
    var g = new bikas.global.Point(e.x - d.x, e.y - d.y),
        h = c,
        i = b,
        j = a,
        k = .25 * (i.x * i.x + i.y * i.y),
        l = h.x * i.x + h.y * i.y,
        m = g.x * i.x + g.y * i.y + (h.x * h.x + h.y * h.y) - j * j,
        n = 2 * (g.x * h.x + g.y * h.y),
        o = g.x * g.x + g.y * g.y,
        p = bikas.algorithms.QuarticSolver.solveQuartic(k, l, m, n, o),
        q = p;
    if (null == q) return null;
    for (var r = q[0], s = 0; s < q.length;) {
        var t = q[s];
        ++s, t < r && (r = t)
    }
    var u = new bikas.global.Point(h.x * r, h.y * r),
        v = new bikas.global.Point(g.x + u.x, g.y + u.y),
        w = r * r,
        x = new bikas.global.Point(i.x * w, i.y * w);
    v.x -= x.x, v.y -= x.y;
    var y = 1 / r;
    return v.x *= y, v.y *= y, v
}, bikas.global.GlobalSolve.getMaximumProjectileTravelDistance = function(a, b, c, d) {
    var e = new bikas.global.Point(a, 0),
        f = -Math.PI / 4,
        g = Math.cos(f),
        h = Math.sin(f);
    e = new bikas.global.Point(g * e.x - h * e.y, h * e.x + g * e.y);
    var i = b,
        j = bikas.global.GlobalSolve.getQuadraticSolutions(.5 * i.y, e.y, c.y - d);
    if (null == j) return new bikas.global.PointTime(0, new bikas.global.Point(0, 0));
    var k = 0;
    if (1 == j.length) k = j[0];
    else if (j[0] > 0) k = j[0];
    else {
        if (!(j[1] > 0)) return new bikas.global.PointTime(0, new bikas.global.Point(0, 0));
        k = j[1]
    }
    var l = .5 * i.x * k * k - e.x * k;
    return new bikas.global.PointTime(k, new bikas.global.Point((-l), d - c.y))
}, bikas.global.VecFunc = $hxClasses["bikas.global.VecFunc"] = function() {}, bikas.global.VecFunc.__name__ = ["bikas", "global", "VecFunc"], bikas.global.VecFunc.add = function(a, b) {
    return new bikas.global.Point(a.x + b.x, a.y + b.y)
}, bikas.global.VecFunc.add2 = function(a, b, c) {
    return new bikas.global.Point(a.x + b.x + c.x, a.y + b.y + c.y)
}, bikas.global.VecFunc.subtract = function(a, b) {
    return new bikas.global.Point(a.x - b.x, a.y - b.y)
}, bikas.global.VecFunc.multiply = function(a, b) {
    return new bikas.global.Point(a.x * b, a.y * b)
}, bikas.global.VecFunc.len = function(a) {
    return Math.sqrt(a.x * a.x + a.y * a.y)
}, bikas.global.VecFunc.magnitude = function(a) {
    return Math.sqrt(a.x * a.x + a.y * a.y)
}, bikas.global.VecFunc.normalize = function(a) {
    var b = new bikas.global.Point,
        c = Math.sqrt(a.x * a.x + a.y * a.y);
    return 0 != c && (b.x = a.x / c, b.y = a.y / c), b
}, bikas.global.VecFunc.dot = function(a, b) {
    return a.x * b.x + a.y * b.y
}, bikas.global.VecFunc.dotUsingLengthsAndAngle = function(a, b, c) {
    return a * b * Math.cos(c)
}, bikas.global.VecFunc.angle = function(a) {
    return Math.atan2(a.y, a.x)
}, bikas.global.VecFunc.direction = function(a) {
    return Math.atan2(a.y, a.x)
}, bikas.global.VecFunc.rotation = function(a) {
    return Math.atan2(a.y, a.x)
}, bikas.global.VecFunc.rotate = function(a, b) {
    var c = Math.cos(b),
        d = Math.sin(b);
    return new bikas.global.Point(c * a.x - d * a.y, d * a.x + c * a.y)
}, bikas.global.VecFunc.scalarProjection = function(a, b) {
    return (b.x * a.x + b.y * a.y) / Math.sqrt(a.x * a.x + a.y * a.y)
}, bikas.global.VecFunc.vectorProjection = function(a, b) {
    var c = (b.x * a.x + b.y * a.y) / (b.x * b.x + b.y * b.y);
    return new bikas.global.Point(a.x * c, a.y * c)
}, bikas.global.VecFunc.cross = function(a, b) {
    return a.x * b.y - a.y * b.x
}, bikas.global.VecFunc.interpolate = function(a, b, c) {
    var d = a.x + (b.x - a.x) * c,
        e = a.y + (b.y - a.y) * c;
    return new bikas.global.Point(d, e)
}, bikas.global.VecFunc.copy = function(a) {
    return new bikas.global.Point(a.x, a.y)
}, bikas.global.VecFunc.isZero = function(a) {
    return 0 == a.x && 0 == a.y
}, bikas.global.VecProc = $hxClasses["bikas.global.VecProc"] = function() {}, bikas.global.VecProc.__name__ = ["bikas", "global", "VecProc"], bikas.global.VecProc.set = function(a, b) {
    return a.x = b.x, a.y = b.y, a
}, bikas.global.VecProc.add = function(a, b) {
    return a.x += b.x, a.y += b.y, a
}, bikas.global.VecProc.addMultiplied = function(a, b, c) {
    return a.x += b.x * c, a.y += b.y * c, a
}, bikas.global.VecProc.addxy = function(a, b, c) {
    return a.x += b, a.y += c, a
}, bikas.global.VecProc.subtract = function(a, b) {
    return a.x -= b.x, a.y -= b.y, a
}, bikas.global.VecProc.multiply = function(a, b) {
    return a.x *= b, a.y *= b, a
}, bikas.global.VecProc.rotate = function(a, b) {
    var c = Math.cos(b),
        d = Math.sin(b),
        e = c * a.x - d * a.y,
        f = d * a.x + c * a.y;
    return a.x = e, a.y = f, a
}, bikas.google || (bikas.google = {}), bikas.google.GoogleAnalyticsWrapper = $hxClasses["bikas.google.GoogleAnalyticsWrapper"] = function() {}, bikas.google.GoogleAnalyticsWrapper.__name__ = ["bikas", "google", "GoogleAnalyticsWrapper"], bikas.google.GoogleAnalyticsWrapper.init = function(a, b) {
    googleAnalytics.Stats.init(a, b), bikas.google.GoogleAnalyticsWrapper.exists = !0
}, bikas.google.GoogleAnalyticsWrapper.trackPage = function(a) {
    bikas.google.GoogleAnalyticsWrapper.exists && googleAnalytics.Stats.trackPageview("/" + a)
}, bikas.google.GoogleAnalyticsWrapper.trackEvent = function(a, b, c) {
    bikas.google.GoogleAnalyticsWrapper.exists && googleAnalytics.Stats.trackEvent(a, b, c)
}, bikas.google.GoogleAnalyticsWrapper.trackMainMenu = function() {
    bikas.google.GoogleAnalyticsWrapper.trackPage("main menu")
}, bikas.google.GoogleAnalyticsWrapper.trackLevelFinish = function(a) {
    bikas.google.GoogleAnalyticsWrapper.trackPage("level finished " + a)
}, bikas.google.GoogleAnalyticsWrapper.trackLevelDeath = function(a) {
    bikas.google.GoogleAnalyticsWrapper.trackPage("level death " + a)
}, bikas.google.GoogleAnalyticsWrapper.trackGameFinish = function() {
    bikas.google.GoogleAnalyticsWrapper.trackPage("game finished")
}, bikas.google.GoogleAnalyticsWrapper.trackCreditsClicked = function() {
    bikas.google.GoogleAnalyticsWrapper.trackEvent("click", "credits", "")
}, bikas.google.GoogleAnalyticsWrapper.trackMoreGamesClicked = function() {
    bikas.google.GoogleAnalyticsWrapper.trackEvent("click", "more games", "")
}, bikas.google.GoogleAnalyticsWrapper.trackBikasNetClicked = function() {
    bikas.google.GoogleAnalyticsWrapper.trackEvent("click", "bikas.net", "")
}, bikas.javascript || (bikas.javascript = {}), bikas.javascript.CustomType = $hxClasses["bikas.javascript.CustomType"] = {
    __ename__: ["bikas", "javascript", "CustomType"],
    __constructs__: ["FloatArray", "IntArray"]
}, bikas.javascript.CustomType.FloatArray = ["FloatArray", 0], bikas.javascript.CustomType.FloatArray.toString = $estr, bikas.javascript.CustomType.FloatArray.__enum__ = bikas.javascript.CustomType, bikas.javascript.CustomType.IntArray = ["IntArray", 1], bikas.javascript.CustomType.IntArray.toString = $estr, bikas.javascript.CustomType.IntArray.__enum__ = bikas.javascript.CustomType, bikas.javascript.JsDebug = $hxClasses["bikas.javascript.JsDebug"] = function() {}, bikas.javascript.JsDebug.__name__ = ["bikas", "javascript", "JsDebug"], bikas.javascript.JsDebug.exportReflectStuff = function() {}, bikas.javascript.JsDebug.addButton = function(a, b, c) {
    var d = window.document.createElement("button");
    d.textContent = b, a.appendChild(d), d.onclick = function(a) {
        c()
    }
}, bikas.javascript.JsDebug.addFieldWatch = function(a, b, c, d) {
    null == d && (d = "");
    var e = window.document,
        f = Reflect.field(b, c),
        g = e.createElement("ul"),
        h = e.createElement("li"),
        i = e.createElement("div"),
        j = window.document.createTextNode("");
    i.className = "textinnerbox", h.appendChild(i), i.appendChild(j);
    var k = null,
        l = function() {
            if (f = Reflect.field(b, c), f != k) {
                k = f;
                var a = Type["typeof"](f);
                if (2 == a[1]) {
                    var e = js.Boot.__cast(f, Float);
                    e = Math.round(1e3 * e) / 1e3,
                        f = e
                }
                "" != d ? j.textContent = d + " = " + f : j.textContent = c + " = " + f
            }
        },
        m = new haxe.Timer(Math.round(250));
    m.run = l, l(), g.appendChild(h), a.appendChild(g)
}, bikas.javascript.JsDebug.addText = function(a, b, c, d) {
    null == d && (d = !1), null == c && (c = !1);
    var e = window.document,
        f = e.createTextNode(b),
        g = e.createElement("div");
    g.style.margin = "0", g.style.padding = "0", c && (g.style.textAlign = "center"), d && (g.style.fontWeight = "bold"), g.appendChild(f), a.appendChild(g)
}, bikas.javascript.JsDebug.addFieldEdit = function(a, b, c, d, e, f) {
    null == d && (d = "");
    var g = window.document,
        h = Reflect.field(b, c),
        i = g.createElement("ul"),
        j = g.createElement("li"),
        k = g.createElement("div"),
        l = window.document.createTextNode("");
    k.className = "textinnerbox", j.appendChild(k), k.appendChild(l), "" != d ? l.textContent = d : l.textContent = c;
    var m = g.createElement("li"),
        n = g.createElement("input");
    m.className = "inputvalue", null != e && (e == bikas.javascript.CustomType.FloatArray ? n.value = bikas.global.GlobalParse.floatArrayToString(h) : e == bikas.javascript.CustomType.IntArray && (n.value = bikas.global.GlobalParse.intArrayToString(h))), n.value = Std.string(h), m.appendChild(n);
    var o = g.createElement("li"),
        p = g.createElement("button");
    o.className = "applyvalue", p.textContent = "Apply", o.appendChild(p), i.appendChild(j), i.appendChild(m), i.appendChild(o), a.appendChild(i);
    var q = Type["typeof"](h);
    p.onclick = function(a) {
        var d = n.value;
        if (null != e) {
            if (e == bikas.javascript.CustomType.FloatArray) {
                var g = bikas.global.GlobalParse.stringToFloatArray(d);
                b[c] = g
            } else if (e == bikas.javascript.CustomType.IntArray) {
                var i = bikas.global.GlobalParse.stringToIntArray(d);
                b[c] = i
            }
        } else switch (q[1]) {
            case 1:
            case 2:
                var j = parseFloat(d);
                isNaN(j) ? n.value = Std.string(h) : b[c] = j;
                break;
            case 3:
                "true" == d ? b[c] = !0 : "false" == d ? b[c] = !1 : n.value = Std.string(h);
                break;
            case 7:
                q[2]
        }
        null != f && f()
    }
}, bikas.pointer || (bikas.pointer = {}), bikas.pointer.PointerStateType = $hxClasses["bikas.pointer.PointerStateType"] = {
    __ename__: ["bikas", "pointer", "PointerStateType"],
    __constructs__: ["DOWNED", "DRAGGED", "UPPED", "NONE", "CLICKED", "DOUBLE_CLICKED"]
}, bikas.pointer.PointerStateType.DOWNED = ["DOWNED", 0], bikas.pointer.PointerStateType.DOWNED.toString = $estr, bikas.pointer.PointerStateType.DOWNED.__enum__ = bikas.pointer.PointerStateType, bikas.pointer.PointerStateType.DRAGGED = ["DRAGGED", 1], bikas.pointer.PointerStateType.DRAGGED.toString = $estr, bikas.pointer.PointerStateType.DRAGGED.__enum__ = bikas.pointer.PointerStateType, bikas.pointer.PointerStateType.UPPED = ["UPPED", 2], bikas.pointer.PointerStateType.UPPED.toString = $estr, bikas.pointer.PointerStateType.UPPED.__enum__ = bikas.pointer.PointerStateType, bikas.pointer.PointerStateType.NONE = ["NONE", 3], bikas.pointer.PointerStateType.NONE.toString = $estr, bikas.pointer.PointerStateType.NONE.__enum__ = bikas.pointer.PointerStateType, bikas.pointer.PointerStateType.CLICKED = ["CLICKED", 4], bikas.pointer.PointerStateType.CLICKED.toString = $estr, bikas.pointer.PointerStateType.CLICKED.__enum__ = bikas.pointer.PointerStateType, bikas.pointer.PointerStateType.DOUBLE_CLICKED = ["DOUBLE_CLICKED", 5], bikas.pointer.PointerStateType.DOUBLE_CLICKED.toString = $estr, bikas.pointer.PointerStateType.DOUBLE_CLICKED.__enum__ = bikas.pointer.PointerStateType, bikas.pointer.Pointer = $hxClasses["bikas.pointer.Pointer"] = function(a) {
    null == a && (a = 0), this.last_game_offset = new bikas.global.Point(0, 0), this.last_game_size = new bikas.global.Size(1024, 768), this.enabled = !0, this.radius = 0, this.upped = new bikas.global.Point(0, 0), this.downed = new bikas.global.Point(0, 0), this.current = new bikas.global.Point(0, 0), this.state = bikas.pointer.PointerStateType.UPPED, this.radius = a
}, bikas.pointer.Pointer.__name__ = ["bikas", "pointer", "Pointer"], bikas.pointer.Pointer.prototype = {
    state: null,
    current: null,
    downed: null,
    upped: null,
    radius: null,
    last_clicked_time: null,
    enabled: null,
    last_game_size: null,
    last_game_offset: null,
    __class__: bikas.pointer.Pointer
}, bikas.serialization || (bikas.serialization = {}), bikas.serialization.Bef = $hxClasses["bikas.serialization.Bef"] = function() {}, bikas.serialization.Bef.__name__ = ["bikas", "serialization", "Bef"], bikas.serialization.ByteCursor = $hxClasses["bikas.serialization.ByteCursor"] = function() {}, bikas.serialization.ByteCursor.__name__ = ["bikas", "serialization", "ByteCursor"], bikas.serialization.ByteCursor.prototype = {
    alloc_size: null,
    bytes: null,
    pos: null,
    __class__: bikas.serialization.ByteCursor
}, bikas.serialization.SerialField = $hxClasses["bikas.serialization.SerialField"] = function() {}, bikas.serialization.SerialField.__name__ = ["bikas", "serialization", "SerialField"], bikas.serialization.SerialField.prototype = {
    field_name: null,
    value_type_flags: null,
    __class__: bikas.serialization.SerialField
}, bikas.serialization.SerialClass = $hxClasses["bikas.serialization.SerialClass"] = function() {
    this.init_func = null
}, bikas.serialization.SerialClass.__name__ = ["bikas", "serialization", "SerialClass"], bikas.serialization.SerialClass.prototype = {
    full_class_name: null,
    serial_type: null,
    unserial_type: null,
    fields: null,
    ignore_fields: null,
    init_func: null,
    __class__: bikas.serialization.SerialClass
}, bikas.serialization.EnumValueCache = $hxClasses["bikas.serialization.EnumValueCache"] = function() {}, bikas.serialization.EnumValueCache.__name__ = ["bikas", "serialization", "EnumValueCache"], bikas.serialization.EnumValueCache.prototype = {
    name: null,
    value: null,
    __class__: bikas.serialization.EnumValueCache
}, bikas.serialization.EnumTypeCache = $hxClasses["bikas.serialization.EnumTypeCache"] = function() {}, bikas.serialization.EnumTypeCache.__name__ = ["bikas", "serialization", "EnumTypeCache"], bikas.serialization.EnumTypeCache.prototype = {
    name: null,
    type: null,
    values: null,
    __class__: bikas.serialization.EnumTypeCache
}, bikas.serialization.SerialData = $hxClasses["bikas.serialization.SerialData"] = function() {
    this.type_table = null
}, bikas.serialization.SerialData.__name__ = ["bikas", "serialization", "SerialData"], bikas.serialization.SerialData.prototype = {
    classes: null,
    enum_cache: null,
    type_table: null,
    __class__: bikas.serialization.SerialData
}, bikas.serialization.UnserialField = $hxClasses["bikas.serialization.UnserialField"] = function() {
    this.serial_field = null
}, bikas.serialization.UnserialField.__name__ = ["bikas", "serialization", "UnserialField"], bikas.serialization.UnserialField.prototype = {
    field_name: null,
    value_type_flags: null,
    serial_field: null,
    __class__: bikas.serialization.UnserialField
}, bikas.serialization.UnserialClass = $hxClasses["bikas.serialization.UnserialClass"] = function() {
    this.serial_class = null, this.fields = null
}, bikas.serialization.UnserialClass.__name__ = ["bikas", "serialization", "UnserialClass"], bikas.serialization.UnserialClass.prototype = {
    full_class_name: null,
    fields: null,
    serial_class: null,
    __class__: bikas.serialization.UnserialClass
}, bikas.serialization.UnserialData = $hxClasses["bikas.serialization.UnserialData"] = function() {}, bikas.serialization.UnserialData.__name__ = ["bikas", "serialization", "UnserialData"], bikas.serialization.UnserialData.prototype = {
    classes: null,
    enum_cache: null,
    __class__: bikas.serialization.UnserialData
}, bikas.serialization.BefDo = $hxClasses["bikas.serialization.BefDo"] = function() {}, bikas.serialization.BefDo.__name__ = ["bikas", "serialization", "BefDo"], bikas.serialization.BefDo.createSerialData = function() {
    var a = new bikas.serialization.SerialData;
    return a.classes = [], a.enum_cache = [], a
}, bikas.serialization.BefDo.pushClass = function(a, b, c) {
    var d = new bikas.serialization.SerialClass;
    return d.full_class_name = Type.getClassName(b), d.serial_type = b, d.unserial_type = b, d.fields = [], d.ignore_fields = [], d.init_func = c, a.classes.push(d), d
}, bikas.serialization.BefDo.pushField = function(a, b, c) {
    var d = new bikas.serialization.SerialField;
    d.field_name = b, d.value_type_flags = [], d.value_type_flags.push(c), a.fields.push(d)
}, bikas.serialization.BefDo.pushBool = function(a, b) {
    var c = new bikas.serialization.SerialField;
    c.field_name = b, c.value_type_flags = [], c.value_type_flags.push(0), a.fields.push(c)
}, bikas.serialization.BefDo.pushInt = function(a, b) {
    var c = new bikas.serialization.SerialField;
    c.field_name = b, c.value_type_flags = [], c.value_type_flags.push(3), a.fields.push(c)
}, bikas.serialization.BefDo.pushDouble = function(a, b) {
    var c = new bikas.serialization.SerialField;
    c.field_name = b, c.value_type_flags = [], c.value_type_flags.push(4), a.fields.push(c)
}, bikas.serialization.BefDo.pushString = function(a, b) {
    var c = new bikas.serialization.SerialField;
    c.field_name = b, c.value_type_flags = [], c.value_type_flags.push(5), a.fields.push(c)
}, bikas.serialization.BefDo.pushEnum = function(a, b) {
    var c = new bikas.serialization.SerialField;
    c.field_name = b, c.value_type_flags = [], c.value_type_flags.push(7), a.fields.push(c)
}, bikas.serialization.BefDo.pushArray = function(a, b, c) {
    c.unshift(11);
    var d = new bikas.serialization.SerialField;
    d.field_name = b, d.value_type_flags = c, a.fields.push(d)
}, bikas.serialization.BefDo.pushInstance = function(a, b) {
    var c = new bikas.serialization.SerialField;
    c.field_name = b, c.value_type_flags = [], c.value_type_flags.push(12), a.fields.push(c)
}, bikas.serialization.BefDo.pushPoint = function(a, b) {
    var c = new bikas.serialization.SerialField;
    c.field_name = b, c.value_type_flags = [], c.value_type_flags.push(128), a.fields.push(c)
}, bikas.serialization.BefDo.pushTransform = function(a, b) {
    var c = new bikas.serialization.SerialField;
    c.field_name = b, c.value_type_flags = [], c.value_type_flags.push(129), a.fields.push(c)
}, bikas.serialization.BefDo.pushIgnore = function(a, b) {
    a.ignore_fields.push(b)
}, bikas.serialization.BefDo.validateSerialData = function(a) {
    for (var b, c = !0, d = 0, e = a.classes; d < e.length;) {
        var f = e[d];
        ++d, b = Type.getInstanceFields(Type.resolveClass(f.full_class_name));
        for (var g = 0; g < b.length;) {
            var h = b[g];
            ++g;
            for (var i = !1, j = 0, k = f.fields; j < k.length;) {
                var l = k[j];
                if (++j, l.field_name == h) {
                    i = !0;
                    break
                }
            }
            f.ignore_fields.indexOf(h) != -1 && (i = !0), i || (c = !1)
        }
        for (var m = 0; m < f.fields.length;) b.indexOf(f.fields[m].field_name) == -1 && (f.fields.splice(m, 1), --m, c = !1), ++m;
        for (m = 0; m < f.ignore_fields.length;) b.indexOf(f.ignore_fields[m]) == -1, ++m
    }
    return c
}, bikas.serialization.BefDo.createTypeTableForSerialData = function(a) {
    var b = bikas.serialization.BefDo.createByteCursorForSerialization(32768);
    b.pos = 0;
    var c = a.classes.length;
    if (b.pos + 2 >= b.bytes.length) {
        var d = b.bytes.length + b.alloc_size;
        d < b.pos + 2 && (d = b.pos + 2);
        var e = new haxe.io.Bytes(new ArrayBuffer(d));
        e.blit(0, b.bytes, 0, b.bytes.length), b.bytes = e
    }
    b.bytes.setUInt16(b.pos, c), b.pos += 2;
    for (var f = 0, g = a.classes; f < g.length;) {
        var h = g[f];
        ++f;
        var i = haxe.io.Bytes.ofString(h.full_class_name),
            j = i.length;
        if (b.pos + 2 >= b.bytes.length) {
            var k = b.bytes.length + b.alloc_size;
            k < b.pos + 2 && (k = b.pos + 2);
            var l = new haxe.io.Bytes(new ArrayBuffer(k));
            l.blit(0, b.bytes, 0, b.bytes.length), b.bytes = l
        }
        b.bytes.setUInt16(b.pos, j), b.pos += 2;
        var m = i.length;
        if (b.pos + m >= b.bytes.length) {
            var n = b.bytes.length + b.alloc_size;
            n < b.pos + m && (n = b.pos + m);
            var o = new haxe.io.Bytes(new ArrayBuffer(n));
            o.blit(0, b.bytes, 0, b.bytes.length), b.bytes = o
        }
        b.bytes.blit(b.pos, i, 0, i.length), b.pos += i.length;
        var p = h.fields.length;
        if (b.pos + 2 >= b.bytes.length) {
            var q = b.bytes.length + b.alloc_size;
            q < b.pos + 2 && (q = b.pos + 2);
            var r = new haxe.io.Bytes(new ArrayBuffer(q));
            r.blit(0, b.bytes, 0, b.bytes.length), b.bytes = r
        }
        b.bytes.setUInt16(b.pos, p), b.pos += 2;
        for (var s = 0, t = h.fields; s < t.length;) {
            var u = t[s];
            ++s;
            var v = haxe.io.Bytes.ofString(u.field_name),
                w = v.length;
            if (b.pos + 2 >= b.bytes.length) {
                var x = b.bytes.length + b.alloc_size;
                x < b.pos + 2 && (x = b.pos + 2);
                var y = new haxe.io.Bytes(new ArrayBuffer(x));
                y.blit(0, b.bytes, 0, b.bytes.length), b.bytes = y
            }
            b.bytes.setUInt16(b.pos, w), b.pos += 2;
            var z = v.length;
            if (b.pos + z >= b.bytes.length) {
                var A = b.bytes.length + b.alloc_size;
                A < b.pos + z && (A = b.pos + z);
                var B = new haxe.io.Bytes(new ArrayBuffer(A));
                B.blit(0, b.bytes, 0, b.bytes.length), b.bytes = B
            }
            b.bytes.blit(b.pos, v, 0, v.length), b.pos += v.length;
            var C = u.value_type_flags.length;
            if (b.pos + 1 >= b.bytes.length) {
                var D = b.bytes.length + b.alloc_size;
                D < b.pos + 1 && (D = b.pos + 1);
                var E = new haxe.io.Bytes(new ArrayBuffer(D));
                E.blit(0, b.bytes, 0, b.bytes.length), b.bytes = E
            }
            b.bytes.b[b.pos] = 255 & C, b.pos += 1;
            for (var F = 0, G = u.value_type_flags; F < G.length;) {
                var H = G[F];
                if (++F, b.pos + 1 >= b.bytes.length) {
                    var I = b.bytes.length + b.alloc_size;
                    I < b.pos + 1 && (I = b.pos + 1);
                    var J = new haxe.io.Bytes(new ArrayBuffer(I));
                    J.blit(0, b.bytes, 0, b.bytes.length), b.bytes = J
                }
                b.bytes.b[b.pos] = 255 & H, b.pos += 1
            }
        }
    }
    var K = b.pos,
        L = new haxe.io.Bytes(new ArrayBuffer(K));
    L.blit(0, b.bytes, 0, K), a.type_table = L
}, bikas.serialization.BefDo.createByteCursorForSerialization = function(a) {
    null == a && (a = 1048576);
    var b = new bikas.serialization.ByteCursor;
    return b.alloc_size = a, b.bytes = new haxe.io.Bytes(new ArrayBuffer(a)), b.pos = 0, b
}, bikas.serialization.BefDo.allocateMoreIfNeeded = function(a, b) {
    if (a.pos + b >= a.bytes.length) {
        var c = a.bytes.length + a.alloc_size;
        c < a.pos + b && (c = a.pos + b);
        var d = new haxe.io.Bytes(new ArrayBuffer(c));
        d.blit(0, a.bytes, 0, a.bytes.length), a.bytes = d
    }
}, bikas.serialization.BefDo.serialize = function(a, b, c, d) {
    if (null == d && (d = 1048576), null == a.type_table) return null;
    var e = bikas.serialization.BefDo.createByteCursorForSerialization(d);
    e.pos = 0;
    var f = haxe.io.Bytes.ofString("BEF_v3"),
        g = f.length;
    if (e.pos + 2 >= e.bytes.length) {
        var h = e.bytes.length + e.alloc_size;
        h < e.pos + 2 && (h = e.pos + 2);
        var i = new haxe.io.Bytes(new ArrayBuffer(h));
        i.blit(0, e.bytes, 0, e.bytes.length), e.bytes = i
    }
    e.bytes.setUInt16(e.pos, g), e.pos += 2;
    var j = f.length;
    if (e.pos + j >= e.bytes.length) {
        var k = e.bytes.length + e.alloc_size;
        k < e.pos + j && (k = e.pos + j);
        var l = new haxe.io.Bytes(new ArrayBuffer(k));
        l.blit(0, e.bytes, 0, e.bytes.length), e.bytes = l
    }
    if (e.bytes.blit(e.pos, f, 0, f.length), e.pos += f.length, e.pos + 4 >= e.bytes.length) {
        var m = e.bytes.length + e.alloc_size;
        m < e.pos + 4 && (m = e.pos + 4);
        var n = new haxe.io.Bytes(new ArrayBuffer(m));
        n.blit(0, e.bytes, 0, e.bytes.length), e.bytes = n
    }
    var o = e.bytes,
        p = e.pos;
    o.b[p] = 0, o.b[p + 1] = 0, o.b[p + 2] = 0, o.b[p + 3] = 0, e.pos += 4;
    var q = a.type_table.length;
    if (e.pos + q >= e.bytes.length) {
        var r = e.bytes.length + e.alloc_size;
        r < e.pos + q && (r = e.pos + q);
        var s = new haxe.io.Bytes(new ArrayBuffer(r));
        s.blit(0, e.bytes, 0, e.bytes.length), e.bytes = s
    }
    e.bytes.blit(e.pos, a.type_table, 0, a.type_table.length), e.pos += a.type_table.length, a.enum_cache = [], bikas.serialization.BefDo.setValue(e, a, b, c);
    var t = e.pos;
    e.pos = 0;
    var u = e.bytes.getUInt16(e.pos);
    e.pos += 2;
    var v = u;
    e.bytes.getString(e.pos, v);
    if (e.pos += v, e.pos + 4 >= e.bytes.length) {
        var w = e.bytes.length + e.alloc_size;
        w < e.pos + 4 && (w = e.pos + 4);
        var x = new haxe.io.Bytes(new ArrayBuffer(w));
        x.blit(0, e.bytes, 0, e.bytes.length), e.bytes = x
    }
    var y = e.bytes,
        z = e.pos;
    y.b[z] = 255 & t, y.b[z + 1] = t >> 8 & 255, y.b[z + 2] = t >> 16 & 255, y.b[z + 3] = t >>> 24 & 255, e.pos += 4;
    var A = new haxe.io.Bytes(new ArrayBuffer(t));
    return A.blit(0, e.bytes, 0, t), A
}, bikas.serialization.BefDo.unserialize = function(a, b) {
    var c = new bikas.serialization.ByteCursor;
    c.bytes = b, c.pos = 0;
    var d = c.bytes.getUInt16(c.pos);
    c.pos += 2;
    var e = d,
        f = c.bytes.getString(c.pos, e);
    c.pos += e;
    var g = f;
    if ("BEF_v3" != g) return null;
    var h = c.bytes,
        i = c.pos,
        j = h.b[i] | h.b[i + 1] << 8 | h.b[i + 2] << 16 | h.b[i + 3] << 24;
    c.pos += 4;
    var k = j;
    if (k != b.length) return null;
    var l = c.bytes.getUInt16(c.pos);
    c.pos += 2;
    var m = l,
        n = new bikas.serialization.UnserialData;
    n.classes = [], n.enum_cache = [];
    for (var o, p = 0, q = m; p < q;) {
        p++;
        o = new bikas.serialization.UnserialClass, o.fields = [], o.serial_class = null;
        var r = c.bytes.getUInt16(c.pos);
        c.pos += 2;
        var s = r,
            t = c.bytes.getString(c.pos, s);
        c.pos += s, o.full_class_name = t;
        var u = c.bytes.getUInt16(c.pos);
        c.pos += 2;
        for (var v = u, w = 0, x = a.classes; w < x.length;) {
            var y = x[w];
            if (++w, y.full_class_name == o.full_class_name) {
                o.serial_class = y;
                break
            }
        }
        null == o.serial_class;
        for (var z = 0, A = v; z < A;) {
            var B = (z++, new bikas.serialization.UnserialField),
                C = c.bytes.getUInt16(c.pos);
            c.pos += 2;
            var D = C,
                E = c.bytes.getString(c.pos, D);
            c.pos += D, B.field_name = E, B.value_type_flags = [];
            var F = c.bytes.b[c.pos];
            c.pos += 1;
            for (var G = F, H = 0, I = G; H < I;) {
                var J = (H++, c.bytes.b[c.pos]);
                c.pos += 1, B.value_type_flags.push(J)
            }
            if (B.serial_field = null, null != o.serial_class) {
                for (var K = 0, L = o.serial_class.fields; K < L.length;) {
                    var M = L[K];
                    ++K, M.field_name == B.field_name && (B.serial_field = M)
                }
                if (null == B.serial_field);
                else if (B.value_type_flags.length != B.serial_field.value_type_flags.length) B.serial_field = null;
                else
                    for (var N = 0, O = B.value_type_flags.length; N < O;) {
                        var P = N++;
                        if (B.value_type_flags[P] != B.serial_field.value_type_flags[P] && (12 != B.value_type_flags[P] || 128 != B.serial_field.value_type_flags[P] && 129 != B.serial_field.value_type_flags[P])) {
                            B.serial_field = null;
                            break
                        }
                    }
            }
            o.fields.push(B)
        }
        n.classes.push(o)
    }
    var Q = c.bytes.b[c.pos];
    c.pos += 1;
    var R = Q,
        S = bikas.serialization.BefDo.getValue(c, n, R, null);
    return S
}, bikas.serialization.BefDo.setByte = function(a, b) {
    if (a.pos + 1 >= a.bytes.length) {
        var c = a.bytes.length + a.alloc_size;
        c < a.pos + 1 && (c = a.pos + 1);
        var d = new haxe.io.Bytes(new ArrayBuffer(c));
        d.blit(0, a.bytes, 0, a.bytes.length), a.bytes = d
    }
    a.bytes.b[a.pos] = 255 & b, a.pos += 1
}, bikas.serialization.BefDo.getByte = function(a) {
    var b = a.bytes.b[a.pos];
    return a.pos += 1, b
}, bikas.serialization.BefDo.setUInt16 = function(a, b) {
    if (a.pos + 2 >= a.bytes.length) {
        var c = a.bytes.length + a.alloc_size;
        c < a.pos + 2 && (c = a.pos + 2);
        var d = new haxe.io.Bytes(new ArrayBuffer(c));
        d.blit(0, a.bytes, 0, a.bytes.length), a.bytes = d
    }
    a.bytes.setUInt16(a.pos, b), a.pos += 2
}, bikas.serialization.BefDo.getUInt16 = function(a) {
    var b = a.bytes.getUInt16(a.pos);
    return a.pos += 2, b
}, bikas.serialization.BefDo.setInt32 = function(a, b) {
    if (a.pos + 4 >= a.bytes.length) {
        var c = a.bytes.length + a.alloc_size;
        c < a.pos + 4 && (c = a.pos + 4);
        var d = new haxe.io.Bytes(new ArrayBuffer(c));
        d.blit(0, a.bytes, 0, a.bytes.length), a.bytes = d
    }
    var e = a.bytes,
        f = a.pos;
    e.b[f] = 255 & b, e.b[f + 1] = b >> 8 & 255, e.b[f + 2] = b >> 16 & 255, e.b[f + 3] = b >>> 24 & 255, a.pos += 4
}, bikas.serialization.BefDo.getInt32 = function(a) {
    var b = a.bytes,
        c = a.pos,
        d = b.b[c] | b.b[c + 1] << 8 | b.b[c + 2] << 16 | b.b[c + 3] << 24;
    return a.pos += 4, d
}, bikas.serialization.BefDo.setDouble = function(a, b) {
    if (a.pos + 8 >= a.bytes.length) {
        var c = a.bytes.length + a.alloc_size;
        c < a.pos + 8 && (c = a.pos + 8);
        var d = new haxe.io.Bytes(new ArrayBuffer(c));
        d.blit(0, a.bytes, 0, a.bytes.length), a.bytes = d
    }
    a.bytes.setDouble(a.pos, b), a.pos += 8
}, bikas.serialization.BefDo.getDouble = function(a) {
    var b = a.bytes.getDouble(a.pos);
    return a.pos += 8, b
}, bikas.serialization.BefDo.setString = function(a, b) {
    var c = haxe.io.Bytes.ofString(b),
        d = c.length;
    if (a.pos + 2 >= a.bytes.length) {
        var e = a.bytes.length + a.alloc_size;
        e < a.pos + 2 && (e = a.pos + 2);
        var f = new haxe.io.Bytes(new ArrayBuffer(e));
        f.blit(0, a.bytes, 0, a.bytes.length), a.bytes = f
    }
    a.bytes.setUInt16(a.pos, d), a.pos += 2;
    var g = c.length;
    if (a.pos + g >= a.bytes.length) {
        var h = a.bytes.length + a.alloc_size;
        h < a.pos + g && (h = a.pos + g);
        var i = new haxe.io.Bytes(new ArrayBuffer(h));
        i.blit(0, a.bytes, 0, a.bytes.length), a.bytes = i
    }
    a.bytes.blit(a.pos, c, 0, c.length), a.pos += c.length
}, bikas.serialization.BefDo.getString = function(a) {
    var b = a.bytes.getUInt16(a.pos);
    a.pos += 2;
    var c = b,
        d = a.bytes.getString(a.pos, c);
    return a.pos += c, d
}, bikas.serialization.BefDo.setEnumValue = function(a, b, c) {
    for (var d, e, f = Type.getEnum(c), g = 0, h = !1, i = 0, j = b.enum_cache; i < j.length;) {
        var k = j[i];
        if (++i, k.type == f) {
            h = !0, e = !1, d = 0;
            for (var l = 0, m = k.values; l < m.length;) {
                var n = m[l];
                if (++l, n.value == c) {
                    e = !0;
                    break
                }++d
            }
            if (e) {
                if (a.pos + 1 >= a.bytes.length) {
                    var o = a.bytes.length + a.alloc_size;
                    o < a.pos + 1 && (o = a.pos + 1);
                    var p = new haxe.io.Bytes(new ArrayBuffer(o));
                    p.blit(0, a.bytes, 0, a.bytes.length), a.bytes = p
                }
                if (a.bytes.b[a.pos] = 8, a.pos += 1, a.pos + 2 >= a.bytes.length) {
                    var q = a.bytes.length + a.alloc_size;
                    q < a.pos + 2 && (q = a.pos + 2);
                    var r = new haxe.io.Bytes(new ArrayBuffer(q));
                    r.blit(0, a.bytes, 0, a.bytes.length), a.bytes = r
                }
                if (a.bytes.setUInt16(a.pos, g), a.pos += 2, a.pos + 2 >= a.bytes.length) {
                    var s = a.bytes.length + a.alloc_size;
                    s < a.pos + 2 && (s = a.pos + 2);
                    var t = new haxe.io.Bytes(new ArrayBuffer(s));
                    t.blit(0, a.bytes, 0, a.bytes.length), a.bytes = t
                }
                a.bytes.setUInt16(a.pos, d), a.pos += 2
            } else {
                var u = new bikas.serialization.EnumValueCache;
                if (u.value = c, u.name = c[0], k.values.push(u), a.pos + 1 >= a.bytes.length) {
                    var v = a.bytes.length + a.alloc_size;
                    v < a.pos + 1 && (v = a.pos + 1);
                    var w = new haxe.io.Bytes(new ArrayBuffer(v));
                    w.blit(0, a.bytes, 0, a.bytes.length), a.bytes = w
                }
                if (a.bytes.b[a.pos] = 9, a.pos += 1, a.pos + 2 >= a.bytes.length) {
                    var x = a.bytes.length + a.alloc_size;
                    x < a.pos + 2 && (x = a.pos + 2);
                    var y = new haxe.io.Bytes(new ArrayBuffer(x));
                    y.blit(0, a.bytes, 0, a.bytes.length), a.bytes = y
                }
                a.bytes.setUInt16(a.pos, g), a.pos += 2;
                var z = haxe.io.Bytes.ofString(u.name),
                    A = z.length;
                if (a.pos + 2 >= a.bytes.length) {
                    var B = a.bytes.length + a.alloc_size;
                    B < a.pos + 2 && (B = a.pos + 2);
                    var C = new haxe.io.Bytes(new ArrayBuffer(B));
                    C.blit(0, a.bytes, 0, a.bytes.length), a.bytes = C
                }
                a.bytes.setUInt16(a.pos, A), a.pos += 2;
                var D = z.length;
                if (a.pos + D >= a.bytes.length) {
                    var E = a.bytes.length + a.alloc_size;
                    E < a.pos + D && (E = a.pos + D);
                    var F = new haxe.io.Bytes(new ArrayBuffer(E));
                    F.blit(0, a.bytes, 0, a.bytes.length), a.bytes = F
                }
                a.bytes.blit(a.pos, z, 0, z.length), a.pos += z.length
            }
            break
        }++g
    }
    if (null == c) {
        if (a.pos + 1 >= a.bytes.length) {
            var G = a.bytes.length + a.alloc_size;
            G < a.pos + 1 && (G = a.pos + 1);
            var H = new haxe.io.Bytes(new ArrayBuffer(G));
            H.blit(0, a.bytes, 0, a.bytes.length), a.bytes = H
        }
        a.bytes.b[a.pos] = 6, a.pos += 1
    } else if (!h) {
        var I = new bikas.serialization.EnumTypeCache;
        I.type = f, I.name = Type.getEnumName(f), I.values = [];
        var J = new bikas.serialization.EnumValueCache;
        if (J.value = c, J.name = c[0], I.values.push(J), a.pos + 1 >= a.bytes.length) {
            var K = a.bytes.length + a.alloc_size;
            K < a.pos + 1 && (K = a.pos + 1);
            var L = new haxe.io.Bytes(new ArrayBuffer(K));
            L.blit(0, a.bytes, 0, a.bytes.length), a.bytes = L
        }
        a.bytes.b[a.pos] = 10, a.pos += 1;
        var M = haxe.io.Bytes.ofString(I.name),
            N = M.length;
        if (a.pos + 2 >= a.bytes.length) {
            var O = a.bytes.length + a.alloc_size;
            O < a.pos + 2 && (O = a.pos + 2);
            var P = new haxe.io.Bytes(new ArrayBuffer(O));
            P.blit(0, a.bytes, 0, a.bytes.length), a.bytes = P
        }
        a.bytes.setUInt16(a.pos, N), a.pos += 2;
        var Q = M.length;
        if (a.pos + Q >= a.bytes.length) {
            var R = a.bytes.length + a.alloc_size;
            R < a.pos + Q && (R = a.pos + Q);
            var S = new haxe.io.Bytes(new ArrayBuffer(R));
            S.blit(0, a.bytes, 0, a.bytes.length), a.bytes = S
        }
        a.bytes.blit(a.pos, M, 0, M.length), a.pos += M.length;
        var T = haxe.io.Bytes.ofString(J.name),
            U = T.length;
        if (a.pos + 2 >= a.bytes.length) {
            var V = a.bytes.length + a.alloc_size;
            V < a.pos + 2 && (V = a.pos + 2);
            var W = new haxe.io.Bytes(new ArrayBuffer(V));
            W.blit(0, a.bytes, 0, a.bytes.length), a.bytes = W
        }
        a.bytes.setUInt16(a.pos, U), a.pos += 2;
        var X = T.length;
        if (a.pos + X >= a.bytes.length) {
            var Y = a.bytes.length + a.alloc_size;
            Y < a.pos + X && (Y = a.pos + X);
            var Z = new haxe.io.Bytes(new ArrayBuffer(Y));
            Z.blit(0, a.bytes, 0, a.bytes.length), a.bytes = Z
        }
        a.bytes.blit(a.pos, T, 0, T.length), a.pos += T.length, b.enum_cache.push(I)
    }
}, bikas.serialization.BefDo.getEnum = function(a, b, c) {
    switch (b) {
        case 8:
            var d = a.bytes.getUInt16(a.pos);
            a.pos += 2;
            var e = d,
                f = a.bytes.getUInt16(a.pos);
            a.pos += 2;
            var g = f,
                h = c.enum_cache[e],
                i = h.values[g];
            return null != h.type && null != i.value ? i.value : null;
        case 9:
            var j = a.bytes.getUInt16(a.pos);
            a.pos += 2;
            var k = j,
                l = a.bytes.getUInt16(a.pos);
            a.pos += 2;
            var m = l,
                n = a.bytes.getString(a.pos, m);
            a.pos += m;
            var o = n,
                p = c.enum_cache[k],
                q = p.type,
                r = new bikas.serialization.EnumValueCache;
            return p.values.push(r), r.name = o, null != q ? (r.value = Type.createEnum(q, o), r.value) : null;
        case 10:
            var s = a.bytes.getUInt16(a.pos);
            a.pos += 2;
            var t = s,
                u = a.bytes.getString(a.pos, t);
            a.pos += t;
            var v = u,
                w = a.bytes.getUInt16(a.pos);
            a.pos += 2;
            var x = w,
                y = a.bytes.getString(a.pos, x);
            a.pos += x;
            var z = y,
                A = Type.resolveEnum(v),
                B = new bikas.serialization.EnumTypeCache;
            B.name = v, B.type = A, B.values = [];
            var C = new bikas.serialization.EnumValueCache;
            return C.name = z, B.values.push(C), c.enum_cache.push(B), null != A ? (C.value = Type.createEnum(A, z), C.value) : null;
        default:
            return null
    }
}, bikas.serialization.BefDo.setPoint = function(a, b) {
    var c = b.x;
    if (a.pos + 8 >= a.bytes.length) {
        var d = a.bytes.length + a.alloc_size;
        d < a.pos + 8 && (d = a.pos + 8);
        var e = new haxe.io.Bytes(new ArrayBuffer(d));
        e.blit(0, a.bytes, 0, a.bytes.length), a.bytes = e
    }
    a.bytes.setDouble(a.pos, c), a.pos += 8;
    var f = b.y;
    if (a.pos + 8 >= a.bytes.length) {
        var g = a.bytes.length + a.alloc_size;
        g < a.pos + 8 && (g = a.pos + 8);
        var h = new haxe.io.Bytes(new ArrayBuffer(g));
        h.blit(0, a.bytes, 0, a.bytes.length), a.bytes = h
    }
    a.bytes.setDouble(a.pos, f), a.pos += 8
}, bikas.serialization.BefDo.getPoint = function(a, b) {
    var c = a.bytes.getDouble(a.pos);
    a.pos += 8;
    var d = c,
        e = a.bytes.getDouble(a.pos);
    a.pos += 8;
    var f = e;
    if (null == b) return new bikas.global.Point(d, f);
    var g = js.Boot.__cast(b, bikas.global.Point);
    return g.x = d, g.y = f, g
}, bikas.serialization.BefDo.setTransform = function(a, b) {
    var c = b.scale_x;
    if (a.pos + 8 >= a.bytes.length) {
        var d = a.bytes.length + a.alloc_size;
        d < a.pos + 8 && (d = a.pos + 8);
        var e = new haxe.io.Bytes(new ArrayBuffer(d));
        e.blit(0, a.bytes, 0, a.bytes.length), a.bytes = e
    }
    a.bytes.setDouble(a.pos, c), a.pos += 8;
    var f = b.scale_y;
    if (a.pos + 8 >= a.bytes.length) {
        var g = a.bytes.length + a.alloc_size;
        g < a.pos + 8 && (g = a.pos + 8);
        var h = new haxe.io.Bytes(new ArrayBuffer(g));
        h.blit(0, a.bytes, 0, a.bytes.length), a.bytes = h
    }
    a.bytes.setDouble(a.pos, f), a.pos += 8;
    var i = b.rotation;
    if (a.pos + 8 >= a.bytes.length) {
        var j = a.bytes.length + a.alloc_size;
        j < a.pos + 8 && (j = a.pos + 8);
        var k = new haxe.io.Bytes(new ArrayBuffer(j));
        k.blit(0, a.bytes, 0, a.bytes.length), a.bytes = k
    }
    a.bytes.setDouble(a.pos, i), a.pos += 8
}, bikas.serialization.BefDo.getTransform = function(a, b) {
    var c = a.bytes.getDouble(a.pos);
    a.pos += 8;
    var d = c,
        e = a.bytes.getDouble(a.pos);
    a.pos += 8;
    var f = e,
        g = a.bytes.getDouble(a.pos);
    a.pos += 8;
    var h = g;
    if (null == b) {
        var i = new bikas.global.Transform;
        return i.scale_x = d, i.scale_y = f, i.rotation = h, i
    }
    var j = js.Boot.__cast(b, bikas.global.Transform);
    return j.scale_x = d, j.scale_y = f, j.rotation = h, j
}, bikas.serialization.BefDo.setValue = function(a, b, c, d) {
    var e = d[0];
    switch (e) {
        case 0:
            if (1 == js.Boot.__cast(c, Bool)) {
                if (a.pos + 1 >= a.bytes.length) {
                    var f = a.bytes.length + a.alloc_size;
                    f < a.pos + 1 && (f = a.pos + 1);
                    var g = new haxe.io.Bytes(new ArrayBuffer(f));
                    g.blit(0, a.bytes, 0, a.bytes.length), a.bytes = g
                }
                a.bytes.b[a.pos] = 1, a.pos += 1
            } else {
                if (a.pos + 1 >= a.bytes.length) {
                    var h = a.bytes.length + a.alloc_size;
                    h < a.pos + 1 && (h = a.pos + 1);
                    var i = new haxe.io.Bytes(new ArrayBuffer(h));
                    i.blit(0, a.bytes, 0, a.bytes.length), a.bytes = i
                }
                a.bytes.b[a.pos] = 2, a.pos += 1
            }
            break;
        case 3:
            if (a.pos + 1 >= a.bytes.length) {
                var j = a.bytes.length + a.alloc_size;
                j < a.pos + 1 && (j = a.pos + 1);
                var k = new haxe.io.Bytes(new ArrayBuffer(j));
                k.blit(0, a.bytes, 0, a.bytes.length), a.bytes = k
            }
            a.bytes.b[a.pos] = 3, a.pos += 1;
            var l = js.Boot.__cast(c, Int);
            if (a.pos + 4 >= a.bytes.length) {
                var m = a.bytes.length + a.alloc_size;
                m < a.pos + 4 && (m = a.pos + 4);
                var n = new haxe.io.Bytes(new ArrayBuffer(m));
                n.blit(0, a.bytes, 0, a.bytes.length), a.bytes = n
            }
            var o = a.bytes,
                p = a.pos;
            o.b[p] = 255 & l, o.b[p + 1] = l >> 8 & 255, o.b[p + 2] = l >> 16 & 255, o.b[p + 3] = l >>> 24 & 255, a.pos += 4;
            break;
        case 4:
            if (a.pos + 1 >= a.bytes.length) {
                var q = a.bytes.length + a.alloc_size;
                q < a.pos + 1 && (q = a.pos + 1);
                var r = new haxe.io.Bytes(new ArrayBuffer(q));
                r.blit(0, a.bytes, 0, a.bytes.length), a.bytes = r
            }
            if (a.bytes.b[a.pos] = 4, a.pos += 1, a.pos + 8 >= a.bytes.length) {
                var s = a.bytes.length + a.alloc_size;
                s < a.pos + 8 && (s = a.pos + 8);
                var t = new haxe.io.Bytes(new ArrayBuffer(s));
                t.blit(0, a.bytes, 0, a.bytes.length), a.bytes = t
            }
            a.bytes.setDouble(a.pos, js.Boot.__cast(c, Float)), a.pos += 8;
            break;
        case 5:
            if (a.pos + 1 >= a.bytes.length) {
                var u = a.bytes.length + a.alloc_size;
                u < a.pos + 1 && (u = a.pos + 1);
                var v = new haxe.io.Bytes(new ArrayBuffer(u));
                v.blit(0, a.bytes, 0, a.bytes.length), a.bytes = v
            }
            a.bytes.b[a.pos] = 5, a.pos += 1;
            var w = haxe.io.Bytes.ofString(js.Boot.__cast(c, String)),
                x = w.length;
            if (a.pos + 2 >= a.bytes.length) {
                var y = a.bytes.length + a.alloc_size;
                y < a.pos + 2 && (y = a.pos + 2);
                var z = new haxe.io.Bytes(new ArrayBuffer(y));
                z.blit(0, a.bytes, 0, a.bytes.length), a.bytes = z
            }
            a.bytes.setUInt16(a.pos, x), a.pos += 2;
            var A = w.length;
            if (a.pos + A >= a.bytes.length) {
                var B = a.bytes.length + a.alloc_size;
                B < a.pos + A && (B = a.pos + A);
                var C = new haxe.io.Bytes(new ArrayBuffer(B));
                C.blit(0, a.bytes, 0, a.bytes.length), a.bytes = C
            }
            a.bytes.blit(a.pos, w, 0, w.length), a.pos += w.length;
            break;
        case 7:
            bikas.serialization.BefDo.setEnumValue(a, b, c);
            break;
        case 11:
            if (null == c) {
                if (a.pos + 1 >= a.bytes.length) {
                    var D = a.bytes.length + a.alloc_size;
                    D < a.pos + 1 && (D = a.pos + 1);
                    var E = new haxe.io.Bytes(new ArrayBuffer(D));
                    E.blit(0, a.bytes, 0, a.bytes.length), a.bytes = E
                }
                a.bytes.b[a.pos] = 6, a.pos += 1
            } else {
                if (a.pos + 1 >= a.bytes.length) {
                    var F = a.bytes.length + a.alloc_size;
                    F < a.pos + 1 && (F = a.pos + 1);
                    var G = new haxe.io.Bytes(new ArrayBuffer(F));
                    G.blit(0, a.bytes, 0, a.bytes.length), a.bytes = G
                }
                a.bytes.b[a.pos] = 11, a.pos += 1;
                var H = d.slice();
                H.shift(), bikas.serialization.BefDo.setArray(a, b, H, js.Boot.__cast(c, Array))
            }
            break;
        case 12:
            if (null == c) {
                if (a.pos + 1 >= a.bytes.length) {
                    var I = a.bytes.length + a.alloc_size;
                    I < a.pos + 1 && (I = a.pos + 1);
                    var J = new haxe.io.Bytes(new ArrayBuffer(I));
                    J.blit(0, a.bytes, 0, a.bytes.length), a.bytes = J
                }
                a.bytes.b[a.pos] = 6, a.pos += 1
            } else {
                for (var K = null, L = 0, M = 0, N = b.classes; M < N.length;) {
                    var O = N[M];
                    if (++M, js.Boot.__instanceof(c, O.serial_type)) {
                        K = O;
                        break
                    }++L
                }
                if (null == K) {
                    if (a.pos + 1 >= a.bytes.length) {
                        var P = a.bytes.length + a.alloc_size;
                        P < a.pos + 1 && (P = a.pos + 1);
                        var Q = new haxe.io.Bytes(new ArrayBuffer(P));
                        Q.blit(0, a.bytes, 0, a.bytes.length), a.bytes = Q
                    }
                    a.bytes.b[a.pos] = 6, a.pos += 1
                } else {
                    if (a.pos + 1 >= a.bytes.length) {
                        var R = a.bytes.length + a.alloc_size;
                        R < a.pos + 1 && (R = a.pos + 1);
                        var S = new haxe.io.Bytes(new ArrayBuffer(R));
                        S.blit(0, a.bytes, 0, a.bytes.length), a.bytes = S
                    }
                    a.bytes.b[a.pos] = 12, a.pos += 1, bikas.serialization.BefDo.setInstance(a, b, K, L, c)
                }
            }
            break;
        case 128:
            if (null == c) {
                if (a.pos + 1 >= a.bytes.length) {
                    var T = a.bytes.length + a.alloc_size;
                    T < a.pos + 1 && (T = a.pos + 1);
                    var U = new haxe.io.Bytes(new ArrayBuffer(T));
                    U.blit(0, a.bytes, 0, a.bytes.length), a.bytes = U
                }
                a.bytes.b[a.pos] = 6, a.pos += 1
            } else {
                if (a.pos + 1 >= a.bytes.length) {
                    var V = a.bytes.length + a.alloc_size;
                    V < a.pos + 1 && (V = a.pos + 1);
                    var W = new haxe.io.Bytes(new ArrayBuffer(V));
                    W.blit(0, a.bytes, 0, a.bytes.length), a.bytes = W
                }
                a.bytes.b[a.pos] = 128, a.pos += 1;
                var X = js.Boot.__cast(c, bikas.global.Point),
                    Y = X.x;
                if (a.pos + 8 >= a.bytes.length) {
                    var Z = a.bytes.length + a.alloc_size;
                    Z < a.pos + 8 && (Z = a.pos + 8);
                    var $ = new haxe.io.Bytes(new ArrayBuffer(Z));
                    $.blit(0, a.bytes, 0, a.bytes.length), a.bytes = $
                }
                a.bytes.setDouble(a.pos, Y), a.pos += 8;
                var _ = X.y;
                if (a.pos + 8 >= a.bytes.length) {
                    var aa = a.bytes.length + a.alloc_size;
                    aa < a.pos + 8 && (aa = a.pos + 8);
                    var ba = new haxe.io.Bytes(new ArrayBuffer(aa));
                    ba.blit(0, a.bytes, 0, a.bytes.length), a.bytes = ba
                }
                a.bytes.setDouble(a.pos, _), a.pos += 8
            }
            break;
        case 129:
            if (null == c) {
                if (a.pos + 1 >= a.bytes.length) {
                    var ca = a.bytes.length + a.alloc_size;
                    ca < a.pos + 1 && (ca = a.pos + 1);
                    var da = new haxe.io.Bytes(new ArrayBuffer(ca));
                    da.blit(0, a.bytes, 0, a.bytes.length), a.bytes = da
                }
                a.bytes.b[a.pos] = 6, a.pos += 1
            } else {
                if (a.pos + 1 >= a.bytes.length) {
                    var ea = a.bytes.length + a.alloc_size;
                    ea < a.pos + 1 && (ea = a.pos + 1);
                    var fa = new haxe.io.Bytes(new ArrayBuffer(ea));
                    fa.blit(0, a.bytes, 0, a.bytes.length), a.bytes = fa
                }
                a.bytes.b[a.pos] = 129, a.pos += 1;
                var ga = js.Boot.__cast(c, bikas.global.Transform),
                    ha = ga.scale_x;
                if (a.pos + 8 >= a.bytes.length) {
                    var ia = a.bytes.length + a.alloc_size;
                    ia < a.pos + 8 && (ia = a.pos + 8);
                    var ja = new haxe.io.Bytes(new ArrayBuffer(ia));
                    ja.blit(0, a.bytes, 0, a.bytes.length), a.bytes = ja
                }
                a.bytes.setDouble(a.pos, ha), a.pos += 8;
                var ka = ga.scale_y;
                if (a.pos + 8 >= a.bytes.length) {
                    var la = a.bytes.length + a.alloc_size;
                    la < a.pos + 8 && (la = a.pos + 8);
                    var ma = new haxe.io.Bytes(new ArrayBuffer(la));
                    ma.blit(0, a.bytes, 0, a.bytes.length), a.bytes = ma
                }
                a.bytes.setDouble(a.pos, ka), a.pos += 8;
                var na = ga.rotation;
                if (a.pos + 8 >= a.bytes.length) {
                    var oa = a.bytes.length + a.alloc_size;
                    oa < a.pos + 8 && (oa = a.pos + 8);
                    var pa = new haxe.io.Bytes(new ArrayBuffer(oa));
                    pa.blit(0, a.bytes, 0, a.bytes.length), a.bytes = pa
                }
                a.bytes.setDouble(a.pos, na), a.pos += 8
            }
    }
}, bikas.serialization.BefDo.getValue = function(a, b, c, d) {
    switch (c) {
        case 1:
            return !0;
        case 2:
            return !1;
        case 3:
            var e = a.bytes,
                f = a.pos,
                g = e.b[f] | e.b[f + 1] << 8 | e.b[f + 2] << 16 | e.b[f + 3] << 24;
            return a.pos += 4, g;
        case 4:
            var h = a.bytes.getDouble(a.pos);
            return a.pos += 8, h;
        case 5:
            var i = a.bytes.getUInt16(a.pos);
            a.pos += 2;
            var j = i,
                k = a.bytes.getString(a.pos, j);
            return a.pos += j, k;
        case 6:
            return null;
        case 8:
        case 9:
        case 10:
            return bikas.serialization.BefDo.getEnum(a, c, b);
        case 11:
            var l = d,
                m = a.bytes,
                n = a.pos;
            m.b[n] | m.b[n + 1] << 8 | m.b[n + 2] << 16 | m.b[n + 3] << 24;
            a.pos += 4;
            a.pos, a.bytes.b[a.pos];
            a.pos += 1;
            var o = a.bytes,
                p = a.pos,
                q = o.b[p] | o.b[p + 1] << 8 | o.b[p + 2] << 16 | o.b[p + 3] << 24;
            a.pos += 4;
            var r = q;
            if (null == l) l = [];
            else
                for (; l.length > r;) l.pop();
            for (var s, t, u = 0, v = r; u < v;) {
                var w = u++,
                    x = a.bytes.b[a.pos];
                a.pos += 1, s = x, w >= l.length ? (t = bikas.serialization.BefDo.getValue(a, b, s, null), l.push(t)) : (t = bikas.serialization.BefDo.getValue(a, b, s, l[w]), l[w] = t)
            }
            return l;
        case 12:
            var y = d,
                z = a.bytes,
                A = a.pos,
                B = z.b[A] | z.b[A + 1] << 8 | z.b[A + 2] << 16 | z.b[A + 3] << 24;
            a.pos += 4;
            var C = B,
                D = a.pos,
                E = a.bytes.getUInt16(a.pos);
            a.pos += 2;
            var F = E,
                G = b.classes[F],
                H = G.serial_class;
            if (null == H) return a.pos = D + C, null;
            null == y && (y = null != H.init_func ? H.init_func() : Type.createInstance(H.unserial_type, []));
            for (var I, J, K, L = 0, M = G.fields; L < M.length;) {
                var N = M[L];
                ++L;
                var O = a.bytes.b[a.pos];
                if (a.pos += 1, K = O, I = N.field_name, null == N.serial_field) bikas.serialization.BefDo.getValue(a, b, K, null);
                else {
                    switch (K) {
                        case 6:
                            J = null;
                            break;
                        case 11:
                        case 12:
                        case 128:
                        case 129:
                            J = bikas.serialization.BefDo.getValue(a, b, K, Reflect.field(y, I));
                            break;
                        default:
                            J = bikas.serialization.BefDo.getValue(a, b, K, null)
                    }
                    y[I] = J
                }
            }
            return y;
        case 128:
            var P = a.bytes.getDouble(a.pos);
            a.pos += 8;
            var Q = P,
                R = a.bytes.getDouble(a.pos);
            a.pos += 8;
            var S = R;
            if (null == d) return new bikas.global.Point(Q, S);
            var T = js.Boot.__cast(d, bikas.global.Point);
            return T.x = Q, T.y = S, T;
        case 129:
            var U = a.bytes.getDouble(a.pos);
            a.pos += 8;
            var V = U,
                W = a.bytes.getDouble(a.pos);
            a.pos += 8;
            var X = W,
                Y = a.bytes.getDouble(a.pos);
            a.pos += 8;
            var Z = Y;
            if (null == d) {
                var $ = new bikas.global.Transform;
                return $.scale_x = V, $.scale_y = X, $.rotation = Z, $
            }
            var _ = js.Boot.__cast(d, bikas.global.Transform);
            return _.scale_x = V, _.scale_y = X, _.rotation = Z, _;
        default:
            return null
    }
}, bikas.serialization.BefDo.setArray = function(a, b, c, d) {
    var e = a.pos;
    if (a.pos + 4 >= a.bytes.length) {
        var f = a.bytes.length + a.alloc_size;
        f < a.pos + 4 && (f = a.pos + 4);
        var g = new haxe.io.Bytes(new ArrayBuffer(f));
        g.blit(0, a.bytes, 0, a.bytes.length), a.bytes = g
    }
    var h = a.bytes,
        i = a.pos;
    if (h.b[i] = 0, h.b[i + 1] = 0, h.b[i + 2] = 0, h.b[i + 3] = 0, a.pos += 4, a.pos + 1 >= a.bytes.length) {
        var j = a.bytes.length + a.alloc_size;
        j < a.pos + 1 && (j = a.pos + 1);
        var k = new haxe.io.Bytes(new ArrayBuffer(j));
        k.blit(0, a.bytes, 0, a.bytes.length), a.bytes = k
    }
    a.bytes.b[a.pos] = 255 & c[0], a.pos += 1;
    var l = d.length;
    if (a.pos + 4 >= a.bytes.length) {
        var m = a.bytes.length + a.alloc_size;
        m < a.pos + 4 && (m = a.pos + 4);
        var n = new haxe.io.Bytes(new ArrayBuffer(m));
        n.blit(0, a.bytes, 0, a.bytes.length), a.bytes = n
    }
    var o = a.bytes,
        p = a.pos;
    o.b[p] = 255 & l, o.b[p + 1] = l >> 8 & 255, o.b[p + 2] = l >> 16 & 255, o.b[p + 3] = l >>> 24 & 255, a.pos += 4;
    for (var q = 0; q < d.length;) {
        var r = d[q];
        ++q, bikas.serialization.BefDo.setValue(a, b, r, c)
    }
    var s = a.pos;
    a.pos = e;
    var t = s - a.pos - 4;
    if (a.pos + 4 >= a.bytes.length) {
        var u = a.bytes.length + a.alloc_size;
        u < a.pos + 4 && (u = a.pos + 4);
        var v = new haxe.io.Bytes(new ArrayBuffer(u));
        v.blit(0, a.bytes, 0, a.bytes.length), a.bytes = v
    }
    var w = a.bytes,
        x = a.pos;
    w.b[x] = 255 & t, w.b[x + 1] = t >> 8 & 255, w.b[x + 2] = t >> 16 & 255, w.b[x + 3] = t >>> 24 & 255, a.pos += 4, a.pos = s
}, bikas.serialization.BefDo.getArray = function(a, b, c) {
    var d = a.bytes,
        e = a.pos;
    d.b[e] | d.b[e + 1] << 8 | d.b[e + 2] << 16 | d.b[e + 3] << 24;
    a.pos += 4;
    a.pos, a.bytes.b[a.pos];
    a.pos += 1;
    var f = a.bytes,
        g = a.pos,
        h = f.b[g] | f.b[g + 1] << 8 | f.b[g + 2] << 16 | f.b[g + 3] << 24;
    a.pos += 4;
    var i = h;
    if (null == c) c = [];
    else
        for (; c.length > i;) c.pop();
    for (var j, k, l = 0, m = i; l < m;) {
        var n = l++,
            o = a.bytes.b[a.pos];
        a.pos += 1, j = o, n >= c.length ? (k = bikas.serialization.BefDo.getValue(a, b, j, null), c.push(k)) : (k = bikas.serialization.BefDo.getValue(a, b, j, c[n]), c[n] = k)
    }
    return c
}, bikas.serialization.BefDo.setInstance = function(a, b, c, d, e) {
    var f = c.fields,
        g = a.pos;
    if (a.pos + 4 >= a.bytes.length) {
        var h = a.bytes.length + a.alloc_size;
        h < a.pos + 4 && (h = a.pos + 4);
        var i = new haxe.io.Bytes(new ArrayBuffer(h));
        i.blit(0, a.bytes, 0, a.bytes.length), a.bytes = i
    }
    var j = a.bytes,
        k = a.pos;
    if (j.b[k] = 0, j.b[k + 1] = 0, j.b[k + 2] = 0, j.b[k + 3] = 0, a.pos += 4, a.pos + 2 >= a.bytes.length) {
        var l = a.bytes.length + a.alloc_size;
        l < a.pos + 2 && (l = a.pos + 2);
        var m = new haxe.io.Bytes(new ArrayBuffer(l));
        m.blit(0, a.bytes, 0, a.bytes.length), a.bytes = m
    }
    a.bytes.setUInt16(a.pos, d), a.pos += 2;
    for (var n, o = 0; o < f.length;) {
        var p = f[o];
        ++o, n = Reflect.field(e, p.field_name), bikas.serialization.BefDo.setValue(a, b, n, p.value_type_flags)
    }
    var q = a.pos;
    a.pos = g;
    var r = q - a.pos - 4;
    if (a.pos + 4 >= a.bytes.length) {
        var s = a.bytes.length + a.alloc_size;
        s < a.pos + 4 && (s = a.pos + 4);
        var t = new haxe.io.Bytes(new ArrayBuffer(s));
        t.blit(0, a.bytes, 0, a.bytes.length), a.bytes = t
    }
    var u = a.bytes,
        v = a.pos;
    u.b[v] = 255 & r, u.b[v + 1] = r >> 8 & 255, u.b[v + 2] = r >> 16 & 255, u.b[v + 3] = r >>> 24 & 255, a.pos += 4, a.pos = q
}, bikas.serialization.BefDo.getInstance = function(a, b, c) {
    var d = a.bytes,
        e = a.pos,
        f = d.b[e] | d.b[e + 1] << 8 | d.b[e + 2] << 16 | d.b[e + 3] << 24;
    a.pos += 4;
    var g = f,
        h = a.pos,
        i = a.bytes.getUInt16(a.pos);
    a.pos += 2;
    var j = i,
        k = b.classes[j],
        l = k.serial_class;
    if (null == l) return a.pos = h + g, null;
    null == c && (c = null != l.init_func ? l.init_func() : Type.createInstance(l.unserial_type, []));
    for (var m, n, o, p = 0, q = k.fields; p < q.length;) {
        var r = q[p];
        ++p;
        var s = a.bytes.b[a.pos];
        if (a.pos += 1, o = s, m = r.field_name, null == r.serial_field) bikas.serialization.BefDo.getValue(a, b, o, null);
        else {
            switch (o) {
                case 6:
                    n = null;
                    break;
                case 11:
                case 12:
                case 128:
                case 129:
                    n = bikas.serialization.BefDo.getValue(a, b, o, Reflect.field(c, m));
                    break;
                default:
                    n = bikas.serialization.BefDo.getValue(a, b, o, null)
            }
            c[m] = n
        }
    }
    return c
};
var googleAnalytics = googleAnalytics || {};
googleAnalytics.Campaign = $hxClasses["googleAnalytics.Campaign"] = function(a) {
    switch (this.responseCount = 0, "direct" != a && "organic" != a && "referral" != a && googleAnalytics.Tracker._raiseError("Campaign type has to be one of the Campaign::TYPE_* constant values.", "Campaign.new"), this.type = a, a) {
        case "direct":
            this.name = "(direct)", this.source = "(direct)", this.medium = "(none)";
            break;
        case "organic":
            this.name = "(organic)", this.medium = "organic";
            break;
        case "referral":
            this.name = "(referral)", this.medium = "referral"
    }
    this.creationTime = new googleAnalytics.DateTime
}, googleAnalytics.Campaign.__name__ = ["googleAnalytics", "Campaign"], googleAnalytics.Campaign.createFromReferrer = function(a) {
    var b = new googleAnalytics.Campaign("referral"),
        c = new googleAnalytics.URLParser(a);
    return b.source = c.host, b.content = c.path, b
}, googleAnalytics.Campaign.prototype = {
    type: null,
    creationTime: null,
    responseCount: null,
    id: null,
    source: null,
    gClickId: null,
    dClickId: null,
    name: null,
    medium: null,
    term: null,
    content: null,
    validate: function() {
        null == this.source && googleAnalytics.Tracker._raiseError('Campaigns need to have at least the "source" attribute defined.', "Campaign.validate")
    },
    setType: function(a) {
        this.type = a
    },
    getType: function() {
        return this.type
    },
    setCreationTime: function(a) {
        this.creationTime = a
    },
    getCreationTime: function() {
        return this.creationTime
    },
    setResponseCount: function(a) {
        this.responseCount = a
    },
    getResponseCount: function() {
        return this.responseCount
    },
    increaseResponseCount: function(a) {
        null == a && (a = 1), this.responseCount += a
    },
    setId: function(a) {
        this.id = a
    },
    getId: function() {
        return this.id
    },
    setSource: function(a) {
        this.source = a
    },
    getSource: function() {
        return this.source
    },
    setGClickId: function(a) {
        this.gClickId = a
    },
    getGClickId: function() {
        return this.gClickId
    },
    setDClickId: function(a) {
        this.dClickId = a
    },
    getDClickId: function() {
        return this.dClickId
    },
    setName: function(a) {
        this.name = a
    },
    getName: function() {
        return this.name
    },
    setMedium: function(a) {
        this.medium = a
    },
    getMedium: function() {
        return this.medium
    },
    setTerm: function(a) {
        this.term = a
    },
    getTerm: function() {
        return this.term
    },
    setContent: function(a) {
        this.content = a
    },
    getContent: function() {
        return this.content
    },
    __class__: googleAnalytics.Campaign
}, googleAnalytics.Config = $hxClasses["googleAnalytics.Config"] = function(a) {
    null == a && (a = !1), this.sitespeedSampleRate = 1, this.endPointPath = "/__utm.gif", this.endPointHost = "www.google-analytics.com", this.urlScheme = "http", this.requestTimeout = 1, this.fireAndForget = !1, this.sendOnShutdown = !1, this.errorSeverity = 2, this.setUrlScheme("http" + (a ? "s" : ""))
}, googleAnalytics.Config.__name__ = ["googleAnalytics", "Config"], googleAnalytics.Config.prototype = {
    errorSeverity: null,
    sendOnShutdown: null,
    fireAndForget: null,
    loggingCallback: null,
    requestTimeout: null,
    urlScheme: null,
    endPointHost: null,
    endPointPath: null,
    sitespeedSampleRate: null,
    getErrorSeverity: function() {
        return this.errorSeverity
    },
    setErrorSeverity: function(a) {
        this.errorSeverity = a
    },
    getSendOnShutdown: function() {
        return this.sendOnShutdown
    },
    setSendOnShutdown: function(a) {
        this.sendOnShutdown = a
    },
    getFireAndForget: function() {
        return this.fireAndForget
    },
    setFireAndForget: function(a) {
        this.fireAndForget = a
    },
    getLoggingCallback: function() {
        return this.loggingCallback
    },
    setLoggingCallback: function(a) {
        this.loggingCallback = a
    },
    getRequestTimeout: function() {
        return this.requestTimeout
    },
    setRequestTimeout: function(a) {
        this.requestTimeout = a
    },
    getUrlScheme: function() {
        return this.urlScheme
    },
    setUrlScheme: function(a) {
        return this.urlScheme = a
    },
    getEndPointHost: function() {
        return this.endPointHost
    },
    setEndPointHost: function(a) {
        this.endPointHost = a
    },
    getEndPointPath: function() {
        return this.endPointPath
    },
    setEndPointPath: function(a) {
        this.endPointPath = a
    },
    getSitespeedSampleRate: function() {
        return this.sitespeedSampleRate
    },
    setSitespeedSampleRate: function(a) {
        return a < 0 || a > 100 ? void googleAnalytics.Tracker._raiseError("For consistency with ga.js, sample rates must be specified as a number between 0 and 100.", "config.setSitespeedSampleRate") : void(this.sitespeedSampleRate = a)
    },
    __class__: googleAnalytics.Config
}, googleAnalytics.CustomVariable = $hxClasses["googleAnalytics.CustomVariable"] = function(a, b, c, d) {
    null == d && (d = 0), null == a && (a = 0), this.scope = 3, 0 != a && this.setIndex(a), null != b && this.setName(b), null != c && this.setValue(c), 0 != d && this.setScope(d)
}, googleAnalytics.CustomVariable.__name__ = ["googleAnalytics", "CustomVariable"], googleAnalytics.CustomVariable.prototype = {
    index: null,
    name: null,
    value: null,
    scope: null,
    validate: function() {
        (this.name + Std.string(this.value)).length > 128 && googleAnalytics.Tracker._raiseError("Custom Variable combined name and value length must not be larger than 128 bytes.", "CustomVariable.validate")
    },
    getIndex: function() {
        return this.index
    },
    setIndex: function(a) {
        (a < 1 || a > 5) && googleAnalytics.Tracker._raiseError("Custom Variable index has to be between 1 and 5.", "CustomVariable.setIndex"), this.index = a
    },
    getName: function() {
        return this.name
    },
    setName: function(a) {
        this.name = a
    },
    getValue: function() {
        return this.value
    },
    setValue: function(a) {
        this.value = a
    },
    getScope: function() {
        return this.scope
    },
    setScope: function(a) {
        3 != a && 2 != a && 1 != a && googleAnalytics.Tracker._raiseError("Custom Variable scope has to be one of the CustomVariable::SCOPE_* constant values.", "CustomVariable.setScope"), this.scope = a
    },
    __class__: googleAnalytics.CustomVariable
}, googleAnalytics.DateTime = $hxClasses["googleAnalytics.DateTime"] = function(a) {
    null == a ? this.date = Math.round((new Date).getTime()) + "" : this.date = a
}, googleAnalytics.DateTime.__name__ = ["googleAnalytics", "DateTime"], googleAnalytics.DateTime.prototype = {
    date: null,
    toString: function() {
        return this.date
    },
    __class__: googleAnalytics.DateTime
}, googleAnalytics.Event = $hxClasses["googleAnalytics.Event"] = function(a, b, c, d, e) {
    null == e && (e = !1), null == d && (d = 0), this.noninteraction = !1, null != a && this.setCategory(a), null != b && this.setAction(b), null != c && this.setLabel(c), this.setValue(d), this.setNoninteraction(e)
}, googleAnalytics.Event.__name__ = ["googleAnalytics", "Event"], googleAnalytics.Event.prototype = {
    category: null,
    action: null,
    label: null,
    value: null,
    noninteraction: null,
    validate: function() {
        null != this.category && null != this.action || googleAnalytics.Tracker._raiseError("Events need at least to have a category and action defined.", "Event.validate")
    },
    getCategory: function() {
        return this.category
    },
    setCategory: function(a) {
        this.category = a
    },
    getAction: function() {
        return this.action
    },
    setAction: function(a) {
        this.action = a
    },
    getLabel: function() {
        return this.label
    },
    setLabel: function(a) {
        this.label = a
    },
    getValue: function() {
        return this.value
    },
    setValue: function(a) {
        this.value = a
    },
    getNoninteraction: function() {
        return this.noninteraction
    },
    setNoninteraction: function(a) {
        this.noninteraction = a
    },
    __class__: googleAnalytics.Event
}, googleAnalytics.Item = $hxClasses["googleAnalytics.Item"] = function() {
    this.quantity = 1
}, googleAnalytics.Item.__name__ = ["googleAnalytics", "Item"], googleAnalytics.Item.prototype = {
    orderId: null,
    sku: null,
    name: null,
    variation: null,
    price: null,
    quantity: null,
    validate: function() {
        null == this.sku && googleAnalytics.Tracker._raiseError("Items need to have a sku/product code defined.", "Item.validate")
    },
    getOrderId: function() {
        return this.orderId
    },
    setOrderId: function(a) {
        this.orderId = a
    },
    getSku: function() {
        return this.sku
    },
    setSku: function(a) {
        this.sku = a
    },
    getName: function() {
        return this.name
    },
    setName: function(a) {
        this.name = a
    },
    getVariation: function() {
        return this.variation
    },
    setVariation: function(a) {
        this.variation = a
    },
    getPrice: function() {
        return this.price
    },
    setPrice: function(a) {
        this.price = a
    },
    getQuantity: function() {
        return this.quantity
    },
    setQuantity: function(a) {
        this.quantity = a
    },
    __class__: googleAnalytics.Item
}, googleAnalytics.Page = $hxClasses["googleAnalytics.Page"] = function(a) {
    this.setPath(a)
}, googleAnalytics.Page.__name__ = ["googleAnalytics", "Page"], googleAnalytics.Page.prototype = {
    path: null,
    title: null,
    charset: null,
    referrer: null,
    loadTime: null,
    setPath: function(a) {
        null != a && "/" != a.charAt(0) && googleAnalytics.Tracker._raiseError('The page path should always start with a slash ("/").', "Page.setPath"), this.path = a
    },
    getPath: function() {
        return this.path
    },
    setTitle: function(a) {
        this.title = a
    },
    getTitle: function() {
        return this.title
    },
    setCharset: function(a) {
        this.charset = a
    },
    getCharset: function() {
        return this.charset
    },
    setReferrer: function(a) {
        this.referrer = a
    },
    getReferrer: function() {
        return this.referrer
    },
    setLoadTime: function(a) {
        this.loadTime = a
    },
    getLoadTime: function() {
        return this.loadTime
    },
    __class__: googleAnalytics.Page
}, googleAnalytics.Session = $hxClasses["googleAnalytics.Session"] = function() {
    this.setSessionId(this.generateSessionId()), this.setTrackCount(0), this.setStartTime(new googleAnalytics.DateTime)
}, googleAnalytics.Session.__name__ = ["googleAnalytics", "Session"], googleAnalytics.Session.prototype = {
    sessionId: null,
    trackCount: null,
    startTime: null,
    fromUtmb: function(a) {
        var b = a.split(".");
        return 4 != b.length ? (googleAnalytics.Tracker._raiseError('The given "__utmb" cookie value is invalid.', "Session.fromUtmb"), this) : (this.setTrackCount(googleAnalytics.internals.Util.parseInt(b[1], 0)), this.setStartTime(new googleAnalytics.DateTime(b[3])), this)
    },
    generateSessionId: function() {
        return googleAnalytics.internals.Util.generate32bitRandom()
    },
    getSessionId: function() {
        return this.sessionId
    },
    setSessionId: function(a) {
        this.sessionId = a
    },
    getTrackCount: function() {
        return this.trackCount
    },
    setTrackCount: function(a) {
        this.trackCount = a
    },
    increaseTrackCount: function(a) {
        null == a && (a = 1), this.trackCount += a
    },
    getStartTime: function() {
        return this.startTime
    },
    setStartTime: function(a) {
        this.startTime = a
    },
    __class__: googleAnalytics.Session
}, googleAnalytics.SocialInteraction = $hxClasses["googleAnalytics.SocialInteraction"] = function(a, b, c) {
    null != a && this.setNetwork(a), null != b && this.setAction(b), null != c && this.setTarget(c)
}, googleAnalytics.SocialInteraction.__name__ = ["googleAnalytics", "SocialInteraction"], googleAnalytics.SocialInteraction.prototype = {
    network: null,
    action: null,
    target: null,
    validate: function() {
        null != this.network && null != this.action || googleAnalytics.Tracker._raiseError('Social interactions need to have at least the "network" and "action" attributes defined.', "SocialInteraction.validate")
    },
    setNetwork: function(a) {
        this.network = a
    },
    getNetwork: function() {
        return this.network
    },
    setAction: function(a) {
        this.action = a
    },
    getAction: function() {
        return this.action
    },
    setTarget: function(a) {
        this.target = a
    },
    getTarget: function() {
        return this.target
    },
    __class__: googleAnalytics.SocialInteraction
}, googleAnalytics.Stats = $hxClasses["googleAnalytics.Stats"] = function() {}, googleAnalytics.Stats.__name__ = ["googleAnalytics", "Stats"], googleAnalytics.Stats.init = function(a, b, c) {
    null == c && (c = !1), null == googleAnalytics.Stats.accountId && (googleAnalytics.Stats.accountId = a, googleAnalytics.Stats.domainName = b, googleAnalytics.Stats.tracker = new googleAnalytics.Tracker(a, b, new googleAnalytics.Config(c)), googleAnalytics.Stats.cache = new haxe.ds.StringMap, googleAnalytics.Stats.session = new googleAnalytics.Session, googleAnalytics.Stats.loadVisitor())
}, googleAnalytics.Stats.trackPageview = function(a, b) {
    var c = "page:" + a,
        d = googleAnalytics.Stats.cache;
    if (!(null != __map_reserved[c] ? d.existsReserved(c) : d.h.hasOwnProperty(c))) {
        var e = new googleAnalytics.Page(a);
        null != b && e.setTitle(b);
        var f = googleAnalytics.Stats.cache,
            g = new googleAnalytics._Stats.GATrackObject(e, null),
            h = f;
        null != __map_reserved[c] ? h.setReserved(c, g) : h.h[c] = g
    }
    googleAnalytics.Stats.track(c)
}, googleAnalytics.Stats.trackEvent = function(a, b, c, d) {
    null == d && (d = 0);
    var e = "event:" + a + "/" + b + "/" + c + ":" + d,
        f = googleAnalytics.Stats.cache;
    if (!(null != __map_reserved[e] ? f.existsReserved(e) : f.h.hasOwnProperty(e))) {
        var g = googleAnalytics.Stats.cache,
            h = new googleAnalytics._Stats.GATrackObject(null, new googleAnalytics.Event(a, b, c, d)),
            i = g;
        null != __map_reserved[e] ? i.setReserved(e, h) : i.h[e] = h
    }
    googleAnalytics.Stats.track(e)
}, googleAnalytics.Stats.track = function(a) {
    if (!googleAnalytics.Stats.paused) {
        var b = googleAnalytics.Stats.cache;
        (null != __map_reserved[a] ? b.getReserved(a) : b.h[a]).track(googleAnalytics.Stats.tracker, googleAnalytics.Stats.visitor, googleAnalytics.Stats.session), googleAnalytics.Stats.persistVisitor()
    }
}, googleAnalytics.Stats.pause = function() {
    googleAnalytics.Stats.paused = !0
}, googleAnalytics.Stats.resume = function() {
    googleAnalytics.Stats.paused = !1
}, googleAnalytics.Stats.loadVisitor = function() {
    var a = " [haxe]";
    googleAnalytics.Stats.visitor = new googleAnalytics.Visitor, googleAnalytics.Stats.visitor.setUserAgent("-not-set-" + a), googleAnalytics.Stats.visitor.setScreenResolution("1024x768"), googleAnalytics.Stats.visitor.setLocale("en_US"), googleAnalytics.Stats.visitor.getUniqueId(), googleAnalytics.Stats.visitor.addSession(googleAnalytics.Stats.session), googleAnalytics.Stats.persistVisitor()
}, googleAnalytics.Stats.persistVisitor = function() {}, googleAnalytics._Stats || (googleAnalytics._Stats = {}), googleAnalytics._Stats.GATrackObject = $hxClasses["googleAnalytics._Stats.GATrackObject"] = function(a, b) {
    this.page = a, this.event = b
}, googleAnalytics._Stats.GATrackObject.__name__ = ["googleAnalytics", "_Stats", "GATrackObject"], googleAnalytics._Stats.GATrackObject.prototype = {
    event: null,
    page: null,
    track: function(a, b, c) {
        null != this.page && a.trackPageview(this.page, c, b), null != this.event && a.trackEvent(this.event, c, b)
    },
    __class__: googleAnalytics._Stats.GATrackObject
}, googleAnalytics.Tracker = $hxClasses["googleAnalytics.Tracker"] = function(a, b, c) {
    this.allowHash = !0, this.customVariables = [], googleAnalytics.Tracker.setConfig(null != c ? c : new googleAnalytics.Config), this.setAccountId(a), this.setDomainName(b)
}, googleAnalytics.Tracker.__name__ = ["googleAnalytics", "Tracker"], googleAnalytics.Tracker.getConfig = function() {
    return googleAnalytics.Tracker.config
}, googleAnalytics.Tracker.setConfig = function(a) {
    googleAnalytics.Tracker.config = a
}, googleAnalytics.Tracker._raiseError = function(a, b) {
    a = b + "(): " + a;
    var c = null != googleAnalytics.Tracker.config ? googleAnalytics.Tracker.config.getErrorSeverity() : 0;
    switch (c) {
        case 0:
            break;
        case 1:
            break;
        case 2:
            throw new js._Boot.HaxeError(a)
    }
}, googleAnalytics.Tracker.prototype = {
    accountId: null,
    domainName: null,
    allowHash: null,
    customVariables: null,
    campaign: null,
    setAccountId: function(a) {
        var b = new EReg("^(UA|MO)-[0-9]*-[0-9]*$", "");
        b.match(a) || googleAnalytics.Tracker._raiseError('"' + a + '" is not a valid Google Analytics account ID.', "Tracker.setAccountId"), this.accountId = a
    },
    getAccountId: function() {
        return this.accountId
    },
    setDomainName: function(a) {
        this.domainName = a
    },
    getDomainName: function() {
        return this.domainName
    },
    setAllowHash: function(a) {
        this.allowHash = a
    },
    getAllowHash: function() {
        return this.allowHash
    },
    addCustomVariable: function(a) {
        a.validate(), this.customVariables[a.getIndex()] = a
    },
    getCustomVariables: function() {
        return this.customVariables
    },
    removeCustomVariable: function(a) {
        HxOverrides.remove(this.customVariables, this.customVariables[a])
    },
    setCampaign: function(a) {
        null != a && a.validate(), this.campaign = a
    },
    getCampaign: function() {
        return this.campaign
    },
    trackPageview: function(a, b, c) {
        var d = new googleAnalytics.internals.request.PageviewRequest(googleAnalytics.Tracker.config);
        d.setPage(a), d.setSession(b), d.setVisitor(c), d.setTracker(this), d.send()
    },
    trackEvent: function(a, b, c) {
        a.validate();
        var d = new googleAnalytics.internals.request.EventRequest(googleAnalytics.Tracker.config);
        d.setEvent(a), d.setSession(b), d.setVisitor(c), d.setTracker(this), d.send()
    },
    trackTransaction: function(a, b, c) {
        a.validate();
        var d = new googleAnalytics.internals.request.TransactionRequest(googleAnalytics.Tracker.config);
        d.setTransaction(a), d.setSession(b), d.setVisitor(c), d.setTracker(this), d.send();
        for (var e = a.getItems(), f = new haxe.ds._StringMap.StringMapIterator(e, e.arrayKeys()); f.hasNext();) {
            var g = f.next();
            g.validate();
            var h = new googleAnalytics.internals.request.ItemRequest(googleAnalytics.Tracker.config);
            h.setItem(g), h.setSession(b), h.setVisitor(c), h.setTracker(this), h.send()
        }
    },
    trackSocial: function(a, b, c, d) {
        var e = new googleAnalytics.internals.request.SocialInteractionRequest(googleAnalytics.Tracker.config);
        e.setSocialInteraction(a), e.setPage(b), e.setSession(c), e.setVisitor(d), e.setTracker(this), e.send()
    },
    __class__: googleAnalytics.Tracker
}, googleAnalytics.Transaction = $hxClasses["googleAnalytics.Transaction"] = function() {
    this.items = new haxe.ds.StringMap
}, googleAnalytics.Transaction.__name__ = ["googleAnalytics", "Transaction"], googleAnalytics.Transaction.prototype = {
    orderId: null,
    affiliation: null,
    total: null,
    tax: null,
    shipping: null,
    city: null,
    region: null,
    country: null,
    items: null,
    validate: function() {
        null == this.items && googleAnalytics.Tracker._raiseError("Transactions need to consist of at least one item.", "Transaction.validate")
    },
    addItem: function(a) {
        a.setOrderId(this.orderId);
        var b = this.items,
            c = a.getSku(),
            d = b;
        null != __map_reserved[c] ? d.setReserved(c, a) : d.h[c] = a
    },
    getItems: function() {
        return this.items
    },
    getOrderId: function() {
        return this.orderId
    },
    setOrderId: function(a) {
        this.orderId = a;
        for (var b = this.items, c = new haxe.ds._StringMap.StringMapIterator(b, b.arrayKeys()); c.hasNext();) {
            var d = c.next();
            d.setOrderId(a)
        }
    },
    getAffiliation: function() {
        return this.affiliation
    },
    setAffiliation: function(a) {
        this.affiliation = a
    },
    getTotal: function() {
        return this.total
    },
    setTotal: function(a) {
        this.total = a
    },
    getTax: function() {
        return this.tax
    },
    setTax: function(a) {
        this.tax = a
    },
    getShipping: function() {
        return this.shipping
    },
    setShipping: function(a) {
        this.shipping = a
    },
    getCity: function() {
        return this.city
    },
    setCity: function(a) {
        this.city = a
    },
    getRegion: function() {
        return this.region
    },
    setRegion: function(a) {
        this.region = a
    },
    getCountry: function() {
        return this.country
    },
    setCountry: function(a) {
        this.country = a
    },
    __class__: googleAnalytics.Transaction
}, googleAnalytics.URLParser = $hxClasses["googleAnalytics.URLParser"] = function(a) {
    this.url = a;
    var b = new EReg("^(?:(?![^:@]+:[^:@/]*@)([^:/?#.]+):)?(?://)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\\d*))?)(((/(?:[^?#](?![^?#/]*\\.[^?#/.]+(?:[?#]|$)))*/?)?([^?#/]*))(?:\\?([^#]*))?(?:#(.*))?)", "");
    b.match(a);
    for (var c = 0, d = googleAnalytics.URLParser.parts.length; c < d;) {
        var e = c++;
        this[googleAnalytics.URLParser.parts[e]] = b.matched(e)
    }
}, googleAnalytics.URLParser.__name__ = ["googleAnalytics", "URLParser"], googleAnalytics.URLParser.parse = function(a) {
    return new googleAnalytics.URLParser(a)
}, googleAnalytics.URLParser.prototype = {
    url: null,
    source: null,
    protocol: null,
    authority: null,
    userInfo: null,
    user: null,
    password: null,
    host: null,
    port: null,
    relative: null,
    path: null,
    directory: null,
    file: null,
    query: null,
    anchor: null,
    toString: function() {
        for (var a = "For Url -> " + this.url + "\n", b = 0, c = googleAnalytics.URLParser.parts.length; b < c;) {
            var d = b++;
            a += googleAnalytics.URLParser.parts[d] + ": " + Std.string(Reflect.field(this, googleAnalytics.URLParser.parts[d])) + (d == googleAnalytics.URLParser.parts.length - 1 ? "" : "\n")
        }
        return a
    },
    __class__: googleAnalytics.URLParser
}, googleAnalytics.Visitor = $hxClasses["googleAnalytics.Visitor"] = function() {
    var a = new googleAnalytics.DateTime;
    this.uniqueId = 0, this.setFirstVisitTime(a), this.setPreviousVisitTime(a), this.setCurrentVisitTime(a), this.setVisitCount(1)
}, googleAnalytics.Visitor.__name__ = ["googleAnalytics", "Visitor"], googleAnalytics.Visitor.prototype = {
    uniqueId: null,
    firstVisitTime: null,
    previousVisitTime: null,
    currentVisitTime: null,
    visitCount: null,
    ipAddress: null,
    userAgent: null,
    locale: null,
    flashVersion: null,
    javaEnabled: null,
    screenColorDepth: null,
    screenResolution: null,
    fromUtma: function(a) {
        var b = a.split(".");
        return 6 != b.length ? (googleAnalytics.Tracker._raiseError('The given "__utma" cookie value is invalid.', "Visitor.fromUtma"), this) : (this.setUniqueId(googleAnalytics.internals.Util.parseInt(b[1], 0)), this.setFirstVisitTime(new googleAnalytics.DateTime(b[2])), this.setPreviousVisitTime(new googleAnalytics.DateTime(b[3])), this.setCurrentVisitTime(new googleAnalytics.DateTime(b[4])), this.setVisitCount(googleAnalytics.internals.Util.parseInt(b[5], 0)), this)
    },
    generateHash: function() {
        return googleAnalytics.internals.Util.generateHash(this.userAgent + this.screenResolution + this.screenColorDepth)
    },
    generateUniqueId: function() {
        return 2147483647 & (googleAnalytics.internals.Util.generate32bitRandom() ^ this.generateHash())
    },
    setUniqueId: function(a) {
        (a < 0 || a > 2147483647) && googleAnalytics.Tracker._raiseError("Visitor unique ID has to be a 32-bit integer between 0 and 2147483647.", "Visitor.setUniqueId"), this.uniqueId = a
    },
    getUniqueId: function() {
        return 0 == this.uniqueId && (this.uniqueId = this.generateUniqueId()), this.uniqueId
    },
    addSession: function(a) {
        var b = a.getStartTime();
        b != this.currentVisitTime && (this.previousVisitTime = this.currentVisitTime, this.currentVisitTime = b, ++this.visitCount)
    },
    setFirstVisitTime: function(a) {
        this.firstVisitTime = a
    },
    getFirstVisitTime: function() {
        return this.firstVisitTime
    },
    setPreviousVisitTime: function(a) {
        this.previousVisitTime = a
    },
    getPreviousVisitTime: function() {
        return this.previousVisitTime
    },
    setCurrentVisitTime: function(a) {
        this.currentVisitTime = a
    },
    getCurrentVisitTime: function() {
        return this.currentVisitTime
    },
    setVisitCount: function(a) {
        this.visitCount = a
    },
    getVisitCount: function() {
        return this.visitCount
    },
    setIpAddress: function(a) {
        this.ipAddress = a
    },
    getIpAddress: function() {
        return this.ipAddress
    },
    setUserAgent: function(a) {
        this.userAgent = a
    },
    getUserAgent: function() {
        return this.userAgent
    },
    setLocale: function(a) {
        this.locale = a
    },
    getLocale: function() {
        return this.locale
    },
    setFlashVersion: function(a) {
        this.flashVersion = a
    },
    getFlashVersion: function() {
        return this.flashVersion
    },
    setJavaEnabled: function(a) {
        this.javaEnabled = a
    },
    getJavaEnabled: function() {
        return this.javaEnabled
    },
    setScreenColorDepth: function(a) {
        this.screenColorDepth = a
    },
    getScreenColorDepth: function() {
        return this.screenColorDepth
    },
    setScreenResolution: function(a) {
        this.screenResolution = a
    },
    getScreenResolution: function() {
        return this.screenResolution
    },
    __class__: googleAnalytics.Visitor
}, googleAnalytics.internals || (googleAnalytics.internals = {}), googleAnalytics.internals.ParameterHolder = $hxClasses["googleAnalytics.internals.ParameterHolder"] = function() {
    this.utmwv = "5.2.5", this.utmr = this.utmcs = this.utmfl = this.utmje = "0"
}, googleAnalytics.internals.ParameterHolder.__name__ = ["googleAnalytics", "internals", "ParameterHolder"], googleAnalytics.internals.ParameterHolder.prototype = {
    utmwv: null,
    utmac: null,
    utmhn: null,
    utmvid: null,
    utmt: null,
    utms: null,
    utmn: null,
    utmcc: null,
    utme: null,
    utmni: null,
    utmu: null,
    utmp: null,
    utmdt: null,
    utmcs: null,
    utmr: null,
    utmip: null,
    utmul: null,
    utmfl: null,
    utmje: null,
    utmsc: null,
    utmsr: null,
    __utma: null,
    utmhid: null,
    __utmb: null,
    __utmc: null,
    utmipc: null,
    utmipn: null,
    utmipr: null,
    utmiqt: null,
    utmiva: null,
    utmtid: null,
    utmtst: null,
    utmtto: null,
    utmttx: null,
    utmtsp: null,
    utmtci: null,
    utmtrg: null,
    utmtco: null,
    utmcn: null,
    utmcr: null,
    utmcid: null,
    utmcsr: null,
    utmgclid: null,
    utmdclid: null,
    utmccn: null,
    utmcmd: null,
    utmctr: null,
    utmcct: null,
    utmcvr: null,
    __utmz: null,
    utmsn: null,
    utmsa: null,
    utmsid: null,
    __utmx: null,
    __utmv: null,
    toHashTable: function() {
        for (var a = new haxe.ds.StringMap, b = 0, c = Type.getInstanceFields(googleAnalytics.internals.ParameterHolder); b < c.length;) {
            var d = c[b];
            if (++b, "_" != d.charAt(0) && !Reflect.isFunction(Reflect.field(this, d))) {
                var e = Reflect.field(this, d);
                null != __map_reserved[d] ? a.setReserved(d, e) : a.h[d] = e
            }
        }
        return a
    },
    toQueryString: function() {
        for (var a = "", b = 0, c = Type.getInstanceFields(googleAnalytics.internals.ParameterHolder); b < c.length;) {
            var d = c[b];
            ++b, "_" == d.charAt(0) || Reflect.isFunction(Reflect.field(this, d)) || null == Reflect.field(this, d) || "null" == Reflect.field(this, d) || (a += d + "=" + StringTools.replace(Std.string(Reflect.field(this, d)) + "", "&", "%26") + "&")
        }
        return a
    },
    __class__: googleAnalytics.internals.ParameterHolder
}, googleAnalytics.internals.Util = $hxClasses["googleAnalytics.internals.Util"] = function() {}, googleAnalytics.internals.Util.__name__ = ["googleAnalytics", "internals", "Util"], googleAnalytics.internals.Util.encodeUriComponent = function(a) {
    return googleAnalytics.internals.Util.convertToUriComponentEncoding(encodeURIComponent(a))
}, googleAnalytics.internals.Util.stringReplaceArray = function(a, b, c) {
    for (var d = 0, e = b.length; d < e;) {
        var f = d++;
        null != b[f] && (a = StringTools.replace(a + " ", b[f], c[f]))
    }
    return StringTools.trim(a)
}, googleAnalytics.internals.Util.parseInt = function(a, b) {
    return null == a ? b : Std.parseInt(a)
}, googleAnalytics.internals.Util.convertToUriComponentEncoding = function(a) {
    return googleAnalytics.internals.Util.stringReplaceArray(a, ["!", "*", "'", "(", ")", " ", "+"], ["%21", "%2A", "%27", "%28", "%29", "%20", "%20"])
}, googleAnalytics.internals.Util.generate32bitRandom = function() {
    return Math.round(2147483647 * Math.random())
}, googleAnalytics.internals.Util.generateHash = function(a) {
    var b, c, d = 1;
    if (null != a && "" != a) {
        d = 0;
        for (var e = a.length - 1; e >= 0;) b = HxOverrides.cca(a, e), d = (d << 6 & 268435455) + b + (b << 14), c = 266338304 & d, 0 != c && (d ^= c >> 21), --e
    }
    return d
}, googleAnalytics.internals.X10 = $hxClasses["googleAnalytics.internals.X10"] = function() {
    this.projectData = new haxe.ds.StringMap, this.KEY = "k", this.VALUE = "v", this.SET = ["k", "v"], this.DELIM_BEGIN = "(", this.DELIM_END = ")", this.DELIM_SET = "*", this.DELIM_NUM_VALUE = "!", this.MINIMUM = 1, this.ESCAPE_CHAR_MAP = new haxe.ds.StringMap;
    var a = this.ESCAPE_CHAR_MAP;
    null != __map_reserved["'"] ? a.setReserved("'", "'0") : a.h["'"] = "'0";
    var b = this.ESCAPE_CHAR_MAP;
    null != __map_reserved[")"] ? b.setReserved(")", "'1") : b.h[")"] = "'1";
    var c = this.ESCAPE_CHAR_MAP;
    null != __map_reserved["*"] ? c.setReserved("*", "'2") : c.h["*"] = "'2";
    var d = this.ESCAPE_CHAR_MAP;
    null != __map_reserved["!"] ? d.setReserved("!", "'3") : d.h["!"] = "'3"
}, googleAnalytics.internals.X10.__name__ = ["googleAnalytics", "internals", "X10"], googleAnalytics.internals.X10.prototype = {
    projectData: null,
    KEY: null,
    VALUE: null,
    SET: null,
    DELIM_BEGIN: null,
    DELIM_END: null,
    DELIM_SET: null,
    DELIM_NUM_VALUE: null,
    ESCAPE_CHAR_MAP: null,
    MINIMUM: null,
    hasProject: function(a) {
        var b = this.projectData;
        return null != __map_reserved[a] ? b.existsReserved(a) : b.h.hasOwnProperty(a)
    },
    setKey: function(a, b, c) {
        this.setInternal(a, this.KEY, b, c)
    },
    getKey: function(a, b) {
        return this.getInternal(a, this.KEY, b)
    },
    clearKey: function(a) {
        this.clearInternal(a, this.KEY)
    },
    setValue: function(a, b, c) {
        this.setInternal(a, this.VALUE, b, c)
    },
    getValue: function(a, b) {
        return this.getInternal(a, this.VALUE, b)
    },
    clearValue: function(a) {
        this.clearInternal(a, this.VALUE)
    },
    setInternal: function(a, b, c, d) {
        var e = this.projectData;
        if (!(null != __map_reserved[a] ? e.existsReserved(a) : e.h.hasOwnProperty(a))) {
            var f = this.projectData,
                g = new haxe.ds.StringMap,
                h = f;
            null != __map_reserved[a] ? h.setReserved(a, g) : h.h[a] = g
        }
        var i = this.projectData,
            j = null != __map_reserved[a] ? i.getReserved(a) : i.h[a];
        if (!(null != __map_reserved[b] ? j.existsReserved(b) : j.h.hasOwnProperty(b))) {
            var k = [];
            null != __map_reserved[b] ? j.setReserved(b, k) : j.h[b] = k
        }(null != __map_reserved[b] ? j.getReserved(b) : j.h[b])[c] = d
    },
    getInternal: function(a, b, c) {
        var d = this.projectData;
        if (!(null != __map_reserved[a] ? d.existsReserved(a) : d.h.hasOwnProperty(a))) return null;
        var e = this.projectData,
            f = null != __map_reserved[a] ? e.getReserved(a) : e.h[a];
        if (!(null != __map_reserved[b] ? f.existsReserved(b) : f.h.hasOwnProperty(b))) return null;
        var g = null != __map_reserved[b] ? f.getReserved(b) : f.h[b];
        return null == g[c] ? null : g[c]
    },
    clearInternal: function(a, b) {
        var c, d = this.projectData;
        if (null != __map_reserved[a] ? d.existsReserved(a) : d.h.hasOwnProperty(a)) {
            var e = this.projectData,
                f = null != __map_reserved[a] ? e.getReserved(a) : e.h[a];
            c = null != __map_reserved[b] ? f.existsReserved(b) : f.h.hasOwnProperty(b)
        } else c = !1; if (c) {
            var g = this.projectData;
            (null != __map_reserved[a] ? g.getReserved(a) : g.h[a]).remove(b)
        }
    },
    escapeExtensibleValue: function(a) {
        for (var b = "", c = 0, d = a.length; c < d;) {
            var e = c++,
                f = a.charAt(e),
                g = this.ESCAPE_CHAR_MAP;
            if (null != __map_reserved[f] ? g.existsReserved(f) : g.h.hasOwnProperty(f)) {
                var h = this.ESCAPE_CHAR_MAP;
                b += null != __map_reserved[f] ? h.getReserved(f) : h.h[f]
            } else b += f
        }
        return b
    },
    SORT_NUMERIC: function(a, b) {
        return a == b ? 0 : a > b ? 1 : -1
    },
    renderDataType: function(a) {
        for (var b = [], c = 0, d = 0, e = a.length; d < e;) {
            var f = d++,
                g = a[f];
            if (null != g) {
                var h = "";
                f != this.MINIMUM && f - 1 != c && (h += f, h += this.DELIM_NUM_VALUE), h += this.escapeExtensibleValue(g), b.push(h)
            }
            c = f
        }
        return this.DELIM_BEGIN + b.join(this.DELIM_SET) + this.DELIM_END
    },
    renderProject: function(a) {
        for (var b = "", c = !1, d = 0, e = this.SET.length; d < e;) {
            var f = d++,
                g = this.SET[f];
            if (null != __map_reserved[g] ? a.existsReserved(g) : a.h.hasOwnProperty(g)) {
                c && (b += this.SET[f]);
                var h = this.SET[f];
                b += this.renderDataType(null != __map_reserved[h] ? a.getReserved(h) : a.h[h]), c = !1
            } else c = !0
        }
        return b
    },
    renderUrlString: function() {
        for (var a = "", b = this.projectData.keys(); b.hasNext();) {
            var c = b.next(),
                d = this.projectData;
            a += c + this.renderProject(null != __map_reserved[c] ? d.getReserved(c) : d.h[c])
        }
        return a
    },
    __class__: googleAnalytics.internals.X10
}, googleAnalytics.internals.request || (googleAnalytics.internals.request = {}), googleAnalytics.internals.request.Request = $hxClasses["googleAnalytics.internals.request.Request"] = function(a) {
    this.setConfig(null != a ? a : new googleAnalytics.Config)
}, googleAnalytics.internals.request.Request.__name__ = ["googleAnalytics", "internals", "request", "Request"], googleAnalytics.internals.request.Request.onError = function(a) {}, googleAnalytics.internals.request.Request.prototype = {
    type: null,
    config: null,
    userAgent: null,
    tracker: null,
    visitor: null,
    session: null,
    getConfig: function() {
        return this.config
    },
    setConfig: function(a) {
        this.config = a
    },
    setUserAgent: function(a) {
        this.userAgent = a
    },
    getTracker: function() {
        return this.tracker
    },
    setTracker: function(a) {
        this.tracker = a
    },
    getVisitor: function() {
        return this.visitor
    },
    setVisitor: function(a) {
        this.visitor = a
    },
    getSession: function() {
        return this.session
    },
    setSession: function(a) {
        this.session = a
    },
    increaseTrackCount: function() {
        this.session.increaseTrackCount(), this.session.getTrackCount() > 500 && googleAnalytics.Tracker._raiseError("Google Analytics does not guarantee to process more than 500 requests per session.", "Request.buildHttpRequest"), null != this.tracker.getCampaign() && this.tracker.getCampaign().increaseResponseCount()
    },
    send: function() {
        if (null != this.config.getEndPointHost()) {
            var a = this.buildParameters();
            null != this.visitor && (this.setUserAgent(this.visitor.getUserAgent()), a.utmvid = this.visitor.getUniqueId());
            var b = googleAnalytics.internals.Util.convertToUriComponentEncoding(a.toQueryString()),
                c = this.config.getUrlScheme() + "://" + this.config.getEndPointHost() + this.config.getEndPointPath() + "?" + b;
            this.increaseTrackCount();
            var d = new Image;
            d.src = c
        }
    },
    getType: function() {
        return null
    },
    buildParameters: function() {
        var a = new googleAnalytics.internals.ParameterHolder;
        return a.utmac = this.tracker.getAccountId(), a.utmhn = this.tracker.getDomainName(), a.utmt = "" + this.getType(), a.utmn = googleAnalytics.internals.Util.generate32bitRandom(), a.utmip = this.visitor.getIpAddress(), a.utmhid = this.session.getSessionId(), a.utms = this.session.getTrackCount(), a = this.buildVisitorParameters(a), a = this.buildCustomVariablesParameter(a), a = this.buildCampaignParameters(a), a = this.buildCookieParameters(a)
    },
    buildVisitorParameters: function(a) {
        return null != this.visitor.getLocale() && (a.utmul = StringTools.replace(this.visitor.getLocale(), "_", "-").toLowerCase()), null != this.visitor.getFlashVersion() && (a.utmfl = this.visitor.getFlashVersion()), a.utmje = this.visitor.getJavaEnabled() ? "1" : "0", null != this.visitor.getScreenColorDepth() && (a.utmsc = this.visitor.getScreenColorDepth() + "-bit"), a.utmsr = this.visitor.getScreenResolution(), a
    },
    buildCustomVariablesParameter: function(a) {
        var b = this.tracker.getCustomVariables();
        if (null == b) return a;
        b.length > 5 && googleAnalytics.Tracker._raiseError("The sum of all custom variables cannot exceed 5 in any given request.", "Request.buildCustomVariablesParameter");
        var c, d, e = new googleAnalytics.internals.X10;
        e.clearKey("8"), e.clearKey("9"), e.clearKey("11");
        for (var f = 0; f < b.length;) {
            var g = b[f];
            ++f, c = googleAnalytics.internals.Util.encodeUriComponent(g.getName()), d = googleAnalytics.internals.Util.encodeUriComponent(g.getValue()), e.setKey("8", g.getIndex(), c), e.setKey("9", g.getIndex(), d), 3 != g.getScope() && e.setKey("11", g.getIndex(), g.getScope())
        }
        var h = e.renderUrlString();
        return null != h && (null == a.utme ? a.utme = h : a.utme += h), a
    },
    buildCookieParameters: function(a) {
        var b = this.generateDomainHash();
        a.__utma = b + ".", a.__utma += this.visitor.getUniqueId() + ".", a.__utma += this.visitor.getFirstVisitTime().toString() + ".", a.__utma += this.visitor.getPreviousVisitTime().toString() + ".", a.__utma += this.visitor.getCurrentVisitTime().toString() + ".", a.__utma += this.visitor.getVisitCount(), a.__utmb = b + ".", a.__utmb += this.session.getTrackCount() + ".", a.__utmb += "10.", a.__utmb += this.session.getStartTime().toString(), a.__utmc = b;
        var c = "__utma=" + a.__utma + ";";
        return null != a.__utmz && (c += "+__utmz=" + a.__utmz + ";"), null != a.__utmv && (c += "+__utmv=" + a.__utmv + ";"), a.utmcc = c, a
    },
    buildCampaignParameters: function(a) {
        var b = this.tracker.getCampaign();
        if (null == b) return a;
        a.__utmz = this.generateDomainHash() + ".", a.__utmz += b.getCreationTime().toString() + ".", a.__utmz += this.visitor.getVisitCount() + ".", a.__utmz += b.getResponseCount() + ".";
        var c = "utmcid=" + b.getId() + "|utmcsr=" + b.getSource() + "|utmgclid=" + b.getGClickId() + "|utmdclid=" + b.getDClickId() + "|utmccn=" + b.getName() + "|utmcmd=" + b.getMedium() + "|utmctr=" + b.getTerm() + "|utmcct=" + b.getContent();
        return a.__utmz += StringTools.replace(StringTools.replace(c, "+", "%20"), " ", "%20"), a
    },
    generateDomainHash: function() {
        var a = 1;
        return this.tracker.getAllowHash() && (a = googleAnalytics.internals.Util.generateHash(this.tracker.getDomainName())), a
    },
    __class__: googleAnalytics.internals.request.Request
}, googleAnalytics.internals.request.EventRequest = $hxClasses["googleAnalytics.internals.request.EventRequest"] = function(a) {
    googleAnalytics.internals.request.Request.call(this, a)
}, googleAnalytics.internals.request.EventRequest.__name__ = ["googleAnalytics", "internals", "request", "EventRequest"], googleAnalytics.internals.request.EventRequest.__super__ = googleAnalytics.internals.request.Request, googleAnalytics.internals.request.EventRequest.prototype = $extend(googleAnalytics.internals.request.Request.prototype, {
    event: null,
    getType: function() {
        return "event"
    },
    buildParameters: function() {
        var a = googleAnalytics.internals.request.Request.prototype.buildParameters.call(this),
            b = new googleAnalytics.internals.X10;
        b.clearKey("5"), b.clearValue("5"), b.setKey("5", 1, this.event.getCategory()), b.setKey("5", 2, this.event.getAction()), null != this.event.getLabel() && b.setKey("5", 3, this.event.getLabel()), 0 != this.event.getValue() && b.setValue("5", 1, this.event.getValue());
        var c = b.renderUrlString();
        return null != c && (null == a.utme ? a.utme = c : a.utme += c), this.event.getNoninteraction() && (a.utmni = 1), a
    },
    getEvent: function() {
        return this.event
    },
    setEvent: function(a) {
        this.event = a
    },
    __class__: googleAnalytics.internals.request.EventRequest
}), googleAnalytics.internals.request.ItemRequest = $hxClasses["googleAnalytics.internals.request.ItemRequest"] = function(a) {
    googleAnalytics.internals.request.Request.call(this, a)
}, googleAnalytics.internals.request.ItemRequest.__name__ = ["googleAnalytics", "internals", "request", "ItemRequest"], googleAnalytics.internals.request.ItemRequest.__super__ = googleAnalytics.internals.request.Request, googleAnalytics.internals.request.ItemRequest.prototype = $extend(googleAnalytics.internals.request.Request.prototype, {
    item: null,
    getType: function() {
        return "item"
    },
    buildParameters: function() {
        var a = googleAnalytics.internals.request.Request.prototype.buildParameters.call(this);
        return a.utmtid = this.item.getOrderId(), a.utmipc = this.item.getSku(), a.utmipn = this.item.getName(), a.utmiva = this.item.getVariation(), a.utmipr = this.item.getPrice(), a.utmiqt = this.item.getQuantity(), a
    },
    buildVisitorParameters: function(a) {
        return a
    },
    buildCustomVariablesParameter: function(a) {
        return a
    },
    getItem: function() {
        return this.item
    },
    setItem: function(a) {
        this.item = a
    },
    __class__: googleAnalytics.internals.request.ItemRequest
}), googleAnalytics.internals.request.PageviewRequest = $hxClasses["googleAnalytics.internals.request.PageviewRequest"] = function(a) {
    googleAnalytics.internals.request.Request.call(this, a)
}, googleAnalytics.internals.request.PageviewRequest.__name__ = ["googleAnalytics", "internals", "request", "PageviewRequest"], googleAnalytics.internals.request.PageviewRequest.__super__ = googleAnalytics.internals.request.Request, googleAnalytics.internals.request.PageviewRequest.prototype = $extend(googleAnalytics.internals.request.Request.prototype, {
    page: null,
    getType: function() {
        return null
    },
    buildParameters: function() {
        var a = googleAnalytics.internals.request.Request.prototype.buildParameters.call(this);
        return a.utmp = this.page.getPath(), a.utmdt = this.page.getTitle(), null != this.page.getCharset() && (a.utmcs = this.page.getCharset()), null != this.page.getReferrer() && (a.utmr = this.page.getReferrer()), 0 != this.page.getLoadTime() && a.utmn % 100 < this.config.getSitespeedSampleRate() && (null == a.utme ? a.utme = "0" : a.utme += 0), a
    },
    getPage: function() {
        return this.page
    },
    setPage: function(a) {
        this.page = a
    },
    __class__: googleAnalytics.internals.request.PageviewRequest
}), googleAnalytics.internals.request.SocialInteractionRequest = $hxClasses["googleAnalytics.internals.request.SocialInteractionRequest"] = function(a) {
    googleAnalytics.internals.request.PageviewRequest.call(this, a)
}, googleAnalytics.internals.request.SocialInteractionRequest.__name__ = ["googleAnalytics", "internals", "request", "SocialInteractionRequest"], googleAnalytics.internals.request.SocialInteractionRequest.__super__ = googleAnalytics.internals.request.PageviewRequest, googleAnalytics.internals.request.SocialInteractionRequest.prototype = $extend(googleAnalytics.internals.request.PageviewRequest.prototype, {
    socialInteraction: null,
    getType: function() {
        return "social"
    },
    buildParameters: function() {
        var a = googleAnalytics.internals.request.PageviewRequest.prototype.buildParameters.call(this);
        return a.utmsn = this.socialInteraction.getNetwork(), a.utmsa = this.socialInteraction.getAction(), a.utmsid = this.socialInteraction.getTarget(), null == a.utmsid && (a.utmsid = this.page.getPath()), a
    },
    getSocialInteraction: function() {
        return this.socialInteraction
    },
    setSocialInteraction: function(a) {
        this.socialInteraction = a
    },
    __class__: googleAnalytics.internals.request.SocialInteractionRequest
}), googleAnalytics.internals.request.TransactionRequest = $hxClasses["googleAnalytics.internals.request.TransactionRequest"] = function(a) {
    googleAnalytics.internals.request.Request.call(this, a)
}, googleAnalytics.internals.request.TransactionRequest.__name__ = ["googleAnalytics", "internals", "request", "TransactionRequest"], googleAnalytics.internals.request.TransactionRequest.__super__ = googleAnalytics.internals.request.Request, googleAnalytics.internals.request.TransactionRequest.prototype = $extend(googleAnalytics.internals.request.Request.prototype, {
    transaction: null,
    getType: function() {
        return "tran"
    },
    buildParameters: function() {
        var a = googleAnalytics.internals.request.Request.prototype.buildParameters.call(this);
        return a.utmtid = this.transaction.getOrderId(), a.utmtst = this.transaction.getAffiliation(), a.utmtto = this.transaction.getTotal(), a.utmttx = this.transaction.getTax(), a.utmtsp = this.transaction.getShipping(), a.utmtci = this.transaction.getCity(), a.utmtrg = this.transaction.getRegion(), a.utmtco = this.transaction.getCountry(), a
    },
    buildVisitorParameters: function(a) {
        return a
    },
    buildCustomVariablesParameter: function(a) {
        return a
    },
    getTransaction: function() {
        return this.transaction
    },
    setTransaction: function(a) {
        this.transaction = a
    },
    __class__: googleAnalytics.internals.request.TransactionRequest
});
var haxe = haxe || {};
haxe.IMap = $hxClasses["haxe.IMap"] = function() {}, haxe.IMap.__name__ = ["haxe", "IMap"], haxe._Int64 || (haxe._Int64 = {}), haxe._Int64.___Int64 = $hxClasses["haxe._Int64.___Int64"] = function(a, b) {
    this.high = a, this.low = b
}, haxe._Int64.___Int64.__name__ = ["haxe", "_Int64", "___Int64"], haxe._Int64.___Int64.prototype = {
    high: null,
    low: null,
    __class__: haxe._Int64.___Int64
}, haxe.Timer = $hxClasses["haxe.Timer"] = function(a) {
    var b = this;
    this.id = setInterval(function() {
        b.run()
    }, a)
}, haxe.Timer.__name__ = ["haxe", "Timer"], haxe.Timer.prototype = {
    id: null,
    run: function() {},
    __class__: haxe.Timer
}, haxe.ds || (haxe.ds = {}), haxe.ds._StringMap || (haxe.ds._StringMap = {}), haxe.ds._StringMap.StringMapIterator = $hxClasses["haxe.ds._StringMap.StringMapIterator"] = function(a, b) {
    this.map = a, this.keys = b, this.index = 0, this.count = b.length
}, haxe.ds._StringMap.StringMapIterator.__name__ = ["haxe", "ds", "_StringMap", "StringMapIterator"], haxe.ds._StringMap.StringMapIterator.prototype = {
    map: null,
    keys: null,
    index: null,
    count: null,
    hasNext: function() {
        return this.index < this.count
    },
    next: function() {
        var a = this.map,
            b = this.keys[this.index++];
        return null != __map_reserved[b] ? a.getReserved(b) : a.h[b]
    },
    __class__: haxe.ds._StringMap.StringMapIterator
}, haxe.ds.StringMap = $hxClasses["haxe.ds.StringMap"] = function() {
    this.h = {}
}, haxe.ds.StringMap.__name__ = ["haxe", "ds", "StringMap"], haxe.ds.StringMap.__interfaces__ = [haxe.IMap], haxe.ds.StringMap.prototype = {
    h: null,
    rh: null,
    setReserved: function(a, b) {
        null == this.rh && (this.rh = {}), this.rh["$" + a] = b
    },
    getReserved: function(a) {
        return null == this.rh ? null : this.rh["$" + a]
    },
    existsReserved: function(a) {
        return null != this.rh && this.rh.hasOwnProperty("$" + a)
    },
    remove: function(a) {
        return null != __map_reserved[a] ? (a = "$" + a, !(null == this.rh || !this.rh.hasOwnProperty(a)) && (delete this.rh[a], !0)) : !!this.h.hasOwnProperty(a) && (delete this.h[a], !0)
    },
    keys: function() {
        return HxOverrides.iter(this.arrayKeys())
    },
    arrayKeys: function() {
        var a = [];
        for (var b in this.h) this.h.hasOwnProperty(b) && a.push(b);
        if (null != this.rh)
            for (var b in this.rh) 36 == b.charCodeAt(0) && a.push(b.substr(1));
        return a
    },
    __class__: haxe.ds.StringMap
}, haxe.io || (haxe.io = {}), haxe.io.Bytes = $hxClasses["haxe.io.Bytes"] = function(a) {
    this.length = a.byteLength, this.b = new Uint8Array(a), this.b.bufferValue = a, a.hxBytes = this, a.bytes = this.b
}, haxe.io.Bytes.__name__ = ["haxe", "io", "Bytes"], haxe.io.Bytes.alloc = function(a) {
    return new haxe.io.Bytes(new ArrayBuffer(a))
}, haxe.io.Bytes.ofString = function(a) {
    for (var b = [], c = 0; c < a.length;) {
        var d = a.charCodeAt(c++);
        55296 <= d && d <= 56319 && (d = d - 55232 << 10 | 1023 & a.charCodeAt(c++)), d <= 127 ? b.push(d) : d <= 2047 ? (b.push(192 | d >> 6), b.push(128 | 63 & d)) : d <= 65535 ? (b.push(224 | d >> 12), b.push(128 | d >> 6 & 63), b.push(128 | 63 & d)) : (b.push(240 | d >> 18), b.push(128 | d >> 12 & 63), b.push(128 | d >> 6 & 63), b.push(128 | 63 & d))
    }
    return new haxe.io.Bytes(new Uint8Array(b).buffer)
}, haxe.io.Bytes.ofData = function(a) {
    var b = a.hxBytes;
    return null != b ? b : new haxe.io.Bytes(a)
}, haxe.io.Bytes.prototype = {
    length: null,
    b: null,
    data: null,
    get: function(a) {
        return this.b[a]
    },
    set: function(a, b) {
        this.b[a] = 255 & b
    },
    blit: function(a, b, c, d) {
        if (a < 0 || c < 0 || d < 0 || a + d > this.length || c + d > b.length) throw new js._Boot.HaxeError(haxe.io.Error.OutsideBounds);
        0 == c && d == b.b.byteLength ? this.b.set(b.b, a) : this.b.set(b.b.subarray(c, c + d), a)
    },
    getDouble: function(a) {
        return null == this.data && (this.data = new DataView(this.b.buffer, this.b.byteOffset, this.b.byteLength)), this.data.getFloat64(a, !0)
    },
    setDouble: function(a, b) {
        null == this.data && (this.data = new DataView(this.b.buffer, this.b.byteOffset, this.b.byteLength)), this.data.setFloat64(a, b, !0)
    },
    getUInt16: function(a) {
        return null == this.data && (this.data = new DataView(this.b.buffer, this.b.byteOffset, this.b.byteLength)), this.data.getUint16(a, !0)
    },
    setUInt16: function(a, b) {
        null == this.data && (this.data = new DataView(this.b.buffer, this.b.byteOffset, this.b.byteLength)), this.data.setUint16(a, b, !0)
    },
    getString: function(a, b) {
        if (a < 0 || b < 0 || a + b > this.length) throw new js._Boot.HaxeError(haxe.io.Error.OutsideBounds);
        for (var c = "", d = this.b, e = String.fromCharCode, f = a, g = a + b; f < g;) {
            var h = d[f++];
            if (h < 128) {
                if (0 == h) break;
                c += e(h)
            } else if (h < 224) c += e((63 & h) << 6 | 127 & d[f++]);
            else if (h < 240) {
                var i = d[f++];
                c += e((31 & h) << 12 | (127 & i) << 6 | 127 & d[f++])
            } else {
                var j = d[f++],
                    k = d[f++],
                    l = (15 & h) << 18 | (127 & j) << 12 | (127 & k) << 6 | 127 & d[f++];
                c += e((l >> 10) + 55232), c += e(1023 & l | 56320)
            }
        }
        return c
    },
    __class__: haxe.io.Bytes
}, haxe.io.Error = $hxClasses["haxe.io.Error"] = {
    __ename__: ["haxe", "io", "Error"],
    __constructs__: ["Blocked", "Overflow", "OutsideBounds", "Custom"]
}, haxe.io.Error.Blocked = ["Blocked", 0], haxe.io.Error.Blocked.toString = $estr, haxe.io.Error.Blocked.__enum__ = haxe.io.Error, haxe.io.Error.Overflow = ["Overflow", 1], haxe.io.Error.Overflow.toString = $estr, haxe.io.Error.Overflow.__enum__ = haxe.io.Error, haxe.io.Error.OutsideBounds = ["OutsideBounds", 2], haxe.io.Error.OutsideBounds.toString = $estr, haxe.io.Error.OutsideBounds.__enum__ = haxe.io.Error, haxe.io.Error.Custom = function(a) {
    var b = ["Custom", 3, a];
    return b.__enum__ = haxe.io.Error, b.toString = $estr, b
}, haxe.io.FPHelper = $hxClasses["haxe.io.FPHelper"] = function() {}, haxe.io.FPHelper.__name__ = ["haxe", "io", "FPHelper"], haxe.io.FPHelper.i32ToFloat = function(a) {
    var b = 1 - (a >>> 31 << 1),
        c = a >>> 23 & 255,
        d = 8388607 & a;
    return 0 == d && 0 == c ? 0 : b * (1 + Math.pow(2, -23) * d) * Math.pow(2, c - 127)
}, haxe.io.FPHelper.floatToI32 = function(a) {
    if (0 == a) return 0;
    var b = a < 0 ? -a : a,
        c = Math.floor(Math.log(b) / .6931471805599453);
    c < -127 ? c = -127 : c > 128 && (c = 128);
    var d = Math.round(8388608 * (b / Math.pow(2, c) - 1));
    return 8388608 == d && c < 128 && (d = 0, ++c), (a < 0 ? -2147483648 : 0) | c + 127 << 23 | d
}, haxe.io.FPHelper.i64ToDouble = function(a, b) {
    var c = 1 - (b >>> 31 << 1),
        d = (b >> 20 & 2047) - 1023,
        e = 4294967296 * (1048575 & b) + 2147483648 * (a >>> 31) + (2147483647 & a);
    return 0 == e && d == -1023 ? 0 : c * (1 + Math.pow(2, -52) * e) * Math.pow(2, d)
}, haxe.io.FPHelper.doubleToI64 = function(a) {
    var b = haxe.io.FPHelper.i64tmp;
    if (0 == a) b.low = 0, b.high = 0;
    else if (isFinite(a)) {
        var c = a < 0 ? -a : a,
            d = Math.floor(Math.log(c) / .6931471805599453),
            e = Math.round(4503599627370496 * (c / Math.pow(2, d) - 1)),
            f = 0 | e,
            g = e / 4294967296 | 0;
        b.low = f, b.high = (a < 0 ? -2147483648 : 0) | d + 1023 << 20 | g
    } else a > 0 ? (b.low = 0, b.high = 2146435072) : (b.low = 0, b.high = -1048576);
    return b
};
var js = js || {};
js._Boot || (js._Boot = {}), js._Boot.HaxeError = $hxClasses["js._Boot.HaxeError"] = function(a) {
    Error.call(this), this.val = a, this.message = String(a), Error.captureStackTrace && Error.captureStackTrace(this, js._Boot.HaxeError)
}, js._Boot.HaxeError.__name__ = ["js", "_Boot", "HaxeError"], js._Boot.HaxeError.wrap = function(a) {
    return a instanceof Error ? a : new js._Boot.HaxeError(a)
}, js._Boot.HaxeError.__super__ = Error, js._Boot.HaxeError.prototype = $extend(Error.prototype, {
    val: null,
    __class__: js._Boot.HaxeError
}), js.Boot = $hxClasses["js.Boot"] = function() {}, js.Boot.__name__ = ["js", "Boot"], js.Boot.getClass = function(a) {
    if (a instanceof Array && null == a.__enum__) return Array;
    var b = a.__class__;
    if (null != b) return b;
    var c = js.Boot.__nativeClassName(a);
    return null != c ? js.Boot.__resolveNativeClass(c) : null
}, js.Boot.__string_rec = function(a, b) {
    if (null == a) return "null";
    if (b.length >= 5) return "<...>";
    var c = typeof a;
    switch ("function" == c && (a.__name__ || a.__ename__) && (c = "object"), c) {
        case "function":
            return "<function>";
        case "object":
            if (a instanceof Array) {
                if (a.__enum__) {
                    if (2 == a.length) return a[0];
                    var d = a[0] + "(";
                    b += "\t";
                    for (var e = 2, f = a.length; e < f;) {
                        var g = e++;
                        d += 2 != g ? "," + js.Boot.__string_rec(a[g], b) : js.Boot.__string_rec(a[g], b)
                    }
                    return d + ")"
                }
                var h = a.length,
                    i = "[";
                b += "\t";
                for (var j = 0, k = h; j < k;) {
                    var l = j++;
                    i += (l > 0 ? "," : "") + js.Boot.__string_rec(a[l], b)
                }
                return i += "]"
            }
            var m;
            try {
                m = a.toString
            } catch (n) {
                return "???"
            }
            if (null != m && m != Object.toString && "function" == typeof m) {
                var o = a.toString();
                if ("[object Object]" != o) return o
            }
            var p = null,
                q = "{\n";
            b += "\t";
            var r = null != a.hasOwnProperty;
            for (var p in a) r && !a.hasOwnProperty(p) || "prototype" != p && "__class__" != p && "__super__" != p && "__interfaces__" != p && "__properties__" != p && (2 != q.length && (q += ", \n"), q += b + p + " : " + js.Boot.__string_rec(a[p], b));
            return b = b.substring(1), q += "\n" + b + "}";
        case "string":
            return a;
        default:
            return String(a)
    }
}, js.Boot.__interfLoop = function(a, b) {
    if (null == a) return !1;
    if (a == b) return !0;
    var c = a.__interfaces__;
    if (null != c)
        for (var d = 0, e = c.length; d < e;) {
            var f = d++,
                g = c[f];
            if (g == b || js.Boot.__interfLoop(g, b)) return !0
        }
    return js.Boot.__interfLoop(a.__super__, b)
}, js.Boot.__instanceof = function(a, b) {
    if (null == b) return !1;
    switch (b) {
        case Array:
            return a instanceof Array && null == a.__enum__;
        case Bool:
            return "boolean" == typeof a;
        case Dynamic:
            return !0;
        case Float:
            return "number" == typeof a;
        case Int:
            return "number" == typeof a && (0 | a) === a;
        case String:
            return "string" == typeof a;
        default:
            if (null == a) return !1;
            if ("function" == typeof b) {
                if (a instanceof b) return !0;
                if (js.Boot.__interfLoop(js.Boot.getClass(a), b)) return !0
            } else if ("object" == typeof b && js.Boot.__isNativeObj(b) && a instanceof b) return !0;
            return b == Class && null != a.__name__ || (b == Enum && null != a.__ename__ || a.__enum__ == b)
    }
}, js.Boot.__cast = function(a, b) {
    if (js.Boot.__instanceof(a, b)) return a;
    throw new js._Boot.HaxeError("Cannot cast " + Std.string(a) + " to " + Std.string(b))
}, js.Boot.__nativeClassName = function(a) {
    var b = js.Boot.__toStr.call(a).slice(8, -1);
    return "Object" == b || "Function" == b || "Math" == b || "JSON" == b ? null : b
}, js.Boot.__isNativeObj = function(a) {
    return null != js.Boot.__nativeClassName(a)
}, js.Boot.__resolveNativeClass = function(a) {
    return $global[a]
}, js.html || (js.html = {}), js.html.compat || (js.html.compat = {}), js.html.compat.ArrayBuffer = $hxClasses["js.html.compat.ArrayBuffer"] = function(a) {
    if (a instanceof Array && null == a.__enum__) this.a = a, this.byteLength = a.length;
    else {
        var b = a;
        this.a = [];
        for (var c = 0, d = b; c < d;) {
            var e = c++;
            this.a[e] = 0
        }
        this.byteLength = b
    }
}, js.html.compat.ArrayBuffer.__name__ = ["js", "html", "compat", "ArrayBuffer"], js.html.compat.ArrayBuffer.sliceImpl = function(a, b) {
    var c = new Uint8Array(this, a, null == b ? null : b - a),
        d = new ArrayBuffer(c.byteLength),
        e = new Uint8Array(d);
    return e.set(c), d
}, js.html.compat.ArrayBuffer.prototype = {
    byteLength: null,
    a: null,
    slice: function(a, b) {
        return new js.html.compat.ArrayBuffer(this.a.slice(a, b))
    },
    __class__: js.html.compat.ArrayBuffer
}, js.html.compat.DataView = $hxClasses["js.html.compat.DataView"] = function(a, b, c) {
    if (this.buf = a, this.offset = null == b ? 0 : b, this.length = null == c ? a.byteLength - this.offset : c, this.offset < 0 || this.length < 0 || this.offset + this.length > a.byteLength) throw new js._Boot.HaxeError(haxe.io.Error.OutsideBounds);
    this.byteLength = this.length, this.byteOffset = this.offset, this.buffer = this.buf
}, js.html.compat.DataView.__name__ = ["js", "html", "compat", "DataView"], js.html.compat.DataView.prototype = {
    buf: null,
    offset: null,
    length: null,
    byteLength: null,
    byteOffset: null,
    buffer: null,
    getInt8: function(a) {
        var b = this.buf.a[this.offset + a];
        return b >= 128 ? b - 256 : b
    },
    getUint8: function(a) {
        return this.buf.a[this.offset + a]
    },
    getInt16: function(a, b) {
        var c = this.getUint16(a, b);
        return c >= 32768 ? c - 65536 : c
    },
    getUint16: function(a, b) {
        return b ? this.buf.a[this.offset + a] | this.buf.a[this.offset + a + 1] << 8 : this.buf.a[this.offset + a] << 8 | this.buf.a[this.offset + a + 1]
    },
    getInt32: function(a, b) {
        var c = this.offset + a,
            d = this.buf.a[c++],
            e = this.buf.a[c++],
            f = this.buf.a[c++],
            g = this.buf.a[c++];
        return b ? d | e << 8 | f << 16 | g << 24 : g | f << 8 | e << 16 | d << 24
    },
    getUint32: function(a, b) {
        var c = this.getInt32(a, b);
        return c < 0 ? c + 4294967296 : c
    },
    getFloat32: function(a, b) {
        return haxe.io.FPHelper.i32ToFloat(this.getInt32(a, b))
    },
    getFloat64: function(a, b) {
        var c = this.getInt32(a, b),
            d = this.getInt32(a + 4, b);
        return haxe.io.FPHelper.i64ToDouble(b ? c : d, b ? d : c)
    },
    setInt8: function(a, b) {
        this.buf.a[a + this.offset] = b < 0 ? b + 128 & 255 : 255 & b
    },
    setUint8: function(a, b) {
        this.buf.a[a + this.offset] = 255 & b
    },
    setInt16: function(a, b, c) {
        this.setUint16(a, b < 0 ? b + 65536 : b, c)
    },
    setUint16: function(a, b, c) {
        var d = a + this.offset;
        c ? (this.buf.a[d] = 255 & b, this.buf.a[d++] = b >> 8 & 255) : (this.buf.a[d++] = b >> 8 & 255, this.buf.a[d] = 255 & b)
    },
    setInt32: function(a, b, c) {
        this.setUint32(a, b, c)
    },
    setUint32: function(a, b, c) {
        var d = a + this.offset;
        c ? (this.buf.a[d++] = 255 & b, this.buf.a[d++] = b >> 8 & 255, this.buf.a[d++] = b >> 16 & 255, this.buf.a[d++] = b >>> 24) : (this.buf.a[d++] = b >>> 24, this.buf.a[d++] = b >> 16 & 255, this.buf.a[d++] = b >> 8 & 255, this.buf.a[d++] = 255 & b)
    },
    setFloat32: function(a, b, c) {
        this.setUint32(a, haxe.io.FPHelper.floatToI32(b), c)
    },
    setFloat64: function(a, b, c) {
        var d = haxe.io.FPHelper.doubleToI64(b);
        c ? (this.setUint32(a, d.low), this.setUint32(a, d.high)) : (this.setUint32(a, d.high), this.setUint32(a, d.low))
    },
    __class__: js.html.compat.DataView
}, js.html.compat.Uint8Array = $hxClasses["js.html.compat.Uint8Array"] = function() {}, js.html.compat.Uint8Array.__name__ = ["js", "html", "compat", "Uint8Array"], js.html.compat.Uint8Array._new = function(a, b, c) {
    var d;
    if ("number" == typeof a) {
        d = [];
        for (var e = 0, f = a; e < f;) {
            var g = e++;
            d[g] = 0
        }
        d.byteLength = d.length, d.byteOffset = 0, d.buffer = new js.html.compat.ArrayBuffer(d)
    } else if (js.Boot.__instanceof(a, js.html.compat.ArrayBuffer)) {
        var h = a;
        null == b && (b = 0), null == c && (c = h.byteLength - b), d = 0 == b ? h.a : h.a.slice(b, b + c), d.byteLength = d.length, d.byteOffset = b, d.buffer = h
    } else {
        if (!(a instanceof Array && null == a.__enum__)) throw new js._Boot.HaxeError("TODO " + Std.string(a));
        d = a.slice(), d.byteLength = d.length, d.byteOffset = 0, d.buffer = new js.html.compat.ArrayBuffer(d)
    }
    return d.subarray = js.html.compat.Uint8Array._subarray, d.set = js.html.compat.Uint8Array._set, d
}, js.html.compat.Uint8Array._set = function(a, b) {
    if (js.Boot.__instanceof(a.buffer, js.html.compat.ArrayBuffer)) {
        var c = a;
        if (a.byteLength + b > this.byteLength) throw new js._Boot.HaxeError("set() outside of range");
        for (var d = 0, e = a.byteLength; d < e;) {
            var f = d++;
            this[f + b] = c[f]
        }
    } else {
        if (!(a instanceof Array && null == a.__enum__)) throw new js._Boot.HaxeError("TODO");
        var g = a;
        if (g.length + b > this.byteLength) throw new js._Boot.HaxeError("set() outside of range");
        for (var h = 0, i = g.length; h < i;) {
            var j = h++;
            this[j + b] = g[j]
        }
    }
}, js.html.compat.Uint8Array._subarray = function(a, b) {
    var c = js.html.compat.Uint8Array._new(this.slice(a, b));
    return c.byteOffset = a, c
};
var $_, $fid = 0;
$hxClasses.Math = Math, String.prototype.__class__ = $hxClasses.String = String, String.__name__ = ["String"], $hxClasses.Array = Array, Array.__name__ = ["Array"], Date.prototype.__class__ = $hxClasses.Date = Date, Date.__name__ = ["Date"];
var Int = $hxClasses.Int = {
        __name__: ["Int"]
    },
    Dynamic = $hxClasses.Dynamic = {
        __name__: ["Dynamic"]
    },
    Float = $hxClasses.Float = Number;
Float.__name__ = ["Float"];
var Bool = $hxClasses.Bool = Boolean;
Bool.__ename__ = ["Bool"];
var Class = $hxClasses.Class = {
        __name__: ["Class"]
    },
    Enum = {},
    __map_reserved = {},
    ArrayBuffer = $global.ArrayBuffer || js.html.compat.ArrayBuffer;
null == ArrayBuffer.prototype.slice && (ArrayBuffer.prototype.slice = js.html.compat.ArrayBuffer.sliceImpl);
var DataView = $global.DataView || js.html.compat.DataView,
    Uint8Array = $global.Uint8Array || js.html.compat.Uint8Array._new;
bikas.algorithms.QuarticSolver.EPSILON = 1e-10, bikas.algorithms.NotBikas_ButWhatever_RootSolver.EQN_EPS = 1e-10, bikas.algorithms.NotBikas_ButWhatever_RootSolver.INV3 = .3333333333333333, bikas.algorithms.NotBikas_ButWhatever_RootSolver.INV2 = .5, bikas.algorithms.NotBikas_ButWhatever_RootSolver.INV4 = .25, bikas.algorithms.NotBikas_ButWhatever_RootSolver.INV8 = .125, bikas.algorithms.NotBikas_ButWhatever_RootSolver.INV16 = .0625, bikas.algorithms.NotBikas_ButWhatever_RootSolver.PI_OVER_3 = 1.0471975511965976, bikas.algorithms.NotBikas_ButWhatever_RootSolver.TWO_OVER_27 = .07407407407407407, bikas.algorithms.NotBikas_ButWhatever_RootSolver.THREE_OVER_8 = .375, bikas.algorithms.NotBikas_ButWhatever_RootSolver.THREE_OVER_256 = .01171875, bikas.global.MathConstants.PI = Math.PI, bikas.global.MathConstants.PI2 = 2 * Math.PI, bikas.global.MathConstants.DEGREES_TO_RADIANS = .017453292519943, bikas.global.MathConstants.RADIANS_TO_DEGREES = 57.29577951308232, bikas.global.MathConstants.INCHES_TO_CENTIMETERS = 2.54, bikas.global.MathConstants.EPSILON = 1e-8, bikas.google.GoogleAnalyticsWrapper.exists = !1, bikas.pointer.Pointer.CLICK_EVENT_DISTANCE = 3, bikas.pointer.Pointer.DOUBLE_CLICK_TIME = 500, bikas.serialization.Bef.NAME = "BEF_v3", bikas.serialization.Bef.BOOL_FLAG = 0, bikas.serialization.Bef.BOOL_TRUE_FLAG = 1, bikas.serialization.Bef.BOOL_FALSE_FLAG = 2, bikas.serialization.Bef.INT_FLAG = 3, bikas.serialization.Bef.DOUBLE_FLAG = 4, bikas.serialization.Bef.STRING_FLAG = 5, bikas.serialization.Bef.NULL_FLAG = 6, bikas.serialization.Bef.ENUM_FLAG = 7, bikas.serialization.Bef.ENUM_INDEX_INDEX_FLAG = 8, bikas.serialization.Bef.ENUM_STRING_INDEX_FLAG = 9, bikas.serialization.Bef.ENUM_STRING_STRING_FLAG = 10, bikas.serialization.Bef.ARRAY_FLAG = 11, bikas.serialization.Bef.INSTANCE_FLAG = 12, bikas.serialization.Bef.INSTANCE_POINT_FLAG = 128, bikas.serialization.Bef.INSTANCE_TRANSFORM_FLAG = 129, googleAnalytics.Campaign.TYPE_DIRECT = "direct", googleAnalytics.Campaign.TYPE_ORGANIC = "organic", googleAnalytics.Campaign.TYPE_REFERRAL = "referral", googleAnalytics.Config.ERROR_SEVERITY_SILENCE = 0, googleAnalytics.Config.ERROR_SEVERITY_TRACE = 1, googleAnalytics.Config.ERROR_SEVERITY_EXCEPTIONS = 2, googleAnalytics.CustomVariable.SCOPE_VISITOR = 1, googleAnalytics.CustomVariable.SCOPE_SESSION = 2, googleAnalytics.CustomVariable.SCOPE_PAGE = 3, googleAnalytics.Page.REFERRER_INTERNAL = "0", googleAnalytics.Stats.paused = !1, googleAnalytics.Tracker.VERSION = "5.2.5", googleAnalytics.URLParser.parts = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"], googleAnalytics.internals.X10.OBJECT_KEY_NUM = 1, googleAnalytics.internals.X10.TYPE_KEY_NUM = 2, googleAnalytics.internals.X10.LABEL_KEY_NUM = 3, googleAnalytics.internals.X10.VALUE_VALUE_NUM = 1, googleAnalytics.internals.request.Request.TYPE_EVENT = "event", googleAnalytics.internals.request.Request.TYPE_TRANSACTION = "tran", googleAnalytics.internals.request.Request.TYPE_ITEM = "item", googleAnalytics.internals.request.Request.TYPE_SOCIAL = "social", googleAnalytics.internals.request.Request.TYPE_CUSTOMVARIABLE = "var", googleAnalytics.internals.request.Request.X10_CUSTOMVAR_NAME_PROJECT_ID = "8", googleAnalytics.internals.request.Request.X10_CUSTOMVAR_VALUE_PROJECT_ID = "9", googleAnalytics.internals.request.Request.X10_CUSTOMVAR_SCOPE_PROJECT_ID = "11", googleAnalytics.internals.request.Request.CAMPAIGN_DELIMITER = "|", googleAnalytics.internals.request.EventRequest.X10_EVENT_PROJECT_ID = "5", haxe.io.FPHelper.i64tmp = function(a) {
    var b, c = new haxe._Int64.___Int64(0, 0);
    return b = c
}(this), js.Boot.__toStr = {}.toString, js.html.compat.Uint8Array.BYTES_PER_ELEMENT = 1;
var __extends = this && this.__extends || function(a, b) {
        function c() {
            this.constructor = a
        }
        for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);
        a.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c)
    },
    MedievalDefenseZ;
! function(a) {
    var b = function() {
        function a() {
            this.static_sprites = new Array, this.animated_sprites = new Array
        }
        return a
    }();
    a.SpriteAnimation = b;
    var c = function() {
        function a(a, b, c) {
            void 0 === c && (c = 1), this.start = a, this.end = b, this.additional_coeff = c
        }
        return a
    }();
    a.AnimationRange = c
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.MathConstants,
        c = bikas.global.Interpolate,
        d = function() {
            function d() {}
            return d.createSpriteAnimation = function(b, c, d) {
                function e(b, c, d) {
                    void 0 === d && (d = null);
                    var e = a.PixiDo.createGroup(),
                        f = a.PixiDo.createSprite(c);
                    e.add(f);
                    var g = b.registration_x / f.width,
                        h = b.registration_y / f.height;
                    return f.anchor.set(g, h), null != d && (e.position.x = d.position_x, e.position.y = d.position_y, e.rotation = d.rotation, e.scale.x = d.scale_x, e.scale.y = d.scale_y), e
                }
                if (c.length != d.length) return null;
                var f = new a.SpriteAnimation;
                f.current_frame = 0, f.source = b;
                for (var g = 0; g < b.static_sprites.length; g++) {
                    var h = b.static_sprites[g],
                        i = h.description,
                        j = h.state,
                        k = d[c.indexOf(i.name)],
                        l = e(i, k, j);
                    f.static_sprites.push(l)
                }
                for (var g = 0; g < b.animated_sprites.length; g++) {
                    var i = b.animated_sprites[g],
                        k = d[c.indexOf(i.name)],
                        j = null;
                    b.keyframe_indexes.length > 0 && (j = b.keyframes[b.keyframe_indexes[0]].states[g]);
                    var l = e(i, k, j);
                    f.animated_sprites.push(l)
                }
                return f
            }, d.addToContainer = function(a, b) {
                for (var c = 0, d = b.static_sprites; c < d.length; c++) {
                    var e = d[c];
                    a.add(e)
                }
                for (var f = 0, g = b.animated_sprites; f < g.length; f++) {
                    var e = g[f];
                    a.add(e)
                }
            }, d.gotoFrame = function(a, d) {
                for (var e = a.source, f = -1, g = -1, h = 1; h < e.keyframe_indexes.length; h++)
                    if (d >= e.keyframe_indexes[h - 1] && d <= e.keyframe_indexes[h]) {
                        f = h - 1, g = h;
                        break
                    }
                if (f != -1 || g != -1) {
                    for (var i = e.keyframes[f], j = e.keyframes[g], k = e.keyframe_indexes[f], l = e.keyframe_indexes[g], m = (d - k) / (l - k), h = 0; h < i.states.length; h++) {
                        var n = i.states[h],
                            o = j.states[h],
                            p = a.animated_sprites[h];
                        p.position.x = c.linear(n.position_x, o.position_x, m), p.position.y = c.linear(n.position_y, o.position_y, m);
                        var q = c.linear(n.rotation, o.rotation, m) * b.DEGREES_TO_RADIANS;
                        p.rotation != q && (p.rotation = q);
                        var r = c.linear(n.scale_x, o.scale_x, m),
                            s = c.linear(n.scale_y, o.scale_y, m);
                        p.scale.x != r && (p.scale.x = r), p.scale.y != s && (p.scale.y = s)
                    }
                    a.current_frame = d
                }
            }, d.play = function(a, b) {
                var c = a.source.keyframe_indexes[a.source.keyframe_indexes.length - 1],
                    e = d.getNextFrame(1, c, a.current_frame + b);
                d.gotoFrame(a, e)
            }, d.playRange = function(a, b, c) {
                var e = a.current_frame + c * b.additional_coeff;
                d.gotoFrame(a, d.getNextFrame(b.start, b.end, e))
            }, d.playRangeOnce = function(a, b, c, e) {
                void 0 === e && (e = !0);
                var f = b.start,
                    g = b.end,
                    h = 1,
                    i = !1;
                if (a.current_frame < f || a.current_frame > g) h = f;
                else if (h = a.current_frame + c * b.additional_coeff, e) Math.round(1e3 * h) / 1e3 >= g && (h = g, i = !0);
                else {
                    h >= g && (i = !0);
                    var j = a.source.keyframe_indexes[a.source.keyframe_indexes.length - 1];
                    h = d.getNextFrame(1, j, h)
                }
                return d.gotoFrame(a, h), !!i
            }, d.playRangeBackwardsOnce = function(a, b, c, e) {
                void 0 === e && (e = !0);
                var f = b.start,
                    g = b.end,
                    h = 1,
                    i = !1;
                if (a.current_frame < f || a.current_frame > g) h = g;
                else if (h = a.current_frame - c * b.additional_coeff, e) Math.round(1e3 * h) / 1e3 <= f && (h = f, i = !0);
                else {
                    h <= f && (i = !0);
                    var j = a.source.keyframe_indexes[a.source.keyframe_indexes.length - 1];
                    h = d.getNextFrame(1, j, h)
                }
                return d.gotoFrame(a, h), !!i
            }, d.getNextFrame = function(a, b, c) {
                if (c <= b && c >= a) return c;
                if (b == a) return c;
                var d = b - a,
                    e = Math.floor((c - a) / d),
                    f = c - e * d;
                return f
            }, d.getTotalFrames = function(a) {
                var b = a.keyframe_indexes[0],
                    c = d.getLastFrame(a);
                return c - b + 1
            }, d.getLastFrame = function(a) {
                return a.keyframe_indexes[a.keyframe_indexes.length - 1]
            }, d.getRelativeRangeFrames = function(a, b) {
                return b.start - a.current_frame
            }, d.findSpriteByName = function(a, b) {
                for (var c = a.source.static_sprites, d = 0; d < c.length; d++)
                    if (c[d].description.name == b) return a.static_sprites[d];
                for (var e = a.source.animated_sprites, d = 0; d < e.length; d++)
                    if (e[d].name == b) return a.animated_sprites[d];
                return null
            }, d
        }();
    a.PixiAnimationDo = d
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = function(b) {
        function c() {
            var c = b.call(this, {
                enableDebug: !1,
                width: window.innerWidth,
                height: window.innerHeight,
                renderer: Phaser.AUTO,
                parent: "content",
                transparent: !1,
                antialias: !0,
                preserveDrawingBuffer: !1,
                physicsConfig: null,
                seed: "",
                state: null,
                forceSetTimeOut: !1
            }) || this;
            return c.state.add(a.Boot.Name, a.Boot, !1), c.state.add(Fabrique.SplashScreen.Preloader.Name, Fabrique.SplashScreen.Preloader, !1), c.state.add(a.Gameplay.Name, a.Gameplay, !1), Phaser.Device.whenReady(function() {
                c.stage.setBackgroundColor("0x2D1807"), c.stage.disableVisibilityChange = !0;
                var a = c.device.desktop ? "click" : "touchstart";
                document.getElementById("content").addEventListener(a, function(a) {
                    c.gameResumed(a)
                }), c.plugins.add(Fabrique.Plugins.GameEvents), c.plugins.add(Fabrique.Plugins.GoogleAnalytics), c.plugins.add(Fabrique.Plugins.GameAnalytics), c.plugins.add(PhaserAds.AdManager), c.plugins.add(PhaserCachebuster.CacheBuster), c.plugins.add(PhaserSpine.SpinePlugin)
            }), c
        }
        return __extends(c, b), c.getInstance = function() {
            return null === c.instance && (c.instance = new c), c.instance
        }, c.prototype.start = function() {
            var b = this,
                c = function() {
                    b.recursiveUpdateText(b.stage)
                };
            WebFont.load({
                custom: {
                    families: ["Aller Display"],
                    urls: ["assets/css/AllerDisplay.css"]
                },
                active: c,
                inactive: c
            }), this.state.start(a.Boot.Name)
        }, c.prototype.recursiveUpdateText = function(a) {}, c
    }(Phaser.Game);
    b.instance = null, a.Game = b
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = function() {
        function a() {
            this.current_angle_goal = 0, this.current_angle_speed = Math.PI / 180, this.radius_threshold = 100
        }
        return a
    }();
    a.Fly = b
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.GlobalFunc,
        c = bikas.global.VecFunc,
        d = bikas.global.VecProc,
        e = function() {
            function e() {}
            return e.create = function(c, d, e, f, g, h, i) {
                var j = new a.Fly;
                return j.position = b.copyPoint(c), j.center = d, j.speed = e, j.angle = f, j.random_angle_goal = h, j.random_angle_speed = g, j.current_angle_goal = b.getRandomSign() * b.getRandomBetween(j.random_angle_goal.min, j.random_angle_goal.max), j.radius_threshold = i, j.current_angle_speed = b.getRandomSign() * b.getRandomBetween(j.random_angle_speed.min, j.random_angle_speed.max), j
            }, e.update = function(a, e) {
                if (a.current_angle_goal -= Math.abs(a.current_angle_speed * e), a.angle += a.current_angle_speed * e, a.position.x += Math.cos(a.angle) * a.speed * e, a.position.y += Math.sin(a.angle) * a.speed * e, a.current_angle_goal < 0)
                    if (b.distanceBetweenPoints(a.position, a.center) >= a.radius_threshold) {
                        var f = c.angle(d.subtract(a.center, a.position));
                        a.current_angle_goal = b.angleDifferenceRad(f, a.angle), a.current_angle_speed = b.getRandomBetween(a.random_angle_speed.min, a.random_angle_speed.max), a.current_angle_goal < 0 && (a.current_angle_speed *= -1)
                    } else a.current_angle_goal = b.getRandomSign() * b.getRandomBetween(a.random_angle_goal.min, a.random_angle_goal.max), a.current_angle_speed = b.getRandomSign() * b.getRandomBetween(a.random_angle_speed.min, a.random_angle_speed.max)
            }, e
        }();
    a.FlyDo = e
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.MinMax,
        c = bikas.global.Point,
        d = function() {
            function d() {}
            return d.createBasic = function() {
                var d = a.FlyDo.create(new c(0, 0), new c(0, 0), 2, 0, new b(.12, .18), new b(1.57, 3.14), 25);
                return d
            }, d
        }();
    a.FlyExamples = d
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var Constants = function() {
    function a() {}
    return a
}();
Constants.GAME_SCALE = 1, Constants.GAME_ORIGINAL_WIDTH = 1280, Constants.GAME_ORIGINAL_HEIGHT = 720, Constants.GAME_WIDTH = Constants.GAME_ORIGINAL_WIDTH, Constants.GAME_HEIGHT = Constants.GAME_ORIGINAL_HEIGHT, Constants.LANDSCAPE_LOCKED = !1, Constants.PORTRAIT_LOCKED = !1, Constants.GAME_KEY = "f7a20c424592c83e86c484778d88098f", Constants.SECRET_KEY = "10f73bf4e8747fe7ae32406f67c1aaafc3d9ced2", Constants.BUILD = "1.0.0", Constants.GOOGLE_ID = "UA-85519155-20", Constants.GOOGLE_APP_NAME = "Medieval Defense Z", Constants.SPLASH_BACKGROUND = 11119017, Constants.SPLASH_IMAGE = "OG_logo_fullcolor", Constants.SPLASH_URL = "http://www.funnygames.nl", Constants.MORE_GAMES_URL = "http://www.funnygames.nl", Constants.GAME_TITLE = "SolitaireFGP", Constants.OPEN_LEVEL = 0, Constants.COUNT_OF_LEVELS = 62, Constants.ACTIVE_LEVEL = 0, Constants.LAST_LEVEL = 0, Constants.UNIQ_TILES = 42;
var MedievalDefenseZ;
! function(a) {
    var b = function() {
        function a(a) {
            this.fadeColor = 0, this.game = a
        }
        return a.Init = function(b) {
            a.instance = new a(b)
        }, a.prototype.fadeTo = function(a, b) {
            this.createBkg(), this.spr_bg.alpha = 0, this.nextState = a, this.ars = b, this.game.add.existing(this.spr_bg);
            var c = this.game.add.tween(this.spr_bg);
            c.to({
                alpha: 1
            }, 500, null), c.onComplete.add(this.changeState, this), c.start()
        }, a.prototype.createBkg = function() {
            this.spr_bg = this.game.make.graphics(0, 0), this.spr_bg.beginFill(this.fadeColor, 1), this.spr_bg.drawRect(0, 0, this.game.world.width, this.game.world.height), this.spr_bg.endFill()
        }, a.prototype.changeState = function() {
            this.game.state.start(this.nextState, !0, !1, this.ars)
        }, a.prototype.fadeOut = function() {
            this.createBkg(), this.spr_bg.alpha = 1, this.game.add.existing(this.spr_bg);
            var a = this.game.add.tween(this.spr_bg);
            a.to({
                alpha: 0
            }, 500, null), a.start()
        }, a
    }();
    a.FadeInOut = b
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var Fabrique;
! function(a) {
    var b = function(a) {
        function b() {
            var c = null !== a && a.apply(this, arguments) || this;
            return c.name = b.Name, c
        }
        return __extends(b, a), b.prototype.create = function() {
            this.game.analytics.google.sendScreenView(this.name)
        }, b
    }(Phaser.State);
    b.Name = "default", a.State = b
}(Fabrique || (Fabrique = {}));
var MedievalDefenseZ;
! function(a) {
    var b = function(b) {
        function c() {
            var a = b.call(this) || this;
            return a.name = c.Name, a
        }
        return __extends(c, b), c.prototype.init = function() {
            var b = this;
            this.game.analytics.game.setup(Constants.GAME_KEY, Constants.SECRET_KEY, version, this.game.analytics.game.createUser());
            var d = Date.now();
            window.addEventListener("beforeunload", function() {
                b.game.analytics.game.addEvent(new GA.Events.SessionEnd((Date.now() - d) / 1e3)), b.game.analytics.game.sendEvents()
            }), this.game.analytics.google.setup(Constants.GOOGLE_ID, Constants.GOOGLE_APP_NAME, version), this.game.ads.setAdProvider(new PhaserAds.AdProvider.GameDistributionAds(this.game, "a90bd3f1fba643828ccfb0109b41a252", "ABD36C6C-E74B-4BA7-BE87-0AB01F98D30D-s1")), this.game.input.maxPointers = 1, this.game.canvas.oncontextmenu = function(a) {
                a.preventDefault()
            }, this.game.device.desktop ? (this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL, this.scale.pageAlignHorizontally = !0, this.game.scale.windowConstraints.bottom = "visual") : (Constants.GAME_SCALE = this.getScaling(), this.scale.scaleMode = Phaser.ScaleManager.USER_SCALE, this.scale.fullScreenScaleMode = Phaser.ScaleManager.USER_SCALE, window.addEventListener("resize", function(a) {
                return c.mobileResizeCallback(b.game.scale)
            }), this.game.scale.onSizeChange.add(function() {
                b.game.state.getCurrentState().resize()
            }, this), c.mobileResizeCallback(this.game.scale)), a.PhaserObjects.game = this.game
        }, c.mobileResizeCallback = function(a) {
            var b = window.innerWidth,
                d = window.innerHeight,
                e = Constants.GAME_ORIGINAL_WIDTH * Constants.GAME_SCALE,
                f = Constants.GAME_ORIGINAL_HEIGHT * Constants.GAME_SCALE,
                g = 1;
            g /= b > d ? b / d < 1.5 && c.inGame || b / d > 1.8 ? d / f : b / e : d / f, a.width === b * g && a.height === d * g || (Constants.GAME_WIDTH = Math.ceil(b * g), Constants.GAME_HEIGHT = Math.ceil(d * g), a.setGameSize(Constants.GAME_WIDTH, Constants.GAME_HEIGHT), a.setUserScale(1 / g, 1 / g))
        }, c.prototype.preload = function() {
            this.game.load.cacheBuster = "undefined" == typeof version ? null : version
        }, c.prototype.create = function() {
            var b = this;
            a.FadeInOut.Init(this.game), this.game.analytics.google.sendScreenView("boot"), this.game.state.start(Fabrique.SplashScreen.Preloader.Name, !0, !1, {
                nextState: a.Gameplay.Name,
                mobilePlayClickhandler: function() {
                    // b.game.ads.onContentPaused.addOnce(function() {
                    //     b.game.analytics.google.sendScreenView("advertisement")
                    // }), b.game.ads.onContentResumed.addOnce(function() {
                        b.game.state.start(a.Gameplay.Name, !0, !1, c.Name)
                     // b.game.ads.onContentPaused.removeAll(), b.game.ads.onContentResumed.removeAll()
                    // }), b.game.ads.showAd(PhaserAds.AdProvider.GameDistributionAdType.preroll)
                },
                preloadHandler: function() {
                    b.game.analytics.google.sendScreenView("splash"), b.game.stage.disableVisibilityChange = !1, b.game.sound.muteOnPause = !0, Fabrique.Branding.preloadImages(b.game), Fabrique.MoreGames.Menu.preloadImages(b.game), a.GameAssets.init(b.game.load, a.InitDo.getConfig())
                }
            })
        }, c.prototype.getScaling = function() {
            var a = window.innerWidth;
            a < window.innerHeight && (a = window.innerHeight);
            var b = 1;
            return b = a < 650 ? .5 : a > 1050 ? 1 : .75
        }, c
    }(Phaser.State);
    b.Name = "boot", b.inGame = !1, b.pause = !1, a.Boot = b
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = function(b) {
        function c() {
            var a = null !== b && b.apply(this, arguments) || this;
            return a.name = c.Name, a
        }
        return __extends(c, b), c.prototype.create = function() {
                var b = this;
                // window.removeEventListener("resize", function(c) {
                //     return a.Boot.mobileResizeCallback(b.game.scale)
                // }), this.game.scale.onSizeChange.removeAll(), this.game.analytics.google.sendScreenView(c.Name), this.game.ads.onContentPaused.addOnce(function() {
                //     b.game.analytics.google.sendScreenView("advertisement")
                // }), this.game.ads.onContentResumed.addOnce(function() {
                //     b.game.ads.onContentPaused.removeAll(), 
                //     b.game.ads.onContentResumed.removeAll(), 
                    b.game_updater = new a.GameUpdater, a.InitDo.initializeAndStart(b.game_updater)
                // }), this.game.ads.showAd(PhaserAds.AdProvider.GameDistributionAdType.midroll)
        }, c.prototype.update = function() {
            this.game_updater.update()
        }, c
    }(Phaser.State);
    b.Name = "gameplay", a.Gameplay = b
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.Point,
        c = bikas.global.PointTime,
        d = bikas.global.GlobalFunc,
        e = bikas.global.GlobalSolve,
        f = bikas.global.VecFunc,
        g = bikas.global.VecProc,
        h = function() {
            function h() {}
            return h.spawn = function(c, d) {
                var e = null;
                if (null != d.removed_archer) e = d.removed_archer;
                else {
                    e = new a.Archer, e.platform = d, e.anim = a.PixiAnimationDo.createSpriteAnimation(a.GameAssets.archer_animation, ["top_string", "bottom_string", "right_forearm", "right_upper_arm", "left_arm", "bow"], [a.GameAssets.archer_string, a.GameAssets.archer_string, a.GameAssets.archer_right_forearm, a.GameAssets.archer_right_upper_arm, a.GameAssets.archer_left_arm, a.GameAssets.archer_bow]), e.shooting_container = a.PixiDo.createGroup(), e.anim.animated_sprites[0].getAt(0).anchor.x = .5, e.anim.animated_sprites[1].getAt(0).anchor.x = .5, a.PixiAnimationDo.addToContainer(e.shooting_container, e.anim), e.right_forearm = a.PixiAnimationDo.findSpriteByName(e.anim, "right_forearm"), e.container = a.PixiDo.createGroup();
                    var f = a.PixiDo.createSprite(a.GameAssets.archer_body);
                    f.anchor.set(.5, .5), f.position.set(-4.957, 14.525), e.container.add(f);
                    var g = a.PixiDo.createSprite(a.GameAssets.archer_head);
                    g.anchor.set(.448, .859), g.position.set(-8.211, -15.387), e.head = g, e.container.add(g), e.shooting_container.position.set(-7.924, -11.868), e.container.add(e.shooting_container), d.platform.scale.x > 0 ? e.container.position.set(d.container.position.x + 34.5, d.container.position.y - 96.5) : e.container.position.set(d.container.position.x - 34.5, d.container.position.y - 96.5), e.global_launch_spot_min = new b(e.container.position.x - 8, e.container.position.y - 6), e.global_launch_spot_max = new b(e.container.position.x - 3, e.container.position.y - 12)
                }
                return a.PixiAnimationDo.gotoFrame(e.anim, 1), c.archers.push(e), e.state = a.ArcherState.Resting, e.exist = !0, d.buy_sign.parent.remove(d.buy_sign), c.machine_container.add(e.container), d.upgrade_sign.visible = !0, d.side == a.MachinePlatformSide.Left && d.upgrade_sign.parent.setChildIndex(d.upgrade_sign, d.upgrade_sign.parent.children.length - 1), d.archer = e, c.total_archer_count = a.GameDo.getTotalArcherCount(c), e
            }, h.resetCompletely = function(a, b) {
                h.clearArrowsAndResetCurrentState(a, b), h.clearLevelUp(a, b), b.accuracy.trained_index = 0, b.strength.trained_index = 0, b.speed.trained_index = 0, b.hook.current_index = 0, b.sharpness.current_index = 0, b.xarrows.current_index = 0
            }, h.clearArrowsAndResetCurrentState = function(b, c) {
                c.state = a.ArcherState.Resting, a.PixiAnimationDo.gotoFrame(c.anim, 1);
                for (var d = 0, e = c.arrows; d < e.length; d++) {
                    var f = e[d];
                    null != f && null != f.parent && (f.parent.removeChild(f), b.garbage.arrow_sprites.push(f))
                }
                c.arrows = [], c.launch_vectors = new Array, c.zombie_target = null, c.relaunch = !1, c.resting.current = 0, c.shooting_container.rotation = 0, c.head.rotation = 0
            }, h.clearLevelUp = function(a, b) {
                b.current_level = 0, b.total_launchs = 0, b.total_hits = 0, b.skill_points = 0, h.removeLevelUpTransitionIfShould(a, b), b.platform.selected_sprite.visible = !1
            }, h.removeAllArchers = function(a) {
                for (var b = 0, c = a.archers.slice(0); b < c.length; b++) {
                    var d = c[b];
                    h.remove(a, d)
                }
            }, h.remove = function(a, b) {
                h.resetCompletely(a, b), b.platform.archer = null, b.platform.removed_archer = b, a.archers.splice(a.archers.indexOf(b), 1), b.platform.container.add(b.platform.buy_sign), b.platform.upgrade_sign.visible = !1, a.machine_container.remove(b.container), b.exist = !1
            }, h.removeLevelUpTransitionIfShould = function(a, b) {
                null != b.level_up_transition && 0 == b.skill_points && (b.level_up_transition.container.parent.remove(b.level_up_transition.container), a.transitions.indexOf(b.level_up_transition) != -1 && a.transitions.splice(a.transitions.indexOf(b.level_up_transition), 1), b.level_up_transition = null, b.platform.selected_sprite.visible = !1)
            }, h.loadArcher = function(a, b, c) {
                h.resetCompletely(a, b), b.current_level = c.current_level, b.total_launchs = c.total_launchs, b.total_hits = c.total_hits, b.skill_points = c.skill_points, b.accuracy.trained_index = c.accuracy_index, b.strength.trained_index = c.strength_index, b.speed.trained_index = c.speed_index, b.hook.current_index = c.hook_index, b.sharpness.current_index = c.sharpness_index, b.xarrows.current_index = c.xarrows_index
            }, h.saveArcher = function(b) {
                var c = new a.SavedArcher;
                return c.current_level = b.current_level, c.total_launchs = b.total_launchs, c.total_hits = b.total_hits, c.skill_points = b.skill_points, c.accuracy_index = b.accuracy.trained_index, c.strength_index = b.strength.trained_index, c.speed_index = b.speed.trained_index, c.hook_index = b.hook.current_index, c.sharpness_index = b.sharpness.current_index, c.xarrows_index = b.xarrows.current_index, c
            }, h.getSkillCoeff = function(b) {
                var c = d.interpolate(b.trained.min, b.trained.max, b.trained_index / a.Skill.trained_max_index);
                return c = d.interpolate(.2, .7, c), null != b.local_boost_coeff && (c *= b.local_boost_coeff), c += b.local_temp_boost_add, null != b.global_boost_coeff && (c *= b.global_boost_coeff), c += b.global_temp_boost_add, d.clamp(c, 0, 2)
            }, h.shootArrowAtTarget = function(b, c, e, g, i) {
                if (c.state == a.ArcherState.Shooting || c.state == a.ArcherState.Loading) return !1;
                c.anim.current_frame == a.Archer.loading_anim_range.end ? c.relaunch = !0 : c.relaunch = !1;
                var j = h.getArrowLoadTime(c),
                    k = h.getSkillCoeff(c.strength),
                    l = h.getArrowSpeed(a.Archer.arrow_speed, k),
                    m = l + g,
                    n = d.rangeCoeff(l, a.Archer.arrow_speed.min, a.Archer.arrow_speed.max),
                    o = h.getSkillCoeff(c.accuracy),
                    p = d.interpolateClamped(a.Archer.headshot_coeff.min, a.Archer.headshot_coeff.max, o),
                    q = null;
                q = Math.random() < p ? d.getRandomPointInRectangle(i.head_hitbox.global_rect) : d.getRandomPointInRectangle(i.body_hitbox.global_rect);
                var r = c.damage_current,
                    s = a.Archer.damage_min,
                    t = a.Archer.damage_max;
                r.body = d.interpolate(s.body, t.body, n), r.head = d.interpolate(s.head, t.head, n), r.legs = d.interpolate(s.legs, t.legs, n), r.walking_penalty_coeff = d.interpolate(s.walking_penalty_coeff, t.walking_penalty_coeff, n);
                var u = c.sharpness.amounts[c.sharpness.current_index].amount;
                r.head += u, r.body += u, r.legs += u;
                var v = c.hook.amounts[c.hook.current_index].amount;
                r.walking_penalty_coeff *= v, r.attack_penalty_coeff = v, q.x -= j * g, q.x += b.foreground_container.x;
                var w = i.velocity,
                    x = f.subtract(a.PixiDo.convertPoint(c.container.position), q),
                    y = 10,
                    z = 412,
                    A = d.clamp(Math.abs(x.x), y, z),
                    B = d.rangeCoeff(A, y, z),
                    C = f.interpolate(c.global_launch_spot_min, c.global_launch_spot_max, B),
                    D = null;
                if (D = h.getProjectileVectorUsingApproximateQuadraticSolution(j, m, e, w, C, q), null == D) return !1;
                if (c.relaunch ? c.zombie_target != i && (i.targeted_by_defenders_count++, c.zombie_target.targeted_by_defenders_count--) : i.targeted_by_defenders_count++, D.x < 0 && (D.x = 0, D.y = m), !c.relaunch || c.zombie_target != i) {
                    var E = x.x + w.x * j,
                        F = d.clamp(Math.abs(E) / 800, 0, 1),
                        G = d.interpolate(0, Math.PI / 12, F);
                    G *= 1 - o, c.random_angle = d.getRandomBetween(-G, G)
                }
                return h.startProjectileLaunch(b, c, D), c.relaunch || (c.total_launchs += 1), c.zombie_target = i, !0
            }, h.startProjectileLaunch = function(c, d, e) {
                if (!d.relaunch) {
                    var g = Math.round(d.xarrows.amounts[d.xarrows.current_index].amount);
                    d.arrows = [];
                    for (var i = 0; i < g; i++) {
                        var j = a.GameDo.createArrow(c.garbage.arrow_sprites);
                        d.arrows.push(j), d.shooting_container.add(j)
                    }
                    a.PixiAnimationDo.gotoFrame(d.anim, 1)
                }
                var k = 0,
                    l = h.getProjectilePointAfterTravelingForSpecificDistance(new b, e, c.gravity, a.GameAssets.arrow.width * a.Archer.arrow_launch_anchor, 5, .01);
                k = f.angle(l.point) - f.angle(e), d.travel_to_anchor_time = l.time, e = h.travelVelocity(e, c.gravity, d.travel_to_anchor_time);
                var m = 0;
                d.launch_vectors = [];
                for (var n = 0, o = d.arrows; n < o.length; n++) {
                    var j = o[n];
                    d.launch_vectors.push(f.rotate(e, d.random_angle + a.Archer.arrow_angles[m])), m++
                }
                d.container_launch_rotation = f.angle(d.launch_vectors[0]), d.container_current_rotation = d.shooting_container.rotation, h.updateLoadingArrows(d)
            }, h.travel = function(a, c, d, e) {
                return new b(.5 * d.x * e * e + c.x * e + a.x, .5 * d.y * e * e + c.y * e + a.y)
            }, h.travelVelocity = function(a, c, d) {
                return new b(a.x + c.x * d, a.y + c.y * d)
            }, h.getProjectilePointAfterTravelingForSpecificDistance = function(a, d, e, g, i, j) {
                void 0 === i && (i = 1), void 0 === j && (j = .01);
                for (var k = 0, l = 0, m = !0, n = new b; i > j;)
                    if (n = h.travel(a, d, e, k), l = f.len(f.subtract(n, a)), l < g) m || (m = !0, i *= .5), k += i;
                    else {
                        if (!(l > g)) return new c(k, n);
                        m && (m = !1, i *= .5), k -= i
                    }
                return new c(k, n)
            }, h.canArcherReachZombie = function(b, c, d) {
                if (null == d) return !1;
                var e = h.getMaximumShootingDistance(h.getArrowSpeed(a.Archer.arrow_speed, h.getSkillCoeff(c.strength)), b.gravity, c.global_launch_spot_max, b.ground_level),
                    f = e.time + h.getArrowLoadTime(c),
                    g = d.container.position.x + b.foreground_container.position.x - c.container.position.x,
                    i = g < b.js_info.min_game_width - c.container.position.x;
                return !!i && (g += d.velocity.x * f, g < e.point.x)
            }, h.pickZombieFromSelection = function(a, b, c, d) {
                if (c.sorted_by_position_zombies.length > 0) {
                    for (var e = 0, f = c.sorted_by_position_zombies; e < f.length; e++) {
                        var g = f[e];
                        if (g.zombie == d) return g.targeted_by = b, g.zombie
                    }
                    for (var i = 0, j = c.sorted_by_position_zombies; i < j.length; i++) {
                        var g = j[i];
                        if (null == g.targeted_by && null != g.zombie && h.canArcherReachZombie(a, b, g.zombie)) return g.targeted_by = b, g.zombie
                    }
                    for (var k = 0, l = c.sorted_by_position_zombies; k < l.length; k++) {
                        var g = l[k];
                        if (!h.canArcherReachZombie(a, b, g.zombie)) return null;
                        if (null != g.zombie) return g.zombie
                    }
                }
                return null
            }, h.selectTarget = function(b, c, e) {
                for (var f = new Array, g = h.getMaximumShootingDistance(h.getArrowSpeed(a.Archer.arrow_speed, h.getSkillCoeff(e.strength)), b.gravity, e.global_launch_spot_max, b.ground_level), i = g.time + h.getArrowLoadTime(e), j = 0, k = b.zombies; j < k.length; j++) {
                    var l = k[j],
                        m = l.container.position.x + b.foreground_container.position.x - e.container.position.x,
                        n = m < b.js_info.min_game_width - e.container.position.x;
                    if (n) {
                        var o = d.rangeCoeffClamped(l.targeted_by_defenders_count, 0, l.lethal_targeted_count);
                        if (Math.random() > o && (m += l.velocity.x * i, m < g.point.x)) {
                            for (var p = 0, q = !1, r = 0, s = f; r < s.length; r++) {
                                var t = s[r];
                                if (m < t.distance) {
                                    f.splice(p, 0, new a.ZombieWithDistance(l, m)), q = !0;
                                    break
                                }
                                p++
                            }
                            q || f.push(new a.ZombieWithDistance(l, m))
                        }
                    }
                }
                for (var u = !1, v = 0, w = f; v < w.length; v++) {
                    var x = w[v],
                        y = x.zombie;
                    if (y.targeted_by_defenders_count < y.lethal_targeted_count) {
                        var m = y.container.position.x + b.foreground_container.position.x,
                            z = y.container.position.x + b.foreground_container.position.x;
                        z < c.zombie_stop_threshold_x && (u = !0)
                    }
                }
                if (u)
                    for (var p = 0; p < f.length;) {
                        var A = f[p].zombie,
                            m = A.container.position.x + b.foreground_container.position.x,
                            z = A.container.position.x + b.foreground_container.position.x;
                        z > c.zombie_stop_threshold_x && f.splice(p, 1), p++
                    }
                var B = null;
                if (f.length > 0) {
                    for (var C = Math.random(), D = d.minInt(a.Archer.zombie_choice_probabilities.length, f.length), E = -1, F = 0; F < D; F++)
                        if (C > a.Archer.zombie_choice_probabilities[F]) {
                            E = F;
                            break
                        }
                    E == -1 && (E = d.getRandomBetweenInt(0, f.length - 1), E = d.clampInt(E, 0, 5)), B = f[E].zombie
                }
                return B
            }, h.getShootingCoeff = function(b) {
                return d.interpolate(a.Archer.shooting_coeff.min, a.Archer.shooting_coeff.max, h.getSkillCoeff(b.speed))
            }, h.getArrowLoadTime = function(b) {
                return (a.PixiAnimationDo.getTotalFrames(b.anim.source) - b.anim.current_frame) / h.getShootingCoeff(b)
            }, h.getArrowSpeed = function(a, b) {
                return d.interpolate(a.min, a.max, b)
            }, h.getMaximumShootingDistance = function(a, b, c, d) {
                return e.getMaximumProjectileTravelDistance(a, b, c, d)
            }, h.getProjectileVectorUsingSearch = function(c, h, i, j, k, l) {
                function m(a, b, c, d, e, f, g) {
                    var h = .5 * b.x * a * a + c * a + f.x,
                        i = .5 * b.y * a * a + d * a + f.y,
                        j = e.x * a + g.x,
                        k = e.y * a + g.y,
                        l = j - h,
                        m = k - i;
                    return Math.sqrt(l * l + m * m)
                }

                function n(b, c, f, g, h, i) {
                    var j = e.getQuadraticSolutions(.5 * b.y, f - g.y, h.y - i.y);
                    if (null == j) return null;
                    for (var k = -1, l = j[0], n = 0, o = j; n < o.length; n++) {
                        var p = o[n];
                        p > 0 && (l < 0 ? l = p : p < l && (l = p))
                    }
                    var q = c - f * f;
                    if (q >= 0) {
                        var r = Math.sqrt(q),
                            s = m(l, b, r, f, g, h, i),
                            t = m(l, b, -r, f, g, h, i),
                            u = d.min(s, t);
                        k == -1 ? k = u : u < k && (k = u)
                    }
                    return new a.DistanceTime(l, k)
                }

                function o(b, c, d, e, f, g, h, i) {
                    void 0 === i && (i = .7);
                    for (var j = 100, k = g, l = h, m = l - k, o = null, p = 0, q = 0; q < j; q++) {
                        var r = n(b, c, k, e, d, f),
                            s = n(b, c, l, e, d, f);
                        if (p = 0, null != r && null != s ? p = r.distance < s.distance ? 1 : 2 : null != r ? p = 1 : null != s && (p = 2), m *= i, 0 == p) return null;
                        if (1 == p ? (o = r, k -= m, k < g && (k = g), l = k + m) : (o = s, l += m, l > h && (l = h), k = l - m), o.distance < .1) break
                    }
                    return 1 == p ? new a.SizeDistanceTime(o.time, k, o.distance) : new a.SizeDistanceTime(o.time, l, o.distance)
                }
                var p = i,
                    q = h * h,
                    r = k,
                    s = j,
                    t = f.add(l, g.multiply(j, c)),
                    u = o(p, q, r, s, t, -h, 0),
                    v = o(p, q, r, s, t, 0, h);
                u.distance > .1 && (u = null), v.distance > .1 && (v = null);
                var w = null;
                if (null != u && null != v ? w = u.time < v.time ? u : v : null != u ? w = u : null != v && (w = v), null != w) {
                    var x = Math.sqrt(q - w.size * w.size),
                        y = w.size,
                        z = m(w.time, p, x, y, s, r, t),
                        A = m(w.time, p, -x, y, s, r, t),
                        B = void 0;
                    return B = z < A ? new b(x, y) : new b((-x), y)
                }
                return null
            }, h.getProjectileVectorUsingApproximateQuadraticSolution = function(a, b, c, d, h, i) {
                var j = f.multiply(d, a);
                g.add(j, i);
                var k = e.getTimeToReachTarget(b, c, h, j, !1);
                if (k == -1) return null;
                var l = f.multiply(d, k),
                    m = g.add(j, l),
                    n = e.getVectorToReachTarget(b, c, h, m, !1);
                return n
            }, h.updateLoadingArrows = function(b) {
                var c = Math.round(1 * a.PixiAnimationDo.getTotalFrames(b.anim.source) / 3),
                    e = b.anim.current_frame / c;
                e = d.clamp(e, 0, 1);
                for (var f = -Math.PI, g = 0, h = 0, i = 0, j = b.arrows; i < j.length; i++) {
                    var k = j[i];
                    if (null == k);
                    k.rotation = d.interpolate(f + a.Archer.arrow_angles[h], g + a.Archer.arrow_angles[h], e);
                    var l = b.right_forearm;
                    k.position.set(l.position.x + 17.181, l.position.y - 5.7845), h++
                }
                b.relaunch && (e = (b.anim.current_frame - a.Archer.shooting_anim_range.start) / (a.Archer.shooting_anim_range.end - a.Archer.shooting_anim_range.start), e = d.clamp(e, 0, 1)), b.shooting_container.rotation = d.interpolate(b.container_current_rotation, b.container_launch_rotation, e), b.head.rotation = b.shooting_container.rotation / 1.5
            }, h.updateStandardRotation = function(a) {
                if (a.total_resting_time > 60) {
                    var b = Math.PI / 12;
                    a.shooting_container.rotation += (b - a.shooting_container.rotation) / 50, a.head.rotation = a.shooting_container.rotation / 1.5
                }
            }, h.tansferArrowsFromArcherToGlobal = function(c, d) {
                for (var e = 0, f = c.arrows; e < f.length; e++) {
                    var g = f[e];
                    g.anchor.x = a.Archer.arrow_launch_anchor, g.position.x += Math.cos(g.rotation) * g.anchor.x * g.width, g.position.y += Math.sin(g.rotation) * g.anchor.x * g.width;
                    var h = g.position.x,
                        i = g.position.y,
                        j = Math.sqrt(h * h + i * i),
                        k = Math.atan2(i, h),
                        l = c.shooting_container.rotation,
                        m = Math.cos(k + l),
                        n = Math.sin(k + l),
                        o = m * j,
                        p = n * j,
                        q = new b(-d.foreground_container.position.x + c.container.x + c.shooting_container.position.x + o, -d.foreground_container.position.y + c.container.y + c.shooting_container.position.y + p),
                        r = c.shooting_container.rotation;
                    g.parent.remove(g), d.particle_container.add(g), g.position.x = q.x, g.position.y = q.y, g.rotation = r + g.rotation
                }
                var s = c.arrows.slice(0);
                return c.arrows = [], s
            }, h
        }();
    a.ArcherDo = h
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = Phaser.BitmapText,
        c = function() {
            function c() {}
            return c.createUpArrowButton = function() {
                var b = a.PixiDo.createSprite(a.GameAssets.button_train, .5, .5, 0, 0),
                    c = a.PixiDo.createSprite(a.GameAssets.button_train_shadow, .5, .5, 5, 5),
                    d = a.GameButtonDo.createBasicButton(b, c, null);
                return d
            }, c.createUpButton = function() {
                var a = c.createUpArrowButton();
                return a.container.position.set(343, 41), a
            }, c.createTrainSkill = function(b, d) {
                var e = new a.TrainSkillMenu;
                e.container = a.PixiDo.createGroup(), e.skill_sprite = a.PixiDo.createSprite(d, 0, 1, 35, 40), e.container.add(e.skill_sprite), e.train_bars = new Array;
                for (var f = 0; f < a.Skill.trained_max_index; f++) {
                    var g = a.PixiDo.createSprite(a.GameAssets.skill_bar_empty);
                    e.train_bars.push(g), g.position.set(32 + 30 * (a.Skill.trained_max_index - 1 - f), 44), e.container.add(g)
                }
                return e.train_bars.reverse(), e.button = c.createUpButton(), e.container.add(e.button.container), e.container.position.set(15, 84 + 91 * b), e
            }, c.createUpgrade = function(d, e) {
                var f = new a.UpgradeMenu;
                f.tiers = e, f.container = a.PixiDo.createGroup(), f.money_icon = a.PixiDo.createSprite(a.GameAssets.skill_money_icon, .5, .5, 27, 45), f.container.add(f.money_icon), f.cost_text = new b(a.PhaserObjects.game, 0, 0, "accidental_presidency_42_light", e[0].cost + "", 42, "left"), f.cost_text.position.set(44, 28), f.container.add(f.cost_text);
                var g = 5;
                return f.name_text = new b(a.PhaserObjects.game, 0, 0, "accidental_presidency_42_light", e[0].name + "", 35, "left"), f.name_text.position.set(a.UpgradeMenu.text_offset_x - f.name_text.width / 2, 15 - g), f.effect_text = new b(a.PhaserObjects.game, 0, 0, "accidental_presidency_42_light", e[0].effect + "", 35, "left"), f.effect_text.position.set(a.UpgradeMenu.text_offset_x - f.effect_text.width / 2, 40 + g), f.container.add(f.name_text), f.container.add(f.effect_text), f.button = c.createUpButton(), f.container.add(f.button.container), f.container.position.set(15, 84 + 91 * d), f
            }, c.create = function(d, e, f) {
                var g = new a.ArcherMenu;
                g.background = a.PixiDo.createSprite(e, 0, 0, 0, 0);
                var h = a.PixiDo.createSprite(a.GameAssets.button_close, .5, .5, 0, 0);
                if (g.close_button = a.GameButtonDo.createBasicButton(h, null, null, function() {
                    c.close(g, f)
                }), g.close_button.container.position.set(g.background.width - 10, 10), g.type = d, g.container = a.PixiDo.createGroup(), g.container.add(g.background), d == a.ArcherMenuType.Skills) g.title = new b(a.PhaserObjects.game, 0, 0, "accidental_presidency_42_light", "Train Skills", 42, "center"), g.speed = c.createTrainSkill(0, a.GameAssets.skill_speed), g.strength = c.createTrainSkill(1, a.GameAssets.skill_strength), g.accuracy = c.createTrainSkill(2, a.GameAssets.skill_accuracy), g.container.add(g.speed.container), g.container.add(g.strength.container), g.container.add(g.accuracy.container), g.close_button.enabled = !1, g.close_button.container.visible = !1;
                else if (d == a.ArcherMenuType.Upgrades) g.title = new b(a.PhaserObjects.game, 0, 0, "accidental_presidency_42_light", "Upgrades", 42, "center"), g.hook = c.createUpgrade(0, [new a.UpgradeTier(a.Archer.hook_settings[1].price, "Hook Tier 1", "slow"), new a.UpgradeTier(a.Archer.hook_settings[2].price, "Hook Tier 2", "slow"), new a.UpgradeTier(a.Archer.hook_settings[3].price, "Hook Tier 3", "slow")]), g.sharpness = c.createUpgrade(1, [new a.UpgradeTier(a.Archer.sharpness_settings[1].price, "Sharpness Tier 1", "damage"), new a.UpgradeTier(a.Archer.sharpness_settings[2].price, "Sharpness Tier 2", "damage"), new a.UpgradeTier(a.Archer.sharpness_settings[3].price, "Sharpness Tier 3", "damage")]), g.xarrows = c.createUpgrade(2, [new a.UpgradeTier(a.Archer.xarrows_settings[1].price, "Double", "Arrows")]), g.container.add(g.hook.container), g.container.add(g.sharpness.container), g.container.add(g.xarrows.container);
                else if (d == a.ArcherMenuType.Buy) {
                    var i = new a.ArcherBuyMenu;
                    i.container = a.PixiDo.createGroup(), i.money_icon = a.PixiDo.createSprite(a.GameAssets.skill_money_icon, .5, .5, 27, 45), i.container.add(i.money_icon), i.cost_text = new b(a.PhaserObjects.game, 0, 0, "accidental_presidency_42_light", "100", 42, "left"), i.cost_text.position.set(44, 28), i.container.add(i.cost_text), i.button = c.createUpButton(), i.button.container.position.set(200, 41), i.container.add(i.button.container), i.container.position.set(15, 84), g.buy_menu = i, g.container.add(g.buy_menu.container)
                }
                return null != g.title && (g.title.position.set(a.ArcherMenu.title_offset_x - g.title.width / 2, a.ArcherMenu.title_offset_y - g.title.height / 2), g.container.add(g.title)), g.container.add(g.close_button.container), g
            }, c.fillBars = function(b, c) {
                for (var d = 0; d < c.trained_index; d++) b[d].texture != a.GameAssets.skill_bar_trained && (b[d].texture = a.GameAssets.skill_bar_trained);
                for (var d = c.trained_index; d < b.length; d++) b[d].texture != a.GameAssets.skill_bar_empty && (b[d].texture = a.GameAssets.skill_bar_empty)
            }, c.updateAfford = function(b, c, d, e) {
                var f = !1;
                b.title.text = "Train Skills (" + e.skill_points + " points)", b.title.position.x = a.ArcherMenu.title_offset_x - b.title.width / 2, d.trained_index >= c.train_bars.length ? (c.button.container.visible = !1, a.ButtonDo.setState(c.button, c.button.default_state), f = !1) : (c.button.container.visible = !0, f = e.skill_points > 0), f ? a.GameButtonDo.activate(c.button) : a.GameButtonDo.deactivate(c.button)
            }, c.setupSkill = function(b, d, e, f, g) {
                c.updateAfford(d, f, g, e), c.fillBars(f.train_bars, g), f.button.down_callback = function() {
                    e.skill_points--, g.trained_index++, c.updateAfford(d, d.speed, e.speed, e), c.updateAfford(d, d.strength, e.strength, e), c.updateAfford(d, d.accuracy, e.accuracy, e), c.fillBars(f.train_bars, g), 0 == e.skill_points && c.close(d, b, 3), a.SoundDo.playSound(a.GameAssets.sound_unlock), a.PhaserObjects.game.analytics.game.addEvent(new GA.Events.Resource("Sink:SkillPoints:Purchase:" + g.name, 1))
                }
            }, c.updateUpgradeAfford = function(b, c, d, e) {
                void 0 === e && (e = "");
                var f, g = !1;
                c.current_index >= c.amounts.length - 1 ? (b.button.container.visible = !1, b.money_icon.visible = !1, b.cost_text.visible = !1, a.ButtonDo.setState(b.button, b.button.default_state), f = b.tiers[b.tiers.length - 1], g = !1) : (b.button.container.visible = !0, b.money_icon.visible = !0, b.cost_text.visible = !0, f = b.tiers[c.current_index], b.cost_text.text = f.cost + "", g = b.tiers[c.current_index].cost <= d.money), b.name_text.text = f.name, b.effect_text.text = e + f.effect, b.name_text.position.x = a.UpgradeMenu.text_offset_x - b.name_text.width / 2, b.effect_text.position.x = a.UpgradeMenu.text_offset_x - b.effect_text.width / 2, b.effect_text.text = e + f.effect, g ? a.GameButtonDo.activate(b.button) : a.GameButtonDo.deactivate(b.button)
            }, c.updateAllUpgradeAffords = function(a, b, d) {
                b.hook.current_index + 1 < b.hook.amounts.length ? c.updateUpgradeAfford(a.hook, b.hook, d, "+" + Math.round(100 * (1 - b.hook.amounts[b.hook.current_index + 1].amount)) + "% ") : c.updateUpgradeAfford(a.hook, b.hook, d, Math.round(100 * (1 - b.hook.amounts[b.hook.current_index].amount)) + "% "), b.sharpness.current_index + 1 < b.sharpness.amounts.length ? c.updateUpgradeAfford(a.sharpness, b.sharpness, d, "+" + Math.round(b.sharpness.amounts[b.sharpness.current_index + 1].amount) + "pt ") : c.updateUpgradeAfford(a.sharpness, b.sharpness, d, Math.round(b.sharpness.amounts[b.sharpness.current_index].amount) + "pt "), c.updateUpgradeAfford(a.xarrows, b.xarrows, d, "")
            }, c.setupUpgrade = function(b, d, e, f, g) {
                e.button.down_callback = function() {
                    var h = e.tiers[f.current_index].cost;
                    g.money -= h, f.current_index++, c.updateAllUpgradeAffords(b, d, g), a.SoundDo.playSound(a.GameAssets.sound_coins), a.PhaserObjects.game.analytics.game.addEvent(new GA.Events.Resource("Sink:Money:Purchase:" + f.name, h))
                }
            }, c.open = function(b, d, e, f, g, h, i) {
                if (void 0 === g && (g = null), void 0 === h && (h = null), void 0 === i && (i = null), null != f.container.parent && f.container.parent.remove(f.container), null != f.current_platform && (f.current_platform.selected_sprite.visible = !1), f.container.position.set(328, 150), f.current_archer = g, null == g ? f.current_platform = i : f.current_platform = g.platform, d.add(f.container), f.close_button.enabled = !0, a.ButtonDo.resetButton(f.close_button), a.ButtonDo.updateBounds(f.close_button, b.pointer), f.type == a.ArcherMenuType.Skills) a.ButtonDo.updateBounds(f.speed.button, b.pointer), a.ButtonDo.updateBounds(f.strength.button, b.pointer), a.ButtonDo.updateBounds(f.accuracy.button, b.pointer), c.setupSkill(e, f, g, f.speed, g.speed), c.setupSkill(e, f, g, f.accuracy, g.accuracy), c.setupSkill(e, f, g, f.strength, g.strength);
                else if (f.type == a.ArcherMenuType.Upgrades) c.setupUpgrade(f, g, f.hook, g.hook, h), c.setupUpgrade(f, g, f.sharpness, g.sharpness, h), c.setupUpgrade(f, g, f.xarrows, g.xarrows, h), c.updateAllUpgradeAffords(f, g, h);
                else if (f.type == a.ArcherMenuType.Buy) {
                    var j = f.buy_menu,
                        k = a.GameDo.getArcherPrice(b, f.current_platform);
                    j.cost_text.text = k + "", f.container.position.y = 250, i.platform.scale.x > 0, a.ButtonDo.updateBounds(j.button, b.pointer), h.money >= k ? (a.GameButtonDo.activate(j.button), j.button.down_callback = function() {
                        h.money -= k, a.GameButtonDo.deactivate(j.button), a.ArcherDo.spawn(b, i), c.close(f, e, .5), a.SoundDo.playSound(a.GameAssets.sound_coins), a.PhaserObjects.game.analytics.game.addEvent(new GA.Events.Resource("Sink:Money:Purchase:Archer", k))
                    }) : a.GameButtonDo.deactivate(j.button)
                }
                f.current_platform.selected_sprite.visible = !0, f.type != a.ArcherMenuType.Skills && (f.current_platform.selected_sprite.scale.x = a.MachinePlatform.selected_sprite_scale, f.current_platform.selected_sprite.scale.y = a.MachinePlatform.selected_sprite_scale), a.ButtonDo.updateBounds(f.close_button, b.pointer), a.GameTransitionDo.launchOpenMenu(e, f.container, function() {
                    a.ButtonDo.updateBounds(f.close_button, b.pointer), f.type == a.ArcherMenuType.Skills ? (a.ButtonDo.updateBounds(f.speed.button, b.pointer), a.ButtonDo.updateBounds(f.strength.button, b.pointer), a.ButtonDo.updateBounds(f.accuracy.button, b.pointer)) : f.type == a.ArcherMenuType.Buy && a.ButtonDo.updateBounds(f.buy_menu.button, b.pointer)
                })
            }, c.close = function(b, d, e, f) {
                if (void 0 === e && (e = 0), void 0 === f && (f = !1), c.isOpened(b)) {
                    b.close_button.enabled = !1;
                    var g = !0;
                    null != b.current_archer && null != b.current_archer.level_up_transition && (0 == b.current_archer.skill_points ? (b.current_archer.level_up_transition.container.parent.remove(b.current_archer.level_up_transition.container), b.current_archer.level_up_transition = null) : g = !1), b.current_platform.selected_sprite.visible = !g, f ? b.container.alpha = 0 : a.GameTransitionDo.launchMenuClose(d, b.container, e)
                }
            }, c.isOpened = function(a) {
                return null != a.container.parent
            }, c.addToBuffer = function(b, c, d) {
                b.push(c.close_button), c.type == a.ArcherMenuType.Skills ? (b.push(c.speed.button), b.push(c.strength.button), b.push(c.accuracy.button)) : c.type == a.ArcherMenuType.Upgrades ? (b.push(c.hook.button), b.push(c.sharpness.button), b.push(c.xarrows.button)) : c.type == a.ArcherMenuType.Buy && b.push(c.buy_menu.button)
            }, c
        }();
    a.ArcherMenuDo = c
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.MinMax,
        c = (bikas.global.Rectangle, bikas.global.Size),
        d = (bikas.global.GlobalFunc, bikas.global.GlobalProc, bikas.javascript.JsDebug),
        e = Phaser.Graphics,
        f = function() {
            function f() {}
            return f.createDebugMenu = function(e, g) {
                function h(b, c) {
                    for (var d = 0; d < b.power_unlocks.king.length; d++) b.power_unlocks.king[d] = a.UnlockType.None;
                    for (var d = 0; d < b.power_unlocks.donkey.length; d++) b.power_unlocks.donkey[d] = a.UnlockType.None;
                    c >= 1 && (b.power_unlocks.king[0] = a.UnlockType.Middle, b.power_unlocks.donkey[0] = a.UnlockType.Middle), c >= 2 && (b.power_unlocks.king[1] = a.UnlockType.Up), c >= 3 && (b.power_unlocks.donkey[1] = a.UnlockType.Middle), c >= 4 && (b.power_unlocks.king[2] = a.UnlockType.Middle), c >= 5 && (b.power_unlocks.donkey[2] = a.UnlockType.Middle), c >= 6 && (b.power_unlocks.king[3] = a.UnlockType.Middle), c >= 7 && (b.power_unlocks.donkey[3] = a.UnlockType.Up), c >= 8 && (b.power_unlocks.king[4] = a.UnlockType.Up), a.GameDo.refreshPowerUnlocks(b)
                }

                function i(b, c) {
                    function d(b, c, d, e, f, g, h, i, j, k) {
                        var l = a.ArcherDo.spawn(b, c);
                        return l.hook.current_index = d, l.sharpness.current_index = e, l.xarrows.current_index = f, l.speed.trained_index = g, l.strength.trained_index = h, l.accuracy.trained_index = i, l.current_level = j, l.total_hits = k, l
                    }
                    a.ArcherDo.removeAllArchers(b);
                    var e = b.machine;
                    if (0 == c) {
                        var f = d(b, e.right_bottom, 0, 0, 0, 0, 0, 0, 0, 0);
                        a.GameDo.setCustomArcherLevelByCoeff(f, a.Archer.init_archer_1st_level_coeff)
                    }
                    h(b, c), b.wallet.money = 0, a.GameDo.gotoLevel(b, c)
                }

                function j(b) {
                    null == b.archer && a.ArcherDo.spawn(e, b), a.GameDo.setCustomArcherLevelByCoeff(b.archer, .95)
                }

                function k(a, b) {
                    if (b)
                        for (var c = 0, d = 0, e = a.level_descriptions.levels; d < e.length; d++) {
                            e[d];
                            c++
                        }
                    for (var f = 0, g = 0, h = a.machine.all_platforms; g < h.length; g++) {
                        var i = h[g];
                        i.archer;
                        f++
                    }
                }

                function l(b, c) {
                    if (!(c >= b.level_descriptions.levels.length)) {
                        h(b, c);
                        var d = "medieval_defense_z_script_level_" + c;
                        a.GameSerializerDo.saveToStorage(b.serial_data, a.GameDo.save(b, a.SavedState.LevelStart), d)
                    }
                }
                var m = e.machine,
                    n = e.pointer,
                    o = e.debug_element;
                d.addText(o, "Debug", !1, !0);
                var p = new a.ScriptData,
                    q = a.ScriptDo.createDefaultProgression(),
                    r = new Array;
                e.machine.current_max_speed = 0, d.addFieldWatch(o, g, "window_scale"), d.addFieldWatch(o, g, "last_delta"), d.addFieldWatch(o, e, "game_update_time"), d.addFieldWatch(o, g, "render_time"), d.addFieldWatch(o, g, "total_update_time"), d.addFieldWatch(o, e, "current_level_index"), d.addButton(o, "0.02x", function() {
                    e.delta_update_coeff = .02
                }), d.addButton(o, "0.1x", function() {
                    e.delta_update_coeff = .1
                }), d.addButton(o, "0.5x", function() {
                    e.delta_update_coeff = .5
                }), d.addButton(o, "1x", function() {
                    e.delta_update_coeff = 1
                }), d.addButton(o, "2x", function() {
                    e.delta_update_coeff = 2
                }), d.addButton(o, "5x", function() {
                    e.delta_update_coeff = 5
                }), d.addButton(o, "10x", function() {
                    e.delta_update_coeff = 10
                }), d.addButton(o, "1382x768", function() {
                    g.max_game_width = 1382, g.max_game_height = 768, g.force_size = null, a.InitDo.scaleAndCenter(e.game_container, g, n)
                }), d.addButton(o, "1024x768", function() {
                    g.max_game_width = 1024, g.max_game_height = 768, g.force_size = null, a.InitDo.scaleAndCenter(e.game_container, g, n)
                }), d.addButton(o, "1280x720 (no scale)", function() {
                    g.force_size = new c(1280, 720), a.InitDo.scaleAndCenter(e.game_container, g, n)
                }), d.addButton(o, "640x360 (no scale)", function() {
                    g.force_size = new c(640, 360), a.InitDo.scaleAndCenter(e.game_container, g, n)
                }), d.addButton(o, "reload game", function() {
                    a.GameDo.load(e, e.init_saved_game)
                }), d.addButton(o, "restart level", function() {
                    a.GameDo.gotoLevel(e, e.current_level_index)
                }), d.addButton(o, "clear level", function() {
                    a.LevelDo.clear(e)
                }), d.addText(o, "Game Control", !1, !0), d.addButton(o, "Save to Storage", function() {
                    a.GameSerializerDo.saveToStorage(e.serial_data, a.GameDo.save(e, a.SavedState.LevelStart))
                }), d.addButton(o, "Load from Storage", function() {
                    var b = a.GameSerializerDo.loadFromStorage(e.serial_data);
                    a.GameDo.load(e, b)
                }), d.addButton(o, "Clear Storage", function() {
                    a.GameSerializerDo.clearStorage()
                }), d.addButton(o, "Start Menu", function() {
                    a.GameDo.gotoStartMenu(e)
                }), d.addButton(o, "Tutorial", function() {
                    a.GameDo.gotoStory(e)
                }), d.addButton(o, "Level End", function() {
                    f.gotoLevelEnd(e)
                }), d.addButton(o, "Kill all zombies", function() {
                    f.killAllZombies(e)
                }), d.addButton(o, "Health = 1000", function() {
                    e.donkey.current_health = 1e3
                }), d.addButton(o, "Die", function() {
                    e.donkey.current_health = 0
                }), d.addText(o, "Levels:");
                for (var s = function(b) {
                    d.addButton(o, "" + b, function() {
                        a.GameDo.gotoLevel(e, b)
                    })
                }, t = 0; t < e.level_descriptions.levels.length; t++) s(t);
                var u = 1,
                    v = (e.level_descriptions.levels[u], e.temp);
                d.addText(o, "Buttons", !1, !0), d.addFieldEdit(o, e.temp, "zombie_spawn_distance"), d.addButton(o, "spawn all archers", function() {
                    for (var b = 0, c = e.machine.all_platforms; b < c.length; b++) {
                        var d = c[b];
                        null == d.archer && a.ArcherDo.spawn(e, d)
                    }
                }), d.addButton(o, "spawn and almost level-up 2 archers", function() {
                    j(e.machine.right_center), j(e.machine.right_bottom)
                }), d.addButton(o, "spawn regular zombie", function() {
                    a.ZombieDo.spawn(e, a.ZombieType.Regular, v.zombie_spawn_distance - e.foreground_container.position.x)
                }), d.addButton(o, "spawn fat zombie", function() {
                    a.ZombieDo.spawn(e, a.ZombieType.Fat, v.zombie_spawn_distance - e.foreground_container.position.x)
                }), d.addButton(o, "spawn limp zombie", function() {
                    a.ZombieDo.spawn(e, a.ZombieType.Limp, v.zombie_spawn_distance - e.foreground_container.position.x)
                }), d.addButton(o, "spawn mega zombie", function() {
                    a.ZombieDo.spawn(e, a.ZombieType.Mega, v.zombie_spawn_distance - e.foreground_container.position.x)
                }), d.addButton(o, "spawn frozen limp zombie", function() {
                    var b = a.ZombieDo.spawn(e, a.ZombieType.Limp, 500 - e.foreground_container.position.x);
                    b.state = a.ZombieState.Frozen, b.velocity.x = 0
                }), d.addButton(o, "kill zombie", function() {
                    e.zombies.length > 0 && (e.zombies[e.zombies.length - 1].received_arrow_damage = !0, e.zombies[e.zombies.length - 1].health = 0)
                }), d.addButton(o, "stop zombie and machine", function() {
                    e.zombies.length > 0 && (e.zombies[e.zombies.length - 1].state = a.ZombieState.Frozen, e.zombies[e.zombies.length - 1].velocity.x = 0), m.current_max_speed = 0, m.current_speed_goal = 0, m.current_speed = 0
                }), d.addButton(o, "spawn 'nice' zombie pack", function() {
                    for (var b = 0; b < 10; b++) a.ZombieDo.spawn(e, a.ZombieType.Regular, e.temp.zombie_spawn_distance - e.foreground_container.position.x, !0);
                    for (var b = 0; b < 3; b++) a.ZombieDo.spawn(e, a.ZombieType.Limp, e.temp.zombie_spawn_distance - e.foreground_container.position.x, !0);
                    for (var b = 0; b < 1; b++) a.ZombieDo.spawn(e, a.ZombieType.Fat, e.temp.zombie_spawn_distance - e.foreground_container.position.x, !0)
                }), d.addButton(o, "spawn baseline frozen zombie pack", function() {
                    a.ScriptDo.spawnBaselineStaticZombies(e)
                }), d.addText(o, "Scripts", !1, !0);
                var w = (e.temp, a.ScriptMode.ZombieCountAdjustment),
                    x = 0;
                if (w == a.ScriptMode.DataGathering) e.machine.current_max_speed = 0, e.machine.current_speed_goal = 0, e.machine.max_speed = 0, e.machine.current_speed = 0, e.temp.zombie_spawn_distance = 700, e.donkey.damage_per_frame = 0, d.addButton(o, "Trace Prices", function() {
                    a.ScriptDo.tracePrices(p, e)
                }), d.addButton(o, "Push Script: right_center", function() {
                    a.ScriptDo.pushRightCenter(r, p, e)
                }), d.addButton(o, "Push Script: right_center and right_top", function() {
                    a.ScriptDo.pushRightCenterAndTop(r, p, e)
                }), d.addButton(o, "Push Script: right_center money earned", function() {
                    a.ScriptDo.pushRightCenterMoneyEarned(r, p, e)
                }), d.addButton(o, "Push Script: dynamic base for all min archers", function() {
                    a.ScriptDo.pushArcherPositionKillTime(r, p, e, a.BaseType.DynamicKills, 0)
                }), d.addButton(o, "Push Script: upgrades", function() {
                    a.ScriptDo.pushUpgradeKillTime(r, p, e)
                }), d.addButton(o, "Push Script: max skills", function() {
                    a.ScriptDo.pushSkillMaxKillTime(r, p, e)
                }), d.addButton(o, "Push Scripts: all data gathering", function() {
                    a.ScriptDo.pushRightCenter(r, p, e), a.ScriptDo.pushRightCenterAndTop(r, p, e), a.ScriptDo.pushArcherPositionKillTime(r, p, e, a.BaseType.DynamicKills, 0), a.ScriptDo.pushUpgradeKillTime(r, p, e), a.ScriptDo.pushSkillMaxKillTime(r, p, e), a.ScriptDo.pushRightCenterMoneyEarned(r, p, e), r.push(new a.Script(function() {})), r.push(new a.Script(function() {
                        a.ScriptDo.tracePrices(p, e)
                    }))
                });
                else if (w == a.ScriptMode.ZombieCountAdjustment) {
                    d.addButton(o, "goto level: " + x + " with progress", function() {
                        i(e, x)
                    }), d.addButton(o, "Push Script: gameplay bot - adjust zombie count (current level)", function() {
                        r.push(new a.Script(function() {
                            q.current_index = 0, e.level_end_enabled = !1
                        })), a.ScriptDo.pushGameplayBot(r, p, a.GameplayBotType.AdjustZombieCount, q, e, e.current_level_index), r.push(new a.Script(function() {
                            l(e, e.current_level_index + 1), k(e, !0), e.level_end_enabled = !0
                        }))
                    });
                    var y = new b(1, 9);
                    d.addButton(o, "Push Script: gameplay bot (+save each level) - adjust zombie count (" + y.min + "-" + y.max + " levels)", function() {
                        r.push(new a.Script(function() {
                            i(e, 0), q.current_index = 0, e.level_end_enabled = !1
                        }));
                        for (var b = Math.round(y.min), c = function(b) {
                            r.push(new a.Script(function() {
                                l(e, b)
                            })), a.ScriptDo.pushGameplayBot(r, p, a.GameplayBotType.PlayOnce, q, e, b), r.push(new a.Script(function() {
                                k(e, !1)
                            }))
                        }, d = 0; d < b; d++) c(d);
                        b = Math.round(y.min);
                        for (var f = Math.round(y.max) + 1, g = function(b) {
                            r.push(new a.Script(function() {
                                l(e, b)
                            })), a.ScriptDo.pushGameplayBot(r, p, a.GameplayBotType.AdjustZombieCount, q, e, b), r.push(new a.Script(function() {
                                k(e, !0)
                            }))
                        }, h = b; h < f; h++) g(h);
                        r.push(new a.Script(function() {
                            k(e, !0), e.level_end_enabled = !0
                        }))
                    });
                    var z = new Array,
                        A = new Array;
                    d.addButton(o, "Push Script: play all levels once", function() {
                        r.push(new a.Script(function() {
                            i(e, 0), q.current_index = 0, e.level_end_enabled = !1
                        }));
                        for (var b = function(b) {
                            r.push(new a.Script(function() {
                                z[b] = e.total_elapsed_time, h(e, b)
                            })), a.ScriptDo.pushGameplayBot(r, p, a.GameplayBotType.PlayOnce, q, e, b, 1), r.push(new a.Script(function() {
                                z[b] = e.total_elapsed_time - z[b], A[b] = e.donkey.current_health, k(e, !0)
                            }))
                        }, c = 0; c < e.level_descriptions.levels.length; c++) b(c);
                        r.push(new a.Script(function() {
                            k(e, !0), e.level_end_enabled = !0
                        }))
                    })
                }
                d.addButton(o, "Run Scripts", function() {
                    a.ScriptDo.runScripts(e, r, e.temp.scripts)
                }), d.addButton(o, "Cancel All Scripts", function() {
                    r.splice(0, r.length)
                })
            }, f.endLevel = function() {
                f.gotoLevelEnd(f.game_data), a.GameDo.update(f.game_data, 16), a.GameDo.update(f.game_data, 16), a.GameDo.update(f.game_data, 16), f.killAllZombies(f.game_data)
            }, f.gotoLevelEnd = function(b) {
                a.GameDo.clearTutorials(b), b.state = a.GameState.InLevel, b.platform_buttons_enabled = !0, b.donkey_button_enabled = !0, b.power_buttons_enabled = !0, b.donkey.mode = a.DonkeyMode.Walk, b.machine.current_max_speed = b.machine.max_speed * b.machine.speed_multiplier, b.distance.traveled_in_pixels = b.distance.to_oasis_in_pixels - b.meters_to_stop_from_oasis * a.GameData.METERS_TO_PIXELS - 10
            }, f.killAllZombies = function(a) {
                for (var b = 0, c = a.zombies; b < c.length; b++) {
                    var d = c[b];
                    d.health = 0, d.received_curse_damage = !0
                }
            }, f.gotoLastLevel = function() {
                a.GameDo.gotoLevel(f.game_data, 8), a.GameDo.update(f.game_data, 16)
            }, f.putPoint = function(a, b, c) {
                return void 0 === b && (b = 16711680), void 0 === c && (c = 10), f.putMarker(a.x, a.y, b, c)
            }, f.putMarker = function(b, c, d, g) {
                if (void 0 === d && (d = 16711680), void 0 === g && (g = 10), null == f.debug_container) return null;
                var h = new e(a.PhaserObjects.game),
                    i = g / 2;
                return h.lineStyle(1, d, 1), h.moveTo(-i, -i), h.lineTo(i, i), h.moveTo(i, -i), h.lineTo(-i, i), h.position.set(b, c), h.cacheAsBitmap = !0, f.debug_container.add(h), h
            }, f.putLinePoints = function(a, b, c) {
                return void 0 === c && (c = 16711680), f.putLine(a.x, a.y, b.x, b.y, c)
            }, f.putLine = function(b, c, d, g, h, i) {
                if (void 0 === h && (h = 16711680), void 0 === i && (i = 1), null == f.debug_container) return null;
                var j = new e(a.PhaserObjects.game);
                return j.lineStyle(i, h, 1), j.moveTo(b, c), j.lineTo(d, g), f.debug_container.add(j), j
            }, f.putRectangle = function(b, c, d, g) {
                if (void 0 === c && (c = 16711680), void 0 === d && (d = !1), void 0 === g && (g = 16777215), null == f.debug_container) return null;
                var h = new e(a.PhaserObjects.game);
                return h.position.set(b.x, b.y), d && h.beginFill(g), h.lineStyle(2, c, 1), h.moveTo(0, 0), h.lineTo(b.width, 0), h.lineTo(b.width, b.height), h.lineTo(0, b.height), h.lineTo(0, 0), d && h.endFill(), h.cacheAsBitmap = !0, f.debug_container.add(h), h
            }, f.putCircle = function(b, c, d, g, h) {
                if (void 0 === d && (d = 16711680), void 0 === g && (g = !1), void 0 === h && (h = 16777215), null == f.debug_container) return null;
                var i = new e(a.PhaserObjects.game);
                return i.position.set(b.x, b.y), g && i.beginFill(h), i.lineStyle(2, d, 1), i.drawCircle(0, 0, c), g && i.endFill(), i.cacheAsBitmap = !0, f.debug_container.add(i), i
            }, f.putTrajectory = function(a, b, c, d, e, g, h) {
                if (void 0 === g && (g = 4294901760), void 0 === h && (h = 10), null != f.debug_container)
                    for (var i = c, j = b, k = a, l = d; l < e; l++) {
                        var m = i.x * l * l / 2 + j.x * l + k.x,
                            n = i.y * l * l / 2 + j.y * l + k.y;
                        f.putMarker(m, n, g, h)
                    }
            }, f
        }();
    f.debug_container = null, f.game_data = null, a.DebugDo = f
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = function() {
        function b() {}
        return b.generateRepeatedScrollingSprites = function(b, c, d, e, f, g, h) {
            if (null != e) {
                var i = f + g,
                    j = 0;
                if (d.length > 0) {
                    var k = d[d.length - 1];
                    j = k.x + k.width
                }
                for (var l = 0; j <= i;) {
                    var m = null;
                    if (d.length > 0 && d[0].x + d[0].width < g && (m = d[0], m.position.x = j - 2, m.position.y = h, d.shift()), null == m && (m = a.PixiDo.createAndAddSprite(c, e, 0, 1, j - 2, h)), j = m.position.x + m.width, d.push(m), l++ > 100) break
                }
            }
        }, b.generateScrollingDunes = function(b, c, d, e, f, g, h) {
            for (var i = g + f, j = 0; j < d.length;) {
                var k = d[j];
                (k.position.x + k.width < g || k.position.x > i) && (d.splice(d.indexOf(k), 1), k.destroy(), j--), j++
            }
            if (0 == d.length)
                for (var l = 0, m = 0, n = 0, o = e.width_cache; n < o.length; n++) {
                    var p = o[n];
                    if (p > g) {
                        var q = e.types[l],
                            r = a.GameDo.getDuneTextureByType(q);
                        d.push(a.PixiDo.createAndAddSprite(c, r, 0, 1, m - 2, h));
                        break
                    }
                    m = p, l++
                }
            for (var s = d[d.length - 1].position.x + d[d.length - 1].width, t = 0, u = 0, v = e.width_cache; u < v.length; u++) {
                var p = v[u];
                if (p > s) break;
                t++
            }
            for (var w = 0; s < i && !(e.types.length <= t);) {
                var q = e.types[t],
                    r = a.GameDo.getDuneTextureByType(q);
                if (d.push(a.PixiDo.createAndAddSprite(c, r, 0, 1, s - 2, h)), s = d[d.length - 1].position.x + d[d.length - 1].width, t++, w++ > 100) break
            }
        }, b.generateRandomScrollingSprites = function(b, c, d, e, f, g) {
            var h = d.sprites,
                i = d.anchor,
                j = f + g,
                k = f;
            if (h.length > 0) {
                var l = h[h.length - 1];
                k = l.x + l.width;
                for (var m = !0, n = 0; m;) h[0].x + h[0].width < -f ? (h[0].parent.remove(h[0]), b.garbage.decoration_sprites.push(h.shift()), m = !0) : m = !1, n == h.length - 1 ? m = !1 : (m = !0, n++)
            }
            if (d.cursor == -1) {
                d.cursor = 0;
                for (var o = 0, p = d.generated; o < p.length; o++) {
                    var q = p[o];
                    if (q.position.x >= e) break;
                    d.cursor++
                }
            }
            for (var r = e - f, s = 0; k <= j && !(d.cursor >= d.generated.length);) {
                var t = d.generated[d.cursor];
                d.cursor++;
                for (var u = t.texture, v = null, w = 0, x = b.garbage.decoration_sprites; w < x.length; w++) {
                    var y = x[w];
                    if (y.texture == u) {
                        b.garbage.decoration_sprites.splice(b.garbage.decoration_sprites.indexOf(y), 1), v = y, c.add(v);
                        break
                    }
                }
                if (null == v && (v = a.PixiDo.createAndAddSprite(c, u, i.x, i.y, 0, 0)), v.position.x = t.position.x - r, v.position.y = t.position.y, k = v.position.x + v.width, h.push(v), s++ > 500) break
            }
        }, b.generateDecoration = function(a, b, c, d, e, f, g) {}, b
    }();
    a.DecorationDo = b
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.Point,
        c = function() {
            function c() {}
            return c.createAndAdd = function(c) {
                var d = new a.Donkey;
                c.donkey = d, d.anim = a.PixiAnimationDo.createSpriteAnimation(a.GameAssets.donkey_animation, ["log", "head", "neck", "body", "leg_front_right", "leg_front_right_lower", "leg_front_left", "leg_front_left_lower", "leg_back_right", "leg_back_right_lower", "leg_back_left", "leg_back_left_lower"], [a.GameAssets.donkey_log, a.GameAssets.donkey_head, a.GameAssets.donkey_neck, a.GameAssets.donkey_body, a.GameAssets.donkey_leg, a.GameAssets.donkey_lower_leg, a.GameAssets.donkey_leg, a.GameAssets.donkey_lower_leg, a.GameAssets.donkey_leg, a.GameAssets.donkey_lower_leg, a.GameAssets.donkey_leg, a.GameAssets.donkey_lower_leg]), d.container = a.PixiDo.createGroup(), a.PixiAnimationDo.addToContainer(d.container, d.anim), a.PixiAnimationDo.gotoFrame(d.anim, 1), d.container.position.set(316, 568), c.machine_container.add(d.container), d.donkey_damage_particle_spawn = new b, d.donkey_damage_particle_spawn.x = d.container.x + 10, d.donkey_damage_particle_spawn.y = d.container.y - 60, d.state = a.DonkeyState.Walking, d.mode = a.DonkeyMode.Walk, d.log = a.PixiAnimationDo.findSpriteByName(d.anim, "log"), d.log_init_rotation = d.log.rotation, d.moving_circle = a.GameDo.createMovingCircle(), d.log_dropped_rotation = d.log_init_rotation + 30 / 180 * Math.PI;
                var e = a.PixiDo.getContainerBounds(d.container);
                return d.button = a.ButtonDo.createButton(null, null, e), d.button.down_sound_callback = function() {
                    a.SoundDo.playSound(a.GameAssets.sound_click)
                }, d.button.down_callback = function() {
                    d.mode == a.DonkeyMode.Walk ? d.mode = a.DonkeyMode.Stop : d.mode = a.DonkeyMode.Walk
                }, d
            }, c.reset = function(b, c) {
                c.speed_mode = a.DonkeySpeedMode.Speed1x, c.current_health = c.max_health + c.max_health_additional, c.time_to_move_current_wait = 0, a.PixiAnimationDo.gotoFrame(c.anim, 1), c.state = a.DonkeyState.Walking
            }, c
        }();
    a.DonkeyDo = c
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.Point,
        c = bikas.global.GlobalFunc,
        d = bikas.pointer.PointerStateType,
        e = Phaser.Sprite,
        f = function() {
            function f() {}
            return f.createButtonFromTexture = function(b, c, d) {
                void 0 === c && (c = .5), void 0 === d && (d = .5);
                var e = a.PixiDo.createSprite(b, c, d, 0, 0),
                    g = f.createBasicButton(e, null, null);
                return g
            }, f.createBasicButton = function(c, d, f, g) {
                void 0 === c && (c = null), void 0 === d && (d = null), void 0 === f && (f = null), void 0 === g && (g = null);
                var h = a.ButtonDo.createButton(c, d, f);
                if (h.down_sound_callback = function() {
                    a.SoundDo.playSound(a.GameAssets.sound_click)
                }, null != c) {
                    h.default_state = a.ButtonDo.createState(new b(c.position.x, c.position.y), new b(1, 1));
                    var i = 1.03,
                        j = new b(0, 0);
                    if (Std.is(c, e)) {
                        new b(c.width * (.5 - c.anchor.x) * (1 - i), c.height * (.5 - c.anchor.y) * (1 - i))
                    } else {
                        new b(.5 * c.width * (1 - i), .5 * c.height * (1 - i))
                    }
                    h.over_state = a.ButtonDo.createState(new b(c.position.x + j.x, c.position.y + j.y), new b(i, i)), h.down_state = a.ButtonDo.createState(new b(c.position.x + 2, c.position.y + 2), new b(1, 1))
                }
                return h.down_callback = g, h
            }, f.activate = function(a) {
                a.container.alpha = 1, a.enabled = !0
            }, f.deactivate = function(b) {
                a.ButtonDo.resetButton(b), b.container.alpha = .5, b.enabled = !1
            }, f.updateBuffer = function(b, e) {
                if (e.enabled)
                    if (e.state == d.DOWNED && e.radius > 0) {
                        for (var f = null, g = e.radius, h = 0, i = b; h < i.length; h++) {
                            var j = i[h];
                            if (j.enabled) {
                                a.ButtonDo.updateBoundsIfNeeded(j, e);
                                var k = e.current;
                                if (c.pointInRectangle(k, j.global_bounds)) null != f ? j.priority_level >= f.priority_level && (f = j) : f = j, g = 0;
                                else if (g > 0) {
                                    var l = c.distanceBetweenPointAndRectangle(k, j.global_bounds);
                                    l <= g && (g = l, f = j)
                                }
                            }
                        }
                        null != f && a.ButtonDo.downButton(f)
                    } else
                        for (var m = 0, n = b; m < n.length; m++) {
                            var j = n[m];
                            a.ButtonDo.updateButton(j, e)
                        }
            }, f.clearBuffer = function(a) {
                a.splice(0, a.length)
            }, f
        }();
    a.GameButtonDo = f
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.MinMax,
        c = bikas.global.MinMaxCurrent,
        d = bikas.global.Point,
        e = bikas.global.Rectangle,
        f = function() {
            function a() {
                this.width = 0, this.position_before = new d, this.position = new d, this.velocity = new d, this.stuck_to_moving = null, this.damage = new g(0, 0, 0, 0), this.owner = null, this.zombie_target = null
            }
            return a
        }();
    a.Projectile = f;
    var g = function() {
        function a(a, b, c, d) {
            this.attack_penalty_coeff = 1, this.head = a, this.body = b, this.legs = c, this.walking_penalty_coeff = d
        }
        return a
    }();
    a.ProjectileDamage = g;
    var h;
    ! function(a) {
        a[a.Ground = 0] = "Ground", a[a.ZombieBody = 1] = "ZombieBody", a[a.ZombieHead = 2] = "ZombieHead", a[a.ZombieLegs = 3] = "ZombieLegs"
    }(h = a.ProjectileIntersectionType || (a.ProjectileIntersectionType = {}));
    var i = function() {
        function a(b, c, d, e) {
            void 0 === e && (e = null), this.zombie = null, this.alpha_out_current_time = 0, this.type = b, this.intersection = c, this.container = d, this.zombie = e, this.alpha_out_current_time = a.alpha_out_time
        }
        return a
    }();
    i.alpha_out_time = 180, a.ProjectileIntersection = i;
    var j;
    ! function(a) {
        a[a.SpawnZombie = 0] = "SpawnZombie", a[a.SpawnTresureChest = 1] = "SpawnTresureChest"
    }(j = a.SpawnType || (a.SpawnType = {}));
    var k = function() {
        function a(a, b, c, d) {
            this.type = a, this.zombie_type = b, this.money = c, this.position_x = d
        }
        return a
    }();
    a.Spawn = k;
    var l = function() {
        function a(a, b, c, d, e) {
            this.zombie_type = null, this.money = 0, this.count = 20, this.distribution = [0, 0, 1, 2, 1, 5, 1, 0], this.type = a, this.zombie_type = b, this.money = c, this.count = d, this.distribution = e
        }
        return a
    }();
    a.SpawnSettings = l;
    var m = function() {
        function a(a, b, c, d) {
            this.total_distance_in_meters = a, this.seed = b, this.name = c, this.spawn_settings = d
        }
        return a
    }();
    a.LevelSettings = m;
    var n = function() {
        function a() {
            this.levels = new Array, this.total_distance_in_pixels = 0
        }
        return a
    }();
    a.LevelDescriptions = n;
    var o;
    ! function(a) {
        a[a.Frozen = 0] = "Frozen", a[a.Standing = 1] = "Standing", a[a.StartingWalk = 2] = "StartingWalk", a[a.Walking = 3] = "Walking", a[a.StartingAttack = 4] = "StartingAttack", a[a.EndingAttack = 5] = "EndingAttack", a[a.Attacking = 6] = "Attacking", a[a.AttackingDying = 7] = "AttackingDying", a[a.WalkingDying = 8] = "WalkingDying", a[a.Dead = 9] = "Dead"
    }(o = a.ZombieState || (a.ZombieState = {}));
    var p;
    ! function(a) {
        a[a.Regular = 0] = "Regular", a[a.Limp = 1] = "Limp", a[a.Fat = 2] = "Fat", a[a.Mega = 3] = "Mega"
    }(p = a.ZombieType || (a.ZombieType = {}));
    var q = function() {
        function a() {
            this.type = p.Regular, this.state = o.Standing, this.anim_ranges = new r, this.attack_damage = .1, this.attack_random_distance = 0, this.curse_coeff = 1, this.stun_coeff = 1, this.legs_coeff = .8, this.velocity = new d, this.received_arrow_damage = !1, this.received_donkey_damage = !1, this.received_curse_damage = !1, this.rotation_twitch_max_time = 20, this.rotation_twitch_current_time = 0, this.rotation_twitch_max_angle = 0, this.current_alert_time = 0, this.stun_decided = !1, this.one_hit_decided = !1, this.one_hit_frames = 0, this.alpha_out_current_time = 0, this.hands = new Array, this.legs = new Array, this.zombie_health_bar = null, this.debug_transition = null
        }
        return a
    }();
    q.alpha_out_time = 180, a.Zombie = q;
    var r = function() {
        function a() {
            this.feeding = null
        }
        return a
    }();
    a.ZombieAnimationRanges = r;
    var s = function() {
        function a() {}
        return a
    }();
    a.Hitbox = s;
    var t;
    ! function(a) {
        a[a.Chilling = 0] = "Chilling", a[a.Resting = 1] = "Resting", a[a.Loading = 2] = "Loading", a[a.Shooting = 3] = "Shooting"
    }(t = a.ArcherState || (a.ArcherState = {}));
    var u;
    ! function(a) {
        a[a.ClosestRandom = 0] = "ClosestRandom", a[a.AlwaysFirst = 1] = "AlwaysFirst"
    }(u = a.ArcherTargetSelectType || (a.ArcherTargetSelectType = {}));
    var v = function() {
        function a(a, b) {
            this.price = a, this.amount = b
        }
        return a
    }();
    a.PriceAndAmount = v;
    var w = function() {
        function a() {
            this.exist = !1, this.state = t.Chilling, this.target_select_type = u.ClosestRandom, this.arrows = new Array, this.launch_vectors = new Array, this.random_angle = 0, this.container_current_rotation = 0, this.container_launch_rotation = 0, this.travel_to_anchor_time = 0, this.zombie_target_suggestion = null, this.zombie_target = null, this.relaunch = !1, this.resting = new c(0, 35, 35), this.total_resting_time = 0, this.damage_current = new g(0, 0, 0, 0), this.current_level = 0, this.total_launchs = 0, this.total_hits = 0, this.skill_points = 0, this.level_up_transition = null, this.level_up_anim_frame = 0, this.accuracy = new x("accuracy"), this.strength = new x("strength"), this.speed = new x("speed"), this.hook = new y("hook", a.hook_settings), this.sharpness = new y("sharpness", a.sharpness_settings), this.xarrows = new y("xarrows", a.xarrows_settings)
        }
        return a
    }();
    w.init_archer_1st_level_coeff = .81, w.arrow_launch_anchor = .5, w.damage_min = new g(11, 3.5, 2, .9), w.damage_max = new g(22, 7, 4, .85), w.max_hits_for_max_skills = 3e3, w.max_levels = 12, w.skills_per_level = 2, w.arrow_angles = [0, Math.PI / 30, -Math.PI / 30, Math.PI / 15], w.zombie_choice_probabilities = [.5, .3, .2], w.shooting_coeff = new b(1, 1.8), w.headshot_coeff = new b(.1, .6), w.arrow_speed = new b(8, 14), w.loading_anim_range = new a.AnimationRange(1, 50), w.shooting_anim_range = new a.AnimationRange(50, 60), w.archer_buy_prices = [180, 165, 150, 140, 130, 120], w.archer_buy_increased_prices = [0, 140, 260, 380, 460, 500], w.hook_settings = [new v(0, 1), new v(85, .9), new v(90, .8), new v(95, .7)], w.sharpness_settings = [new v(0, 0), new v(90, 2), new v(110, 4), new v(120, 8)], w.xarrows_settings = [new v(0, 1), new v(265, 2)], a.Archer = w;
    var x = function() {
        function a(a) {
            this.trained = new b(0, 1), this.trained_index = 0, this.local_boost_coeff = 1, this.global_boost_coeff = 1, this.local_temp_boost_add = 0, this.global_temp_boost_add = 0, this.name = a
        }
        return a
    }();
    x.trained_max_index = 8, a.Skill = x;
    var y = function() {
        function a(a, b) {
            this.name = "", this.current_index = 0, this.name = a, this.amounts = b
        }
        return a
    }();
    y.max_index = 3, a.Upgrade = y;
    var z = function() {
        function a(a, b) {
            this.time = a, this.distance = b
        }
        return a
    }();
    a.DistanceTime = z;
    var A = function() {
        function a(a, b, c) {
            this.time = a, this.size = b, this.distance = c
        }
        return a
    }();
    a.SizeDistanceTime = A;
    var B = function() {
        function a(a, b) {
            this.zombie = a, this.distance = b
        }
        return a
    }();
    a.ZombieWithDistance = B;
    var C;
    ! function(a) {
        a[a.Left = 0] = "Left", a[a.Right = 1] = "Right"
    }(C = a.MachinePlatformSide || (a.MachinePlatformSide = {}));
    var D = function() {
        function a() {
            this.archer = null, this.removed_archer = null
        }
        return a
    }();
    D.selected_sprite_scale = 1.3, a.MachinePlatform = D;
    var E;
    ! function(a) {
        a[a.Skills = 0] = "Skills", a[a.Upgrades = 1] = "Upgrades", a[a.Buy = 2] = "Buy"
    }(E = a.ArcherMenuType || (a.ArcherMenuType = {}));
    var F = function() {
        function a() {
            this.title = null, this.speed = null, this.strength = null, this.accuracy = null, this.hook = null, this.sharpness = null, this.xarrows = null, this.buy_menu = null
        }
        return a
    }();
    F.title_offset_x = 210, F.title_offset_y = 38, a.ArcherMenu = F;
    var G = function() {
        function a() {
            this.current_can_afford = !1
        }
        return a
    }();
    a.TrainSkillMenu = G;
    var H = function() {
        function a(a, b, c) {
            this.cost = a, this.name = b, this.effect = c
        }
        return a
    }();
    a.UpgradeTier = H;
    var I = function() {
        function a() {}
        return a
    }();
    I.text_offset_x = 200, a.UpgradeMenu = I;
    var J = function() {
        function a(a) {
            this.points = a
        }
        return a
    }();
    a.LevelUpPoints = J;
    var K = function() {
        function a() {}
        return a
    }();
    a.ArcherBuyMenu = K;
    var L = function() {
        function a() {
            this.index = 0, this.behind_next_arrow = null, this.description1 = "", this.description2 = ""
        }
        return a
    }();
    a.PowerUnlock = L;
    var M = function() {
        function a() {
            this.king_unlocks = new Array, this.donkey_unlocks = new Array
        }
        return a
    }();
    M.title_center = new d(452, 53), a.PowerMenu = M;
    var N = function() {
        function a() {}
        return a
    }();
    N.text1_position = new d(224, 51), N.text2_position = new d(224, 99), a.PowerSubMenu = N;
    var O = function() {
        function a() {}
        return a
    }();
    O.None = 1, O.Middle = 2, O.Up = 3, O.Down = 4, a.UnlockType = O;
    var P = function() {
        function a() {
            this.points = 0, this.king = [O.None, O.None, O.None, O.None, O.None], this.donkey = [O.None, O.None, O.None, O.None, O.None]
        }
        return a
    }();
    P.king_force_index = 0, P.king_rain_or_force_index = 1, P.king_rally_index = 2, P.king_curse_index = 3, P.king_rally_or_curse_index = 4, P.donkey_heart_index = 0, P.donkey_attack_index = 1, P.donkey_paralysis_index = 2, P.donkey_attack_or_heart_index = 3, P.donkey_instant_kill_index = 4, a.Unlocks = P;
    var Q = function() {
        function b() {
            this.start_ability_range = new a.AnimationRange(1, 30, 1), this.end_ability_range = new a.AnimationRange(30, 45, .5), this.rain_ability = new S, this.force_ability = new T, this.rally_ability = new U, this.curse_ability = new V, this.wave = null
        }
        return b
    }();
    a.King = Q;
    var R = function() {
        function a() {
            this.zombies = null, this.current_duration = 0
        }
        return a
    }();
    a.ForceWave = R;
    var S = function() {
        function a() {
            this.count = 40, this.additional_count = 0, this.speed = 6, this.area = new e(120, (-200), 550, 150), this.angle = Math.PI / 4, this.angle_random_offset = Math.PI / 24, this.arrow_damage = new g(11, 3.5, 2, .9)
        }
        return a
    }();
    a.RainAbility = S;
    var T = function() {
        function a() {
            this.force = 4e3, this.additional_force = 4e3, this.duration = 12, this.max_position = 900
        }
        return a
    }();
    a.ForceAbility = T;
    var U = function() {
        function a() {
            this.skill_add = 1, this.skill_add_additional = 0
        }
        return a
    }();
    a.RallyAbility = U;
    var V = function() {
        function a() {
            this.coeff = .2, this.damage_per_frame = .1, this.damage_per_frame_additional = 0
        }
        return a
    }();
    a.CurseAbility = V;
    var W;
    ! function(a) {
        a[a.Rain = 0] = "Rain", a[a.Force = 1] = "Force", a[a.Rally = 2] = "Rally", a[a.Curse = 3] = "Curse"
    }(W = a.AbilityType || (a.AbilityType = {}));
    var X;
    ! function(a) {
        a[a.Idle = 0] = "Idle", a[a.Activated = 1] = "Activated", a[a.Starting = 2] = "Starting", a[a.InPorgress = 3] = "InPorgress", a[a.Ending = 4] = "Ending", a[a.Charging = 5] = "Charging", a[a.Finishing = 6] = "Finishing"
    }(X = a.AbilityState || (a.AbilityState = {}));
    var Y = function() {
        function a() {
            this.ability_seconds = 0, this.recharge_distance = 0, this.recharge_distance_start = 0, this.current_recharge_time = 0, this.used = !1
        }
        return a
    }();
    a.Ability = Y;
    var Z;
    ! function(a) {
        a[a.Walking = 0] = "Walking", a[a.StartingAttack = 1] = "StartingAttack", a[a.WaitingToAttack = 2] = "WaitingToAttack", a[a.Attacking = 3] = "Attacking", a[a.EndingAttack = 4] = "EndingAttack"
    }(Z = a.DonkeyState || (a.DonkeyState = {}));
    var $;
    ! function(a) {
        a[a.Walk = 0] = "Walk", a[a.Stop = 1] = "Stop"
    }($ = a.DonkeyMode || (a.DonkeyMode = {}));
    var _ = function() {
        function a() {}
        return a
    }();
    _.Speed1x = 1, _.Speed3x = 2, a.DonkeySpeedMode = _;
    var aa = function() {
        function b() {
            this.time_to_move_max_wait = 120, this.time_to_move_current_wait = 0, this.walking_range = new a.AnimationRange(1, 50, 1), this.starting_attack_range = new a.AnimationRange(50, 60, .7), this.ending_attack_range = new a.AnimationRange(50, 60, .3), this.attacking_range = new a.AnimationRange(60, 80, .75), this.speed_to_walking_coeff = 1.15, this.damage_per_frame = .25, this.damage_per_frame_additional = 0, this.current_health = 0, this.max_health = 50, this.max_health_additional = 0, this.health_before_shown_damage = 0, this.chance_of_stun = 0, this.one_hit_kill = !1, this.one_hit_frames = 5, this.zombie_stop_threshold_x = 500, this.zombie_prepare_attack_x = 370, this.zombie_barrier_x = 340
        }
        return b
    }();
    a.Donkey = aa;
    var ba = function() {
        function a() {
            this.spark_interval = 120, this.current_spark_time = 0, this.button = null, this.picked = !1
        }
        return a
    }();
    a.TreasureChest = ba;
    var ca = function() {
        function a(a, b) {
            this.texture = a, this.position = b
        }
        return a
    }();
    a.GeneratedDecoration = ca;
    var da = function() {
        function a() {
            this.generated = new Array, this.sprites = new Array, this.cursor = -1
        }
        return a
    }();
    a.Decoration = da;
    var ea = function() {
        function a() {
            this.decorations = new Array, this.chunk_width = 256
        }
        return a
    }();
    a.Decorations = ea;
    var fa = function() {
        function a() {}
        return a
    }();
    a.FlyWithGraphics = fa;
    var ga = function() {
        function a() {}
        return a
    }();
    a.Castle = ga;
    var ha = function() {
        function a() {}
        return a
    }();
    ha.wave = 0, ha.triangle = 1, ha.big = 2, ha.medium = 3, ha.flat = 4, ha.rock_big = 5, ha.rock_double = 6, ha.rock_flat = 7, ha.rock_medium = 8, ha.rock_pointy = 9, ha.regular_to_rock = 10, ha.rock_to_regular = 11, a.DuneType = ha;
    var ia = function() {
        function a(a) {
            this.types = new Array, this.width_cache = new Array, this.types = a
        }
        return a
    }();
    a.DuneLevel = ia;
    var ja = function() {
        function a() {
            this.levels = new Array
        }
        return a
    }();
    ja.dune_scroll_coeff = .4, a.DuneDescriptions = ja;
    var ka = function() {
        function a() {
            this.all_platforms = new Array, this.all_platforms_reversed = new Array, this.acceleration_speed = .03, this.max_speed = 1.5 / (60 * Oa.PIXELS_TO_METERS), this.speed_multiplier = 1, this.current_max_speed = 0, this.current_speed_goal = 0, this.current_speed = 0
        }
        return a
    }();
    a.Machine = ka;
    var la = function() {
        function a(a, b, c, d, e) {
            void 0 === a && (a = 60), void 0 === b && (b = 10), void 0 === c && (c = 10),
                void 0 === d && (d = 5), void 0 === e && (e = 1), this.current_duration = 0, this.current_delay = a, this.duration = b, this.smooth_in_duration = c, this.smooth_out_duration = d, this.time_coeff = e
        }
        return a
    }();
    a.SlowDownTime = la;
    var ma = function() {
        function a() {
            this.current_transition = null
        }
        return a
    }();
    a.Indicator = ma;
    var na = function() {
        function a() {}
        return a
    }();
    a.TopStats = na;
    var oa = function() {
        function a(a) {
            this.score = 0, this.zombies_killed = 0, this.money = a
        }
        return a
    }();
    a.Wallet = oa;
    var pa = function() {
        function a() {}
        return a
    }();
    a.Oasis = pa;
    var qa = function() {
        function a() {
            this.to_oasis_in_pixels = 0, this.traveled_in_pixels = 0, this.traveled_in_meters = 0
        }
        return a
    }();
    a.Distance = qa;
    var ra = function() {
        function a() {
            this.max_alpha = 1, this.alpha_change_min = .01, this.alpha_change_max = .02
        }
        return a
    }();
    a.SunRay = ra;
    var sa = function() {
        function a() {
            this.adjusted_to_width = 0, this.rays = new Array, this.flies = new Array
        }
        return a
    }();
    a.StartMenu = sa;
    var ta = function() {
        function a() {}
        return a
    }();
    a.StoryMenu = ta;
    var ua = function() {
        function a() {
            this.zombies = new Array, this.flies = new Array, this.aligned_width = 0
        }
        return a
    }();
    a.DeathMenu = ua;
    var va = function() {
        function a() {
            this.all_buttons = new Array, this.listed_buttons = new Array, this.aligned_x = 0
        }
        return a
    }();
    a.PauseMenu = va;
    var wa = function() {
        function a() {
            this.aligned_x = 0, this.transitions = new Array
        }
        return a
    }();
    a.WinMenu = wa;
    var xa = function() {
        function a() {
            this.current_level = 0, this.total_launchs = 0, this.total_hits = 0, this.skill_points = 0, this.accuracy_index = 0, this.strength_index = 0, this.speed_index = 0, this.hook_index = 0, this.sharpness_index = 0, this.xarrows_index = 0
        }
        return a
    }();
    a.SavedArcher = xa;
    var ya = function() {
        function a() {}
        return a
    }();
    ya.LevelStart = 1, ya.UnlockMenu = 2, a.SavedState = ya;
    var za = function() {
        function a() {
            this.level_index = 0, this.money = 0, this.score = 0, this.zombies_killed = 0, this.unlocks = null, this.archers = [null, null, null, null, null, null]
        }
        return a
    }();
    a.SavedGame = za;
    var Aa = function() {
        function a(a) {
            this.money = 0, this.money = a
        }
        return a
    }();
    a.DebugSpawnMoney = Aa;
    var Ba = function() {
        function b() {
            this.intersection_rectangle = a.PixiDo.createGroup(), this.generate_zombies = 0, this.zombie_spawn_distance = 800, this.head_hitbox = new e((-2), (-115), 12, 12), this.body_hitbox = new e((-12), (-100), 32, 60), this.legs_hitbox = new e(0, (-30), 15, 22), this.debug_level_generation = !1, this.debug_graph = null, this.scripts = new Array, this.spawn_money = new Array
        }
        return b
    }();
    a.Temp = Ba;
    var Ca = function() {
        function a() {
            this.graphics = new Array, this.background_color = 16053492, this.axis_color = 855309, this.distribution_color = 11403264, this.stage_color = 1458317, this.line_width = 2
        }
        return a
    }();
    a.DebugGraph = Ca;
    var Da = function() {
        function a() {
            this.offset = new d
        }
        return a
    }();
    a.ObjectDrag = Da;
    var Ea = function() {
        function a() {
            this.zombies = new Array, this.treasure_chests = new Array, this.arrow_sprites = new Array, this.projectiles = new Array, this.decoration_sprites = new Array
        }
        return a
    }();
    a.Garbage = Ea;
    var Fa = function() {
        function a() {
            this.zombies = new Array
        }
        return a
    }();
    a.ZombieCollisionChunk = Fa;
    var Ga = function() {
        function a() {
            this.chunks = new Array
        }
        return a
    }();
    a.ZombieCollisionArea = Ga;
    var Ha = function() {
        function a() {
            this.selected_zombies = new Array, this.sorted_by_selection_zombies = new Array, this.sorted_by_position_zombies = new Array
        }
        return a
    }();
    a.ZombieSelection = Ha;
    var Ia = function() {
        function a() {
            this.targeted_by = null
        }
        return a
    }();
    a.SelectedZombie = Ia;
    var Ja = function() {
        function a() {}
        return a
    }();
    a.MovingCircle = Ja;
    var Ka = function() {
        function a(a, b) {
            this.current = a, this.max = b
        }
        return a
    }();
    a.Wait = Ka;
    var La;
    ! function(a) {
        a[a.None = 0] = "None", a[a.AnimIn = 1] = "AnimIn", a[a.AnimBackground = 2] = "AnimBackground", a[a.AnimWaitMedieval = 3] = "AnimWaitMedieval", a[a.AnimMedieval = 4] = "AnimMedieval", a[a.AnimDefense = 5] = "AnimDefense", a[a.AnimLogo = 6] = "AnimLogo", a[a.Idle = 7] = "Idle", a[a.AnimOut = 8] = "AnimOut"
    }(La = a.TrailerState || (a.TrailerState = {}));
    var Ma = function() {
        function a() {
            this.current_coeff = 0, this.transitions = new Array, this.temp_additional_wait = 0
        }
        return a
    }();
    a.Trailer = Ma;
    var Na;
    ! function(a) {
        a[a.InUpdateDisabled = 0] = "InUpdateDisabled", a[a.InStartMenu = 1] = "InStartMenu", a[a.InTransitionToStory = 2] = "InTransitionToStory", a[a.InStory = 3] = "InStory", a[a.InTransitionToTutorial = 4] = "InTransitionToTutorial", a[a.InDonkeyClick = 5] = "InDonkeyClick", a[a.InArcherHire = 6] = "InArcherHire", a[a.InRainPower = 7] = "InRainPower", a[a.InArcherUpgrade = 8] = "InArcherUpgrade", a[a.InTransitionToLevel = 9] = "InTransitionToLevel", a[a.InOasis = 10] = "InOasis", a[a.InOasisStats = 11] = "InOasisStats", a[a.InTransitionToUnlockMenu = 12] = "InTransitionToUnlockMenu", a[a.InUnlockMenu = 13] = "InUnlockMenu", a[a.InTransitionFromUnlockToContinue = 14] = "InTransitionFromUnlockToContinue", a[a.InContinueLevel = 15] = "InContinueLevel", a[a.InStartLevel = 16] = "InStartLevel", a[a.InLevel = 17] = "InLevel", a[a.InTransitionToDeathMenu = 18] = "InTransitionToDeathMenu", a[a.InDeathMenu = 19] = "InDeathMenu", a[a.InTransitionToWinMenu = 20] = "InTransitionToWinMenu", a[a.InWinMenu = 21] = "InWinMenu", a[a.InPauseMenu = 22] = "InPauseMenu", a[a.InFinalMenu = 23] = "InFinalMenu"
    }(Na = a.GameState || (a.GameState = {}));
    var Oa = function() {
        function c() {
            this.state = null, this.previous_state = null, this.is_webgl = !0, this.delta_update_coeff = 1, this.delta_update_coeff_by_effect = 1, this.delta_update_coeff_by_menu = 1, this.total_elapsed_time = 0, this.current_level_index = 0, this.platform_buttons_enabled = !1, this.donkey_button_enabled = !1, this.power_buttons_enabled = !1, this.treasure_buttons_enabled = !1, this.wallet = new oa(1e5), this.level_end_enabled = !0, this.in_tutorial_mode = !1, this.death_to_trailer = !1, this.zombies_approaching = 0, this.zombies_close_to_machine = 0, this.zombies_very_close_to_donkey = 0, this.zombies_attacking_donkey = 0, this.any_ability_is_active = !1, this.any_archer_menu_opened = !1, this.total_archer_count = 0, this.ground_level = 617, this.gravity = new d(0, .2), this.dunes_y = 631, this.grass_y = 0, this.zombie_alert_width_range = new b(256, 512), this.zombie_alert_width = 256, this.script_data = new a.ScriptData, this.story_text_position = new d(662, 326), this.tutorial_text_position = new d(662, 326), this.road_text_position = new d(662, 250), this.continue_button_text_position = new d(662, 210), this.meters_to_stop_from_oasis = 11, this.moving_circles = new Array, this.top_stats = new na, this.distance = new qa, this.machine = new ka, this.garbage = new Ea, this.decorations = new ea, this.dunes = new Array, this.grasses = new Array, this.platforms = new Array, this.abilities = new Array, this.archers = new Array, this.spawns = new Array, this.zombies = new Array, this.cursed_zombies = null, this.treasure_chests = new Array, this.dead_zombies = new Array, this.zombie_collision_area = new Ga, this.flying_projectiles = new Array, this.stuck_projectiles = new Array, this.transitions = new Array, this.overlay_transitions = new Array, this.slow_down_time = null, this.button_buffer = new Array, this.zombie_selection = new Ha, this.power_unlocks = new P, this.flies = new Array, this.oasis = new pa, this.wait = null, this.temp = new Ba, this.debug_element = null, this.drags = new Array, this.current_drag = null, this.game_update_time = 0
        }
        return c
    }();
    Oa.METERS_TO_PIXELS = 76 / 1.8, Oa.PIXELS_TO_METERS = 1.8 / 76, a.GameData = Oa
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.algorithms.ProceduralNumberGenerator,
        c = bikas.global.MathConstants,
        d = bikas.global.MinMax,
        e = bikas.global.Point,
        f = bikas.global.Rectangle,
        g = bikas.global.GlobalFunc,
        h = bikas.global.Interpolate,
        i = bikas.global.GlobalSolve,
        j = bikas.global.VecFunc,
        k = bikas.global.VecProc,
        l = bikas.pointer.PointerStateType,
        m = Phaser.BitmapText,
        n = PIXI.Texture,
        o = function() {
            function o() {}
            return o.createGame = function(b, d, g, h, i) {
                function j(b, c, d, e, f) {
                    var g = a.PixiDo.createSprite(c, .5, .5),
                        h = a.PixiDo.createGroup();
                    h.add(g);
                    var i = a.GameButtonDo.createBasicButton(h, null, null, f);
                    return i.container.position.x = d, i.container.position.y = e, b.add(i.container), i
                }

                function k(b, c, d, e, f) {
                    var g = new Phaser.Button(a.PhaserObjects.game, d, e, "", function() {
                        g.scale.x = g.scale.y = 1, f()
                    });
                    return g.texture = c, g.onInputOver.add(function() {
                        g.scale.x = g.scale.y = 1.03
                    }), g.onInputOut.add(function() {
                        g.scale.x = g.scale.y = 1
                    }), null != b && b.add(g), g
                }

                function l(a, b) {}

                function p(b, c, d, e) {
                    var f = new m(a.PhaserObjects.game, 0, 0, "accidental_presidency_42_light", c, 42, "left");
                    return f.position.set(d, e), b.add(f), f
                }

                function q(c) {
                    var d = c.game_container;
                    d.add(c.background_container), d.add(c.dunes_container), d.add(c.ground_container), d.add(c.decoration_container), d.add(c.machine_container), d.add(c.foreground_container), c.foreground_container.add(c.particle_container), d.add(c.abilities_container), d.add(c.top_stats_container), d.add(c.menu_container), d.add(c.logo_container), b.type != a.ConfigType.Release && (a.DebugDo.debug_container = a.PixiDo.createGroup(), d.add(a.DebugDo.debug_container))
                }

                function r(b) {
                    var c = a.PixiDo.createAndAddSprite(b, a.GameAssets.target_select_line, .5, .5, 0, 0);
                    return c
                }

                function s(b, c, d) {
                    var e = new m(a.PhaserObjects.game, 0, 0, "accidental_presidency_42_light", c, 25, "left");
                    e.position.set(30, d), b.add(e)
                }

                function t(a, b) {
                    a.container.position.x = b.current_game_width - 35 - a.container.width / 2
                }

                function u(b, c) {
                    return a.PixiDo.createSprite(c, .5, .5, b.tutorial_text_position.x, b.tutorial_text_position.y)
                }

                function v(b, d, e, f, g, h, i) {
                    void 0 === i && (i = 1);
                    var j = a.ZombieDo.create(w, d, f, !0);
                    return a.PixiAnimationDo.gotoFrame(j.anim, j.anim_ranges.feeding.start), j.container.position.x = f, j.container.position.y = g, j.container.scale.x = i, j.container.rotation = h * c.DEGREES_TO_RADIANS, b.container.add(j.container), j
                }
                var w = new a.GameData;
                w.pointer = g, w.js_info = d, w.pointer = g, w.is_webgl = i, w.config = b, w.grass_y = w.ground_level + 2, w.serial_data = a.GameSerializerDo.describeData(), b.type == a.ConfigType.DevelopmentTrailer && (w.death_to_trailer = !0), w.game_container = h, w.background_container = a.PixiDo.createGroup(), w.dunes_container = a.PixiDo.createGroup(), w.ground_container = a.PixiDo.createGroup(), w.decoration_container = a.PixiDo.createGroup(), w.machine_container = a.PixiDo.createGroup(), w.foreground_container = a.PixiDo.createGroup(), w.particle_container = a.PixiDo.createGroup(), w.overlay_container = a.PixiDo.createGroup(), w.top_stats_container = a.PixiDo.createGroup(), w.abilities_container = a.PixiDo.createGroup(), w.menu_container = a.PixiDo.createGroup(), w.logo_container = a.PixiDo.createGroup(), q(w);
                var x = (w.distance, w.machine),
                    y = (w.decoration_container, w.machine_container);
                w.foreground_container, w.ground_level;
                w.top_stats.health = o.createAndAddIndicator(w.top_stats_container, a.GameAssets.top_menu_health, "0", 703, 10, 65, 11), w.top_stats.money = o.createAndAddIndicator(w.top_stats_container, a.GameAssets.top_menu_money, "0", 834, 10, 60, 11), w.top_stats.distance = o.createAndAddIndicator(w.top_stats_container, a.GameAssets.top_menu_distance, "0", 860, 80, 24, 11), w.pause_button = j(w.menu_container, a.GameAssets.pause_button, 45, 45, function() {
                    o.switchPause(w)
                }), d.scale_listeners.push(function() {
                    w.top_stats_container.position.x = d.current_game_width - d.min_game_width, w.top_stats_container.position.y = -d.height_offset, w.pause_button.container.y = 45 - d.height_offset
                }), w.background = o.createAndPlace(w.background_container, a.GameAssets.background, 0, 0, 0, 0);
                var z = o.createAndPlace(w.background_container, a.GameAssets.clouds, .5, .5, 0, 0),
                    A = o.createAndPlace(w.background_container, a.GameAssets.sun_rays, .5, .5, 0, 0);
                z.position.x = d.current_game_width - 661, z.position.y = 105 - d.height_offset, A.position.x = d.current_game_width - 413, A.position.y = 160 - d.height_offset, d.scale_listeners.push(function() {
                    z.position.x = d.current_game_width - 661, z.position.y = 105 - d.height_offset, A.position.x = d.current_game_width - 413, A.position.y = 160 - d.height_offset, d.current_game_height > 768 ? (w.background.texture = a.GameAssets.background_extended, w.background.position.x = 0, w.background.position.y = a.GameAssets.background.height - a.GameAssets.background_extended.height) : (w.background.texture = a.GameAssets.background, w.background.position.x = -(a.GameAssets.background.width - d.current_game_width) + 4, w.background.position.y = 0)
                }), w.ground_container.position.set(0, w.ground_level), a.PixiDo.createAndAddSprite(w.ground_container, a.GameAssets.ground, 0, 0, 0, 0), a.PixiDo.createAndAddSprite(w.overlay_container, a.GameAssets.brown, 0, 0, 0, 0), d.scale_listeners.push(function() {
                    w.overlay_container.position.y = -d.height_offset, w.overlay_container.scale.y = d.current_game_height / 768 + .1
                }), w.level_descriptions = a.LevelDo.create();
                var B = w.oasis;
                B.container = a.PixiDo.createGroup(), B.sprite = a.PixiDo.createSprite(a.GameAssets.oasis, .5, 1, 0, w.ground_level + 2), B.text = new m(a.PhaserObjects.game, 0, 0, "accidental_presidency_60_brown", "Oasis 0/10", 60, "center"), B.text.position.x = .35 * -B.text.width, B.text.position.y = w.oasis.sprite.y - w.oasis.sprite.height - 1.5 * w.oasis.text.height, B.menu = a.PixiDo.createGroup(), B.background = a.PixiDo.createAndAddSprite(B.menu, a.GameAssets.oasis_stats_background, 0, 0, 0, 0), B.menu.position.x = .41 * -B.background.width, B.menu.position.y = B.background.height;
                var C = 30,
                    D = 30,
                    E = 52;
                B.text1 = p(B.menu, "• Progress saved", C, D), B.text2 = p(B.menu, "• Health restored", C, D + 1 * E), B.text3 = p(B.menu, "• Zombies killed: " + w.wallet.zombies_killed, C, D + 2 * E), B.text4 = p(B.menu, "• Score: " + w.wallet.score, C, D + 3 * E);
                var F = a.PixiDo.createSprite(a.GameAssets.oasis_next, .5, .5, 179, 298);
                B.next = a.GameButtonDo.createBasicButton(F, null, null, function() {
                    w.state = a.GameState.InTransitionToUnlockMenu
                }), B.menu.add(B.next.container), B.container.add(B.sprite), B.container.add(B.text), w.continue_button = a.GameButtonDo.createButtonFromTexture(a.GameAssets.button_continue, .5, .5), w.continue_button.container.position.x = w.continue_button_text_position.x, w.continue_button.container.position.y = w.continue_button_text_position.y, 
                w.continue_button.down_callback = function() {
                        console.log("continue_button.down_callback");
                        // a.PhaserObjects.game.analytics.google.sendScreenView(a.Gameplay.Name), 
                        // a.PhaserObjects.game.ads.onContentPaused.addOnce(function() {
                        //     a.PhaserObjects.game.analytics.google.sendScreenView("advertisement")
                        // }), a.PhaserObjects.game.ads.onContentResumed.addOnce(function() {
                        //     a.PhaserObjects.game.ads.onContentPaused.removeAll(),
                        //      a.PhaserObjects.game.ads.onContentResumed.removeAll(), 
                        //      o.launchOverlayTransition(w, 1, 0, function() {
                                w.state = a.GameState.InStartLevel
                        //     })
                        // }), a.PhaserObjects.game.ads.showAd(PhaserAds.AdProvider.GameDistributionAdType.midroll)
                
                }, w.castle = o.createCastle(w.ground_level), w.dune_descriptions = new a.DuneDescriptions;
                var G = w.dune_descriptions;
                G.levels.push(new a.DuneLevel([a.DuneType.wave, a.DuneType.wave, a.DuneType.flat, a.DuneType.flat])), G.levels.push(new a.DuneLevel([a.DuneType.flat, a.DuneType.triangle, a.DuneType.wave, a.DuneType.triangle, a.DuneType.triangle, a.DuneType.triangle])), G.levels.push(new a.DuneLevel([a.DuneType.triangle, a.DuneType.flat, a.DuneType.flat, a.DuneType.regular_to_rock, a.DuneType.rock_big, a.DuneType.rock_to_regular, a.DuneType.flat, a.DuneType.flat])), G.levels.push(new a.DuneLevel([a.DuneType.flat, a.DuneType.medium, a.DuneType.big, a.DuneType.medium, a.DuneType.wave, a.DuneType.triangle, a.DuneType.flat, a.DuneType.flat, a.DuneType.big])), G.levels.push(new a.DuneLevel([a.DuneType.big, a.DuneType.triangle, a.DuneType.medium, a.DuneType.flat, a.DuneType.triangle, a.DuneType.medium, a.DuneType.medium, a.DuneType.triangle, a.DuneType.wave, a.DuneType.flat])), G.levels.push(new a.DuneLevel([a.DuneType.flat, a.DuneType.medium, a.DuneType.wave, a.DuneType.big, a.DuneType.wave, a.DuneType.medium, a.DuneType.flat, a.DuneType.medium, a.DuneType.wave, a.DuneType.regular_to_rock])), G.levels.push(new a.DuneLevel([a.DuneType.rock_big, a.DuneType.rock_medium, a.DuneType.rock_flat, a.DuneType.rock_to_regular, a.DuneType.wave, a.DuneType.regular_to_rock, a.DuneType.rock_double, a.DuneType.rock_big, a.DuneType.rock_flat, a.DuneType.rock_pointy, a.DuneType.rock_to_regular, a.DuneType.flat, a.DuneType.big])), G.levels.push(new a.DuneLevel([a.DuneType.big, a.DuneType.regular_to_rock, a.DuneType.rock_pointy, a.DuneType.rock_big, a.DuneType.rock_double, a.DuneType.rock_medium, a.DuneType.rock_big, a.DuneType.rock_to_regular, a.DuneType.medium, a.DuneType.wave, a.DuneType.flat, a.DuneType.regular_to_rock, a.DuneType.rock_double, a.DuneType.rock_big])), G.levels.push(new a.DuneLevel([a.DuneType.rock_big, a.DuneType.rock_double, a.DuneType.rock_medium, a.DuneType.rock_flat, a.DuneType.rock_big, a.DuneType.rock_medium, a.DuneType.rock_flat, a.DuneType.rock_big, a.DuneType.rock_to_regular, a.DuneType.flat, a.DuneType.flat, a.DuneType.medium, a.DuneType.wave, a.DuneType.big, a.DuneType.triangle]));
                for (var H = 0, I = 0, J = G.levels; I < J.length; I++) {
                    for (var K = J[I], L = 0, M = 0, N = K.types; M < N.length; M++) {
                        var O = N[M];
                        L += o.getDuneTextureByType(O).width - 2, K.width_cache.push(L)
                    }
                    var P = w.level_descriptions.levels[H].total_distance_in_pixels;
                    P += 2.2 * d.original_max_game_width;
                    var Q = L / a.DuneDescriptions.dune_scroll_coeff;
                    Q < P || Q > P + 3 * d.original_max_game_width, H++
                }
                w.decorations = new a.Decorations;
                var R = w.decorations.decorations,
                    S = w.ground_level + 1;
                R.push(o.createDecoration(w, [a.GameAssets.cactus1, a.GameAssets.cactus2, a.GameAssets.cactus3, a.GameAssets.cactus4, a.GameAssets.cactus5, a.GameAssets.cactus6, a.GameAssets.cactus7], .13, .5, 1, 400, 800, S, S + 2)), R.push(o.createDecoration(w, [a.GameAssets.plant1, a.GameAssets.plant2, a.GameAssets.plant3], .2, .5, 1, 100, 500, S, S + 5)), R.push(o.createDecoration(w, [a.GameAssets.rock1, a.GameAssets.rock2], .3, .5, 1, 100, 600, S, S + 5)), x.tower_container = a.PixiDo.createGroup(), x.tower_container.position.set(171, 409), y.add(x.tower_container), x.tower = o.createAndPlace(x.tower_container, a.GameAssets.machine, .5, .5, 0, 0), x.wheel1 = o.createAndPlace(x.tower_container, a.GameAssets.wheel, .5, .5, -69, 180), x.wheel2 = o.createAndPlace(x.tower_container, a.GameAssets.wheel, .5, .5, 69, 180);
                var T = x.all_platforms;
                x.right_top = o.createAndAddMachinePlatform(w, y, T, 206.2, 329, a.MachinePlatformSide.Right), x.right_center = o.createAndAddMachinePlatform(w, y, T, 221.3, 445, a.MachinePlatformSide.Right), x.right_bottom = o.createAndAddMachinePlatform(w, y, T, 235.75, 555.95, a.MachinePlatformSide.Right), x.left_top = o.createAndAddMachinePlatform(w, y, T, 135.75, 329, a.MachinePlatformSide.Left), x.left_center = o.createAndAddMachinePlatform(w, y, T, 120.65, 445, a.MachinePlatformSide.Left), x.left_bottom = o.createAndAddMachinePlatform(w, y, T, 106.2, 555.95, a.MachinePlatformSide.Left), x.all_platforms_reversed = x.all_platforms.slice(0), x.all_platforms_reversed.reverse(), x.current_max_speed = x.max_speed, a.KingDo.createAndAdd(w), a.DonkeyDo.createAndAdd(w), w.donkey.current_health = w.donkey.max_health + w.donkey.max_health_additional;
                var U = w.donkey;
                U.speed_mode = a.DonkeySpeedMode.Speed1x, U.button_1x = a.GameButtonDo.createBasicButton(null, null, new f(813, 657, 83, 97), function() {
                    U.speed_mode = a.DonkeySpeedMode.Speed1x, o.refreshDonkeySpeedControls(w)
                }), U.button_3x = a.GameButtonDo.createBasicButton(null, null, new f(913, 657, 83, 97), function() {
                    U.speed_mode = a.DonkeySpeedMode.Speed3x, o.refreshDonkeySpeedControls(w)
                }), U.speed_frame = a.PixiDo.createAndAddSprite(w.abilities_container, a.GameAssets.donkey_speed_frame, 0, 0, 813, 657), U.speed_1x = a.PixiDo.createAndAddSprite(w.abilities_container, a.GameAssets.donkey_speed_1x, .5, .5, 854, 705), U.speed_3x = a.PixiDo.createAndAddSprite(w.abilities_container, a.GameAssets.donkey_speed_3x, .5, .5, 954, 705), d.scale_listeners.push(function() {
                    o.refreshDonkeySpeedControls(w)
                });
                for (var V = new a.ZombieSelection, W = 0; W < w.machine.all_platforms.length; W++) {
                    var X = new a.SelectedZombie,
                        Y = a.PixiDo.createGroup();
                    X.container = Y, X.top_left = r(Y), X.top_right = r(Y), X.bottom_left = r(Y), X.bottom_right = r(Y), V.selected_zombies.push(X)
                }
                w.zombie_selection = V;
                var Z = new a.StartMenu;
                w.start_menu = Z, Z.container = a.PixiDo.createGroup(), Z.decoration_container = a.PixiDo.createGroup(), Z.container.add(Z.decoration_container), Z.title = a.PixiDo.createAndAddSprite(Z.container, a.GameAssets.text_medieval_defense_z, .5, .5, 0, 0);
                var C = d.current_game_width - 35 - 150;
                Z.button_continue = j(Z.container, a.GameAssets.button_continue, C, 0, function() {
                    o.launchOverlayTransition(w, 1, 0, function() {
                        o.load(w, w.last_save)
                    })
                }), Z.button_new_game = j(Z.container, a.GameAssets.button_new_game, C, 0, function() {
                    o.launchOverlayTransition(w, 1, 0, function() {
                        o.load(w, w.init_saved_game)
                    })
                }), Z.button_credits = j(Z.container, a.GameAssets.button_credits, C, 0, function() {
                    Z.credits.visible = !Z.credits.visible
                }), Z.more_games_button = k(Z.container, a.GameAssets.button_more_games, C, 0, o.moreGamesClick), Z.more_games_button.anchor.set(.5, .5), o.moreGamesCreate(Z.more_games_button, Z.container), a.PixiDo.createAndAddSprite(Z.decoration_container, a.GameAssets.dune_wave, .5, 1, -635, 189), a.PixiDo.createAndAddSprite(Z.decoration_container, a.GameAssets.dune_wave, .5, 1, 387, 189), Z.oasis = a.PixiDo.createAndAddSprite(Z.decoration_container, a.GameAssets.oasis, .5, 1, 0, 175), Z.pile_of_zombies = a.PixiDo.createAndAddSprite(Z.decoration_container, a.GameAssets.pile_of_zombies, .5, .5, 15, 121), Z.dead_zombie = a.PixiDo.createAndAddSprite(Z.decoration_container, a.GameAssets.dead_zombie, .5, .5, 174, 153), a.PixiDo.createAndAddSprite(Z.decoration_container, a.GameAssets.plant1, .5, 1, 391, 176), a.PixiDo.createAndAddSprite(Z.decoration_container, a.GameAssets.cactus6, .5, 1, 288, 177), a.PixiDo.createAndAddSprite(Z.decoration_container, a.GameAssets.plant3, .5, .5, -140, 157), a.PixiDo.createAndAddSprite(Z.decoration_container, a.GameAssets.cactus1, .5, .5, -166, 93), a.PixiDo.createAndAddSprite(Z.decoration_container, a.GameAssets.plant2, .5, .5, -191, 162), a.PixiDo.createAndAddSprite(Z.decoration_container, a.GameAssets.plant1, .5, 1, -329, 175), a.PixiDo.createAndAddSprite(Z.decoration_container, a.GameAssets.grass, 0, 1, -652, 176), a.PixiDo.createAndAddSprite(Z.decoration_container, a.GameAssets.grass, 0, 1, -142, 176), a.PixiDo.createAndAddSprite(Z.decoration_container, a.GameAssets.grass, 0, 1, 370, 176);
                for (var W = 0; W < 7; W++) a.PixiDo.createAndAddSprite(Z.decoration_container, a.GameAssets.ground_tile, .5, .5, -580 + (a.GameAssets.ground_tile.width - 2) * W, 250);
                Z.decoration_container.position.set(341, 443), Z.dead_zombie.rotation = .9198;
                for (var $ = [new e(178, 154), new e(154, 125), new e(127, 113), new e(103, 113), new e(93, 96), new e(73, 110), new e(73, 86), new e(19, 76), new e((-42), 101), new e((-54), 113), new e((-85), 111), new e((-91), 115), new e((-115), 124)], _ = 0, aa = $; _ < aa.length; _++) {
                    var ba = aa[_],
                        ca = o.createFly(ba);
                    Z.decoration_container.add(ca.container), Z.flies.push(ca)
                }
                var da = a.GameAssets.brown.frame.clone();
                da.width = 475, da.height = 330;
                var ea = a.PixiDo.createGroup();
                ea.position.set(184, 209), Z.credits = ea;
                var fa = new n(a.GameAssets.brown.baseTexture, da),
                    ga = (a.PixiDo.createAndAddSprite(ea, fa, 0, 0, 0, 0), a.PixiDo.createAndAddSprite(ea, a.GameAssets.credits_text, .5, .5, 238, 48), a.PixiDo.createAndAddSprite(ea, a.GameAssets.credits_line, 0, 0, -3, 104), new m(a.PhaserObjects.game, 0, 0, "accidental_presidency_42_light", "Code and art by Bikas.net", 42, "left")),
                    ha = new m(a.PhaserObjects.game, 0, 0, "accidental_presidency_42_light", "Music", 42, "left");
                ga.hitArea = a.PixiDo.convertRectangleTo(a.PixiDo.getLocalContainerBounds(ga)), l(ga, o.bikasNetClick), ga.position.set(30, 135), ha.position.set(30, 195), ea.add(ga), ea.add(ha), s(ea, "'In the Desert' by MusicDog", 245), s(ea, "'Medieval Background Ambience Loop 2' by Werihukka", 280), Z.credits.visible = !1, Z.container.add(Z.credits), d.scale_listeners.push(function() {
                    Z.title.position.x = d.current_game_width / 2, Z.title.position.y = 60 - .92 * d.height_offset, Z.credits.position.x = 184 + (d.current_game_width - d.min_game_width);
                    var a = d.current_game_width - 35 - Z.button_new_game.container.width;
                    Z.decoration_container.position.x = a / 2, t(Z.button_continue, d), t(Z.button_new_game, d), t(Z.button_credits, d), Z.more_games_button.position.x = d.current_game_width - 35 - Z.more_games_button.width / 2, Z.adjusted_to_width = d.current_game_width
                });
                var ia = new a.StoryMenu;
                w.story_menu = ia, ia.container = a.PixiDo.createGroup(), ia.container.position.x = w.story_text_position.x, ia.container.position.y = w.story_text_position.y, ia.text = a.PixiDo.createAndAddSprite(ia.container, a.GameAssets.text_story, .5, .5, 0, -50), ia.start = j(ia.container, a.GameAssets.button_start, 0, 128, function() {
                    w.state = a.GameState.InTransitionToTutorial
                }), w.text_click_donkey = u(w, a.GameAssets.text_click_donkey), w.text_click_archer = u(w, a.GameAssets.text_click_archer), w.text_click_power = u(w, a.GameAssets.text_click_power), w.text_click_upgrades = u(w, a.GameAssets.text_click_upgrades), w.archer_skill_menu = a.ArcherMenuDo.create(a.ArcherMenuType.Skills, a.GameAssets.skill_menu, w.transitions), w.archer_upgrade_menu = a.ArcherMenuDo.create(a.ArcherMenuType.Upgrades, a.GameAssets.skill_menu, w.transitions), w.archer_buy_menu = a.ArcherMenuDo.create(a.ArcherMenuType.Buy, a.GameAssets.hire_archer_menu, w.transitions), w.power_menu = a.PowerMenuDo.create(w), w.power_sub_menu = a.PowerMenuDo.createSubMenu(w);
                var ja = new a.DeathMenu;
                w.death_menu = ja, ja.container = a.PixiDo.createGroup(), ja.container.position.set(188, 521), ja.pile = a.PixiDo.createAndAddSprite(ja.container, a.GameAssets.tower_pile, .5, .5, 0, 0), ja.zombies.push(v(ja, a.ZombieType.Fat, ja.container, 260, 98, -64.2)), ja.zombies.push(v(ja, a.ZombieType.Regular, ja.container, 27, 44, 0)), ja.zombies.push(v(ja, a.ZombieType.Regular, ja.container, -97, 42, -15, -1)), ja.restart_button = a.GameButtonDo.createButtonFromTexture(a.GameAssets.button_restart_level), ja.restart_button.down_callback = function() {
                    o.launchOverlayTransition(w, 1, 0, function() {
                        o.restartLevel(w)
                    })
                }, ja.restart_button.container.position.x = 512, ja.restart_button.container.position.y = 214, ja.text_dead = a.PixiDo.createSprite(a.GameAssets.text_dead, .5, .5, 512, 80);
                for (var $ = [new e(202, 65), new e(170, 46), new e(132, 50), new e(112, (-4)), new e(85, 29), new e(38, 43), new e(34, 8), new e((-9), 2), new e((-26), 49), new e((-72), 14), new e((-82), 49), new e((-127), 35)], ka = 0, la = $; ka < la.length; ka++) {
                    var ba = la[ka];
                    ba.y += 10;
                    var ca = o.createFly(ba);
                    ja.container.add(ca.container), ja.flies.push(ca)
                }
                var ma = new a.PauseMenu;
                w.pause_menu = ma, ma.container = a.PixiDo.createGroup(), ma.button_container = a.PixiDo.createGroup(), ma.button_container.position.x = d.current_game_width / 2, ma.button_container.position.y = 0, ma.backgound = a.PixiDo.createAndAddSprite(ma.container, a.GameAssets.brown_light, 0, 0, 0, 0), ma.backgound.alpha = .9, ma.pause_text = a.PixiDo.createAndAddSprite(ma.button_container, a.GameAssets.text_paused, .5, .5, 0, 0), ma.container.add(ma.button_container), ma.all_buttons.push(j(ma.button_container, a.GameAssets.button_continue, 0, 0, function() {
                    o.switchPause(w)
                })), ma.all_buttons.push(j(ma.button_container, a.GameAssets.button_restart_level, 0, 0, function() {
                    o.launchOverlayTransition(w, 1, 0, function() {
                        w.in_tutorial_mode || w.previous_state == a.GameState.InStartMenu ? o.load(w, w.init_saved_game) : o.restartLevel(w)
                    })
                })), ma.all_buttons.push(j(ma.button_container, a.GameAssets.button_main_menu, 0, 0, function() {
                    o.launchOverlayTransition(w, 1, 0, function() {
                        o.gotoStartMenu(w)
                    })
                })), ma.more_games_button = k(ma.button_container, a.GameAssets.button_more_games, 0, 0, o.moreGamesClick), ma.more_games_button.anchor.set(.5, .5), o.moreGamesCreate(ma.more_games_button, ma.container);
                var na = a.PixiDo.createSprite(a.GameAssets.icon_line, .5, .5, 0, 0);
                ma.music_button = j(ma.container, a.GameAssets.icon_music, 821, 73, function() {
                    a.SoundDo.setMusicEnabled(!a.SoundDo.music_enabled), na.visible = !a.SoundDo.music_enabled
                });
                var oa = a.PixiDo.createSprite(a.GameAssets.icon_line, .5, .5, 0, 0);
                ma.sound_button = j(ma.container, a.GameAssets.icon_sound, 951, 73, function() {
                    a.SoundDo.setSoundsEnabled(!a.SoundDo.sounds_enabled), oa.visible = !a.SoundDo.sounds_enabled
                }), na.rotation = -Math.PI / 4, oa.rotation = -Math.PI / 4, na.visible = !a.SoundDo.music_enabled, oa.visible = !a.SoundDo.sounds_enabled, ma.listed_buttons = ma.all_buttons.slice(0), ma.music_button.foreground.add(na), ma.sound_button.foreground.add(oa), ma.all_buttons.push(ma.music_button), ma.all_buttons.push(ma.sound_button), ma.pause_text.position.x = 17, ma.pause_text.position.y = 100;
                for (var pa = 300, qa = 110, ra = 0, sa = ma.listed_buttons; ra < sa.length; ra++) {
                    var ta = sa[ra];
                    ta.container.position.y = pa, pa += qa
                }
                ma.more_games_button.y = pa, d.scale_listeners.push(function() {
                    ma.container.position.y = -d.height_offset, ma.backgound.scale.y = d.current_game_height / 768 + .1, ma.button_container.position.y = d.height_offset;
                    for (var b = 0, c = ma.listed_buttons; b < c.length; b++) {
                        var e = c[b];
                        a.ButtonDo.updateBounds(e, w.pointer)
                    }
                });
                var ua = new a.WinMenu;
                w.win_menu = ua, ua.container = a.PixiDo.createGroup(), ua.container.position.x = 512, ua.container.position.y = 360, ua.victory = a.PixiDo.createAndAddSprite(ua.container, a.GameAssets.text_victory, .5, .5, 0, -249), ua.characters = a.PixiDo.createAndAddSprite(ua.container, a.GameAssets.characters_celebrating, .5, .5, 0, -16), ua.main_menu = a.GameButtonDo.createButtonFromTexture(a.GameAssets.button_main_menu), ua.main_menu.down_callback = function() {
                    o.launchOverlayTransition(w, 1, 0, function() {
                        o.gotoStartMenu(w)
                    })
                }, ua.more_games_button = k(null, a.GameAssets.button_more_games_light, 0, 0, o.moreGamesClick), ua.more_games_button.anchor.set(.5, .5), o.moreGamesCreate(ua.more_games_button, ua.container), ua.main_menu.container.position.set(0, -299), ua.more_games_button.position.set(0, 210), ua.container.add(ua.main_menu.container), ua.container.add(ua.more_games_button);
                var C = -131,
                    D = 60,
                    E = 52;
                ua.text1 = p(ua.container, "• Created by Bikas", C, D), ua.text1.visible = !1, ua.text3 = p(ua.container, "• Zombies killed: " + w.wallet.zombies_killed, C, D + 0 * E), ua.text4 = p(ua.container, "• Score: " + w.wallet.score, C, D + 1 * E), ua.submit = a.GameButtonDo.createButtonFromTexture(a.GameAssets.button_submit), ua.submit.down_callback = function() {}, ua.submit.container.visible = !1, ua.submit.container.position.set(0, 280), ua.container.add(ua.submit.container);
                var va = w.trailer = new a.Trailer;
                va.state = a.TrailerState.None, va.container = a.PixiDo.createGroup(), va.background = a.PixiDo.createSprite(a.GameAssets.brown_light, 0, 0, 0, 0), va.background_dark = a.PixiDo.createSprite(a.GameAssets.brown, 0, 0, 0, 0), va.container.position.set(512, 360), va.medieval = a.PixiDo.createAndAddSprite(va.container, a.GameAssets.trailer_text_medieval, .5, .5, 0, -210), va.defense = a.PixiDo.createAndAddSprite(va.container, a.GameAssets.trailer_text_defense, .5, .5, 0, -81), va.logo = a.PixiDo.createAndAddSprite(va.container, a.GameAssets.trailer_logo, .5, .5, -8, 122), va.arrow1 = a.PixiDo.createAndAddSprite(va.container, a.GameAssets.trailer_arrow, .5, .5, -30, 190, -30 * c.DEGREES_TO_RADIANS), va.arrow2 = a.PixiDo.createAndAddSprite(va.container, a.GameAssets.trailer_arrow, .5, .5, 18, 190, -150 * c.DEGREES_TO_RADIANS), va.by_bikas = a.PixiDo.createAndAddSprite(va.container, a.GameAssets.trailer_by_bikas, .5, .5, 0, 306), d.scale_listeners.push(function() {
                    va.container.position.x = d.current_game_width / 2, va.background.position.y = -d.height_offset - 4, va.background.scale.y = d.current_game_height / 768 + .1, va.background_dark.position.y = -d.height_offset - 4, va.background_dark.scale.y = d.current_game_height / 768 + .1
                }), w.text_road = new m(a.PhaserObjects.game, 0, 0, "accidental_presidency_60_brown", "Road 1/10", 60, "center"), w.text_road.position.x = w.road_text_position.x - w.text_road.width / 2, w.text_road.position.y = w.road_text_position.y - 40, w.text_road_name = new m(a.PhaserObjects.game, 0, 0, "accidental_presidency_60_brown", "", 60, "center"), w.text_road_name.position.x = w.road_text_position.x - w.text_road_name.width / 2, w.text_road_name.position.y = w.road_text_position.y + 40;
                for (var W = 0; W < 1e3; W++) {
                    var wa = a.PixiDo.createSprite(a.GameAssets.arrow, 0, .5, 0, 0);
                    w.garbage.arrow_sprites.push(wa)
                }
                for (var W = 0; W < 1e3; W++) {
                    var xa = new a.Projectile;
                    xa.collision_position = xa.position, xa.collision_position_before = xa.position_before, w.garbage.projectiles.push(xa)
                }
                for (var W = 0; W < 200; W++) {
                    var ya = a.ZombieDo.create(w, a.ZombieType.Regular, 0, !1);
                    w.garbage.zombies.push(ya)
                }
                for (var W = 0; W < 100; W++) {
                    var ya = a.ZombieDo.create(w, a.ZombieType.Limp, 0, !1);
                    w.garbage.zombies.push(ya)
                }
                for (var W = 0; W < 50; W++) {
                    var ya = a.ZombieDo.create(w, a.ZombieType.Fat, 0, !1);
                    w.garbage.zombies.push(ya)
                }
                w.wallet.money = 0, o.refreshPowerUnlocks(w);
                var za = a.ArcherDo.spawn(w, w.machine.right_bottom);
                o.setCustomArcherLevelByCoeff(za, a.Archer.init_archer_1st_level_coeff);
                var Aa = Fabrique.Branding.getLogoWithLink(a.PhaserObjects.game, "medieval-defence-z");
                Aa.x = 0, Aa.y = 653, Aa.position.x = d.current_game_width - Aa.width - 54, Aa.anchor.set(0), w.logo_container.add(Aa), d.scale_listeners.push(function() {
                    Aa.position.x = d.current_game_width - Aa.width - 54
                });
                a.JsDo.getTimer();
                if (w.last_save = a.GameSerializerDo.loadFromStorage(w.serial_data), w.init_saved_game = o.save(w, a.SavedState.LevelStart), null != w.last_save && (w.last_save.state == a.SavedState.LevelStart ? w.last_levelstart_save = w.last_save : w.last_levelstart_save = null), a.DebugDo.game_data = w, b.type != a.ConfigType.Release && (w.debug_element = document.getElementById("gamedebug"), null == w.debug_element || a.DebugDo.createDebugMenu(w, d)), b.type == a.ConfigType.Release) {
                    var Ba = w.trailer;
                    w.game_container.add(Ba.background_dark), Ba.state = a.TrailerState.AnimIn, Ba.temp_before_finish = function() {
                        w.game_container.add(Ba.background), w.game_container.add(Ba.container),
                            o.gotoStartMenu(w);
                        for (var a = 0, b = w.js_info.scale_listeners; a < b.length; a++) {
                            var c = b[a];
                            c()
                        }
                    }
                } else o.gotoStartMenu(w);
                return w
            }, o.createAndPlace = function(b, c, d, e, f, g) {
                return a.PixiDo.createAndAddSprite(b, c, d, e, f, g)
            }, o.createAndAddIndicator = function(b, c, d, e, f, g, h) {
                var i = new a.Indicator;
                return i.container = a.PixiDo.createGroup(), i.background = a.PixiDo.createSprite(c), i.background.anchor.set(0, 0), i.text = new m(a.PhaserObjects.game, 0, 0, "accidental_presidency_42_light", d, 42, "left"), i.text.text = d, i.container.position.set(e, f), i.background.position.set(0, 0), i.text.position.set(g, h), i.container.add(i.background), i.container.add(i.text), b.add(i.container), i
            }, o.createDecoration = function(c, d, f, g, i, j, k, l, m) {
                var n = new a.Decoration;
                n.textures = d, n.anchor = new e(g, i), n.min = new e(j, l), n.max = new e(k, m);
                for (var o = 0, p = 3600 * a.GameData.METERS_TO_PIXELS, q = new b(f); o <= p;) {
                    var r = Math.round(h.linear(0, d.length - 1, q.getRandom())),
                        s = h.linear(n.min.x, n.max.x, q.getRandom()),
                        t = h.linear(n.min.y, n.max.y, q.getRandom());
                    o += s;
                    for (var u = !0, v = 0; v < c.level_descriptions.levels.length; v++) {
                        var w = 0;
                        if (w = v < c.level_descriptions.levels.length - 1 ? a.LevelDo.getTotalDistanceTraveledInPixels(c.level_descriptions.levels, v + 1, 0) : a.LevelDo.getTotalDistanceTraveledInPixels(c.level_descriptions.levels, v, 0), Math.abs(o - w) < 1024) {
                            u = !1;
                            break
                        }
                    }
                    u && n.generated.push(new a.GeneratedDecoration(d[r], new e(o, t)))
                }
                return n
            }, o.createAndAddMachinePlatform = function(b, c, d, g, h, i) {
                var j = new a.MachinePlatform;
                j.side = i;
                var k = 1;
                i == a.MachinePlatformSide.Right ? k = 1 : i == a.MachinePlatformSide.Left && (k = -1), j.container = a.PixiDo.createGroup(), j.container.position.set(g, h), c.add(j.container), j.platform = o.createAndPlace(j.container, a.GameAssets.machine_platform, 0, 1, 0, 0), j.platform.scale.x = k;
                var l = o.createAndPlace(j.container, a.GameAssets.archer_buy_sign, .5, 1, 0, -55),
                    m = null,
                    n = new e(0, (-62));
                i == a.MachinePlatformSide.Right ? m = j.container : (m = c, n.x += j.container.position.x, n.y += j.container.position.y);
                var p = o.createAndPlace(m, a.GameAssets.archer_upgrade_sign, .5, .5, n.x, n.y);
                j.upgrade_sign = p, p.visible = !1;
                var q = o.createAndPlace(j.container, a.GameAssets.archer_selected_circle, .5, .5, 0, -90);
                q.scale.x = a.MachinePlatform.selected_sprite_scale, q.scale.y = a.MachinePlatform.selected_sprite_scale;
                var r = null,
                    s = 80,
                    t = 100;
                return k > 0 ? (l.position.x = 30, p.position.x += 54, q.position.x = 30, r = new f(g - 10, h - 1.4 * t, s, t)) : (l.position.x = -30, p.position.x += -54, q.position.x = -30, r = new f(g - s + 10, h - 1.4 * t, s, t)), q.visible = !1, j.buy_sign = l, j.selected_sprite = q, j.button = a.ButtonDo.createButton(null, null, r), j.button.priority_level = 1, j.button.down_sound_callback = function() {
                    a.SoundDo.playSound(a.GameAssets.sound_click)
                }, j.button.down_callback = function() {
                    null == j.archer ? o.openBuy(b, j) : 0 == j.archer.skill_points || b.state == a.GameState.InArcherUpgrade ? o.openUpgrades(b, j.archer) : o.openSkills(b, j.archer)
                }, b.machine.current_speed_goal = b.machine.current_max_speed, d.push(j), j
            }, o.openSkills = function(b, c) {
                a.ArcherMenuDo.close(b.archer_upgrade_menu, b.transitions), a.ArcherMenuDo.close(b.archer_buy_menu, b.transitions), a.ArcherMenuDo.isOpened(b.archer_skill_menu) || a.ArcherMenuDo.open(b, b.menu_container, b.transitions, b.archer_skill_menu, c)
            }, o.openUpgrades = function(b, c) {
                if (!a.ArcherMenuDo.isOpened(b.archer_skill_menu)) {
                    a.ArcherMenuDo.close(b.archer_buy_menu, b.transitions);
                    var d = !0;
                    a.ArcherMenuDo.isOpened(b.archer_upgrade_menu) && c == b.archer_upgrade_menu.current_archer && (d = !1, a.ArcherMenuDo.close(b.archer_upgrade_menu, b.transitions)), d && a.ArcherMenuDo.open(b, b.menu_container, b.transitions, b.archer_upgrade_menu, c, b.wallet)
                }
            }, o.openBuy = function(b, c) {
                if (!a.ArcherMenuDo.isOpened(b.archer_skill_menu)) {
                    a.ArcherMenuDo.close(b.archer_upgrade_menu, b.transitions);
                    var d = !0;
                    a.ArcherMenuDo.isOpened(b.archer_buy_menu) && c == b.archer_buy_menu.current_platform && (d = !1, a.ArcherMenuDo.close(b.archer_buy_menu, b.transitions)), d && a.ArcherMenuDo.open(b, b.menu_container, b.transitions, b.archer_buy_menu, null, b.wallet, c)
                }
            }, o.clear = function(b) {
                a.LevelDo.clear(b), o.setDonkeySpeedControlVisiblity(b, !1), a.SoundDo.pauseMusic(a.GameAssets.sound_loop_flies), a.SoundDo.pauseMusic(a.GameAssets.sound_loop_eating), o.safeRemove(b.oasis.container), o.safeRemove(b.castle.container), o.clearZombieSelection(b.zombie_selection), o.safeRemove(b.start_menu.container), o.safeRemove(b.pause_menu.container), o.safeRemove(b.death_menu.container), o.safeRemove(b.death_menu.text_dead), o.safeRemove(b.death_menu.restart_button.container), o.safeRemove(b.win_menu.container), null != b.oasis.menu.parent && b.oasis.menu.parent.remove(b.oasis.menu), o.clearTutorials(b), a.PowerMenuDo.close(b, b.power_menu, 0), a.PowerMenuDo.closeSub(b, b.power_sub_menu, !0);
                for (var c = 0, d = b.archers; c < d.length; c++) {
                    var e = d[c];
                    e.accuracy.global_temp_boost_add = 0, e.strength.global_temp_boost_add = 0, e.speed.global_temp_boost_add = 0
                }
                b.abilities[0].container.visible = !0, b.machine_container.visible = !0, b.abilities_container.visible = !0, b.top_stats_container.visible = !0, b.dunes_container.visible = !0, b.oasis.container.visible = !0, b.death_menu.restart_button.container.visible = !0, b.pause_button.container.visible = !0;
                for (var f = 0, g = b.grasses; f < g.length; f++) {
                    var h = g[f];
                    h.visible = !0
                }
            }, o.clearZombieSelection = function(a) {
                for (var b = 0, c = a.selected_zombies; b < c.length; b++) {
                    var d = c[b];
                    null != d.container.parent && d.container.parent.remove(d.container), d.zombie = null
                }
                a.sorted_by_selection_zombies = [], a.sorted_by_position_zombies = []
            }, o.clearTutorials = function(a) {
                o.safeRemove(a.story_menu.container), o.safeRemove(a.text_click_donkey), o.safeRemove(a.text_click_archer), o.safeRemove(a.text_click_power), o.safeRemove(a.text_click_upgrades), o.safeRemove(a.text_road), o.safeRemove(a.text_road_name), o.safeRemove(a.continue_button.container);
                for (var b = 0, c = a.moving_circles; b < c.length; b++) {
                    var d = c[b];
                    o.safeRemove(d.sprite)
                }
                a.moving_circles = [], a.in_tutorial_mode = !1
            }, o.gotoStartMenu = function(b) {
                o.clear(b), o.fadeOutGameplayMusic(b, 1), null != a.GameAssets.music_medieval && (a.GameAssets.music_medieval.played_once ? o.fadeInMenuMusic(b, 2) : a.SoundDo.playMusic(a.GameAssets.music_medieval)), a.ArcherDo.removeAllArchers(b), b.state = a.GameState.InStartMenu, o.safeAdd(b.menu_container, b.start_menu.container), b.machine_container.visible = !1, b.top_stats_container.visible = !1, b.abilities_container.visible = !1, a.ButtonDo.resetButton(b.start_menu.button_continue), a.ButtonDo.resetButton(b.start_menu.button_new_game), a.ButtonDo.resetButton(b.start_menu.button_credits);
                for (var c = 0, d = b.grasses; c < d.length; c++) {
                    var e = d[c];
                    e.visible = !1
                }
                b.dunes_container.visible = !1;
                var f = b.start_menu,
                    g = !1;
                null != b.last_save && (g = !0), g ? (f.button_continue.container.position.y = 200, f.button_new_game.container.position.y = f.button_continue.container.position.y + 109, f.button_credits.container.position.y = f.button_new_game.container.position.y + 109, f.more_games_button.position.y = f.button_credits.container.position.y + 109, f.button_continue.container.visible = !0) : (f.button_new_game.container.position.y = 250, f.button_credits.container.position.y = f.button_new_game.container.position.y + 109, f.more_games_button.position.y = f.button_credits.container.position.y + 109, f.button_continue.container.visible = !1), a.PhaserObjects.game.analytics.google.sendScreenView("menu")
            }, o.gotoStory = function(b) {
                o.clear(b), o.fadeOutMenuMusic(b, 1), b.state = a.GameState.InTransitionToStory, o.safeAdd(b.menu_container, b.story_menu.container), b.story_menu.text.alpha = 0, b.story_menu.start.container.alpha = 0, b.platform_buttons_enabled = !1, b.donkey_button_enabled = !1, b.power_buttons_enabled = !1, b.treasure_buttons_enabled = !1, b.donkey.mode = a.DonkeyMode.Stop, b.abilities[0].container.visible = !1, a.LevelDo.start(b, 0), b.in_tutorial_mode = !0, b.donkey.health_before_shown_damage = b.donkey.current_health, a.PhaserObjects.game.analytics.google.sendScreenView("story")
            }, o.gotoLevel = function(b, c) {
                o.clear(b), o.fadeOutMenuMusic(b, 1), o.fadeInGameplayMusic(b, 5), b.state = a.GameState.InLevel, b.platform_buttons_enabled = !0, b.donkey_button_enabled = !0, b.power_buttons_enabled = !0, b.treasure_buttons_enabled = !0, b.donkey.mode = a.DonkeyMode.Walk, b.donkey.current_health = b.donkey.max_health + b.donkey.max_health_additional, b.donkey.health_before_shown_damage = b.donkey.current_health, a.LevelDo.start(b, c), a.PhaserObjects.game.analytics.google.sendScreenView("gameplay"), a.PhaserObjects.game.analytics.game.addEvent(new GA.Events.Progression("Start:Level:" + b.current_level_index))
            }, o.gotoDeathMenu = function(b) {
                for (o.fadeOutGameplayMusic(b, 1), a.ArcherDo.removeAllArchers(b), a.SoundDo.playMusic(a.GameAssets.sound_loop_flies), a.SoundDo.playMusic(a.GameAssets.sound_loop_eating); b.zombies.length > 0;) a.ZombieDo.remove(b, b.zombies[0], b.zombies);
                for (; b.dead_zombies.length > 0;) a.ZombieDo.remove(b, b.dead_zombies[0], b.dead_zombies);
                for (; b.flying_projectiles.length > 0;) {
                    var c = b.flying_projectiles.pop();
                    c.sprite.parent.remove(c.sprite), b.garbage.arrow_sprites.push(c.sprite)
                }
                b.oasis.text.visible = !1, b.machine_container.visible = !1, b.abilities_container.visible = !1, a.ArcherMenuDo.close(b.archer_buy_menu, b.transitions, 0), a.ArcherMenuDo.close(b.archer_upgrade_menu, b.transitions, 0), a.ArcherMenuDo.close(b.archer_skill_menu, b.transitions, 0), b.delta_update_coeff_by_effect = 1, b.delta_update_coeff_by_menu = 1, o.clearZombieSelection(b.zombie_selection);
                var d = b.death_menu;
                b.menu_container.add(d.container), b.menu_container.add(d.text_dead), b.menu_container.add(d.restart_button.container), a.ButtonDo.resetButton(d.restart_button), a.ButtonDo.updateBounds(d.restart_button, b.pointer), b.state = a.GameState.InDeathMenu, a.PhaserObjects.game.analytics.google.sendScreenView("game_over"), a.PhaserObjects.game.analytics.game.addEvent(new GA.Events.Progression("Fail:Level:" + b.current_level_index))
            }, o.gotoWinMenu = function(b) {
                function c(b, c, d) {
                    void 0 === c && (c = 1.1), void 0 === d && (d = 15), b.scale.set(1, 1), b.alpha = 0;
                    var e = a.GameTransitionDo.createScaleUpAndDown(b, c, d);
                    return e.states[0].alpha = 0, e.states[1].alpha = 1, e.states[2].alpha = 1, e
                }
                o.fadeOutGameplayMusic(b, 1), o.fadeInMenuMusic(b, 3);
                var d = b.win_menu;
                b.machine_container.visible = !1, b.abilities_container.visible = !1, b.top_stats_container.visible = !1, b.platform_buttons_enabled = !1, b.donkey_button_enabled = !1, b.power_buttons_enabled = !1, b.menu_container.add(d.container), b.machine.current_speed = 0, b.machine.current_speed_goal = 0, a.ButtonDo.resetButton(d.main_menu), a.ButtonDo.resetButton(d.submit), null != d.submit && (d.submit.container.alpha = 0), d.transitions = [];
                for (var e = 0, f = b.machine.all_platforms; e < f.length; e++) {
                    var g = f[e];
                    null != g.archer && a.ArcherDo.clearLevelUp(b, g.archer)
                }
                d.transitions.push(a.GameTransitionDo.createWait(30)), d.transitions.push(c(d.victory, 1.5, 60)), d.transitions.push(a.GameTransitionDo.createWait(60)), d.transitions.push(c(d.text1)), d.transitions.push(a.GameTransitionDo.createWait(30)), d.transitions.push(c(d.text3)), d.transitions.push(a.GameTransitionDo.createWait(30)), d.transitions.push(c(d.text4)), d.transitions.push(a.GameTransitionDo.createWait(1)), d.transitions.push(c(d.submit.container)), d.transitions.push(a.GameTransitionDo.createWait(30)), d.transitions.push(c(d.more_games_button, 1, 30)), d.transitions.push(a.GameTransitionDo.createAlphaOut(d.victory, 1, 120, !1)), d.transitions.push(c(d.main_menu.container, 1, 60)), a.GameTransitionDo.launchTransition(b.transitions, d.transitions[0]), b.win_menu.text3.text = "• Zombies killed: " + b.wallet.zombies_killed, b.win_menu.text4.text = "• Score: " + b.wallet.score, b.state = a.GameState.InWinMenu, a.PhaserObjects.game.analytics.google.sendScreenView("win"), a.PhaserObjects.game.analytics.game.addEvent(new GA.Events.Progression("Complete:Level:" + b.current_level_index))
            }, o.restartLevel = function(a) {
                0 == a.current_level_index ? o.load(a, a.init_saved_game) : null != a.last_levelstart_save ? o.load(a, a.last_levelstart_save) : o.load(a, a.last_save)
            }, o.switchPause = function(b) {
                if (b.state != a.GameState.InPauseMenu) {
                    b.previous_state = b.state, b.state = a.GameState.InPauseMenu, o.safeAdd(b.menu_container, b.pause_menu.container);
                    for (var c = 0, d = b.pause_menu.all_buttons; c < d.length; c++) {
                        var e = d[c];
                        a.ButtonDo.resetButton(e), a.ButtonDo.updateBounds(e, b.pointer)
                    }
                } else b.state = b.previous_state, o.safeRemove(b.pause_menu.container)
            }, o.createArrow = function(b) {
                var c = null;
                return c = b.length > 0 ? b.pop() : a.PixiDo.createSprite(a.GameAssets.arrow), c.position.set(0, 0), c.anchor.set(0, .5), c
            }, o.copyProjectileDamage = function(b) {
                return new a.ProjectileDamage(b.head, b.body, b.legs, b.walking_penalty_coeff)
            }, o.createProjectile = function(b, c, d, e, f, g, h, i) {
                void 0 === h && (h = null), void 0 === i && (i = null);
                var j = null;
                return b.garbage.projectiles.length > 0 ? j = b.garbage.projectiles.pop() : (j = new a.Projectile, j.collision_position = j.position, j.collision_position_before = j.position_before), k.set(j.position, e), k.set(j.position_before, e), k.set(j.velocity, f), j.damage.head = g.head, j.damage.body = g.body, j.damage.legs = g.legs, j.damage.walking_penalty_coeff = g.walking_penalty_coeff, j.damage.attack_penalty_coeff = g.attack_penalty_coeff, j.sprite = c, j.width = d, j.owner = h, j.zombie_target = i, j
            }, o.save = function(b, c) {
                var d = new a.SavedGame;
                d.state = c, d.level_index = b.current_level_index, d.money = b.wallet.money, d.score = b.wallet.score, d.zombies_killed = b.wallet.zombies_killed, d.archers = new Array, d.unlocks = new a.Unlocks, d.unlocks.king.splice(0, d.unlocks.king.length), d.unlocks.donkey.splice(0, d.unlocks.donkey.length), d.unlocks.points = b.power_unlocks.points;
                for (var e = 0, f = b.power_unlocks.king; e < f.length; e++) {
                    var g = f[e];
                    d.unlocks.king.push(g)
                }
                for (var h = 0, i = b.power_unlocks.donkey; h < i.length; h++) {
                    var g = i[h];
                    d.unlocks.donkey.push(g)
                }
                for (var j = 0, k = b.machine.all_platforms; j < k.length; j++) {
                    var l = k[j];
                    null == l.archer ? d.archers.push(null) : d.archers.push(a.ArcherDo.saveArcher(l.archer))
                }
                return d
            }, o.load = function(b, c) {
                a.LevelDo.clear(b), a.ArcherDo.removeAllArchers(b), b.current_level_index = c.level_index, b.wallet.money = c.money, b.wallet.score = c.score, b.wallet.zombies_killed = c.zombies_killed, b.power_unlocks.points = c.unlocks.points, b.power_unlocks.king.splice(0, b.power_unlocks.king.length), b.power_unlocks.donkey.splice(0, b.power_unlocks.donkey.length);
                for (var d = 0, e = c.unlocks.king; d < e.length; d++) {
                    var f = e[d];
                    b.power_unlocks.king.push(f)
                }
                for (var g = 0, h = c.unlocks.donkey; g < h.length; g++) {
                    var f = h[g];
                    b.power_unlocks.donkey.push(f)
                }
                for (var i = 0, j = 0, k = c.archers; j < k.length; j++) {
                    var l = k[j];
                    if (null != l) {
                        var m = b.machine.all_platforms[i];
                        a.ArcherDo.spawn(b, m), a.ArcherDo.loadArcher(b, m.archer, l)
                    }
                    i++
                }
                o.refreshPowerUnlocks(b), c.state == a.SavedState.LevelStart ? 0 == b.current_level_index ? o.gotoStory(b) : (o.gotoLevel(b, b.current_level_index), o.showRoad(b)) : c.state == a.SavedState.UnlockMenu && (o.clear(b), b.donkey.mode = a.DonkeyMode.Stop, b.machine_container.visible = !1, b.abilities_container.visible = !1, b.top_stats_container.visible = !1, b.oasis.container.visible = !1, b.platform_buttons_enabled = !1, b.donkey_button_enabled = !1, b.power_buttons_enabled = !1, b.state = a.GameState.InUnlockMenu, 0 == b.current_level_index ? b.power_unlocks.points = 2 : b.power_unlocks.points = 1, o.alignPowerMenus(b, !1), a.PowerMenuDo.open(b, b.power_menu))
            }, o.fadeInMenuMusic = function(b, c) {
                if (null != a.GameAssets.music_medieval) {
                    var d = a.GameAssets.music_medieval.max_volume / (60 * c);
                    a.SoundDo.fadeInMusic(a.GameAssets.music_medieval, d)
                }
            }, o.fadeOutMenuMusic = function(b, c) {
                if (null != a.GameAssets.music_medieval) {
                    var d = a.GameAssets.music_medieval.max_volume / (60 * c);
                    a.SoundDo.fadeOutMusic(a.GameAssets.music_medieval, d)
                }
            }, o.fadeInGameplayMusic = function(b, c) {
                if (null != a.GameAssets.music_desert) {
                    var d = a.GameAssets.music_desert.max_volume / (60 * c);
                    a.SoundDo.fadeInMusic(a.GameAssets.music_desert, d)
                }
            }, o.fadeOutGameplayMusic = function(b, c) {
                if (null != a.GameAssets.music_desert) {
                    var d = a.GameAssets.music_desert.max_volume / (60 * c);
                    a.SoundDo.fadeOutMusic(a.GameAssets.music_desert, d)
                }
            }, o.launchOverlayTransition = function(b, c, d, e, f) {
                void 0 === c && (c = 1), void 0 === d && (d = 0), void 0 === e && (e = null), void 0 === f && (f = null);
                var g = 0;
                if (1 == b.overlay_transitions.length) {
                    if (!b.pointer.enabled) return;
                    var h = b.overlay_transitions[0];
                    g = h.container.alpha, h.remove_from_container && h.container.parent.remove(h.container), b.overlay_transitions.shift()
                } else if (b.overlay_transitions.length > 1) return;
                b.pointer.enabled = !1, a.GameTransitionDo.launchOverlayTransitionIn(b.overlay_transitions, b.game_container, b.overlay_container, g, c, function() {
                    d > 0 ? (null != f && f(), a.GameTransitionDo.launchWait(b.overlay_transitions, d, function() {
                        null != e && e(), a.GameTransitionDo.launchOverlayTransitionOut(b.overlay_transitions, b.overlay_container, c), b.pointer.enabled = !0
                    })) : (null != e && e(), a.GameTransitionDo.launchOverlayTransitionOut(b.overlay_transitions, b.overlay_container, c), b.pointer.enabled = !0)
                })
            }, o.createFly = function(b) {
                var c = 25,
                    f = Math.random() * c,
                    g = Math.random() * Math.PI * 2 - Math.PI,
                    h = b.x + Math.cos(g) * f,
                    i = b.y + Math.sin(g) * f,
                    j = a.FlyDo.create(new e(h, i), b, 2, 0, new d(.12, .18), new d(1.57, 3.14), c),
                    k = new a.FlyWithGraphics;
                return k.fly = j, k.container = a.PixiDo.createGroup(), k.body = a.PixiDo.createSprite(a.GameAssets.fly_no_wings, .5, .5), k.wings = a.PixiDo.createSprite(a.GameAssets.fly_wings, .5, .5), k.wings.alpha = .5, k.container.add(k.body), k.container.add(k.wings), k
            }, o.updateFly = function(b, c) {
                a.FlyDo.update(b.fly, c), b.container.position.x = b.fly.position.x, b.container.position.y = b.fly.position.y, b.container.rotation = b.fly.angle + Math.PI / 2
            }, o.createCastle = function(b) {
                var c = new a.Castle;
                c.container = a.PixiDo.createGroup();
                var d = 163.35,
                    e = -139,
                    f = -76;
                return a.PixiDo.createAndAddSprite(c.container, a.GameAssets.castle, .5, 1, 0, -211), a.PixiDo.createAndAddSprite(c.container, a.GameAssets.ground_tile, .5, .5, -d, e), a.PixiDo.createAndAddSprite(c.container, a.GameAssets.ground_tile, .5, .5, 0, e), a.PixiDo.createAndAddSprite(c.container, a.GameAssets.ground_tile, .5, .5, d, e), a.PixiDo.createAndAddSprite(c.container, a.GameAssets.ground_tile, .5, .5, -d, f), a.PixiDo.createAndAddSprite(c.container, a.GameAssets.ground_tile, .5, .5, 0, f), a.PixiDo.createAndAddSprite(c.container, a.GameAssets.ground_tile, .5, .5, d, f), c.container.position.y = b + 4, c
            }, o.zombiePositionSort = function(a, b) {
                return a.container.x > b.container.x ? 1 : a.container.x < b.container.x ? -1 : 0
            }, o.zombieSelectedPositionSort = function(a, b) {
                return a.zombie.container.x > b.zombie.container.x ? 1 : a.zombie.container.x < b.zombie.container.x ? -1 : 0
            }, o.anyArcherMenuOpened = function(b) {
                return !!a.ArcherMenuDo.isOpened(b.archer_buy_menu) || (!!a.ArcherMenuDo.isOpened(b.archer_skill_menu) || !!a.ArcherMenuDo.isOpened(b.archer_upgrade_menu))
            }, o.activateArrowRain = function(a) {
                for (var b = a.king.rain_ability, c = (new Array, b.count + b.additional_count), d = 0; d < c; d++) {
                    var f = o.createArrow(a.garbage.arrow_sprites),
                        h = g.getRandomPointInRectangle(b.area);
                    h.x += -a.foreground_container.x;
                    var i = new e(b.speed, 0);
                    k.rotate(i, b.angle + g.getRandomBetween(-b.angle_random_offset, b.angle_random_offset));
                    var j = o.createProjectile(a, f, f.width, h, i, b.arrow_damage, null);
                    a.flying_projectiles.push(j), a.particle_container.add(j.sprite)
                }
            }, o.refreshPowerUnlocks = function(b) {
                b.abilities[1].container.visible = !1, b.abilities[2].container.visible = !1, b.abilities[3].container.visible = !1, b.king.rain_ability.additional_count = 0, b.king.force_ability.additional_force = 0, b.king.rally_ability.skill_add_additional = 0, b.king.curse_ability.damage_per_frame_additional = 0, b.donkey.damage_per_frame_additional = 0, b.donkey.max_health_additional = 0, b.donkey.chance_of_stun = 0, b.donkey.one_hit_kill = !1, b.power_unlocks.king[a.Unlocks.king_force_index] == a.UnlockType.Middle && (b.abilities[1].container.visible = !0), b.power_unlocks.king[a.Unlocks.king_rally_index] == a.UnlockType.Middle && (b.abilities[2].container.visible = !0), b.power_unlocks.king[a.Unlocks.king_curse_index] == a.UnlockType.Middle && (b.abilities[3].container.visible = !0), b.power_unlocks.king[a.Unlocks.king_rain_or_force_index] == a.UnlockType.Up ? b.king.rain_ability.additional_count = Math.round(.35 * b.king.rain_ability.count) : b.power_unlocks.king[a.Unlocks.king_rain_or_force_index] == a.UnlockType.Down && (b.king.force_ability.additional_force = .35 * b.king.force_ability.force), b.power_unlocks.king[a.Unlocks.king_rally_or_curse_index] == a.UnlockType.Up ? b.king.rally_ability.skill_add_additional = .35 * b.king.rally_ability.skill_add : b.power_unlocks.king[a.Unlocks.king_rally_or_curse_index] == a.UnlockType.Down && (b.king.curse_ability.damage_per_frame_additional = .35 * b.king.curse_ability.damage_per_frame), b.donkey.max_health_additional = 0, b.donkey.damage_per_frame_additional = 0, b.power_unlocks.donkey[a.Unlocks.donkey_heart_index] == a.UnlockType.Middle && (b.donkey.max_health_additional += 10), b.power_unlocks.donkey[a.Unlocks.donkey_attack_index] == a.UnlockType.Middle && (b.donkey.damage_per_frame_additional = .3 * (b.donkey.damage_per_frame + b.donkey.damage_per_frame_additional)), b.power_unlocks.donkey[a.Unlocks.donkey_paralysis_index] == a.UnlockType.Middle && (b.donkey.chance_of_stun = .35), b.power_unlocks.donkey[a.Unlocks.donkey_attack_or_heart_index] == a.UnlockType.Up ? b.donkey.damage_per_frame_additional = .5 * (b.donkey.damage_per_frame + b.donkey.damage_per_frame_additional) : b.power_unlocks.donkey[a.Unlocks.donkey_attack_or_heart_index] == a.UnlockType.Down && (b.donkey.max_health_additional += 30), b.power_unlocks.donkey[a.Unlocks.donkey_instant_kill_index] == a.UnlockType.Middle && (b.donkey.one_hit_kill = !0), o.refreshDonkeySpeedControls(b)
            }, o.getTotalArcherCount = function(a) {
                for (var b = 0, c = 0, d = a.machine.all_platforms; c < d.length; c++) {
                    var e = d[c];
                    null != e.archer && b++
                }
                return b
            }, o.updateDisplayTransition = function(a, b, c, d, e) {
                return void 0 === e && (e = .1), c && null == b.parent && (b.alpha = 0, a.add(b)), null == b.parent || (c ? (b.alpha = g.clamp(b.alpha + d * e, 0, 1), 1 == b.alpha) : (b.alpha = g.clamp(b.alpha - d * e, 0, 1), 0 == b.alpha && (a.remove(b), !0)))
            }, o.createMovingCircle = function(b, c) {
                void 0 === b && (b = .9), void 0 === c && (c = 1);
                var d = new a.MovingCircle;
                return d.sprite = a.PixiDo.createSprite(a.GameAssets.archer_selected_circle, .5, .5, 0, 0), d.min_scale = b, d.max_scale = c, d.frame = 0, d
            }, o.updateMovingCircle = function(b, c) {
                b.frame = a.PixiAnimationDo.getNextFrame(0, 1, b.frame + .03 * c);
                var d = h.linearForwardAndBackward(b.min_scale, b.max_scale, b.frame);
                b.sprite.scale.set(d, d)
            }, o.safeRemove = function(a) {
                null != a.parent && a.parent.remove(a)
            }, o.safeAdd = function(a, b) {
                null == b.parent && a.add(b)
            }, o.wait = function(b, c, d) {
                return null == b.wait ? (b.wait = new a.Wait(0, d), !1) : (b.wait.current += c, b.wait.current >= b.wait.max && (b.wait = null, !0))
            }, o.alignPowerMenus = function(b, c) {
                if (!c || c && 1 == b.power_menu.container.alpha) {
                    var d = (b.js_info.current_game_width - b.power_menu.background.width) / 2;
                    b.power_menu.container.x != d && (b.power_menu.container.x = d, a.PowerMenuDo.refresh(b, b.power_menu))
                }
                if (a.PowerMenuDo.isOpenedSub(b.power_sub_menu) && (!c || c && 1 == b.power_sub_menu.container.alpha)) {
                    var e = b.power_sub_menu.position.x + b.power_menu.container.position.x;
                    b.power_sub_menu.container.position.x != e && (b.power_sub_menu.container.position.x = e)
                }
            }, o.setCustomArcherLevelByCoeff = function(b, c) {
                void 0 === c && (c = .65);
                var d = c;
                b.total_hits = Math.round(Math.asin(d / a.Archer.max_levels) / (.5 * Math.PI) * a.Archer.max_hits_for_max_skills)
            }, o.showRoad = function(b) {
                b.text_road.text = "Road " + (b.current_level_index + 1 + "/" + b.level_descriptions.levels.length), b.text_road_name.text = b.level_descriptions.levels[b.current_level_index].name, b.text_road.position.x = b.road_text_position.x - b.text_road.width / 2, b.text_road.position.y = b.road_text_position.y, b.text_road_name.position.x = b.road_text_position.x - b.text_road_name.width / 2, b.text_road_name.position.y = b.road_text_position.y + 60, b.menu_container.add(b.text_road), b.menu_container.add(b.text_road_name), b.text_road.alpha = 0, b.text_road_name.alpha = 0, a.GameTransitionDo.launchAlphaInOut(b.transitions, b.text_road, 60, 60, 60, !0), a.GameTransitionDo.launchAlphaInOut(b.transitions, b.text_road_name, 60, 60, 60, !0), a.SoundDo.playSound(a.GameAssets.sound_bell)
            }, o.pushZombieSelected = function(a, b) {
                for (var c = a.zombie_selection, d = a.total_archer_count, e = 0, f = c.selected_zombies; e < f.length; e++) {
                    var g = f[e];
                    if (g.zombie == b) return void(g.zombie = null)
                }
                if (0 != d) {
                    var h = null;
                    if (c.sorted_by_selection_zombies.length >= d) h = c.sorted_by_selection_zombies[0];
                    else
                        for (var i = 0, j = c.selected_zombies; i < j.length; i++) {
                            var k = j[i];
                            if (null == k.zombie) {
                                h = k;
                                break
                            }
                        }
                    null != h && (h.targeted_by = null, h.zombie = b)
                }
            }, o.canAffordNewUpgrade = function(a, b) {
                return a.current_index + 1 < a.amounts.length && a.amounts[a.current_index + 1].price <= b
            }, o.getDuneTextureByType = function(b) {
                switch (b) {
                    case a.DuneType.wave:
                        return a.GameAssets.dune_wave;
                    case a.DuneType.triangle:
                        return a.GameAssets.dune_triangle;
                    case a.DuneType.big:
                        return a.GameAssets.dune_big;
                    case a.DuneType.medium:
                        return a.GameAssets.dune_medium;
                    case a.DuneType.flat:
                        return a.GameAssets.dune_flat;
                    case a.DuneType.rock_big:
                        return a.GameAssets.dune_rock_big;
                    case a.DuneType.rock_double:
                        return a.GameAssets.dune_rock_double;
                    case a.DuneType.rock_flat:
                        return a.GameAssets.dune_rock_flat;
                    case a.DuneType.rock_medium:
                        return a.GameAssets.dune_rock_medium;
                    case a.DuneType.rock_pointy:
                        return a.GameAssets.dune_rock_pointy;
                    case a.DuneType.regular_to_rock:
                        return a.GameAssets.dune_regular_to_rock;
                    case a.DuneType.rock_to_regular:
                        return a.GameAssets.dune_rock_to_regular
                }
                return null
            }, o.getArcherPrice = function(b, c) {
                var d = a.Archer.archer_buy_prices[b.machine.all_platforms.indexOf(c)];
                return b.archers.length > 0 && (d += a.Archer.archer_buy_increased_prices[b.archers.length - 1]), d
            }, o.refreshDonkeySpeedControls = function(b) {
                var c = b.donkey;
                b.js_info;
                c.button_1x.global_bounds.x = 0, c.button_3x.global_bounds.x = 100;
                for (var d = 0, e = b.abilities; d < e.length; d++) {
                    var f = e[d];
                    f.container.visible && (c.button_1x.global_bounds.x = f.container.x + f.container.width - 30, c.button_3x.global_bounds.x = c.button_1x.global_bounds.x + 100)
                }
                c.speed_mode == a.DonkeySpeedMode.Speed1x ? (c.speed_frame.position.x = c.button_1x.global_bounds.x, b.machine.speed_multiplier = 1.5) : c.speed_mode == a.DonkeySpeedMode.Speed3x && (c.speed_frame.position.x = c.button_3x.global_bounds.x, b.machine.speed_multiplier = 3), b.machine.current_max_speed = b.machine.max_speed * b.machine.speed_multiplier, c.speed_1x.position.x = c.button_1x.global_bounds.x + 41, c.speed_3x.position.x = c.button_3x.global_bounds.x + 41
            }, o.setDonkeySpeedControlVisiblity = function(a, b) {
                a.donkey.speed_1x.visible = b, a.donkey.speed_3x.visible = b, a.donkey.speed_frame.visible = b
            }, o.moreGamesCreate = function(b, c) {
                Fabrique.Utils.isOnDevice(a.PhaserObjects.game) || Fabrique.Utils.getBrandingDomain() == Fabrique.BrandingDomain.Bild || Fabrique.Branding.isContracted(a.PhaserObjects.game) ? b.visible = !1 : (a.PhaserObjects.more_games_menu || (a.PhaserObjects.more_games_menu = new Fabrique.MoreGames.Menu(a.PhaserObjects.game, "medieval-defence-z")), a.PhaserObjects.game.add.existing(a.PhaserObjects.more_games_menu))
            }, o.moreGamesClick = function() {
                a.PhaserObjects.more_games_menu.visible = !0, a.PhaserObjects.more_games_menu.x = a.PhaserObjects.game.width / 2, a.PhaserObjects.more_games_menu.y = a.PhaserObjects.game.height / 2
            }, o.bikasNetClick = function() {
                window.open("http://www.bikas.net", "_blank")
            }, o.updateMoreGamesButtonVisibility = function(a, b) {
                for (var c = b.parent, d = !1; null != c;) {
                    if (c == a.game_container) {
                        d = !0;
                        break
                    }
                    c = c.parent
                }
                d ? b.inputEnabled || (b.inputEnabled = !0) : b.inputEnabled && (b.inputEnabled = !1)
            }, o.update = function(b, c) {
                var d = c / (1e3 / b.js_info.game_fps),
                    e = d * b.delta_update_coeff * b.delta_update_coeff_by_menu * b.delta_update_coeff_by_effect,
                    f = d * b.delta_update_coeff,
                    g = a.JsDo.getTimer();
                if (b.total_elapsed_time += d, a.TransitionDo.update(b.overlay_transitions, d, f), a.ButtonDo.updateButton(b.pause_button, b.pointer), a.SoundDo.updateMusic(a.GameAssets.music_medieval, a.SoundDo.music_enabled), a.SoundDo.updateMusic(a.GameAssets.music_desert, a.SoundDo.music_enabled), a.SoundDo.updateMusic(a.GameAssets.sound_loop_flies, a.SoundDo.sounds_enabled), a.SoundDo.updateMusic(a.GameAssets.sound_loop_eating, a.SoundDo.sounds_enabled), o.updateMoreGamesButtonVisibility(b, b.start_menu.more_games_button), o.updateMoreGamesButtonVisibility(b, b.pause_menu.more_games_button), o.updateMoreGamesButtonVisibility(b, b.win_menu.more_games_button), o.updateTrailer(b, d, e, f) && o.updateMenuAndTutorial(b, d, e, f)) {
                    b.zombies_approaching = 0, b.zombies_close_to_machine = 0, b.zombies_very_close_to_donkey = 0, b.zombies_attacking_donkey = 0, b.zombies.sort(o.zombiePositionSort), d *= 1.25, e *= 1.25, o.updateSpawn(b, d, e, f), o.updateArchers(b, d, e, f), o.updateZombies(b, d, e, f), o.updateTreasureChests(b, d, e, f), o.updateKingAbilities(b, d, e, f), o.updateProjectiles(b, d, e, f), o.updateDonkey(b, d, e, f), o.updateConsequences(b, d, e, f), a.TransitionDo.update(b.transitions, e, f), o.updateEffects(b, d, e, f);
                    for (var h = 0, i = b.flies; h < i.length; h++) {
                        var j = i[h];
                        o.updateFly(j, e)
                    }
                    o.updateZombieSelection(b, d, e, f), o.updateDeadZombies(b, d, e, f), o.updateStuckProjectiles(b, d, e, f), o.updateLevel(b, d, e, f), o.updateInGameMenus(b, d, e, f), o.updateTopStatsDisplay(b, d, e, f), a.GameButtonDo.updateBuffer(b.button_buffer, b.pointer), a.GameButtonDo.clearBuffer(b.button_buffer), b.game_update_time = a.JsDo.getTimer() - g, o.updateDebugStuff(b, d, e, f)
                }
            }, o.updateTrailer = function(b, c, d, e) {
                if (b.trailer.state != a.TrailerState.None) {
                    var f = b.trailer,
                        g = 15,
                        h = 30,
                        i = 2,
                        j = 3,
                        k = 8,
                        l = 12;
                    switch (f.state) {
                        case a.TrailerState.None:
                            break;
                        case a.TrailerState.AnimIn:
                            o.safeAdd(b.game_container, f.background), o.safeAdd(b.game_container, f.container), f.container.alpha = 0, f.background.alpha = 0, f.state = a.TrailerState.AnimBackground;
                            break;
                        case a.TrailerState.AnimBackground:
                            f.background.alpha += c / 15, f.background.alpha >= 1 && (f.background.alpha = 1, f.medieval.alpha = 0, f.defense.alpha = 0, f.logo.alpha = 0, f.arrow1.alpha = 0, f.arrow2.alpha = 0, f.by_bikas.alpha = 0, f.container.alpha = 1, f.state = a.TrailerState.AnimWaitMedieval);
                            break;
                        case a.TrailerState.AnimWaitMedieval:
                            o.wait(b, d, 15) && (f.background_dark.alpha = 0, f.state = a.TrailerState.AnimMedieval);
                            break;
                        case a.TrailerState.AnimMedieval:
                            null == f.current_transition ? (a.SoundDo.playSound(a.GameAssets.sound_transition_in), f.current_transition = a.GameTransitionDo.launchTrailerSpriteIn(f.transitions, f.medieval, g)) : f.current_transition.finished && (a.SoundDo.playSound(a.GameAssets.sound_bang_short), f.current_transition = null, a.GameTransitionDo.launchShakeEffect(f.transitions, f.container, k, i, i), f.state = a.TrailerState.AnimDefense);
                            break;
                        case a.TrailerState.AnimDefense:
                            null == f.current_transition ? (a.SoundDo.playSound(a.GameAssets.sound_transition_in), f.current_transition = a.GameTransitionDo.launchTrailerSpriteIn(f.transitions, f.defense, g)) : f.current_transition.finished && (a.SoundDo.playSound(a.GameAssets.sound_bang_short), f.current_transition = null, a.GameTransitionDo.launchShakeEffect(f.transitions, f.container, k, i, i), f.state = a.TrailerState.AnimLogo);
                            break;
                        case a.TrailerState.AnimLogo:
                            null == f.current_transition && (a.SoundDo.playSound(a.GameAssets.sound_transition_in), f.current_transition = a.GameTransitionDo.launchTrailerSpriteIn(f.transitions, f.logo, h), a.GameTransitionDo.launchTrailerArrowIn(f.transitions, f.arrow1, h), a.GameTransitionDo.launchTrailerArrowIn(f.transitions, f.arrow2, h)), f.current_transition.finished && (a.SoundDo.playSound(a.GameAssets.sound_bang), f.current_transition = null, a.GameTransitionDo.launchShakeEffect(f.transitions, f.container, l, j, j), a.GameTransitionDo.launchAlphaIn(f.transitions, f.by_bikas, 45, !1), f.state = a.TrailerState.Idle);
                            break;
                        case a.TrailerState.Idle:
                            o.wait(b, d, 60 + f.temp_additional_wait) && (f.state = a.TrailerState.AnimOut, f.temp_additional_wait = 0, null != f.temp_before_finish && (f.temp_before_finish(), f.temp_before_finish = null));
                            break;
                        case a.TrailerState.AnimOut:
                            var m = c / 30;
                            f.container.alpha -= m, f.background.alpha -= m, f.container.alpha <= 0 && (f.background.alpha = 0, f.container.alpha = 1, o.safeRemove(f.background_dark), o.safeRemove(f.background), o.safeRemove(f.container), f.state = a.TrailerState.None)
                    }
                    if (a.TransitionDo.update(f.transitions, d, d), f.state != a.TrailerState.AnimOut) return !1
                }
                return !0
            }, o.updateMenuAndTutorial = function(b, c, d, e) {
                var f = b.js_info,
                    h = b.pointer;
                b.machine, b.donkey;
                if (b.state == a.GameState.InUpdateDisabled) return !1;
                if (b.state == a.GameState.InStartMenu) {
                    b.delta_update_coeff_by_menu = 1;
                    var i = b.start_menu;
                    b.dunes_container.position.x = 0;
                    for (var j = 0, k = i.rays; j < k.length; j++) {
                        var l = k[j];
                        l.sprite.alpha += l.current_alpha_change, l.sprite.alpha = g.clamp(l.sprite.alpha, 0, l.max_alpha), l.sprite.alpha == l.max_alpha ? l.current_alpha_change = -g.getRandomBetween(l.alpha_change_min, l.alpha_change_max) : 0 == l.sprite.alpha && (l.current_alpha_change = g.getRandomBetween(l.alpha_change_min, l.alpha_change_max))
                    }
                    for (var m = 0, n = b.start_menu.flies; m < n.length; m++) {
                        var p = n[m];
                        o.updateFly(p, d)
                    }
                    return a.TransitionDo.update(b.transitions, d, e), i.button_continue.container.visible && b.button_buffer.push(i.button_continue), b.button_buffer.push(i.button_new_game), b.button_buffer.push(i.button_credits),
                        a.GameButtonDo.updateBuffer(b.button_buffer, h), a.GameButtonDo.clearBuffer(b.button_buffer), !1
                }
                if (b.state == a.GameState.InTransitionToStory) o.wait(b, d, 50) && (b.state = a.GameState.InStory, a.ButtonDo.resetButton(b.story_menu.start));
                else if (b.state == a.GameState.InStory) {
                    var q = b.story_menu;
                    q.text.alpha < 1 ? q.text.alpha = g.clamp(q.text.alpha + d / 75, 0, 1) : q.start.container.alpha < 1 ? (q.start.container.alpha = g.clamp(q.start.container.alpha + d / 50, 0, 1), b.button_buffer.push(q.start)) : b.button_buffer.push(q.start)
                } else if (b.state == a.GameState.InTransitionToTutorial) {
                    var q = b.story_menu;
                    q.text.alpha = g.clamp(q.text.alpha - d / 10, 0, 1), q.start.container.alpha = g.clamp(q.start.container.alpha - d / 10, 0, 1), 0 == q.text.alpha && (b.state = a.GameState.InDonkeyClick, o.safeRemove(q.container))
                } else if (b.state == a.GameState.InDonkeyClick) o.updateDisplayTransition(b.menu_container, b.text_click_donkey, !0, d), b.donkey_button_enabled = !0, 1 == b.text_click_donkey.alpha && (b.donkey.time_to_move_current_wait = b.donkey.time_to_move_max_wait), b.donkey.mode == a.DonkeyMode.Walk && (b.treasure_buttons_enabled = !0, b.machine.current_max_speed = b.machine.max_speed * b.machine.speed_multiplier, b.state = a.GameState.InArcherHire, o.showRoad(b), a.SoundDo.replayMusic(a.GameAssets.music_desert));
                else if (b.state == a.GameState.InArcherHire) {
                    if (o.updateDisplayTransition(b.menu_container, b.text_click_donkey, !1, d), b.wallet.money >= o.getArcherPrice(b, b.machine.right_top)) {
                        if (!a.ArcherMenuDo.isOpened(b.archer_buy_menu))
                            if (0 == b.moving_circles.length)
                                for (var r = 0, s = b.machine.all_platforms; r < s.length; r++) {
                                    var t = s[r];
                                    if (null == t.archer) {
                                        var u = o.createMovingCircle();
                                        u.sprite.position.x = t.buy_sign.position.x, u.sprite.position.y = -90, t.container.add(u.sprite), b.moving_circles.push(u)
                                    }
                                } else
                                    for (var v = 0, w = b.moving_circles; v < w.length; v++) {
                                        var u = w[v];
                                        o.updateMovingCircle(u, d)
                                    }
                            a.TransitionDo.update(b.transitions, d, e), o.updateDisplayTransition(b.menu_container, b.text_click_archer, !0, d);
                        for (var x = 0, y = b.machine.all_platforms; x < y.length; x++) {
                            var t = y[x];
                            null == t.archer && b.button_buffer.push(t.button)
                        }
                        if (a.ArcherMenuDo.isOpened(b.archer_buy_menu)) {
                            for (var z = 0, A = b.moving_circles; z < A.length; z++) {
                                var u = A[z];
                                u.sprite.parent.remove(u.sprite)
                            }
                            b.moving_circles = [], a.ArcherMenuDo.addToBuffer(b.button_buffer, b.archer_buy_menu, h)
                        }
                        return a.GameButtonDo.updateBuffer(b.button_buffer, h), a.GameButtonDo.clearBuffer(b.button_buffer), !1
                    }
                    if (b.archers.length >= 2) {
                        b.state = a.GameState.InRainPower, b.platform_buttons_enabled = !0;
                        for (var B = 0, C = b.moving_circles; B < C.length; B++) {
                            var u = C[B];
                            u.sprite.parent.remove(u.sprite)
                        }
                        b.moving_circles = []
                    }
                } else if (b.state == a.GameState.InRainPower) {
                    if (o.updateDisplayTransition(b.menu_container, b.text_click_donkey, !1, d), o.updateDisplayTransition(b.menu_container, b.text_click_archer, !1, d), b.abilities[0].container.visible) {
                        if (o.updateDisplayTransition(b.menu_container, b.text_click_power, !0, d), a.ButtonDo.updateButton(b.abilities[0].button, h), 0 == b.moving_circles.length) {
                            var u = o.createMovingCircle(1.35, 1.5);
                            u.sprite.position.x = b.abilities[0].container.x, u.sprite.position.y = b.abilities[0].container.y, b.menu_container.add(u.sprite), b.moving_circles.push(u)
                        } else o.updateMovingCircle(b.moving_circles[0], d);
                        return b.abilities[0].state == a.AbilityState.Activated && (b.state = a.GameState.InArcherUpgrade, o.safeRemove(b.moving_circles[0].sprite), b.moving_circles = []), !1
                    }
                    var D = 5;
                    if (b.zombies_approaching >= D) {
                        for (var E = 0, F = b.king.rain_ability.area.x + 350, G = F + b.king.rain_ability.area.width - 150, H = 0; H < b.zombies_approaching; H++)
                            if (H < b.zombies.length) {
                                var I = b.zombies[H].container.position,
                                    J = b.foreground_container.position.x + I.x;
                                g.isValueBetween(J, F, G) && E++
                            }
                        E >= D && (b.abilities[0].container.visible = !0, b.power_buttons_enabled = !0)
                    }
                } else if (b.state == a.GameState.InArcherUpgrade) {
                    if (o.updateDisplayTransition(b.menu_container, b.text_click_donkey, !1, d), o.updateDisplayTransition(b.menu_container, b.text_click_archer, !1, d), o.updateDisplayTransition(b.menu_container, b.text_click_power, !1, d), b.wallet.money >= a.Archer.hook_settings[1].price) {
                        a.TransitionDo.update(b.transitions, d, e), o.updateDisplayTransition(b.menu_container, b.text_click_upgrades, !0, d);
                        for (var K = 0, L = b.machine.all_platforms; K < L.length; K++) {
                            var t = L[K];
                            null != t.archer && b.button_buffer.push(t.button)
                        }
                        if (a.ArcherMenuDo.isOpened(b.archer_upgrade_menu)) {
                            for (var M = 0, N = b.moving_circles; M < N.length; M++) {
                                var u = N[M];
                                u.sprite.parent.remove(u.sprite)
                            }
                            b.moving_circles = [], a.ArcherMenuDo.addToBuffer(b.button_buffer, b.archer_upgrade_menu, h)
                        } else if (0 == b.moving_circles.length)
                            for (var O = 0, P = b.machine.all_platforms; O < P.length; O++) {
                                var t = P[O];
                                if (null != t.archer) {
                                    var u = o.createMovingCircle();
                                    u.sprite.position.x = t.buy_sign.position.x, u.sprite.position.y = -90, t.container.add(u.sprite), b.moving_circles.push(u)
                                }
                            } else
                                for (var Q = 0, R = b.moving_circles; Q < R.length; Q++) {
                                    var u = R[Q];
                                    o.updateMovingCircle(u, d)
                                }
                        return a.GameButtonDo.updateBuffer(b.button_buffer, h), a.GameButtonDo.clearBuffer(b.button_buffer), !1
                    }
                    for (var S = !1, T = 0, U = b.archers; T < U.length; T++) {
                        var V = U[T];
                        if (V.hook.current_index > 0) {
                            S = !0;
                            break
                        }
                        if (V.sharpness.current_index > 0) {
                            S = !0;
                            break
                        }
                        if (V.xarrows.current_index > 0) {
                            S = !0;
                            break
                        }
                    }
                    if (S) {
                        b.state = a.GameState.InTransitionToLevel;
                        for (var W = 0, X = b.moving_circles; W < X.length; W++) {
                            var u = X[W];
                            u.sprite.parent.remove(u.sprite)
                        }
                        b.moving_circles = []
                    }
                } else if (b.state == a.GameState.InTransitionToLevel) o.updateDisplayTransition(b.menu_container, b.text_click_donkey, !1, d), o.updateDisplayTransition(b.menu_container, b.text_click_archer, !1, d), o.updateDisplayTransition(b.menu_container, b.text_click_power, !1, d), o.updateDisplayTransition(b.menu_container, b.text_click_upgrades, !1, d), null == b.text_click_upgrades.parent && (b.state = a.GameState.InLevel);
                else if (b.state == a.GameState.InOasis) {
                    b.donkey.mode = a.DonkeyMode.Stop, b.donkey_button_enabled = !1, b.power_buttons_enabled = !1;
                    for (var Y = !0, Z = 0, $ = b.archers; Z < $.length; Z++) {
                        var V = $[Z];
                        if (V.skill_points > 0) {
                            Y = !1;
                            break
                        }
                    }
                    b.any_archer_menu_opened && (Y = !1), b.any_ability_is_active && (Y = !1), Y && (o.fadeOutGameplayMusic(b, 1), o.fadeInMenuMusic(b, 2), a.SoundDo.playSound(a.GameAssets.sound_drums), b.platform_buttons_enabled = !1, b.donkey.current_health = b.donkey.max_health + b.donkey.max_health_additional, b.top_stats.health.current_transition = a.GameTransitionDo.launchScaleUpAndDown(b.transitions, b.top_stats.health.container, 1.5, 10), b.oasis.text3.text = "• Zombies killed: " + b.wallet.zombies_killed, b.oasis.text4.text = "• Score: " + b.wallet.score, b.state = a.GameState.InOasisStats, a.ButtonDo.resetButton(b.oasis.next), b.last_save = o.save(b, a.SavedState.UnlockMenu), a.GameSerializerDo.saveToStorage(b.serial_data, b.last_save))
                } else if (b.state == a.GameState.InOasisStats) b.platform_buttons_enabled = !1, b.donkey_button_enabled = !1, b.power_buttons_enabled = !1, a.ButtonDo.updateBounds(b.oasis.next, h), a.ButtonDo.updateButton(b.oasis.next, h), o.updateDisplayTransition(b.oasis.container, b.oasis.menu, !0, d);
                else if (b.state == a.GameState.InTransitionToUnlockMenu) o.updateDisplayTransition(b.oasis.container, b.oasis.menu, !1, d), 0 == b.current_level_index ? b.power_unlocks.points = 2 : b.power_unlocks.points = 1, b.platform_buttons_enabled = !1, b.donkey_button_enabled = !1, b.power_buttons_enabled = !1, b.state = a.GameState.InUnlockMenu, o.alignPowerMenus(b, !1), a.PowerMenuDo.open(b, b.power_menu);
                else if (b.state == a.GameState.InUnlockMenu) {
                    if (o.updateDisplayTransition(b.oasis.container, b.oasis.menu, !1, d), b.platform_buttons_enabled = !1, b.donkey_button_enabled = !1, b.power_buttons_enabled = !1, o.alignPowerMenus(b, !0), 0 == b.power_unlocks.points) o.wait(b, d, 60) && (b.state = a.GameState.InTransitionFromUnlockToContinue, a.PowerMenuDo.close(b, b.power_menu, 15), b.oasis.text.visible = !1);
                    else if (b.in_tutorial_mode && 2 == b.power_unlocks.points && 0 == b.moving_circles.length && o.wait(b, d, 30)) {
                        var u = o.createMovingCircle(1.3 * .9, 1.3),
                            _ = a.PixiDo.getContainerBounds(b.power_menu.king_unlocks[0].button.container),
                            I = g.getRectangleMiddle(_);
                        u.sprite.position.x = I.x, u.sprite.position.y = I.y, b.menu_container.add(u.sprite), b.moving_circles.push(u);
                        var aa = o.createMovingCircle(1.3 * .9, 1.3),
                            ba = a.PixiDo.getContainerBounds(b.power_menu.donkey_unlocks[0].button.container),
                            ca = g.getRectangleMiddle(ba);
                        aa.sprite.position.x = ca.x, aa.sprite.position.y = ca.y, b.menu_container.add(aa.sprite), b.moving_circles.push(aa)
                    }
                    if (b.moving_circles.length > 0)
                        if (2 != b.power_unlocks.points) {
                            for (var da = 0, ea = b.moving_circles; da < ea.length; da++) {
                                var u = ea[da];
                                o.safeRemove(u.sprite)
                            }
                            b.moving_circles = []
                        } else
                            for (var fa = 0, ga = b.moving_circles; fa < ga.length; fa++) {
                                var u = ga[fa];
                                o.updateMovingCircle(u, e)
                            }
                } else if (b.state == a.GameState.InTransitionFromUnlockToContinue) o.wait(b, d, 15) && (b.state = a.GameState.InContinueLevel, a.ButtonDo.resetButton(b.continue_button));
                else if (b.state == a.GameState.InContinueLevel) o.updateDisplayTransition(b.menu_container, b.continue_button.container, !0, d, .05), a.ButtonDo.updateBounds(b.continue_button, h), a.ButtonDo.updateButton(b.continue_button, h);
                else {
                    if (b.state == a.GameState.InStartLevel) return b.continue_button.container.parent.remove(b.continue_button.container), o.gotoLevel(b, b.current_level_index + 1), b.last_save = o.save(b, a.SavedState.LevelStart), b.last_levelstart_save = b.last_save, a.GameSerializerDo.saveToStorage(b.serial_data, b.last_save), b.config.save_separate_levels && a.GameSerializerDo.saveToStorage(b.serial_data, b.last_save, "medieval_defense_z_level_" + b.current_level_index), o.showRoad(b), !1;
                    if (b.state == a.GameState.InTransitionToDeathMenu) return !1;
                    if (b.state == a.GameState.InDeathMenu) {
                        var ha = b.death_menu;
                        ha.aligned_width != f.current_game_width && (ha.aligned_width = f.current_game_width, ha.text_dead.position.x = f.current_game_width / 2, ha.restart_button.container.position.x = f.current_game_width / 2 - 23, a.ButtonDo.resetButton(ha.restart_button), a.ButtonDo.updateBounds(ha.restart_button, h)), a.ButtonDo.updateButton(ha.restart_button, h), a.TransitionDo.update(b.transitions, d, e);
                        for (var ia = 0, ja = ha.zombies; ia < ja.length; ia++) {
                            var ka = ja[ia];
                            a.PixiAnimationDo.playRange(ka.anim, ka.anim_ranges.feeding, d)
                        }
                        for (var la = 0, ma = ha.flies; la < ma.length; la++) {
                            var p = ma[la];
                            o.updateFly(p, d)
                        }
                        return !1
                    }
                    if (b.state == a.GameState.InPauseMenu) {
                        var na = b.pause_menu;
                        if (na.aligned_x != f.current_game_width / 2) {
                            na.aligned_x = f.current_game_width / 2, na.button_container.position.x = na.aligned_x;
                            for (var oa = 0, pa = na.all_buttons; oa < pa.length; oa++) {
                                var qa = pa[oa];
                                a.ButtonDo.resetButton(qa)
                            }
                            na.sound_button.container.position.y = na.sound_button.container.height / 2 + 20, na.music_button.container.position.y = na.sound_button.container.position.y, na.sound_button.container.position.x = f.current_game_width - na.sound_button.container.width / 2 - 20, na.music_button.container.position.x = na.sound_button.container.position.x - na.sound_button.container.width - 20;
                            for (var ra = 0, sa = na.all_buttons; ra < sa.length; ra++) {
                                var qa = sa[ra];
                                a.ButtonDo.updateBounds(qa, h)
                            }
                        }
                        for (var ta = 0, ua = na.all_buttons; ta < ua.length; ta++) {
                            var qa = ua[ta];
                            b.button_buffer.push(qa)
                        }
                        return a.GameButtonDo.updateBuffer(b.button_buffer, h), !1
                    }
                    if (b.state == a.GameState.InTransitionToWinMenu);
                    else if (b.state == a.GameState.InWinMenu) {
                        var va = b.win_menu;
                        b.distance.traveled_in_pixels = b.distance.to_oasis_in_pixels - b.castle.container.width / 2 + 30 + (f.original_max_game_width - f.current_game_width) / 2, b.foreground_container.position.x = -b.distance.traveled_in_pixels;
                        var wa = b.castle.container.position.x + b.foreground_container.position.x;
                        va.aligned_x != wa && (va.aligned_x = wa, va.container.position.x = wa, a.ButtonDo.resetButton(va.main_menu), a.ButtonDo.resetButton(va.submit), a.ButtonDo.updateBounds(va.main_menu, h), a.ButtonDo.updateBounds(va.submit, h)), va.main_menu.container.alpha > 0 && b.button_buffer.push(va.main_menu), null != va.submit && va.submit.container.visible && va.submit.container.alpha > 0 && b.button_buffer.push(va.submit), va.transitions.length > 0 && va.transitions[0].finished && (va.transitions.shift(), va.transitions.length > 0 && a.GameTransitionDo.launchTransition(b.transitions, va.transitions[0]))
                    }
                }
                return !0
            }, o.updateSpawn = function(b, c, d, e) {
                if (b.spawns.length > 0)
                    for (var f = !0; f;) {
                        var g = b.foreground_container.position.x + b.spawns[0].position_x;
                        if (g - b.zombie_spawn_distance <= 0) {
                            var h = b.spawns[0].zombie_type,
                                i = b.spawns[0].money;
                            switch (b.spawns[0].type) {
                                case a.SpawnType.SpawnZombie:
                                    a.ZombieDo.spawn(b, h, b.spawns[0].position_x, !0);
                                    break;
                                case a.SpawnType.SpawnTresureChest:
                                    a.ItemDo.spawnTreasureChest(b, i, b.spawns[0].position_x)
                            }
                            b.spawns.shift(), f = b.spawns.length > 0
                        } else f = !1
                    }
            }, o.updateArchers = function(b, c, d, e) {
                for (var f = b.machine, i = b.donkey, j = 0, k = b.machine.all_platforms_reversed; j < k.length; j++) {
                    var l = k[j],
                        m = l.archer;
                    if (null != m) {
                        var n = b.zombie_selection,
                            p = a.ArcherDo.getShootingCoeff(m);
                        if (m.state == a.ArcherState.Resting) {
                            if (m.total_resting_time += d, a.ArcherDo.updateStandardRotation(m), m.resting.current -= d * p, m.resting.current < m.resting.min) {
                                m.resting.current = m.resting.min;
                                var q = null;
                                if (q = a.ArcherDo.pickZombieFromSelection(b, m, n, null), null == q) switch (m.target_select_type) {
                                    case a.ArcherTargetSelectType.ClosestRandom:
                                        q = a.ArcherDo.selectTarget(b, i, m);
                                        break;
                                    case a.ArcherTargetSelectType.AlwaysFirst:
                                        b.zombies.length > 0 && (q = b.zombies[0])
                                }
                                var r = !1;
                                if (null != q) {
                                    a.JsDo.getTimer();
                                    r = a.ArcherDo.shootArrowAtTarget(b, m, b.gravity, f.current_speed_goal, q), r && (m.anim.current_frame == a.Archer.loading_anim_range.end ? m.state = a.ArcherState.Shooting : m.state = a.ArcherState.Loading)
                                } else r = !1;
                                r || (m.resting.current = (m.resting.max + m.resting.min) / 2)
                            }
                        } else if (m.state == a.ArcherState.Loading) {
                            m.total_resting_time = 0;
                            var s = a.PixiAnimationDo.playRangeOnce(m.anim, a.Archer.loading_anim_range, p * d, !1);
                            if (a.ArcherDo.updateLoadingArrows(m), s) {
                                a.PixiAnimationDo.gotoFrame(m.anim, a.Archer.loading_anim_range.end), m.state = a.ArcherState.Resting;
                                var q = a.ArcherDo.pickZombieFromSelection(b, m, n, m.zombie_target);
                                null != q && (m.zombie_target = q), m.zombie_target.health > 0 ? a.ArcherDo.shootArrowAtTarget(b, m, b.gravity, f.current_speed_goal, m.zombie_target) ? m.state = a.ArcherState.Shooting : (m.resting.current = (m.resting.max - m.resting.min) / 2, m.zombie_target.targeted_by_defenders_count--) : m.resting.current = (m.resting.max - m.resting.min) / 2
                            }
                        } else if (m.state == a.ArcherState.Shooting) {
                            m.total_resting_time = 0;
                            var t = a.PixiAnimationDo.playRangeOnce(m.anim, a.Archer.shooting_anim_range, p * d);
                            if (a.ArcherDo.updateLoadingArrows(m), t) {
                                for (var u = a.ArcherDo.tansferArrowsFromArcherToGlobal(m, b), v = 0, w = 0, x = u; w < x.length; w++) {
                                    var y = x[w],
                                        z = o.createProjectile(b, y, y.width, a.PixiDo.convertPoint(y.position), m.launch_vectors[v], m.damage_current, m, m.zombie_target);
                                    b.flying_projectiles.push(z), v++
                                }
                                m.resting.current = m.resting.max, m.state = a.ArcherState.Resting, a.PixiAnimationDo.gotoFrame(m.anim, 1), a.SoundDo.playSound(a.GameAssets.sound_arrow)
                            }
                        }
                        var A = g.interpolateSmoothIn(0, 1, m.total_hits / a.Archer.max_hits_for_max_skills),
                            B = Math.floor(A * a.Archer.max_levels);
                        if (B <= a.Archer.max_levels && m.current_level < B) {
                            var C = a.Archer.skills_per_level * (B - m.current_level);
                            m.skill_points += C, m.current_level = B, a.PhaserObjects.game.analytics.game.addEvent(new GA.Events.Resource("Source:SkillPoints:Reward:Archer", C))
                        }
                        if (b.state != a.GameState.InArcherUpgrade && m.skill_points > 0 && 0 == m.platform.selected_sprite.visible && (m.platform.selected_sprite.visible = !0, null == m.level_up_transition && (m.level_up_transition = a.GameTransitionDo.launchLevelUp(b.transitions, b.menu_container, a.GameAssets.level_up, m), m.level_up_anim_frame = 0, a.SoundDo.playSound(a.GameAssets.sound_level_up))), null != m.level_up_transition) {
                            m.level_up_anim_frame = a.PixiAnimationDo.getNextFrame(0, 1, m.level_up_anim_frame + .03 * d), o.anyArcherMenuOpened(b) && (m.level_up_anim_frame = 0);
                            var D = h.linearForwardAndBackward(.9, 1, m.level_up_anim_frame);
                            m.level_up_transition.container.scale.set(D, D), m.platform.selected_sprite.visible && m.platform.selected_sprite.scale.set(D, D)
                        }
                    }
                }
            }, o.updateZombies = function(b, c, d, e) {
                for (var f = b.donkey, g = 0, h = b.zombies; g < h.length; g++) {
                    var i = h[g],
                        j = i.curse_coeff * i.stun_coeff * d,
                        k = i.container.position.x + b.foreground_container.position.x;
                    if (i.state == a.ZombieState.Standing) {
                        if (a.PixiAnimationDo.playRange(i.anim, i.anim_ranges.idle, j), k < b.zombie_alert_distance)
                            for (var l = 0, m = 0, n = 0, o = b.zombies; n < o.length; n++) {
                                var p = o[n];
                                if (p.state == a.ZombieState.Standing) {
                                    var q = p.container.position.x + b.foreground_container.position.x,
                                        r = b.zombie_alert_distance + b.zombie_alert_width;
                                    if (q < r) {
                                        p.state = a.ZombieState.StartingWalk;
                                        var s = b.zombie_alert_width - (r - q);
                                        s > 0 ? p.current_alert_time = s / 4 : p.current_alert_time = 0, l++
                                    }
                                }
                                m++
                            }
                    } else i.state == a.ZombieState.Walking || i.state == a.ZombieState.StartingWalk ? i.current_alert_time <= 0 ? (i.state == a.ZombieState.StartingWalk && a.PixiAnimationDo.playRangeOnce(i.anim, i.anim_ranges.start_walking, i.walking_coeff.current * j, !1) && (i.state = a.ZombieState.Walking), i.state == a.ZombieState.Walking && a.PixiAnimationDo.playRange(i.anim, i.anim_ranges.walking, i.walking_coeff.current * j), i.container.position.x += i.velocity.x * j) : i.current_alert_time -= d : i.state == a.ZombieState.StartingAttack ? (b.zombies_attacking_donkey++, a.PixiAnimationDo.playRangeOnce(i.anim, i.anim_ranges.starting_attack, j) && (i.state = a.ZombieState.Attacking)) : i.state == a.ZombieState.Attacking ? (b.zombies_attacking_donkey++, f.current_health -= i.attack_damage * i.attack_damage_coeff * j, a.PixiAnimationDo.playRange(i.anim, i.anim_ranges.attacking, j)) : i.state == a.ZombieState.EndingAttack && a.PixiAnimationDo.playRangeBackwardsOnce(i.anim, i.anim_ranges.starting_attack, j) && (i.state = a.ZombieState.Walking, a.ZombieDo.refreshVelocity(i)); if (k < f.zombie_stop_threshold_x) {
                        b.zombies_close_to_machine++, k < f.zombie_prepare_attack_x && b.zombies_very_close_to_donkey++;
                        var t = 1,
                            u = 5;
                        k - t < f.zombie_barrier_x + i.attack_random_distance ? (i.container.position.x = f.zombie_barrier_x - b.foreground_container.position.x + i.attack_random_distance, i.state == a.ZombieState.Walking && (i.state = a.ZombieState.StartingAttack, a.ZombieDo.refreshVelocity(i))) : k + u > f.zombie_barrier_x + i.attack_random_distance && (i.state != a.ZombieState.Attacking && i.state != a.ZombieState.StartingAttack || (i.state = a.ZombieState.EndingAttack))
                    } else i.state != a.ZombieState.Attacking && i.state != a.ZombieState.StartingAttack || (i.state = a.ZombieState.EndingAttack);
                    i.state != a.ZombieState.Standing && b.zombies_approaching++, null != i.zombie_health_bar && (i.zombie_health_bar.scale.x = i.health / i.total_health, i.zombie_health_bar.scale.x > 0 && i.zombie_health_bar.scale.x < 1 ? i.zombie_health_bar.visible || (i.zombie_health_bar.visible = !0) : (i.zombie_health_bar.scale.x < 0 && (i.zombie_health_bar.scale.x = 0), i.zombie_health_bar.visible = !1)), a.ZombieDo.setHitboxGlobalPosition(i.head_hitbox, i.container.position.x, i.container.position.y), a.ZombieDo.setHitboxGlobalPosition(i.body_hitbox, i.container.position.x, i.container.position.y), a.ZombieDo.setHitboxGlobalPosition(i.legs_hitbox, i.container.position.x, i.container.position.y), a.ZombieDo.setHitboxGlobalPosition(i.overall_hitbox, i.container.position.x, i.container.position.y), i.global_bounds.x = i.overall_hitbox.global_rect.x + b.foreground_container.x, i.global_bounds.y = i.overall_hitbox.global_rect.y + b.foreground_container.y, b.button_buffer.push(i.select_button)
                }
            }, o.updateTreasureChests = function(b, c, d, f) {
                for (var g, h = 0; h < b.treasure_chests.length;) {
                    g = b.treasure_chests[h], g.button.global_bounds.x = g.init_bounds.x + (b.foreground_container.position.x - g.init_foreground_position.x), g.button.global_bounds.y = g.init_bounds.y + (b.foreground_container.position.y - g.init_foreground_position.y);
                    var i = g.container.position.x + b.foreground_container.position.x;
                    if (g.picked || i - 85 <= b.donkey.zombie_barrier_x) {
                        a.GameTransitionDo.launchFloatingPointText(b.transitions, b.foreground_container, "+" + g.money, new e(g.container.x - 35, g.container.y - 85), 60), a.GameTransitionDo.launchAlphaOut(b.transitions, g.container, 60, !0), b.wallet.money += g.money, a.PhaserObjects.game.analytics.game.addEvent(new GA.Events.Resource("Source:Money:Reward:Chest", g.money)), a.SoundDo.playSound(a.GameAssets.sound_treasure);
                        for (var j = 0, k = 0, l = b.machine.all_platforms; k < l.length; k++) {
                            var m = l[k];
                            if (null == m.archer) {
                                var n = o.getArcherPrice(b, b.machine.all_platforms[j]);
                                n <= b.wallet.money && a.GameTransitionDo.launchDoubleScaleUpAndDown(b.transitions, m.buy_sign, 1.2, 40)
                            } else {
                                var p = m.archer;
                                (o.canAffordNewUpgrade(p.hook, b.wallet.money) || o.canAffordNewUpgrade(p.sharpness, b.wallet.money) || o.canAffordNewUpgrade(p.xarrows, b.wallet.money)) && a.GameTransitionDo.launchDoubleScaleUpAndDown(b.transitions, m.upgrade_sign, 1.3, 40)
                            }
                            j++
                        }
                        a.ItemDo.removeTreasureChestButLeaveContainer(b, g), h--
                    } else b.treasure_buttons_enabled && b.button_buffer.push(g.button), g.current_spark_time += d, g.current_spark_time >= g.spark_interval && (g.current_spark_time = 0, a.GameTransitionDo.launchSpark(b.transitions, g.container, a.PixiDo.createSprite(a.GameAssets.gold_spark, .5, .5, 20 * Math.random() - 20, 5 * Math.random() - 34)));
                    h++
                }
            }, o.updateKingAbilities = function(b, c, d, e) {
                var f = b.js_info,
                    h = b.king;
                b.any_ability_is_active = !1;
                for (var i = 0, j = b.abilities; i < j.length; i++) {
                    var k = j[i];
                    if (k.state == a.AbilityState.Activated || k.state == a.AbilityState.Starting || k.state == a.AbilityState.InPorgress || k.state == a.AbilityState.Ending) {
                        b.any_ability_is_active = !0;
                        break
                    }
                }
                for (var l = 0, m = b.abilities; l < m.length; l++) {
                    var k = m[l],
                        p = !1;
                    if (k.state == a.AbilityState.Idle && (p = !0), k.container.visible || (p = !1), 0 == b.any_ability_is_active && p && b.power_buttons_enabled && b.button_buffer.push(k.button), k.state == a.AbilityState.Activated) {
                        a.ButtonDo.setState(k.button, k.button.default_state), k.button.downed = !1, k.button.overed = !1, k.state = a.AbilityState.Starting, k.last_state_switch_time = 0, k.activated_sprite.visible = !0, k.activated_sprite.alpha = 0, k.used = !1, a.SoundDo.playSound(a.GameAssets.sound_power_charge);
                        for (var q = 0, r = b.abilities; q < r.length; q++) {
                            var s = r[q];
                            s.state == a.AbilityState.Idle && (s.normal_sprite.alpha = .6)
                        }
                    } else if (k.state == a.AbilityState.Starting) {
                        if (k.last_state_switch_time += d, k.activated_sprite.alpha = g.interpolateClamped(0, 1, k.last_state_switch_time / 5), a.PixiAnimationDo.playRangeOnce(h.anim, h.start_ability_range, d))
                            if (a.SoundDo.playSound(a.GameAssets.sound_power_release), k.state = a.AbilityState.InPorgress, k.last_state_switch_time = 0, k.current_recharge_time = 0, a.GameTransitionDo.launchScepterLight(b.transitions, b.game_container, h.scepter_light, k.ability_seconds * f.game_fps), k.type == a.AbilityType.Rally)
                                for (var t = 0, u = b.archers; t < u.length; t++) {
                                    var v = u[t],
                                        w = h.rally_ability.skill_add + h.rally_ability.skill_add_additional;
                                    v.accuracy.global_temp_boost_add = w, v.strength.global_temp_boost_add = w, v.speed.global_temp_boost_add = w, a.GameTransitionDo.launchRallyIcon(b.transitions, b.abilities_container, a.GameAssets.ability_rally_icon, v, k.ability_seconds * f.game_fps)
                                } else if (k.type == a.AbilityType.Curse) {
                                    b.cursed_zombies = new Array;
                                    for (var x = 0, y = b.zombies; x < y.length; x++) {
                                        var z = y[x],
                                            A = z.container.position.x + b.foreground_container.position.x;
                                        if (A < b.zombie_alert_distance) {
                                            z.curse_coeff = h.curse_ability.coeff;
                                            var B = g.getRectangleMiddle(z.head_hitbox.global_rect);
                                            B.x -= z.container.x - 5, B.y -= z.container.y - 50, a.GameTransitionDo.launchCurseIcon(b.transitions, z.container, a.GameAssets.ability_curse_icon, B, 60 * k.ability_seconds), b.cursed_zombies.push(z)
                                        }
                                    }
                                }
                    } else if (k.state == a.AbilityState.InPorgress) {
                        var C = k.ability_seconds * f.game_fps;
                        if (k.last_state_switch_time += d, k.current_recharge_time += d, !k.used && k.current_recharge_time >= C / 2)
                            if (k.type == a.AbilityType.Rain) o.activateArrowRain(b), a.SoundDo.playSound(a.GameAssets.sound_power_arrows), k.used = !0, null == b.slow_down_time && (b.slow_down_time = new a.SlowDownTime(44, 60, 10, 10, .03));
                            else if (k.type == a.AbilityType.Force) {
                            a.GameTransitionDo.launchForceCircle(b.transitions, b.abilities_container, h.force_wave), a.SoundDo.playSound(a.GameAssets.sound_power_force), h.wave = new a.ForceWave, h.wave.zombies = new Array, h.wave.current_duration = h.force_ability.duration;
                            for (var D = 0, E = b.zombies; D < E.length; D++) {
                                var z = E[D],
                                    A = z.container.position.x + b.foreground_container.position.x;
                                A < h.force_ability.max_position && h.wave.zombies.push(z)
                            }
                            k.used = !0
                        }
                        if (k.current_recharge_time >= C) {
                            if (k.state = a.AbilityState.Ending, k.last_state_switch_time = 0, k.normal_sprite.visible = !1, k.empty_sprite.visible = !0, k.type == a.AbilityType.Rally)
                                for (var F = 0, G = b.archers; F < G.length; F++) {
                                    var v = G[F];
                                    v.accuracy.global_temp_boost_add = 0, v.strength.global_temp_boost_add = 0, v.speed.global_temp_boost_add = 0
                                } else if (k.type == a.AbilityType.Curse) {
                                    for (var H = 0, I = b.cursed_zombies; H < I.length; H++) {
                                        var z = I[H];
                                        z.curse_coeff = 1
                                    }
                                    b.cursed_zombies = null
                                }
                        } else if (k.type == a.AbilityType.Curse)
                            for (var J = 0, K = b.cursed_zombies; J < K.length; J++) {
                                var z = K[J];
                                z.curse_coeff = h.curse_ability.coeff, z.health -= (h.curse_ability.damage_per_frame + h.curse_ability.damage_per_frame_additional) * d, z.received_curse_damage = !0
                            }
                    }
                    if (k.state == a.AbilityState.Ending) {
                        if (k.last_state_switch_time += d, k.activated_sprite.alpha = g.interpolateClamped(1, 0, k.last_state_switch_time / 5), a.PixiAnimationDo.playRangeOnce(h.anim, h.end_ability_range, d)) {
                            k.state = a.AbilityState.Charging, k.last_state_switch_time = 0, k.current_recharge_time = 0, k.recharge_distance_start = b.distance.traveled_in_pixels, k.normal_sprite.visible = !0, k.normal_sprite.alpha = .6, k.activated_sprite.visible = !1;
                            var L = k.normal_sprite.texture.frame;
                            L.height = .1, k.normal_sprite.texture.frame = L;
                            for (var M = 0, N = b.abilities; M < N.length; M++) {
                                var s = N[M];
                                s.state == a.AbilityState.Idle && (s.normal_sprite.alpha = 1)
                            }
                        }
                    } else if (k.state == a.AbilityState.Charging) {
                        k.last_state_switch_time += d;
                        var O = b.distance.traveled_in_pixels - k.recharge_distance_start,
                            L = new PIXI.Rectangle(k.normal_sprite.texture.frame.x, k.normal_sprite.texture.frame.y, k.normal_sprite.texture.frame.width, k.normal_sprite.texture.frame.height);
                        L.height = g.interpolateClamped(0, k.normal_sprite_frame_height, O / k.recharge_distance), O >= k.recharge_distance && (k.state = a.AbilityState.Finishing, L.height = k.normal_sprite_frame_height, k.normal_sprite.texture.frame = L, k.current_recharge_time = 0, k.last_state_switch_time = 0, k.empty_sprite.visible = !1);
                        var P = new n(k.normal_sprite.texture.baseTexture, L);
                        k.normal_sprite.texture = P
                    } else if (k.state == a.AbilityState.Finishing) {
                        var C = 40;
                        k.current_recharge_time += d;
                        var Q = k.current_recharge_time / C,
                            R = g.interpolateForwardAndBackward(1, 1.25, Q),
                            S = 1;
                        b.any_ability_is_active && (S = .6);
                        var T = g.interpolate(.6, S, Q);
                        k.current_recharge_time >= C && (k.state = a.AbilityState.Idle, R = 1, T = S), k.normal_sprite.alpha = T, k.button.container.scale.set(R, R)
                    }
                }
            }, o.updateProjectiles = function(b, c, d, f) {
                for (var h, l = 0, m = new e, n = (new e, new e); l < b.flying_projectiles.length;) {
                    h = b.flying_projectiles[l], h.width > 0 && (k.set(m, j.normalize(h.velocity)), d < 3 ? h.collision_position_before = k.add(j.multiply(j.normalize(h.velocity), (1 - h.sprite.anchor.x) * h.sprite.width), h.position) : h.collision_position_before = j.copy(h.position)), k.set(h.position_before, h.position), k.set(n, h.velocity), h.position.x += .5 * b.gravity.x * d * d + h.velocity.x * d, h.position.y += .5 * b.gravity.y * d * d + h.velocity.y * d, h.velocity.x += b.gravity.x * d, h.velocity.y += b.gravity.y * d, h.sprite.position.set(h.position.x, h.position.y), h.sprite.rotation = j.angle(h.velocity), h.width > 0 && (d < 3 ? h.collision_position = k.add(k.multiply(j.normalize(h.velocity), (1 - h.sprite.anchor.x) * h.sprite.width), h.position) : h.collision_position = j.copy(h.position));
                    for (var o = null, p = 0, q = b.zombies; p < q.length; p++) {
                        var r = q[p],
                            s = i.getProjectileAndRectangleCollisionPoint(h.collision_position_before, h.collision_position, n, b.gravity, r.overall_hitbox.global_rect);
                        if (null == s) {
                            var t = !1;
                            if (g.pointInRectangle(h.collision_position, r.overall_hitbox.global_rect) && (t = !0), t || g.pointInRectangle(h.collision_position_before, r.overall_hitbox.global_rect) && (t = !0), !t) continue
                        }
                        var u = i.getProjectileAndRectangleCollisionPoint(h.collision_position_before, h.collision_position, n, b.gravity, r.head_hitbox.global_rect),
                            v = i.getProjectileAndRectangleCollisionPoint(h.collision_position_before, h.collision_position, n, b.gravity, r.body_hitbox.global_rect),
                            w = i.getProjectileAndRectangleCollisionPoint(h.collision_position_before, h.collision_position, n, b.gravity, r.legs_hitbox.global_rect);
                        null == v && null == u && null == w || (null == o && (o = new Array), null != v && o.push(new a.ProjectileIntersection(a.ProjectileIntersectionType.ZombieBody, v, r.body, r)), null != u && o.push(new a.ProjectileIntersection(a.ProjectileIntersectionType.ZombieHead, u, r.head, r)), null != w && o.push(new a.ProjectileIntersection(a.ProjectileIntersectionType.ZombieLegs, w, r.legs[g.getRandomBetweenInt(0, r.legs.length - 1)], r)))
                    }
                    if (g.didValuePass(h.collision_position_before.y, h.collision_position.y, b.ground_level)) {
                        var x = i.getProjectileAndHorizontalLineIntersection(h.collision_position_before, n, b.gravity, b.ground_level);
                        null != x && (null == o && (o = new Array), o.push(new a.ProjectileIntersection(a.ProjectileIntersectionType.Ground, x, b.foreground_container)))
                    }
                    var y = null;
                    if (null != o) {
                        y = o[0];
                        for (var z = 0, A = o; z < A.length; z++) {
                            var B = A[z];
                            B.intersection.time < y.intersection.time && (y = B)
                        }
                    }
                    if (null != y) {
                        null != h.zombie_target && h.zombie_target.targeted_by_defenders_count--, y.projectile = h;
                        var x = y.intersection,
                            C = 1,
                            D = 1,
                            E = g.clamp((j.len(h.velocity) - 8) / 16, 0, 1);
                        switch (y.type) {
                            case a.ProjectileIntersectionType.Ground:
                                C = .9 - .2 * E, D = .99 - .1 * E;
                                break;
                            case a.ProjectileIntersectionType.ZombieHead:
                                C = .8 - .3 * E, D = .9 - .2 * E, y.zombie.health -= h.damage.head, a.SoundDo.playSound(a.GameAssets.sound_zombie_headshot);
                                break;
                            case a.ProjectileIntersectionType.ZombieBody:
                                C = .65 - .35 * E, D = .9 - .4 * E, y.zombie.health -= h.damage.body, a.SoundDo.playSound(a.GameAssets.sound_zombie_hit);
                                break;
                            case a.ProjectileIntersectionType.ZombieLegs:
                                C = .6 - .2 * E, D = .8 - .3 * E, y.zombie.health -= h.damage.legs, a.SoundDo.playSound(a.GameAssets.sound_zombie_hit)
                        }
                        if (y.type == a.ProjectileIntersectionType.ZombieHead || y.type == a.ProjectileIntersectionType.ZombieBody || y.type == a.ProjectileIntersectionType.ZombieLegs) {
                            var r = y.zombie;
                            r.walking_coeff.current *= h.damage.walking_penalty_coeff + (1 - h.damage.walking_penalty_coeff) * (1 - r.walking_penalty_received_coeff), r.attack_damage_coeff = h.damage.attack_penalty_coeff, y.type == a.ProjectileIntersectionType.ZombieLegs && (r.walking_coeff.current *= r.legs_coeff), r.state == a.ZombieState.Walking && (r.velocity.x = r.walking_coeff.current * r.walking_speed), y.zombie.received_arrow_damage = !0, null != y.projectile.owner && y.projectile.owner.exist && (y.projectile.owner.total_hits += 1)
                        }
                        var F = g.getRandomBetween(C, D);
                        if (h.sprite.anchor.set(F, .5), h.position = x.point, h.sprite.position.set(h.position.x, h.position.y), h.sprite.parent != y.container) {
                            var G = y.container.toLocal(h.sprite.position, h.sprite.parent);
                            h.sprite.parent.remove(h.sprite), y.container.add(h.sprite), h.sprite.x = G.x, h.sprite.y = G.y, h.sprite.rotation -= y.container.rotation
                        }
                        b.flying_projectiles.splice(l, 1), l--, b.stuck_projectiles.push(y)
                    }
                    l++
                }
            }, o.updateDonkey = function(b, c, d, e) {
                var f = b.machine,
                    g = b.donkey;
                if (b.zombies_very_close_to_donkey > 0 ? g.state != a.DonkeyState.Walking && g.state != a.DonkeyState.EndingAttack || (g.state = a.DonkeyState.StartingAttack) : g.state != a.DonkeyState.StartingAttack && g.state != a.DonkeyState.Attacking && g.state != a.DonkeyState.WaitingToAttack || (g.state = a.DonkeyState.EndingAttack), g.state == a.DonkeyState.Walking ? a.PixiAnimationDo.playRange(g.anim, g.walking_range, d * f.current_speed * g.speed_to_walking_coeff) : g.state == a.DonkeyState.StartingAttack ? a.PixiAnimationDo.playRangeOnce(g.anim, g.starting_attack_range, d) && (g.state = a.DonkeyState.WaitingToAttack) : g.state == a.DonkeyState.WaitingToAttack && b.zombies_attacking_donkey > 0 && (g.state = a.DonkeyState.Attacking), g.state == a.DonkeyState.Attacking) {
                    var h = g.health_before_shown_damage - g.current_health;
                    if (h >= 10) {
                        var i = j.copy(g.donkey_damage_particle_spawn);
                        i.x += 20 * Math.random() - 10, i.y += 4 * Math.random() - 2 - 10, a.GameTransitionDo.launchFloatingSprite(b.transitions, b.machine_container, a.GameAssets.heart_lost_big, i, 90, -100), a.SoundDo.playSound(a.GameAssets.sound_health_lost), g.health_before_shown_damage = g.current_health
                    }
                    a.PixiAnimationDo.playRange(g.anim, g.attacking_range, d);
                    for (var k = 0, l = b.zombies; k < l.length; k++) {
                        var m = l[k];
                        if (m.state == a.ZombieState.Attacking || m.state == a.ZombieState.StartingAttack) {
                            m.health -= (g.damage_per_frame + g.damage_per_frame_additional) * d, m.received_donkey_damage = !0, g.chance_of_stun > 0 && (m.stun_decided || (m.type != a.ZombieType.Mega && Math.random() < g.chance_of_stun && (m.stun_coeff = .001), m.stun_decided = !0)), g.one_hit_kill && m.type == a.ZombieType.Regular && (m.one_hit_decided ? (m.one_hit_frames -= d, m.one_hit_frames <= 0 && (m.received_donkey_damage = !0, m.health = 0)) : (m.one_hit_decided = !0, m.one_hit_frames = g.one_hit_frames));
                            break
                        }
                    }
                    0 == b.zombies_very_close_to_donkey && (g.state = a.DonkeyState.WaitingToAttack)
                } else g.state == a.DonkeyState.EndingAttack && a.PixiAnimationDo.playRangeBackwardsOnce(g.anim, g.ending_attack_range, d) && (g.state = a.DonkeyState.Walking);
                g.mode == a.DonkeyMode.Walk ? g.log.rotation = g.log_init_rotation : g.mode == a.DonkeyMode.Stop && (g.log.rotation = g.log_dropped_rotation),
                    b.state == a.GameState.InLevel && b.level_end_enabled && g.current_health <= 0 && (g.current_health = 0, b.state = a.GameState.InTransitionToDeathMenu, a.SoundDo.fadeOutMusic(a.GameAssets.music_desert), b.death_to_trailer ? (b.trailer.state = a.TrailerState.AnimIn, b.trailer.temp_additional_wait = 120, b.trailer.temp_before_finish = function() {
                        o.gotoDeathMenu(b), b.death_menu.restart_button.container.visible = !1, b.top_stats_container.visible = !1, b.pause_button.container.visible = !1
                    }) : o.launchOverlayTransition(b, 2, 120, function() {
                        o.gotoDeathMenu(b)
                    }, function() {
                        a.SoundDo.playSound(a.GameAssets.sound_collapse)
                    })), b.donkey_button_enabled && (b.button_buffer.push(g.button), b.donkey.speed_1x.visible && (b.button_buffer.push(g.button_1x), b.button_buffer.push(g.button_3x)))
            }, o.updateConsequences = function(b, c, d, e) {
                for (var f = 0, h = b.zombies.length; f < h;) {
                    var i = b.zombies[f],
                        j = i.received_arrow_damage || i.received_donkey_damage || i.received_curse_damage;
                    if (j)
                        if (i.health <= 0) {
                            if (i.type == a.ZombieType.Fat ? a.SoundDo.playSound(a.GameAssets.sound_zombie_fat_dead) : i.type == a.ZombieType.Mega ? (null != i.zombie_health_bar && (i.zombie_health_bar.visible = !1), a.SoundDo.playSound(a.GameAssets.sound_zombie_mega_dead)) : a.SoundDo.playSound(a.GameAssets.sound_zombie_dead), !i.received_donkey_damage || i.received_arrow_damage || i.received_curse_damage) {
                                var k = g.getRectangleMiddle(i.head_hitbox.global_rect);
                                k.y -= 35, k.x -= 25, a.GameTransitionDo.launchFloatingPointText(b.transitions, b.foreground_container, "+" + i.score_for_kill, k), b.wallet.score += i.score_for_kill
                            }
                            b.wallet.zombies_killed++, b.zombies.splice(f, 1), b.dead_zombies.push(i), i.state == a.ZombieState.Attacking ? i.state = a.ZombieState.AttackingDying : i.state = a.ZombieState.WalkingDying, f--, h--
                        } else i.received_arrow_damage && (i.rotation_twitch_current_time = i.rotation_twitch_max_time - 5, i.container.position.x += i.twitch_position_addition);
                    if (i.received_arrow_damage = !1, i.received_donkey_damage = !1, i.rotation_twitch_current_time > 0) {
                        var l = 1 - i.rotation_twitch_current_time / i.rotation_twitch_max_time,
                            m = g.interpolateForwardAndBackward(0, i.rotation_twitch_max_angle, l);
                        i.rotation_twitch_current_time -= 1 * d, i.rotation_twitch_current_time <= 0 && (m = 0), i.container.rotation = m
                    }
                    f++
                }
                var n = b.king;
                if (null != n.wave)
                    if (n.wave.current_duration -= d, n.wave.current_duration <= 0) n.wave.current_duration = 0, n.wave = null;
                    else
                        for (var o = 0, p = n.wave.zombies; o < p.length; o++) {
                            var i = p[o];
                            i.container.position.x += (n.force_ability.force + n.force_ability.additional_force) / i.weight * d
                        }
            }, o.updateEffects = function(a, b, c, d) {
                if (null != a.slow_down_time) {
                    var e = a.slow_down_time,
                        f = b * a.delta_update_coeff * a.delta_update_coeff_by_menu;
                    if (e.current_delay -= f, e.current_delay <= 0) {
                        e.current_duration += f;
                        var i = 1;
                        if (e.current_duration <= e.smooth_in_duration) {
                            var j = g.range(e.current_duration, 0, e.smooth_in_duration);
                            i = h.linear(1, e.time_coeff, j)
                        } else if (e.current_duration >= e.duration - e.smooth_out_duration) {
                            var j = g.range(e.current_duration, e.duration - e.smooth_out_duration, e.duration);
                            i = h.linear(e.time_coeff, 1, j)
                        } else i = e.time_coeff;
                        e.current_duration >= e.duration ? (a.delta_update_coeff_by_effect = 1, a.slow_down_time = null) : a.delta_update_coeff_by_effect = i
                    }
                }
            }, o.updateZombieSelection = function(a, b, c, d) {
                for (var e = a.zombie_selection, f = 0, h = e.selected_zombies; f < h.length; f++) {
                    var i = h[f];
                    if (null == i.zombie) null != i.container.parent && (i.container.parent.remove(i.container), e.sorted_by_selection_zombies.splice(e.sorted_by_selection_zombies.indexOf(i), 1), e.sorted_by_position_zombies.splice(e.sorted_by_position_zombies.indexOf(i), 1));
                    else if (i.zombie.health <= 0) i.zombie = null, i.targeted_by = null, null != i.container.parent && i.container.parent.remove(i.container), e.sorted_by_selection_zombies.splice(e.sorted_by_selection_zombies.indexOf(i), 1), e.sorted_by_position_zombies.splice(e.sorted_by_position_zombies.indexOf(i), 1);
                    else {
                        e.sorted_by_selection_zombies.indexOf(i) == -1 && (e.sorted_by_selection_zombies.push(i), e.sorted_by_position_zombies.push(i), e.sorted_by_selection_zombies.length > a.machine.all_platforms.length), null == i.container.parent && a.foreground_container.add(i.container);
                        var j = i.zombie.overall_hitbox.global_rect,
                            k = g.expandRectangle(j, 15);
                        k.height -= 30;
                        Math.atan2(k.height, k.width);
                        i.top_left.position.set(k.x, k.y), i.top_right.position.set(k.x + k.width, k.y), i.bottom_right.position.set(k.x + k.width, k.y + k.height), i.bottom_left.position.set(k.x, k.y + k.height), i.top_left.rotation = Math.PI / 4, i.top_right.rotation = -Math.PI / 4, i.bottom_right.rotation = Math.PI / 4, i.bottom_left.rotation = -Math.PI / 4
                    }
                }
                e.sorted_by_position_zombies.length >= 2 && e.sorted_by_position_zombies.sort(o.zombieSelectedPositionSort)
            }, o.updateDeadZombies = function(b, c, d, e) {
                for (var f = 0, g = b.dead_zombies.length; f < g;) {
                    var h = b.dead_zombies[f];
                    if (h.state == a.ZombieState.AttackingDying) a.PixiAnimationDo.playRangeOnce(h.anim, h.anim_ranges.attacking_death, d) && (h.state = a.ZombieState.Dead);
                    else if (h.state == a.ZombieState.WalkingDying) a.PixiAnimationDo.playRangeOnce(h.anim, h.anim_ranges.walking_death, d) && (h.state = a.ZombieState.Dead);
                    else if (h.state == a.ZombieState.Dead) {
                        h.alpha_out_current_time -= d;
                        var i = !1;
                        h.type != a.ZombieType.Mega && h.alpha_out_current_time < 0 && (h.container.alpha -= d / 60, h.container.alpha <= 0 && (i = !0)), h.container.position.x + b.foreground_container.position.x < -500 && (i = !0), i && (h.container.parent.remove(h.container), b.garbage.zombies.push(h), b.dead_zombies.splice(f, 1), f--, g--)
                    }
                    f++
                }
            }, o.updateStuckProjectiles = function(b, c, d, e) {
                for (var f = 0, g = b.stuck_projectiles.length; f < g;) {
                    var h = b.stuck_projectiles[f],
                        i = h.projectile,
                        j = !1;
                    null != h.zombie ? (h.zombie.container.x + b.foreground_container.position.x < -400 && (j = !0), h.zombie.container.alpha <= 0 && (j = !0)) : (i.sprite.position.x + b.foreground_container.position.x < -400 && (j = !0), h.alpha_out_current_time -= d, h.alpha_out_current_time <= 0 && (i.sprite.alpha -= d / 60, i.sprite.alpha <= 0 && (j = !0))), j && (i.sprite.alpha = 1, h.alpha_out_current_time = a.ProjectileIntersection.alpha_out_time, i.sprite.parent.remove(i.sprite), b.garbage.arrow_sprites.push(i.sprite), i.sprite = null, b.garbage.projectiles.push(i), b.stuck_projectiles.splice(f, 1), f--, g--), f++
                }
            }, o.updateLevel = function(b, c, d, e) {
                var f = b.machine,
                    g = b.js_info,
                    h = b.distance,
                    i = b.donkey,
                    j = a.LevelDo.getTotalDistanceTraveledInPixels(b.level_descriptions.levels, b.current_level_index, h.traveled_in_pixels);
                i.state == a.DonkeyState.Walking && (h.traveled_in_pixels += f.current_speed * d, h.traveled_in_meters = h.traveled_in_pixels * a.GameData.PIXELS_TO_METERS), b.zombies_close_to_machine > 0 || i.mode == a.DonkeyMode.Stop ? f.current_speed_goal = 0 : (f.current_speed_goal = f.current_max_speed, i.time_to_move_current_wait = 0), b.donkey_button_enabled && 0 == b.zombies_approaching && i.mode == a.DonkeyMode.Stop ? (i.time_to_move_current_wait += d, i.time_to_move_current_wait >= i.time_to_move_max_wait && (null == i.moving_circle.sprite.parent && i.container.addAt(i.moving_circle.sprite, 0), o.updateMovingCircle(i.moving_circle, d))) : null != i.moving_circle.sprite.parent && i.container.remove(i.moving_circle.sprite), f.current_speed < f.current_speed_goal ? (f.current_speed += f.acceleration_speed * d, f.current_speed > f.current_speed_goal && (f.current_speed = f.current_speed_goal)) : f.current_speed > f.current_speed_goal && (f.current_speed -= f.acceleration_speed * d, f.current_speed < f.current_speed_goal && (f.current_speed = f.current_speed_goal));
                var k = h.traveled_in_pixels * a.DuneDescriptions.dune_scroll_coeff;
                b.dunes_container.x = -k, b.dune_descriptions.levels.length <= b.current_level_index || a.DecorationDo.generateScrollingDunes(b, b.dunes_container, b.dunes, b.dune_descriptions.levels[b.current_level_index], g.current_game_width, k, b.dunes_y), b.decoration_container.x = -h.traveled_in_pixels, a.DecorationDo.generateRepeatedScrollingSprites(b, b.decoration_container, b.grasses, a.GameAssets.grass, g.current_game_width, h.traveled_in_pixels, b.grass_y);
                for (var l = 0, m = b.decorations.decorations; l < m.length; l++) {
                    var n = m[l];
                    a.DecorationDo.generateRandomScrollingSprites(b, b.decoration_container, n, j, h.traveled_in_pixels, g.current_game_width + b.decorations.chunk_width)
                }
                b.foreground_container.x = -h.traveled_in_pixels;
                var p = f.wheel1.width / 2,
                    q = f.current_speed / p;
                f.wheel1.rotation += q * d, f.wheel1.rotation = f.wheel1.rotation % (2 * Math.PI), f.wheel2.rotation = f.wheel1.rotation + Math.PI / 4;
                var r = b.oasis,
                    s = Math.abs(h.to_oasis_in_pixels - h.traveled_in_pixels);
                s < g.max_game_width + r.sprite.width && (b.current_level_index == a.LevelDo.getLevelCount(b.level_descriptions) - 1 ? null == b.castle.container.parent && (b.castle.container.position.x = h.to_oasis_in_pixels + .75 * b.castle.container.width, b.foreground_container.add(b.castle.container)) : null == r.container.parent && (r.container.position.x = h.to_oasis_in_pixels + r.sprite.width / 2, r.text.text = "Oasis " + (b.current_level_index + 1) + "/" + b.level_descriptions.levels.length, b.oasis.text.visible = !0, b.foreground_container.add(r.container)), b.state == a.GameState.InLevel && b.level_end_enabled && s * a.GameData.PIXELS_TO_METERS <= b.meters_to_stop_from_oasis && (b.donkey.mode = a.DonkeyMode.Stop, b.donkey_button_enabled = !1, 0 == b.zombies.length && (b.current_level_index == a.LevelDo.getLevelCount(b.level_descriptions) - 1 ? (a.ArcherMenuDo.isOpened(b.archer_skill_menu) && a.ArcherMenuDo.close(b.archer_skill_menu, b.transitions, 0, !0), a.ArcherMenuDo.isOpened(b.archer_upgrade_menu) && a.ArcherMenuDo.close(b.archer_upgrade_menu, b.transitions, 0, !0), a.ArcherMenuDo.isOpened(b.archer_buy_menu) && a.ArcherMenuDo.close(b.archer_buy_menu, b.transitions, 0, !0), b.state = a.GameState.InTransitionToWinMenu, o.launchOverlayTransition(b, 5, 0, function() {
                    o.gotoWinMenu(b)
                })) : b.state = a.GameState.InOasis)))
            }, o.updateInGameMenus = function(b, c, d, e) {
                var f = b.pointer,
                    g = !1;
                if (b.any_archer_menu_opened = !1, b.platform_buttons_enabled)
                    for (var h = 0, i = b.machine.all_platforms; h < i.length; h++) {
                        var j = i[h];
                        b.button_buffer.push(j.button)
                    }
                a.ArcherMenuDo.isOpened(b.archer_skill_menu) && (b.any_archer_menu_opened = !0, 1 == b.archer_skill_menu.container.alpha && (g = !0), a.ArcherMenuDo.addToBuffer(b.button_buffer, b.archer_skill_menu, f)), a.ArcherMenuDo.isOpened(b.archer_upgrade_menu) && (b.any_archer_menu_opened = !0, 1 == b.archer_upgrade_menu.container.alpha && (g = !0), a.ArcherMenuDo.addToBuffer(b.button_buffer, b.archer_upgrade_menu, f)), a.ArcherMenuDo.isOpened(b.archer_buy_menu) && (b.any_archer_menu_opened = !0, 1 == b.archer_buy_menu.container.alpha && (g = !0), a.ArcherMenuDo.addToBuffer(b.button_buffer, b.archer_buy_menu, f)), a.PowerMenuDo.isOpenedSub(b.power_sub_menu) ? a.PowerMenuDo.addToBufferSub(b.button_buffer, b.power_sub_menu) : a.PowerMenuDo.isOpened(b.power_menu) && a.PowerMenuDo.addToBuffer(b.button_buffer, b.power_menu), g ? b.delta_update_coeff_by_menu = .1 : b.delta_update_coeff_by_menu = 1
            }, o.updateTopStatsDisplay = function(b, c, d, e) {
                var f = (b.machine, b.donkey),
                    g = b.top_stats,
                    h = Math.round(f.current_health / 10);
                g.health.last_value != h && (g.health.last_value > h && (null == g.health.current_transition ? g.health.current_transition = a.GameTransitionDo.launchScaleUpAndDown(b.transitions, g.health.container, 1.5, 10) : g.health.current_transition.finished && (g.health.current_transition = a.GameTransitionDo.launchScaleUpAndDown(b.transitions, g.health.container, 1.5, 10))), g.health.text.text = h + "", g.health.last_value = h), h <= 1 && (null == g.health.current_transition ? g.health.current_transition = a.GameTransitionDo.launchScaleUpAndDown(b.transitions, g.health.container, 1.1, 30) : g.health.current_transition.finished && (g.health.current_transition = a.GameTransitionDo.launchScaleUpAndDown(b.transitions, g.health.container, 1.1, 30)));
                var i = b.wallet.money;
                g.money.last_value != i && (i - g.money.last_value > 10 && a.GameTransitionDo.launchScaleUpAndDown(b.transitions, g.money.container, 1.3, 20), g.money.text.text = i + "", g.money.last_value = i);
                var j = Math.floor((b.distance.to_oasis_in_pixels - b.distance.traveled_in_pixels) * a.GameData.PIXELS_TO_METERS);
                g.distance.last_value != j && (g.distance.text.text = j + "", g.distance.last_value = j)
            }, o.updateDebugStuff = function(b, c, d, e) {
                var f = b.js_info,
                    g = b.pointer;
                if (null != b.temp.debug_graph) {
                    var h = b.temp.debug_graph,
                        i = h.rect.x + b.distance.traveled_in_pixels / b.distance.traveled_in_pixels * h.rect.width,
                        j = h.rect.x + (b.distance.traveled_in_pixels + b.machine.tower_container.position.x) / b.distance.to_oasis_in_pixels * h.rect.width,
                        k = h.rect.x + (b.distance.traveled_in_pixels + f.max_game_width) / b.distance.to_oasis_in_pixels * h.rect.width;
                    h.machine_start.x = i, h.machine_marker.x = j, h.machine_end.x = k
                }
                if (g.state == l.DOWNED)
                    for (var m = 0, n = b.drags; m < n.length; m++) {
                        var o = n[m];
                        if (a.PixiDo.isPointInsideContainer(g.current, o.object)) {
                            o.offset.x = o.object.position.x - g.current.x, o.offset.y = o.object.position.y - g.current.y, b.current_drag = o;
                            break
                        }
                    }
                null != b.current_drag && (b.current_drag.object.position.x = g.current.x + b.current_drag.offset.x, b.current_drag.object.position.y = g.current.y + b.current_drag.offset.y), g.state == l.UPPED && null != b.current_drag && (b.current_drag = null);
                for (var p = 0, q = b.temp.scripts; p < q.length; p++) {
                    var r = q[p];
                    r(d)
                }
            }, o
        }();
    a.GameDo = o
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.serialization.Bef,
        c = bikas.serialization.BefDo,
        d = haxe.io.Bytes,
        e = function() {
            function e() {}
            return e.describeData = function() {
                var d = (c.pushClass, c.pushBool, c.pushInt),
                    e = (c.pushDouble, c.pushString, c.pushEnum, c.pushArray),
                    f = c.pushInstance;
                c.pushIgnore;
                $hxClasses["bikas.game.GameData.SavedGame"] = a.SavedGame, a.SavedGame.__class__ = a.SavedGame, a.SavedGame.__name__ = ["bikas", "game", "GameData", "SavedGame"], $hxClasses["bikas.game.GameData.SavedArcher"] = a.SavedArcher, a.SavedArcher.__class__ = a.SavedArcher, a.SavedArcher.__name__ = ["bikas", "game", "GameData", "SavedArcher"], $hxClasses["bikas.game.GameData.Unlocks"] = a.Unlocks, a.Unlocks.__class__ = a.Unlocks, a.Unlocks.__name__ = ["bikas", "game", "GameData", "Unlocks"];
                var g, h = c.createSerialData();
                return g = c.pushClass(h, a.SavedGame, null), g.full_class_name = "bikas.game.GameData.SavedGame", d(g, "state"), d(g, "level_index"), d(g, "money"), d(g, "score"), d(g, "zombies_killed"), f(g, "unlocks"), e(g, "archers", [b.INSTANCE_FLAG]), g = c.pushClass(h, a.SavedArcher, null), g.full_class_name = "bikas.game.GameData.SavedArcher", d(g, "current_level"), d(g, "total_launchs"), d(g, "total_hits"), d(g, "skill_points"), d(g, "accuracy_index"), d(g, "strength_index"), d(g, "speed_index"), d(g, "hook_index"), d(g, "sharpness_index"), d(g, "xarrows_index"), g = c.pushClass(h, a.Unlocks, null), g.full_class_name = "bikas.game.GameData.Unlocks", d(g, "points"), e(g, "king", [b.INT_FLAG]), e(g, "donkey", [b.INT_FLAG]), c.createTypeTableForSerialData(h), h
            }, e.isLocalStorageNameSupported = function() {
                var a = "test",
                    b = window.localStorage;
                try {
                    return b.setItem(a, "1"), b.removeItem(a), !0
                } catch (c) {
                    return !1
                }
            }, e.saveToStorage = function(a, d, f) {
                if (void 0 === f && (f = "medieval_defense_z_ts"), e.isLocalStorageNameSupported()) {
                    var g = c.serialize(a, d, [b.INSTANCE_FLAG]),
                        h = e.binaryToString(g);
                    window.localStorage.setItem(f, h)
                }
            }, e.loadFromStorage = function(a, b) {
                if (void 0 === b && (b = "medieval_defense_z_ts"), e.isLocalStorageNameSupported()) {
                    var d = window.localStorage.getItem(b);
                    if (null == d) return null;
                    var f = d,
                        g = e.stringToBinary(f),
                        h = c.unserialize(a, g);
                    return h
                }
            }, e.clearStorage = function() {
                e.isLocalStorageNameSupported() && window.localStorage.clear()
            }, e.stringToBinary = function(a) {
                for (var b = a.split(","), c = d.alloc(b.length), e = 0; e < c.length; e++) c.set(e, Std.parseInt(b[e]));
                return c
            }, e.binaryToString = function(a) {
                for (var b = new Array, c = 0; c < a.length; c++) b.push(a.get(c));
                return b.join(",")
            }, e
        }();
    a.GameSerializerDo = e
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.Point,
        c = bikas.global.GlobalFunc,
        d = bikas.global.Interpolate,
        e = bikas.global.VecFunc,
        f = Phaser.BitmapText,
        g = function() {
            function g() {}
            return g.launchTransition = function(b, c, d) {
                void 0 === d && (d = null), a.TransitionDo.setInitState(c), b.push(c), null != d && d.add(c.container)
            }, g.launchFloatingPointText = function(c, d, h, i, j) {
                void 0 === j && (j = 30);
                var k = new f(a.PhaserObjects.game, 0, 0, "accidental_presidency_35_brown", h, 35, "center"),
                    l = a.TransitionDo.create(a.TransitionCategoryType.InGame, k),
                    m = i,
                    n = e.add(i, new b(0, (-20))),
                    o = 0;
                l.states.push(a.TransitionDo.createState(o, m, null, 0, .25)), o = 4;
                var p = e.interpolate(m, n, o / j);
                return l.states.push(a.TransitionDo.createState(o, p, new b(1, 1), 0, 1)), l.states.push(a.TransitionDo.createState(j, n, new b(1.3, 1.3), 0, 0)), g.launchTransition(c, l, d), l
            }, g.launchFloatingSprite = function(c, d, f, h, i, j) {
                void 0 === i && (i = 30), void 0 === j && (j = -20);
                var k = a.PixiDo.createSprite(f, .5, .5, h.x, h.y),
                    l = a.TransitionDo.create(a.TransitionCategoryType.InGame, k),
                    m = h,
                    n = e.add(h, new b(0, j)),
                    o = 0;
                l.states.push(a.TransitionDo.createState(o, m, null, 0, .25)), o = 4;
                var p = e.interpolate(m, n, o / i);
                return l.states.push(a.TransitionDo.createState(o, p, new b(1, 1), 0, 1)), l.states.push(a.TransitionDo.createState(i, n, new b(1.3, 1.3), 0, 0)), g.launchTransition(c, l, d), l
            }, g.launchScepterLight = function(d, e, f, h) {
                var i = a.TransitionDo.create(a.TransitionCategoryType.InGame, f),
                    j = Math.PI / 10,
                    k = c.clamp(Math.PI / 120 * h, 0, 2 * Math.PI - j),
                    l = k + j;
                return a.TransitionDo.pushState(i, 0, null, new b(.3, .3), 0, 1), a.TransitionDo.pushState(i, 10, null, new b(1, 1), j, 1), a.TransitionDo.pushState(i, h - 10, null, new b(1, 1), k, 1), a.TransitionDo.pushState(i, h, null, new b(1, 1), l, 0), g.launchTransition(d, i, e), i
            }, g.launchForceCircle = function(c, d, e) {
                var f = a.TransitionDo.create(a.TransitionCategoryType.InGame, e),
                    h = 15,
                    i = 5;
                return a.TransitionDo.pushState(f, 0, null, new b(.2, .2)), a.TransitionDo.pushState(f, h, null, new b(i, i)), g.launchTransition(c, f, d), f
            }, g.launchSpark = function(c, e, f) {
                var h = a.TransitionDo.create(a.TransitionCategoryType.InGame, f),
                    i = Math.random() * Math.PI,
                    j = i + Math.PI / 4,
                    k = d.linear(i, j, .5);
                return a.TransitionDo.pushState(h, 0, null, new b(.5, .5), i, 0), a.TransitionDo.pushState(h, 30, null, new b(1, 1), k, 1), a.TransitionDo.pushState(h, 60, null, new b(1.2, 1.2), j, 0), g.launchTransition(c, h, e), h
            }, g.launchOpenMenu = function(c, d, f) {
                var h = a.TransitionDo.create(a.TransitionCategoryType.Menu, d, !1);
                h.on_finish = f;
                var i = .03,
                    j = 1 - i,
                    k = 1 + i,
                    l = a.PixiDo.convertPoint(d.position),
                    m = .5,
                    n = new b(d.width * m * (1 - j), d.height * m * (1 - j)),
                    o = new b(d.width * m * (1 - k), d.height * m * (1 - k)),
                    p = e.add(l, n),
                    q = e.add(l, o);
                return a.TransitionDo.pushState(h, 0, p, new b(j, j), null, 0), a.TransitionDo.pushState(h, 4, q, new b(k, k), null, .5), a.TransitionDo.pushState(h, 6, l, new b(1, 1), null, 1), g.launchTransition(c, h), h
            }, g.launchMenuClose = function(c, d, f, h) {
                void 0 === f && (f = 0), void 0 === h && (h = 3);
                var i = a.TransitionDo.create(a.TransitionCategoryType.Menu, d, !0),
                    j = .97,
                    k = a.PixiDo.convertPoint(d.position),
                    l = new b(d.width / 2 * (1 - j), d.height / 2 * (1 - j)),
                    m = e.add(k, l),
                    n = 0;
                return 0 != f && (a.TransitionDo.pushState(i, 0, k, new b(1, 1), null, 1), n += f), a.TransitionDo.pushState(i, n, k, new b(1, 1), null, 1), n += h, a.TransitionDo.pushState(i, n, m, new b(j, j), null, 0), g.launchTransition(c, i), i
            }, g.launchLevelUp = function(c, d, f, h) {
                var i = a.PixiDo.createSprite(f);
                i.anchor.set(.5, .5);
                var j = a.TransitionDo.create(a.TransitionCategoryType.InGame, i, !1),
                    k = a.PixiDo.convertPoint(h.container.position);
                i.position.x = k.x - 8, i.position.y = k.y;
                var l = e.add(k, new b(0, (-60))),
                    m = 30;
                return a.TransitionDo.pushState(j, 0, k, null, null, 0), a.TransitionDo.pushState(j, m, l, null, null, 1), g.launchTransition(c, j, d), j
            }, g.launchRallyIcon = function(c, d, e, f, h) {
                var i = a.PixiDo.createSprite(e);
                i.anchor.set(.5, .5);
                var j = a.TransitionDo.create(a.TransitionCategoryType.InGame, i),
                    k = a.PixiDo.convertPoint(f.container.position);
                i.position.x = k.x - 8, i.position.y = k.y - 50;
                var l = 10,
                    m = h - 10,
                    n = h;
                return a.TransitionDo.pushState(j, 0, null, new b(1.5, 1.5), null, 0), a.TransitionDo.pushState(j, l, null, new b(1, 1), null, 1), a.TransitionDo.pushState(j, m, null, new b(1, 1), null, 1), a.TransitionDo.pushState(j, n, null, null, null, 0), g.launchTransition(c, j, d), j
            }, g.launchCurseIcon = function(c, d, f, h, i) {
                var j = a.PixiDo.createSprite(f);
                j.anchor.set(.5, .5);
                var k = a.TransitionDo.create(a.TransitionCategoryType.InGame, j),
                    l = e.copy(h);
                l.x -= 8, l.y -= 80;
                var m = e.add(l, new b(0, (-10))),
                    n = e.add(l, new b(0, (-30))),
                    o = (e.add(l, new b(0, (-40))), i / 4),
                    p = i;
                return a.TransitionDo.pushState(k, 0, l, null, null, 0), a.TransitionDo.pushState(k, o, m, new b(1, 1), null, 1), a.TransitionDo.pushState(k, p, n, new b(1.5, 1.5), null, 0), g.launchTransition(c, k, d), k
            }, g.createScaleUpAndDown = function(c, d, e, f) {
                void 0 === d && (d = 1.5), void 0 === e && (e = 30), void 0 === f && (f = null);
                var g = a.TransitionDo.create(a.TransitionCategoryType.InGame, c, !1);
                g.on_finish = f;
                var h = c.scale.x,
                    i = d,
                    j = c.scale.x,
                    k = e / 2;
                return a.TransitionDo.pushState(g, 0, null, new b(h, h)), a.TransitionDo.pushState(g, k, null, new b(i, i)), a.TransitionDo.pushState(g, e, null, new b(j, j)), g
            }, g.launchScaleUpAndDown = function(a, b, c, d, e) {
                void 0 === c && (c = 1.5), void 0 === d && (d = 30), void 0 === e && (e = null);
                var f = g.createScaleUpAndDown(b, c, d, e);
                return g.launchTransition(a, f), f
            }, g.launchDoubleScaleUpAndDown = function(c, d, e, f, h) {
                void 0 === e && (e = 1.5), void 0 === f && (f = 30), void 0 === h && (h = null);
                var i = a.TransitionDo.create(a.TransitionCategoryType.InGame, d, !1);
                i.on_finish = h;
                var j = d.scale.x,
                    k = f / 4,
                    l = f / 2;
                return a.TransitionDo.pushState(i, 0, null, new b(j, j)), a.TransitionDo.pushState(i, k, null, new b(e, e)), a.TransitionDo.pushState(i, l, null, new b(j, j)), a.TransitionDo.pushState(i, l + k, null, new b(e, e)), a.TransitionDo.pushState(i, f, null, new b(j, j)), g.launchTransition(c, i), i
            }, g.createWait = function(b) {
                var c = a.TransitionDo.create(a.TransitionCategoryType.InGame);
                return a.TransitionDo.pushState(c, b), c
            }, g.launchWait = function(a, b, c) {
                void 0 === c && (c = null);
                var d = g.createWait(b);
                return d.on_finish = c, g.launchTransition(a, d), d
            }, g.createAlphaOut = function(b, c, d, e) {
                void 0 === c && (c = 1), void 0 === d && (d = 30), void 0 === e && (e = !1);
                var f = a.TransitionDo.create(a.TransitionCategoryType.InGame, b, e);
                return a.TransitionDo.pushState(f, 0, null, null, null, c), a.TransitionDo.pushState(f, d, null, null, null, 0), f
            }, g.launchAlphaOut = function(a, b, c, d) {
                void 0 === c && (c = 30), void 0 === d && (d = !1);
                var e = g.createAlphaOut(b, b.alpha, c, d);
                return g.launchTransition(a, e), e
            }, g.createAlphaIn = function(b, c, d) {
                void 0 === c && (c = 30), void 0 === d && (d = !1);
                var e = a.TransitionDo.create(a.TransitionCategoryType.InGame, b, d);
                return a.TransitionDo.pushState(e, 0, null, null, null, 0), a.TransitionDo.pushState(e, c, null, null, null, 1), e
            }, g.launchAlphaIn = function(a, b, c, d) {
                void 0 === c && (c = 30), void 0 === d && (d = !1);
                var e = g.createAlphaIn(b, c, d);
                return g.launchTransition(a, e), e
            }, g.createAlphaInOut = function(b, c, d, e, f, g) {
                void 0 === c && (c = 1), void 0 === d && (d = 15), void 0 === e && (e = 15), void 0 === f && (f = 15), void 0 === g && (g = !1);
                var h = a.TransitionDo.create(a.TransitionCategoryType.InGame, b, g);
                return a.TransitionDo.pushState(h, 0, null, null, null, c), a.TransitionDo.pushState(h, d, null, null, null, 1), a.TransitionDo.pushState(h, d + e, null, null, null, 1), a.TransitionDo.pushState(h, d + e + f, null, null, null, 0), h
            }, g.launchAlphaInOut = function(a, b, c, d, e, f) {
                void 0 === c && (c = 15), void 0 === d && (d = 15), void 0 === e && (e = 15), void 0 === f && (f = !1);
                var h = g.createAlphaInOut(b, b.alpha, c, d, e, f);
                return g.launchTransition(a, h), h
            }, g.launchShakeEffect = function(c, d, e, f, h) {
                var i = a.TransitionDo.create(a.TransitionCategoryType.InGame, d, !1),
                    j = new b(d.position.x - f, d.position.y - h),
                    k = new b(d.position.x + f, d.position.y + h);
                return a.TransitionDo.pushState(i, 0, j, null, null, null, a.InterpolationType.RandomNearStartEnd), a.TransitionDo.pushState(i, e, k, null, null, null, a.InterpolationType.RandomNearStartEnd), a.TransitionDo.pushState(i, e + 1, new b(d.position.x, d.position.y), null, null, null, a.InterpolationType.Linear), g.launchTransition(c, i), i
            }, g.launchTrailerSpriteIn = function(c, d, e) {
                var f = a.TransitionDo.create(a.TransitionCategoryType.InGame, d, !1);
                return a.TransitionDo.pushState(f, 0, null, new b(1.5, 1.5), null, 0, a.InterpolationType.SmoothStart), a.TransitionDo.pushState(f, e, null, new b(1, 1), null, 1, a.InterpolationType.SmoothStart), g.launchTransition(c, f), f
            }, g.launchTrailerArrowIn = function(c, d, f) {
                var h = a.TransitionDo.create(a.TransitionCategoryType.InGame, d, !1),
                    i = 200,
                    j = d.rotation,
                    k = new b(d.position.x, d.position.y),
                    l = e.rotate(new b(1, 0), j);
                return l = e.subtract(k, e.multiply(l, i)), a.TransitionDo.pushState(h, 0, l, null, null, 0, a.InterpolationType.SmoothStart), a.TransitionDo.pushState(h, f, k, null, null, 1, a.InterpolationType.SmoothStart), g.launchTransition(c, h), h
            }, g.launchOverlayTransitionIn = function(b, c, d, e, f, h) {
                null == d.parent && c.add(d), d.alpha = e;
                var i = a.TransitionDo.create(a.TransitionCategoryType.InGame, d, !1);
                i.on_finish = h, a.TransitionDo.pushState(i, 0, null, null, null, d.alpha), a.TransitionDo.pushState(i, 15 * f, null, null, null, 1), a.TransitionDo.pushState(i, 22 * f, null, null, null, 1), g.launchTransition(b, i)
            }, g.launchOverlayTransitionOut = function(b, c, d) {
                if (null != c.parent) {
                    var e = a.TransitionDo.create(a.TransitionCategoryType.InGame, c, !0);
                    a.TransitionDo.pushState(e, 0, null, null, null, c.alpha), a.TransitionDo.pushState(e, 22 * d, null, null, null, 0), g.launchTransition(b, e)
                }
            }, g
        }();
    a.GameTransitionDo = g
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.GlobalFunc,
        c = function() {
            function c() {}
            return c.spawnTreasureChest = function(c, d, e) {
                var f = null;
                return c.garbage.treasure_chests.length > 0 ? f = c.garbage.treasure_chests.pop() : (f = new a.TreasureChest, f.container = a.PixiDo.createGroup(), f.sprite = a.PixiDo.createSprite(a.GameAssets.treasure_chest, .5, 1, 0, 0), f.container.add(f.sprite)), f.picked = !1, f.money = d, f.container.alpha = 1, f.container.position.x = e, f.container.position.y = c.ground_level + 2, c.treasure_chests.push(f), c.foreground_container.add(f.container), null == f.button ? (f.button = a.ButtonDo.createButton(null, null, null), f.button.down_callback = function() {
                    f.picked = !0
                }) : a.ButtonDo.resetButton(f.button), f.button.global_bounds = a.PixiDo.getContainerBounds(f.container), f.init_bounds = b.copyRectangle(f.button.global_bounds), f.init_foreground_position = a.PixiDo.convertPoint(c.foreground_container.position), f
            }, c.removeTreasureChestButLeaveContainer = function(a, b) {
                a.treasure_chests.splice(a.treasure_chests.indexOf(b), 1), a.garbage.treasure_chests.push(b), b.container.alpha = 1
            }, c.removeTreasureChest = function(a, b) {
                c.removeTreasureChestButLeaveContainer(a, b), null != b.container.parent && b.container.parent.remove(b.container)
            }, c
        }();
    a.ItemDo = c
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.Point,
        c = function() {
            function c() {}
            return c.createAndAdd = function(d) {
                var e = new a.King;
                e.anim = a.PixiAnimationDo.createSpriteAnimation(a.GameAssets.king_animation, ["head", "body", "right_forearm", "right_upper_arm", "right_lower_leg", "right_upper_leg", "scepter"], [a.GameAssets.king_head, a.GameAssets.king_body, a.GameAssets.king_right_forearm, a.GameAssets.king_right_upper_arm, a.GameAssets.king_right_lower_leg, a.GameAssets.king_right_upper_leg, a.GameAssets.king_scepter]), e.container = a.PixiDo.createGroup(), a.PixiAnimationDo.addToContainer(e.container, e.anim), a.PixiAnimationDo.gotoFrame(e.anim, 1), e.container.position.set(162, 176), d.machine_container.add(e.container), d.king = e;
                var f = new b(188, 124);
                return e.scepter_light = a.PixiDo.createSprite(a.GameAssets.scepter_light), e.scepter_light.anchor.set(.5, .5), e.scepter_light.position.set(f.x, f.y), e.force_wave = a.PixiDo.createSprite(a.GameAssets.force_wave), e.force_wave.anchor.set(.5, .5), e.force_wave.position.set(f.x, f.y), d.abilities.push(c.createAbility(d.abilities_container, 0, a.AbilityType.Rain, .7, 25, a.GameAssets.ability_rain_normal, a.GameAssets.ability_rain_empty, a.GameAssets.ability_rain_activated)), d.abilities.push(c.createAbility(d.abilities_container, 1, a.AbilityType.Force, .5, 30, a.GameAssets.ability_force_normal, a.GameAssets.ability_force_empty, a.GameAssets.ability_force_activated)), d.abilities.push(c.createAbility(d.abilities_container, 2, a.AbilityType.Rally, 5, 40, a.GameAssets.ability_rally_normal, a.GameAssets.ability_rally_empty, a.GameAssets.ability_rally_activated)), d.abilities.push(c.createAbility(d.abilities_container, 3, a.AbilityType.Curse, 5, 50, a.GameAssets.ability_curse_normal, a.GameAssets.ability_curse_empty, a.GameAssets.ability_curse_activated)), e
            }, c.createAbility = function(b, c, d, e, f, g, h, i) {
                var j = new a.Ability;
                j.container = a.PixiDo.createGroup(), j.container.position.set(70 + 100 * c, 705), j.type = d, j.state = a.AbilityState.Idle, j.ability_seconds = e, j.recharge_distance = f * a.GameData.METERS_TO_PIXELS, j.recharge_distance_start = 0;
                var k = a.PixiDo.createSprite(g, 0, 0, 0, 0);
                k.position.x -= k.width / 2, k.position.y -= k.height / 2;
                var l = a.PixiDo.createSprite(a.GameAssets.ability_shadow, .5, .5, 5, 5);
                return j.button = a.GameButtonDo.createBasicButton(k, null, null, function() {
                    j.state == a.AbilityState.Idle && (j.state = a.AbilityState.Activated)
                }), j.normal_sprite = k, j.normal_sprite_frame_height = j.normal_sprite.texture.frame.height, j.activated_sprite = a.PixiDo.createSprite(i, .5, .5, 0, 0), j.empty_sprite = a.PixiDo.createSprite(h, .5, .5, 0, 0), j.container.add(l), j.container.add(j.empty_sprite), j.container.add(j.button.container), j.container.add(j.activated_sprite), j.empty_sprite.visible = !1, j.activated_sprite.visible = !1, b.add(j.container), j
            }, c
        }();
    a.KingDo = c
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.algorithms.ProceduralNumberGenerator,
        c = bikas.global.MathConstants,
        d = bikas.global.Interpolate,
        e = PIXI.Texture,
        f = function() {
            function f() {}
            return f.create = function() {
                var b = new a.LevelDescriptions,
                    c = b.levels;
                c.push(new a.LevelSettings(90, .11, "First Steps", [new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Regular, 0, 30, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 4, 2, 1, 1, 1, 1, 4, 1]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Limp, 0, 2, [0, 0, 0, 0, 0, 0, 0, 1, 0]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Fat, 0, 0, [1, 1]), new a.SpawnSettings(a.SpawnType.SpawnTresureChest, null, 180, 1, [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new a.SpawnSettings(a.SpawnType.SpawnTresureChest, null, 90, 1, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0])])), c.push(new a.LevelSettings(130, .2, "No Turning Back", [new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Regular, 0, 35, [0, 0, 0, 0, 3, 2, 0, 6, 2, 1, 3, 5, 0]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Limp, 0, 6, [0, 0, 0, 0, 1, 2, 3, 2, 1, 3, 2, 4, 0]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Fat, 0, 1, [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new a.SpawnSettings(a.SpawnType.SpawnTresureChest, null, 85, 4, [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0])])), c.push(new a.LevelSettings(180, .3, "Flatland", [new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Regular, 0, 66, [0, 0, 0, 9, 1, 1, 1, 1, 1, 0, 0, 2, 0, 5, 1, 8, 0, 0]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Limp, 0, 13, [0, 0, 0, 0, 0, 2, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0, 2]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Fat, 0, 3, [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 2]), new a.SpawnSettings(a.SpawnType.SpawnTresureChest, null, 100, 4, [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0])])), c.push(new a.LevelSettings(220, .4, "The Rotten Sand", [new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Regular, 0, 70, [0, 0, 1, 0, 5, 1, 2, 0, 2, 0, 0]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Limp, 0, 23, [0, 0, 3, 1, 3, 2, 2, 5, 0, 0, 0]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Fat, 0, 4, [0, 0, 1, 0, 2, 0, 0, 5, 0, 0, 0]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Mega, 0, 1, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]), new a.SpawnSettings(a.SpawnType.SpawnTresureChest, null, 110, 5, [0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1])])), c.push(new a.LevelSettings(260, .5, "Survival", [new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Regular, 0, 138, [0, 0, 0, 5, 0, 2, 1, 2, 3, 0, 0, 1, 1]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Limp, 0, 43, [0, 0, 5, 0, 0, 2, 1, 2, 3, 2, 2, 0, 0]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Fat, 0, 12, [0, 0, 0, 0, 5, 2, 1, 2, 3, 0, 0, 0, 0]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Mega, 0, 1, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]), new a.SpawnSettings(a.SpawnType.SpawnTresureChest, null, 160, 4, [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1])])), c.push(new a.LevelSettings(303, .6, "Heat of the Desert", [new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Regular, 0, 120, [0, 0, 1, 2, 3, 4, 5, 4, 3, 2, 1, 2, 3, 4, 4]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Limp, 0, 118, [0, 0, 1, 2, 3, 4, 5, 4, 3, 2, 1, 2, 3, 4, 4]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Fat, 0, 30, [0, 0, 1, 2, 3, 4, 5, 4, 3, 2, 1, 2, 3, 4, 0]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Mega, 0, 1, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]), new a.SpawnSettings(a.SpawnType.SpawnTresureChest, null, 160, 4, [0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0])])), c.push(new a.LevelSettings(350, .7, "Endless Waves", [new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Regular, 0, 130, [0, 1, 0, 0, 7, 1, 0, 5, 1, 0, 7, 1, 0, 6, 1, 0, 5]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Limp, 0, 130, [0, 0, 1, 0, 7, 0, 1, 5, 0, 1, 7, 0, 1, 6, 0, 1, 5]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Fat, 0, 45, [0, 0, 0, 1, 7, 0, 0, 5, 0, 0, 7, 0, 0, 6, 0, 0, 2]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Mega, 0, 1, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]), new a.SpawnSettings(a.SpawnType.SpawnTresureChest, null, 173, 5, [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0])])),
                    c.push(new a.LevelSettings(380, .8, "Donkey is Tired", [new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Regular, 0, 370, [0, 0, 0, 1, 3, 2, 6, 2, 8, 1, 4, 5, 7, 2, 3, 6, 3, 2, 1]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Limp, 0, 230, [0, 0, 0, 3, 2, 1, 7, 2, 5, 1, 6, 1, 5, 6, 7, 5, 4, 4, 3]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Fat, 0, 110, [0, 0, 0, 5, 1, 6, 1, 4, 1, 5, 3, 2, 5, 4, 1, 2, 1, 1, 3]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Mega, 0, 2, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]), new a.SpawnSettings(a.SpawnType.SpawnTresureChest, null, 183, 5, [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0])])), c.push(new a.LevelSettings(421, .9, "The Wasteland of Black Death", [new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Regular, 0, 375, [0, 0, 7, 5, 3, 4, 5, 7, 8, 0, 4, 5, 4, 4, 2, 0, 8, 2, 2, 4, 6]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Limp, 0, 295, [0, 0, 5, 7, 2, 6, 5, 6, 2, 0, 2, 0, 5, 0, 7, 5, 2, 4, 2, 4, 6]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Fat, 0, 165, [0, 0, 6, 3, 0, 8, 2, 5, 3, 8, 6, 5, 7, 1, 5, 0, 3, 5, 3, 4, 6]), new a.SpawnSettings(a.SpawnType.SpawnZombie, a.ZombieType.Mega, 0, 5, [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3]), new a.SpawnSettings(a.SpawnType.SpawnTresureChest, null, 190, 5, [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0])]));
                for (var e = 1.2, f = 1.4, g = 0; g <= 8; g++)
                    for (var h = d.linear(e, f, g / 8), i = 0, j = c[g].spawn_settings; i < j.length; i++) {
                        var k = j[i];
                        k.zombie_type == a.ZombieType.Regular ? k.count = Math.round(k.count * h) : k.zombie_type == a.ZombieType.Limp ? k.count = Math.round(k.count * h) : k.zombie_type == a.ZombieType.Fat && (k.count = Math.round(k.count * h))
                    }
                b.total_distance_in_pixels = 0;
                for (var l = 0, m = c; l < m.length; l++) {
                    var n = m[l];
                    n.total_distance_in_pixels = n.total_distance_in_meters * a.GameData.METERS_TO_PIXELS, b.total_distance_in_pixels += n.total_distance_in_pixels
                }
                return b
            }, f.getTotalDistanceTraveledInPixels = function(a, b, c) {
                for (var d = 0, e = 1024, f = 0; f < b; f++) d += a[f].total_distance_in_pixels;
                return d + b * e + c
            }, f.getLevelCount = function(a) {
                return a.levels.length
            }, f.clear = function(b) {
                for (b.machine.current_max_speed = b.machine.max_speed * b.machine.speed_multiplier, b.machine.current_speed_goal = b.machine.current_max_speed, b.machine.current_speed = 0, b.machine.current_max_speed = 0, b.machine.wheel1.rotation = 0, b.distance.traveled_in_pixels = 0, b.distance.traveled_in_meters = 0, b.foreground_container.x = 0, b.decoration_container.x = 0; b.dunes.length > 0;) {
                    var c = b.dunes.pop();
                    c.parent.remove(c), c.destroy()
                }
                for (; b.grasses.length > 0;) {
                    var d = b.grasses.pop();
                    d.parent.remove(d), d.destroy()
                }
                for (var f = 0, g = b.decorations.decorations; f < g.length; f++) {
                    var h = g[f];
                    for (h.cursor = -1; h.sprites.length > 0;) {
                        var i = h.sprites.pop();
                        i.parent.remove(i), b.garbage.decoration_sprites.push(i)
                    }
                }
                for (; b.flies.length > 0;) {
                    var j = b.flies.pop();
                    j.container.parent.remove(j.container), j.body.destroy(), j.wings.destroy(), j.container.destroy()
                }
                for (; b.zombies.length > 0;) a.ZombieDo.remove(b, b.zombies[0], b.zombies);
                for (; b.dead_zombies.length > 0;) a.ZombieDo.remove(b, b.dead_zombies[0], b.dead_zombies);
                for (; b.treasure_chests.length > 0;) a.ItemDo.removeTreasureChest(b, b.treasure_chests[0]);
                for (; b.flying_projectiles.length > 0;) {
                    var k = b.flying_projectiles.pop();
                    k.sprite.parent.remove(k.sprite), b.garbage.arrow_sprites.push(k.sprite)
                }
                for (; b.stuck_projectiles.length > 0;) {
                    var l = b.stuck_projectiles.pop();
                    l.projectile.sprite.parent.remove(l.projectile.sprite), b.garbage.arrow_sprites.push(l.projectile.sprite)
                }
                for (var m = 0, n = b.transitions; m < n.length; m++) {
                    var o = n[m];
                    null != o.container && o.remove_from_container && null != o.container.parent && o.container.parent.remove(o.container), a.TransitionDo.setLastState(o)
                }
                b.transitions.splice(0, b.transitions.length);
                for (var p = 0, q = b.abilities; p < q.length; p++) {
                    var r = q[p];
                    r.last_state_switch_time = 0, r.current_recharge_time = 0, r.state = a.AbilityState.Idle, r.used = !1, r.normal_sprite.visible = !0, r.normal_sprite.alpha = 1, r.activated_sprite.visible = !1, r.activated_sprite.alpha = 1, r.empty_sprite.visible = !1, r.empty_sprite.alpha = 1;
                    var s = new PIXI.Rectangle(r.normal_sprite.texture.frame.x, r.normal_sprite.texture.frame.y, r.normal_sprite.texture.frame.width, r.normal_sprite.texture.frame.height);
                    s.height = r.normal_sprite_frame_height, r.normal_sprite.texture.frame = s, r.button.container.scale.set(1, 1);
                    var t = new e(r.normal_sprite.texture.baseTexture, s);
                    r.normal_sprite.texture = t;
                    var u = r.normal_sprite;
                    u.updateCrop()
                }
                for (var v = 0, w = b.archers; v < w.length; v++) {
                    var x = w[v];
                    a.ArcherDo.clearArrowsAndResetCurrentState(b, x)
                }
                a.DonkeyDo.reset(b, b.donkey), a.GameDo.refreshDonkeySpeedControls(b), a.PixiAnimationDo.gotoFrame(b.king.anim, 1), b.king.wave = null, a.ArcherMenuDo.close(b.archer_buy_menu, b.transitions, 0), a.ArcherMenuDo.close(b.archer_upgrade_menu, b.transitions, 0), a.ArcherMenuDo.close(b.archer_skill_menu, b.transitions, 0), b.spawns.splice(0, b.spawns.length)
            }, f.clearZombiesAndProjectiles = function(a) {
                for (var b = 0, c = a.zombies; b < c.length; b++) {
                    var d = c[b];
                    d.container.parent.remove(d.container), a.garbage.zombies.push(d)
                }
                for (var e = 0, f = a.dead_zombies; e < f.length; e++) {
                    var d = f[e];
                    d.container.parent.remove(d.container), a.garbage.zombies.push(d)
                }
                for (var g = 0, h = a.stuck_projectiles; g < h.length; g++) {
                    var i = h[g];
                    i.projectile.sprite.parent.remove(i.projectile.sprite), a.garbage.arrow_sprites.push(i.projectile.sprite)
                }
                a.zombies = [], a.dead_zombies = [], a.stuck_projectiles = []
            }, f.start = function(b, c) {
                b.current_level_index = c, b.spawns = f.generate(b, b.level_descriptions.levels[c]), b.machine.current_max_speed = b.machine.max_speed * b.machine.speed_multiplier, b.machine.current_speed_goal = b.machine.current_max_speed, b.distance.to_oasis_in_pixels = b.level_descriptions.levels[c].total_distance_in_pixels, b.distance.traveled_in_pixels = 0, b.distance.traveled_in_meters = b.distance.traveled_in_pixels * a.GameData.PIXELS_TO_METERS, b.zombie_alert_distance = b.js_info.min_game_width + 16, b.zombie_alert_width = d.linear(b.zombie_alert_width_range.min, b.zombie_alert_width_range.max, c / f.getLevelCount(b.level_descriptions)), b.zombie_spawn_distance = b.js_info.original_max_game_width + b.zombie_alert_width
            }, f.generate = function(c, d) {
                new Array;
                if (d.total_distance_in_pixels = d.total_distance_in_meters * a.GameData.METERS_TO_PIXELS, null != c.temp.debug_graph) {
                    for (var e = 0, g = c.temp.debug_graph.graphics; e < g.length; e++) {
                        var h = g[e];
                        h.parent.remove(h)
                    }
                    c.temp.debug_graph.graphics.splice(0, c.temp.debug_graph.graphics.length), c.temp.debug_graph = null
                }
                for (var i = new Array, j = new b(d.seed), k = 0, l = d.spawn_settings; k < l.length; k++)
                    for (var m = l[k], n = f.generateSpawns(c, j, d.total_distance_in_pixels, m, c.temp.debug_graph), o = 0, p = n; o < p.length; o++) {
                        var q = p[o];
                        i.push(q)
                    }
                return i.sort(function(a, b) {
                    return a.position_x > b.position_x ? 1 : a.position_x < b.position_x ? -1 : 0
                }), i
            }, f.generateSpawns = function(b, d, e, f, g, h) {
                void 0 === h && (h = 16711680);
                for (var i = f, j = i.distribution.length, k = 0, l = 0, m = 0, n = i.distribution; m < n.length; m++) {
                    var o = n[m];
                    k += o, o > l && (l = o)
                }
                for (var p = e / (j - 1), q = p / 2, r = 0, s = 0, t = new Array, u = 0; u < j; u++) {
                    var v = i.distribution[u],
                        w = v / k,
                        x = w * i.count,
                        y = Math.floor(x),
                        z = x - y;
                    r += z, r + c.EPSILON >= 1 && (y++, r -= 1), s += y;
                    var A = 0,
                        B = 0;
                    if (0 == u ? (A = 0, B = q) : u == j - 1 ? (A = e - q, B = e) : (A = u * p - q, B = u * p + q), y > 0) {
                        var C = B - A,
                            D = void 0,
                            E = void 0;
                        1 == y ? (D = C, E = C) : (D = C / (y - 1), E = D / 2);
                        for (var F = 0; F < y; F++) {
                            var G = 0,
                                H = 0;
                            0 == F ? (G = 0, H = E) : F == y - 1 ? (G = C - E, H = C) : (G = F * D - E, H = F * D + E), G += A, H += A;
                            var I = d.getRandomBetween(G, H);
                            t.push(new a.Spawn(i.type, i.zombie_type, i.money, I))
                        }
                    }
                }
                if (b.temp.debug_level_generation) {
                    var J = g.rect,
                        K = g.graphics,
                        L = 16711680,
                        M = i.zombie_type;
                    i.money;
                    switch (i.type) {
                        case a.SpawnType.SpawnZombie:
                            switch (M) {
                                case a.ZombieType.Regular:
                                    L = 10294035;
                                    break;
                                case a.ZombieType.Limp:
                                    L = 1218319;
                                    break;
                                case a.ZombieType.Fat:
                                    L = 1731479;
                                    break;
                                case a.ZombieType.Mega:
                                    L = 10197013
                            }
                            break;
                        case a.SpawnType.SpawnTresureChest:
                            L = 9406467
                    }
                    for (var u = 1; u < j; u++) {
                        var N = i.distribution[u - 1],
                            O = i.distribution[u],
                            P = J.x + (u - 1) / (j - 1) * J.width,
                            Q = J.x + u / (j - 1) * J.width,
                            R = J.y + J.height - N / l * J.height,
                            S = J.y + J.height - O / l * J.height;
                        K.push(a.DebugDo.putLine(P, R, Q, S, L, g.line_width))
                    }
                    for (var T = 0, U = t; T < U.length; T++) {
                        var V = U[T],
                            W = V.position_x,
                            X = W / e,
                            Y = X * J.width,
                            P = J.x + Y,
                            R = J.y + J.height;
                        K.push(a.DebugDo.putMarker(P, R, L, 6)), K.push(a.DebugDo.putLine(P, R, P, R - 20, L, g.line_width))
                    }
                }
                return t
            }, f
        }();
    a.LevelDo = f
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.Point,
        c = bikas.global.Interpolate,
        d = Phaser.BitmapText,
        e = function() {
            function e() {}
            return e.create = function(f) {
                function g(b, d, g, l, m, n, o, p, q) {
                    var r = h.container,
                        s = new a.PowerUnlock;
                    s.type = o, s.index = l;
                    var t = a.PixiDo.createGroup(),
                        u = a.PixiDo.createSprite(a.GameAssets.power_unlock_button_dark, .5, .5);
                    s.blank = u;
                    var v = a.PixiDo.createSprite(g, .5, .5);
                    t.add(u), t.add(v);
                    var w = a.PixiDo.createSprite(a.GameAssets.power_unlock_button_shadow, .5, .5, 5, 5);
                    s.button = a.GameButtonDo.createBasicButton(t, w, null, function() {
                        e.openSub(f, f.power_sub_menu, d, l, o, n, g, p, q), e.refresh(f, f.power_menu)
                    }), s.button.container.position.x = c.linear(i, j, l / k), o == a.UnlockType.Up ? s.button.container.position.y = m - 37 : o == a.UnlockType.Down ? s.button.container.position.y = m + 37 : o == a.UnlockType.Middle && (s.button.container.position.y = m), r.add(s.button.container);
                    var x = null;
                    return 0 != l && (o == a.UnlockType.Middle ? x = a.PixiDo.createSprite(a.GameAssets.unlock_next_arrow, .5, .5) : o != a.UnlockType.Up && o != a.UnlockType.Down || (x = a.PixiDo.createSprite(a.GameAssets.unlock_next_2arrows, .5, .5))), null != x && (x.position.x = c.linear(i, j, (l - .5) / k), x.position.y = m, r.add(x), s.behind_next_arrow = x), b.push(s), s
                }
                var h = new a.PowerMenu;
                h.container = a.PixiDo.createGroup(), h.background = a.PixiDo.createAndAddSprite(h.container, a.GameAssets.power_menu, 0, 0, 0, 0), h.title = new d(a.PhaserObjects.game, 0, 0, "accidental_presidency_42_light", "Powers and Upgrades (1 Point)", 50, "center"), h.container.add(h.title);
                var i = 261,
                    j = 801,
                    k = 4,
                    l = 191,
                    m = 378,
                    n = new b(295, 209),
                    o = new b(295, 209);
                return g(h.king_unlocks, f.power_unlocks.king, a.GameAssets.unlock_force, a.Unlocks.king_force_index, l, n, a.UnlockType.Middle, "Unlock:", "Force Power"), g(h.king_unlocks, f.power_unlocks.king, a.GameAssets.unlock_rally, a.Unlocks.king_rally_index, l, n, a.UnlockType.Middle, "Unlock:", "Rally Power"), g(h.king_unlocks, f.power_unlocks.king, a.GameAssets.unlock_curse, a.Unlocks.king_curse_index, l, n, a.UnlockType.Middle, "Unlock:", "Curse Power"), g(h.king_unlocks, f.power_unlocks.king, a.GameAssets.unlock_arrows, a.Unlocks.king_rain_or_force_index, l, n, a.UnlockType.Up, "35% more Arrows", "for Rain Power"), g(h.king_unlocks, f.power_unlocks.king, a.GameAssets.unlock_force, a.Unlocks.king_rain_or_force_index, l, n, a.UnlockType.Down, "35% stronger", "Force Power"), g(h.king_unlocks, f.power_unlocks.king, a.GameAssets.unlock_rally, a.Unlocks.king_rally_or_curse_index, l, n, a.UnlockType.Up, "35% stronger", "Rally Power"), g(h.king_unlocks, f.power_unlocks.king, a.GameAssets.unlock_curse, a.Unlocks.king_rally_or_curse_index, l, n, a.UnlockType.Down, "35% stronger", "Curse Power"), g(h.donkey_unlocks, f.power_unlocks.donkey, a.GameAssets.unlock_heart, a.Unlocks.donkey_heart_index, m, o, a.UnlockType.Middle, "+1", "health"), g(h.donkey_unlocks, f.power_unlocks.donkey, a.GameAssets.unlock_donkey, a.Unlocks.donkey_attack_index, m, o, a.UnlockType.Middle, "+30%", "attack damage"), g(h.donkey_unlocks, f.power_unlocks.donkey, a.GameAssets.unlock_legs, a.Unlocks.donkey_paralysis_index, m, o, a.UnlockType.Middle, "+35% chance", "of paralysis"), g(h.donkey_unlocks, f.power_unlocks.donkey, a.GameAssets.unlock_donkey, a.Unlocks.donkey_attack_or_heart_index, m, o, a.UnlockType.Up, "+50%", "damage"), g(h.donkey_unlocks, f.power_unlocks.donkey, a.GameAssets.unlock_heart, a.Unlocks.donkey_attack_or_heart_index, m, o, a.UnlockType.Down, "+3", "health"), g(h.donkey_unlocks, f.power_unlocks.donkey, a.GameAssets.unlock_instant_kill, a.Unlocks.donkey_instant_kill_index, m, o, a.UnlockType.Middle, "instantly kill", "regular zombie"), h
            }, e.createSubMenu = function(b) {
                var c = new a.PowerSubMenu;
                c.container = a.PixiDo.createGroup(), c.background = a.PixiDo.createSprite(a.GameAssets.power_sub_menu, 0, 0), c.container.add(c.background), c.text1 = new d(a.PhaserObjects.game, 0, 0, "accidental_presidency_42_light", "Text1", 42, "center"), c.text2 = new d(a.PhaserObjects.game, 0, 0, "accidental_presidency_42_light", "Text2", 42, "center"), c.container.add(c.text1), c.container.add(c.text2);
                var f = a.PixiDo.createSprite(a.GameAssets.button_close, .5, .5, 0, 0);
                return c.close_button = a.GameButtonDo.createBasicButton(f, null, null, function() {
                    e.closeSub(b, c)
                }), c.close_button.container.position.set(c.background.width + 5, -5), c.container.add(c.close_button.container), c.button = a.ArcherMenuDo.createUpArrowButton(), c.button.container.position.set(403, 83), c.container.add(c.button.container), c.icon = a.PixiDo.createSprite(a.GameAssets.unlock_arrows, .5, .5, 60, 74), c.container.add(c.icon), c
            }, e.isOpenedSub = function(a) {
                return null != a.container.parent
            }, e.openSub = function(b, c, d, f, g, h, i, j, k) {
                e.isOpenedSub(c) || (c.text1.text = j, c.text2.text = k, c.text1.position.set(a.PowerSubMenu.text1_position.x - c.text1.width / 2, a.PowerSubMenu.text1_position.y - c.text1.height / 2), c.text2.position.set(a.PowerSubMenu.text2_position.x - c.text2.width / 2, a.PowerSubMenu.text2_position.y - c.text2.height / 2), c.icon.texture = i, b.menu_container.add(c.container), c.position = h, c.container.position.set(h.x + b.power_menu.container.position.x, h.y + b.power_menu.container.position.y), a.GameTransitionDo.launchOpenMenu(b.transitions, c.container, function() {
                    a.ButtonDo.updateBounds(c.button, b.pointer), a.ButtonDo.updateBounds(c.close_button, b.pointer)
                }), e.refresh(b, b.power_menu), c.button.down_callback = function() {
                    d[f] = g, b.power_unlocks.points -= 1, a.GameDo.refreshPowerUnlocks(b), a.DonkeyDo.reset(b, b.donkey), e.closeSub(b, b.power_sub_menu), c.button.enabled = !1, c.close_button.enabled = !1, a.SoundDo.playSound(a.GameAssets.sound_unlock)
                }, c.button.enabled = !0, c.close_button.enabled = !0, a.ButtonDo.resetButton(c.close_button), a.ButtonDo.updateBounds(c.button, b.pointer), a.ButtonDo.updateBounds(c.close_button, b.pointer))
            }, e.closeSub = function(b, c, d) {
                void 0 === d && (d = !1), e.isOpenedSub(c) && (e.refresh(b, b.power_menu), d ? c.container.parent.remove(c.container) : a.GameTransitionDo.launchMenuClose(b.transitions, c.container))
            }, e.addToBufferSub = function(a, b) {
                a.push(b.button), a.push(b.close_button)
            }, e.isOpened = function(a) {
                return null != a.container.parent
            }, e.open = function(b, c) {
                e.isOpened(c) || (b.menu_container.add(c.container), c.container.position.y = 86, a.GameTransitionDo.launchOpenMenu(b.transitions, c.container, function() {
                    for (var d = 0, e = c.king_unlocks; d < e.length; d++) {
                        var f = e[d];
                        a.ButtonDo.updateBounds(f.button, b.pointer)
                    }
                    for (var g = 0, h = c.donkey_unlocks; g < h.length; g++) {
                        var i = h[g];
                        a.ButtonDo.updateBounds(i.button, b.pointer)
                    }
                }), e.refresh(b, c))
            }, e.refresh = function(b, c) {
                function d(b, c, d) {
                    for (var e = 0, f = !1, g = 0, h = c; g < h.length; g++) {
                        var i = h[g];
                        if (f)
                            for (var j = 0, k = d; j < k.length; j++) {
                                var l = k[j];
                                l.index == e && (l.button.enabled = !1, l.button.container.alpha = .2, l.blank.texture = a.GameAssets.power_unlock_button_dark, null != l.behind_next_arrow && (l.behind_next_arrow.alpha = .2))
                            } else if (i == a.UnlockType.None) {
                                for (var m = 0, n = d; m < n.length; m++) {
                                    var l = n[m];
                                    l.index == e && (l.blank.texture = a.GameAssets.power_unlock_button_dark, 0 == b ? (l.button.enabled = !1, l.button.container.alpha = .2, null != l.behind_next_arrow && (l.behind_next_arrow.alpha = .2)) : (l.button.enabled = !0, l.button.container.alpha = 1, null != l.behind_next_arrow && (l.behind_next_arrow.alpha = 1)))
                                }
                                f = !0
                            } else
                                for (var o = !1, p = 0, q = d; p < q.length; p++) {
                                    var l = q[p];
                                    l.index == e && (i == l.type ? (o = !0, l.button.enabled = !1, l.button.container.alpha = 1, l.blank.texture = a.GameAssets.power_unlock_button_green, null != l.behind_next_arrow && (l.behind_next_arrow.alpha = 1)) : (l.button.enabled = !1, l.button.container.alpha = .2, l.blank.texture = a.GameAssets.power_unlock_button_dark, null != l.behind_next_arrow && (l.behind_next_arrow.alpha = .2)))
                                }
                            e++
                    }
                }
                b.power_unlocks.king;
                1 == b.power_unlocks.points ? c.title.text = "Powers and Upgrades (" + b.power_unlocks.points + " Point)" : c.title.text = "Powers and Upgrades (" + b.power_unlocks.points + " Points)", c.title.position.set(a.PowerMenu.title_center.x - c.title.width / 2, a.PowerMenu.title_center.y - c.title.height / 2), d(b.power_unlocks.points, b.power_unlocks.king, c.king_unlocks), d(b.power_unlocks.points, b.power_unlocks.donkey, c.donkey_unlocks);
                for (var e = 0, f = c.king_unlocks; e < f.length; e++) {
                    var g = f[e];
                    a.ButtonDo.updateBounds(g.button, b.pointer)
                }
                for (var h = 0, i = c.donkey_unlocks; h < i.length; h++) {
                    var j = i[h];
                    a.ButtonDo.updateBounds(j.button, b.pointer)
                }
            }, e.close = function(b, c, d) {
                void 0 === d && (d = 3), e.isOpened(c) && (0 == d ? c.container.parent.remove(c.container) : a.GameTransitionDo.launchMenuClose(b.transitions, c.container, 0, d))
            }, e.addToBuffer = function(a, b) {
                for (var c = 0, d = b.king_unlocks; c < d.length; c++) {
                    var e = d[c];
                    e.button.enabled && a.push(e.button)
                }
                for (var f = 0, g = b.donkey_unlocks; f < g.length; f++) {
                    var e = g[f];
                    e.button.enabled && a.push(e.button)
                }
            }, e
        }();
    a.PowerMenuDo = e
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = function() {
        function a(a, b) {
            void 0 === a && (a = null), void 0 === b && (b = null), this.init = a, this.update = b
        }
        return a
    }();
    a.Script = b;
    var c = function() {
        function a(a, b) {
            this.value = 0, this.name = "", this.name = a, this.value = b
        }
        return a
    }();
    a.BaseValue = c;
    var d;
    ! function(a) {
        a[a.BaseKillType = 0] = "BaseKillType", a[a.BaseHealthLostType = 1] = "BaseHealthLostType", a[a.BaseZombieTraveledType = 2] = "BaseZombieTraveledType", a[a.BaseMoneyEarnedType = 3] = "BaseMoneyEarnedType"
    }(d = a.EitherBase || (a.EitherBase = {}));
    var e = function() {
        function a() {
            this.right_top = new c("BaseKill", 20), this.right_center = new c("BaseKill", 22), this.right_bottom = new c("BaseKill", 24), this.left_top = new c("BaseKill", 26), this.left_center = new c("BaseKill", 28), this.left_bottom = new c("BaseKill", 30)
        }
        return a
    }();
    a.PositionKills = e;
    var f = function() {
        function a() {
            this.accuracy = new c("BaseKill", 73), this.strength = new c("BaseKill", 68), this.speed = new c("BaseKill", 66)
        }
        return a
    }();
    a.SkillKills = f;
    var g;
    ! function(a) {
        a[a.StaticKills = 0] = "StaticKills", a[a.DynamicKills = 1] = "DynamicKills", a[a.FatKill = 2] = "FatKill", a[a.TimedKills = 3] = "TimedKills"
    }(g = a.BaseType || (a.BaseType = {}));
    var h = function() {
        function a() {
            this.position_dynamic_kills = new e, this.right_center_static_skills_min = new c("BaseKill", 70), this.right_center_static_skills_max = new c("BaseKill", 11.9), this.right_center_and_top_static_skills_min = new c("BaseKill", 36.5), this.right_center_and_top_static_skills_max = new c("BaseKill", 7.3), this.right_center_static_money_earned_per_time = new c("BaseMoneyEarned", 170), this.skills_max = new f, this.hook_fat = [new c("BaseZombieTraveled", 109), new c("BaseZombieTraveled", 106), new c("BaseZombieTraveled", 102), new c("BaseZombieTraveled", 94)], this.sharpness_max_fat = new c("BaseZombieTraveled", 90), this.sharpness_static = [new c("BaseKill", 0), new c("BaseKill", 65), new c("BaseKill", 55), new c("BaseKill", 50)], this.xarrows_static = [new c("BaseKill", 0), new c("BaseKill", 55), new c("BaseKill", 39)]
        }
        return a
    }();
    a.ScriptData = h;
    var i;
    ! function(a) {
        a[a.BuyArcher = 0] = "BuyArcher", a[a.BuyHook = 1] = "BuyHook", a[a.BuySharpness = 2] = "BuySharpness", a[a.BuyXArrows = 3] = "BuyXArrows"
    }(i = a.ProgressionActionType || (a.ProgressionActionType = {}));
    var j;
    ! function(a) {
        a[a.AdjustZombieCount = 0] = "AdjustZombieCount", a[a.PlayOnce = 1] = "PlayOnce"
    }(j = a.GameplayBotType || (a.GameplayBotType = {}));
    var k = function() {
        function a() {}
        return a
    }();
    k.DataGathering = 1, k.ZombieCountAdjustment = 2, a.ScriptMode = k;
    var l = function() {
        function a(a, b, c) {
            this.type = a, this.upgrade_index = b, this.archer_index = c
        }
        return a
    }();
    a.ProgressionAction = l;
    var m = function() {
        function a() {
            this.current_index = 0, this.actions = new Array
        }
        return a
    }();
    a.Progression = m
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.GlobalFunc,
        c = function() {
            function c() {}
            return c.pushGameplayBot = function(d, e, f, g, h, i, j) {
                function k() {
                    a.GameDo.load(h, z), a.DonkeyDo.reset(h, h.donkey), p = h.donkey.current_health, g.current_index = A, v++, a.GameDo.gotoLevel(h, h.current_level_index)
                }

                function l() {
                    h.current_level_index = i, o = h.level_descriptions.levels[h.current_level_index].spawn_settings;
                    for (var b = 0, c = o; b < c.length; b++) {
                        var d = c[b];
                        d.zombie_type, d.money;
                        switch (d.type) {
                            case a.SpawnType.SpawnZombie:
                                C.push(d.count), D += d.count;
                                break;
                            case a.SpawnType.SpawnTresureChest:
                        }
                    }
                    z = a.GameDo.save(h, a.SavedState.LevelStart), A = g.current_index, k()
                }

                function m(a, b, c, d, e) {
                    if (null == a) return 1;
                    var f = c.current_index + 1;
                    if (f > d) return 1;
                    if (f < b.length) {
                        var g = b[f].price;
                        return g <= e.money ? (c.current_index++, e.money -= g, 1) : 0
                    }
                    return 1
                }
                void 0 === j && (j = 10);
                var n = d.length;
                d.push(c.createUpdateCoeffChange(h, j));
                var o = null,
                    p = 0,
                    q = .8,
                    r = .2,
                    s = 100,
                    t = 20,
                    u = .02,
                    v = 0,
                    w = 5,
                    x = 1.2,
                    y = 0,
                    z = null,
                    A = 0,
                    B = !1,
                    C = new Array,
                    D = 0;
                d.push(new a.Script(l, function(c) {
                    if (f == a.GameplayBotType.PlayOnce && h.distance.traveled_in_pixels >= h.distance.to_oasis_in_pixels) return !0;
                    if (f == a.GameplayBotType.AdjustZombieCount && (h.distance.traveled_in_pixels >= h.distance.to_oasis_in_pixels || h.donkey.current_health <= 0)) {
                        var d = h.donkey.current_health,
                            e = b.interpolate(q, r, h.current_level_index / (h.level_descriptions.levels.length - 1)),
                            i = p * e,
                            j = p * u,
                            l = b.clamp((d - i) / s, -1, 1),
                            n = t * l;
                        n < 0 ? n > -1 && (n = -1) : n > 0 && n < 1 && (n = 1);
                        for (var z = 0, A = o; z < A.length; z++) {
                            var E = A[z];
                            switch (E.type) {
                                case a.SpawnType.SpawnZombie:
                                    break;
                                case a.SpawnType.SpawnTresureChest:
                            }
                        }
                        if (b.near(d, i, j)) return !0;
                        v % w == 0 && (u *= x), y += n;
                        for (var F = !1, G = 0, H = 0, I = o; H < I.length; H++) {
                            var E = I[H],
                                J = E.zombie_type;
                            switch (E.type) {
                                case a.SpawnType.SpawnZombie:
                                    var K = C[G] / D,
                                        L = Math.round(y * K),
                                        M = C[G] + L;
                                    E.count != M && (F = !0, E.count = M), G++;
                                    break;
                                case a.SpawnType.SpawnTresureChest:
                            }
                        }
                        return k(), !1
                    }
                    if (g.current_index < g.actions.length) {
                        var N = g.actions[g.current_index],
                            O = h.machine.all_platforms[N.archer_index],
                            P = O.archer,
                            Q = N.upgrade_index;
                        switch (N.type) {
                            case a.ProgressionActionType.BuyArcher:
                                if (null == P) {
                                    var R = a.GameDo.getArcherPrice(h, h.machine.all_platforms[N.archer_index]);
                                    R <= h.wallet.money && (a.ArcherDo.spawn(h, O), h.wallet.money -= R, g.current_index++)
                                } else g.current_index++;
                                break;
                            case a.ProgressionActionType.BuyHook:
                                g.current_index += m(P, a.Archer.hook_settings, P.hook, Q, h.wallet);
                                break;
                            case a.ProgressionActionType.BuySharpness:
                                g.current_index += m(P, a.Archer.sharpness_settings, P.sharpness, Q, h.wallet);
                                break;
                            case a.ProgressionActionType.BuyXArrows:
                                g.current_index += m(P, a.Archer.xarrows_settings, P.xarrows, Q, h.wallet)
                        }
                    }
                    B || g.current_index >= g.actions.length - 1 && (g.current_index++, B = !0);
                    for (var S = 0, T = h.archers; S < T.length; S++) {
                        var P = T[S];
                        if (P.skill_points > 0) {
                            for (; P.skill_points > 0;) {
                                var U = P.accuracy;
                                P.strength.trained_index < U.trained_index && (U = P.strength), P.speed.trained_index < U.trained_index && (U = P.speed), U.trained_index < a.Skill.trained_max_index && (U.trained_index++, P.skill_points--)
                            }
                            a.ArcherDo.removeLevelUpTransitionIfShould(h, P)
                        }
                    }
                    var V = a.GameDo.getTotalArcherCount(h),
                        W = h.any_ability_is_active,
                        X = null;
                    if (!W && (X = h.abilities[1], X.container.visible && X.state == a.AbilityState.Idle)) {
                        for (var Y = 2 * V, Z = 0, $ = 0; $ < h.zombies_approaching; $++)
                            if ($ < h.zombies.length) {
                                var J = h.zombies[$],
                                    _ = J.container.position.x + h.foreground_container.position.x;
                                _ < h.donkey.zombie_stop_threshold_x && (J.type == a.ZombieType.Fat ? Z += 6 : J.type == a.ZombieType.Limp ? Z += 4 : J.type == a.ZombieType.Regular && (Z += 1))
                            }
                        Z >= Y && (X.state = a.AbilityState.Activated, W = !0)
                    }
                    if (!W && (X = h.abilities[3], X.container.visible && X.state == a.AbilityState.Idle)) {
                        var aa = 3 * V,
                            ba = 6 * V;
                        if (h.zombies_approaching >= aa) {
                            for (var Z = 0, $ = 0; $ < h.zombies_approaching; $++) $ < h.zombies.length && (h.zombies[$].type == a.ZombieType.Fat ? Z += 1 : h.zombies[$].type == a.ZombieType.Limp ? Z += 3 : h.zombies[$].type == a.ZombieType.Regular && (Z += 1));
                            Z >= ba && (X.state = a.AbilityState.Activated, W = !0)
                        }
                    }
                    if (!W && (X = h.abilities[2], X.container.visible && X.state == a.AbilityState.Idle)) {
                        var aa = 2 * V,
                            ba = 6 * V;
                        if (h.zombies_approaching >= aa) {
                            for (var Z = 0, $ = 0; $ < h.zombies_approaching; $++) $ < h.zombies.length && (h.zombies[$].type == a.ZombieType.Fat ? Z += 6 : h.zombies[$].type == a.ZombieType.Limp ? Z += 4 : h.zombies[$].type == a.ZombieType.Regular && (Z += 1));
                            Z >= ba && (X.state = a.AbilityState.Activated, W = !0)
                        }
                    }
                    if (!W && (X = h.abilities[0], X.container.visible && X.state == a.AbilityState.Idle && h.zombies_approaching >= 2 * V)) {
                        for (var Z = 0, ca = h.king.rain_ability.area.x + 260, da = ca + h.king.rain_ability.area.width - 50, $ = 0; $ < h.zombies_approaching; $++)
                            if ($ < h.zombies.length) {
                                var ea = h.zombies[$].container.position,
                                    fa = h.foreground_container.position.x + ea.x;
                                b.isValueBetween(fa, ca, da) && Z++
                            }
                        Z >= 3 * V && (X.state = a.AbilityState.Activated, h.slow_down_time = new a.SlowDownTime(100, 600, 5, 5, .1), W = !0)
                    }
                    return !1
                })), d.push(c.createUpdateCoeffChange(h, 1)), c.print(d, n)
            }, c.pushRightCenter = function(b, d, e) {
                c.pushBaseKillTime(b, d, e, !1, !0, a.BaseType.StaticKills, 0, a.EitherBase.BaseKillType, d.right_center_static_skills_min, [e.machine.right_center]), c.pushBaseKillTime(b, d, e, !0, !0, a.BaseType.StaticKills, 0, a.EitherBase.BaseKillType, d.right_center_static_skills_max, [e.machine.right_center])
            }, c.pushRightCenterAndTop = function(b, d, e) {
                c.pushBaseKillTime(b, d, e, !1, !0, a.BaseType.StaticKills, 0, a.EitherBase.BaseKillType, d.right_center_and_top_static_skills_min, [e.machine.right_center, e.machine.right_top]), c.pushBaseKillTime(b, d, e, !0, !0, a.BaseType.StaticKills, 0, a.EitherBase.BaseKillType, d.right_center_and_top_static_skills_max, [e.machine.right_center, e.machine.right_top])
            }, c.pushRightCenterMoneyEarned = function(b, d, e) {
                c.pushBaseKillTime(b, d, e, !1, !1, a.BaseType.TimedKills, 3600, a.EitherBase.BaseMoneyEarnedType, d.right_center_static_money_earned_per_time, [e.machine.right_center])
            }, c.tracePrices = function(a, b) {
                function c(a) {
                    return 5 * Math.round(a / 5)
                }

                function d(a, b, d) {
                    for (var e = 0, f = d; e < f.length; e++) {
                        var g = f[e];
                        if (0 != g.value) {
                            var i = b.value / g.value,
                                j = c(i * a);
                            h += j
                        }
                    }
                }

                function e(a, b, d, e) {
                    for (var f = d.value / e[e.length - 1].value, g = 0, i = e; g < i.length; g++) {
                        var j = i[g];
                        if (j != e[0]) {
                            var k = e[0].value / j.value * f,
                                l = c(k * a);
                            h += l
                        }
                    }
                }
                var f = a.right_center_static_money_earned_per_time.value,
                    g = .5;
                f *= g;
                for (var h = 0, i = [a.position_dynamic_kills.right_top, a.position_dynamic_kills.right_center, a.position_dynamic_kills.right_bottom, a.position_dynamic_kills.left_top, a.position_dynamic_kills.left_center, a.position_dynamic_kills.left_bottom], j = a.right_center_static_skills_min.value / a.right_center_and_top_static_skills_min.value, k = a.position_dynamic_kills.right_center, l = 0, m = i; l < m.length; l++) {
                    var n = m[l],
                        o = k.value / n.value * j,
                        p = c(o * f);
                    h += p
                }
                e(f, a.right_center_static_skills_min, a.sharpness_max_fat, a.hook_fat), d(f, a.right_center_static_skills_min, a.sharpness_static), d(f, a.right_center_static_skills_min, a.xarrows_static)
            }, c.pushBaseKillTime = function(b, d, e, f, g, h, i, j, k, l) {
                var m = b.length;
                if (b.push(c.createUpdateCoeffChange(e, 10)), f) b.push(c.createArcherKill(h, i, a.ArcherTargetSelectType.ClosestRandom, j, k, e, l, a.Skill.trained_max_index, a.Skill.trained_max_index, a.Skill.trained_max_index, a.Archer.hook_settings.length - 1, a.Archer.sharpness_settings.length - 1, a.Archer.xarrows_settings.length - 1));
                else {
                    var n = 0;
                    g && (n = c.getBaseAccuracy()), b.push(c.createArcherKill(h, i, a.ArcherTargetSelectType.ClosestRandom, j, k, e, l, n, 0, 0, 0, 0, 0))
                }
                b.push(new a.Script(function() {})), b.push(c.createUpdateCoeffChange(e, 1)), c.print(b, m)
            }, c.pushArcherPositionKillTime = function(b, d, e, f, g) {
                var h = b.length,
                    i = e.machine,
                    j = d.position_dynamic_kills,
                    k = [j.left_bottom, j.left_center, j.left_top, j.right_bottom, j.right_center, j.right_top],
                    l = [i.left_bottom, i.left_center, i.left_top, i.right_bottom, i.right_center, i.right_top];
                b.push(c.createUpdateCoeffChange(e, 10));
                for (var m = 0; m < k.length; m++) {
                    var n = k[m],
                        o = l[m];
                    b.push(c.createArcherKill(f, g, a.ArcherTargetSelectType.ClosestRandom, a.EitherBase.BaseKillType, n, e, [o], c.getBaseAccuracy(), 0, 0, 0, 0, 0))
                }
                b.push(c.createTraceBaseKills(d)), b.push(c.createUpdateCoeffChange(e, 1)), c.print(b, h)
            }, c.pushUpgradeKillTime = function(b, d, e) {
                function f(d, f, g, h, i, j, k, l) {
                    g ? b.push(c.createArcherKill(k, l, a.ArcherTargetSelectType.ClosestRandom, d, f, e, [e.machine.right_center], a.Skill.trained_max_index, a.Skill.trained_max_index, a.Skill.trained_max_index, h, i, j)) : b.push(c.createArcherKill(k, l, a.ArcherTargetSelectType.ClosestRandom, d, f, e, [e.machine.right_center], c.getBaseAccuracy(), 0, 0, h, i, j))
                }
                var g = b.length;
                b.push(c.createUpdateCoeffChange(e, 10));
                for (var h = 0; h < a.Archer.hook_settings.length; h++) f(a.EitherBase.BaseZombieTraveledType, d.hook_fat[h], !1, h, 0, 0, a.BaseType.FatKill, 0);
                for (var h = 0; h < a.Archer.sharpness_settings.length; h++) f(a.EitherBase.BaseKillType, d.sharpness_static[h], !1, 0, h, 0, a.BaseType.StaticKills, 0);
                for (var h = 0; h < a.Archer.xarrows_settings.length; h++) f(a.EitherBase.BaseKillType, d.xarrows_static[h], !1, 0, 0, h, a.BaseType.StaticKills, 0);
                f(a.EitherBase.BaseZombieTraveledType, d.sharpness_max_fat, !1, 0, a.Archer.sharpness_settings.length - 1, 0, a.BaseType.FatKill, 0), b.push(new a.Script(function() {})), b.push(c.createUpdateCoeffChange(e, 1)), c.print(b, g)
            }, c.pushSkillMaxKillTime = function(b, d, e) {
                function f(d, f, g, h, i, j) {
                    b.push(c.createArcherKill(i, j, a.ArcherTargetSelectType.ClosestRandom, a.EitherBase.BaseKillType, d, e, [e.machine.right_center], f, g, h, 0, 0, 0))
                }
                var g = b.length;
                b.push(c.createUpdateCoeffChange(e, 10)), f(d.skills_max.accuracy, a.Skill.trained_max_index, 0, 0, a.BaseType.StaticKills, 0), f(d.skills_max.strength, 0, a.Skill.trained_max_index, 0, a.BaseType.StaticKills, 0), f(d.skills_max.speed, 0, 0, a.Skill.trained_max_index, a.BaseType.StaticKills, 0), b.push(new a.Script(function() {})), b.push(c.createUpdateCoeffChange(e, 1)), c.print(b, g)
            }, c.createUpdateCoeffChange = function(b, c) {
                return void 0 === c && (c = 1), new a.Script(function() {
                    b.delta_update_coeff = c
                })
            }, c.createTrace = function(b) {
                return new a.Script(function() {})
            }, c.createTraceBaseKills = function(b) {
                b.position_dynamic_kills;
                return new a.Script(function() {})
            }, c.createArcherKill = function(b, d, e, f, g, h, i, j, k, l, m, n, o) {
                var p = new a.Script,
                    q = 5,
                    r = 0,
                    s = 0,
                    t = -1,
                    u = 0,
                    v = q;
                p.init = function() {
                    for (var f = 0, g = h.zombies; f < g.length; f++) {
                        var p = g[f];
                        p.health = 0, p.received_arrow_damage = !0
                    }
                    for (var w = 0, x = h.archers.slice(0); w < x.length; w++) {
                        var y = x[w];
                        a.ArcherDo.remove(h, y)
                    }
                    a.LevelDo.clearZombiesAndProjectiles(h);
                    for (var z = 0, A = i; z < A.length; z++) {
                        var B = A[z],
                            y = a.ArcherDo.spawn(h, B);
                        y.target_select_type = e, y.accuracy.trained_index = j, y.strength.trained_index = k, y.speed.trained_index = l, y.hook.current_index = m, y.sharpness.current_index = n, y.xarrows.current_index = o
                    }
                    switch (h.machine.current_speed = 0, h.machine.current_speed_goal = 0, h.machine.current_max_speed = 0, r = h.donkey.current_health, u = h.wallet.money, b) {
                        case a.BaseType.StaticKills:
                            c.spawnBaselineStaticZombies(h);
                            break;
                        case a.BaseType.DynamicKills:
                            c.spawnBaselineDynamicZombies(h);
                            break;
                        case a.BaseType.FatKill:
                            c.spawnBaselineFatZombie(h);
                            break;
                        case a.BaseType.TimedKills:
                            c.spawnBaselineStaticZombies(h), t = d, q = 999, v = q
                    }
                    s = h.zombies[0].container.x, v--
                };
                var w = 0,
                    x = 0,
                    y = 0,
                    z = 0,
                    A = 0;
                return p.update = function(d) {
                    if (w += d, t > 0 && (t -= d, t <= 0 && (v = 0, a.LevelDo.clearZombiesAndProjectiles(h))), 0 == h.zombies.length) {
                        if (x += w, z += r - h.donkey.current_health, v > 0) {
                            v--, w = 0, r = h.donkey.current_health;
                            for (var e = 0, j = i; e < j.length; e++) {
                                var k = j[e];
                                a.ArcherDo.clearArrowsAndResetCurrentState(h, k.archer), a.ArcherDo.clearLevelUp(h, k.archer)
                            }
                            switch (b) {
                                case a.BaseType.StaticKills:
                                    c.spawnBaselineStaticZombies(h);
                                    break;
                                case a.BaseType.DynamicKills:
                                    c.spawnBaselineDynamicZombies(h);
                                    break;
                                case a.BaseType.FatKill:
                                    c.spawnBaselineFatZombie(h);
                                    break;
                                case a.BaseType.TimedKills:
                                    c.spawnBaselineStaticZombies(h)
                            }
                            return !1
                        }
                        y = x / q;
                        var l = g;
                        switch (f) {
                            case a.EitherBase.BaseKillType:
                                l.value = c.convertToSeconds(y);
                                break;
                            case a.EitherBase.BaseHealthLostType:
                                l.value = z / q;
                                break;
                            case a.EitherBase.BaseZombieTraveledType:
                                l.value = A / q;
                                break;
                            case a.EitherBase.BaseMoneyEarnedType:
                                l.value = h.wallet.money - u
                        }
                        return !0
                    }
                    return A = s - h.zombies[0].container.x, !1
                }, p
            }, c.getBaseAccuracy = function() {
                return Math.round(a.Skill.trained_max_index)
            }, c.spawnBaselineStaticZombies = function(c) {
                for (var d = 400 - c.foreground_container.position.x, e = 700 - c.foreground_container.position.x, f = 10, g = 5, h = 2, i = 0; i < f; i++) a.ZombieDo.spawn(c, a.ZombieType.Regular, b.interpolate(d, e, i / f), !0);
                for (var i = 0; i < g; i++) a.ZombieDo.spawn(c, a.ZombieType.Limp, b.interpolate(d, e, i / g), !0);
                for (var i = 0; i < h; i++) a.ZombieDo.spawn(c, a.ZombieType.Fat, b.interpolate(d, e, 1 - i / h), !0);
                for (var j = 0, k = c.zombies; j < k.length; j++) {
                    var l = k[j];
                    l.walking_coeff.current = 0, l.velocity.x = 0
                }
            }, c.spawnBaselineDynamicZombies = function(c) {
                for (var d = 1024 - c.foreground_container.position.x, e = 1524 - c.foreground_container.position.x, f = 6, g = 0; g < f; g++) {
                    var h = a.ZombieDo.spawn(c, a.ZombieType.Regular, b.interpolate(d, e, g / f), !0);
                    h.state = a.ZombieState.Walking
                }
            }, c.spawnBaselineFatZombie = function(b) {
                var c = a.ZombieDo.spawn(b, a.ZombieType.Fat, 1024, !0);
                c.state = a.ZombieState.Walking
            }, c.print = function(a, b) {}, c.convertToSeconds = function(a) {
                return Math.round(1e3 * a / 60) / 1e3
            }, c.createDefaultProgression = function() {
                function b(b, c) {
                    b.push(new a.ProgressionAction(a.ProgressionActionType.BuyArcher, 0, c)), b.push(new a.ProgressionAction(a.ProgressionActionType.BuyHook, 1, c)), b.push(new a.ProgressionAction(a.ProgressionActionType.BuySharpness, 1, c)),
                        b.push(new a.ProgressionAction(a.ProgressionActionType.BuyHook, 2, c)), b.push(new a.ProgressionAction(a.ProgressionActionType.BuySharpness, 2, c)), b.push(new a.ProgressionAction(a.ProgressionActionType.BuyHook, 3, c)), b.push(new a.ProgressionAction(a.ProgressionActionType.BuySharpness, 3, c)), b.push(new a.ProgressionAction(a.ProgressionActionType.BuyXArrows, 1, c))
                }
                var c = 0,
                    d = 1,
                    e = 2,
                    f = 3,
                    g = 4,
                    h = 5,
                    i = new a.Progression;
                i.actions.push(new a.ProgressionAction(a.ProgressionActionType.BuyArcher, 0, c)), i.actions.push(new a.ProgressionAction(a.ProgressionActionType.BuySharpness, 1, c)), i.actions.push(new a.ProgressionAction(a.ProgressionActionType.BuyArcher, 0, d));
                for (var j = e + 1, k = c; k < j; k++) i.actions.push(new a.ProgressionAction(a.ProgressionActionType.BuyHook, 1, k)), i.actions.push(new a.ProgressionAction(a.ProgressionActionType.BuySharpness, 1, k));
                for (var k = c; k < j; k++) i.actions.push(new a.ProgressionAction(a.ProgressionActionType.BuyHook, 2, k)), i.actions.push(new a.ProgressionAction(a.ProgressionActionType.BuySharpness, 2, k));
                for (var k = c; k < j; k++) i.actions.push(new a.ProgressionAction(a.ProgressionActionType.BuyHook, 3, k)), i.actions.push(new a.ProgressionAction(a.ProgressionActionType.BuySharpness, 3, k));
                for (var k = c; k < j; k++) i.actions.push(new a.ProgressionAction(a.ProgressionActionType.BuyXArrows, 1, k));
                return b(i.actions, f), b(i.actions, g), b(i.actions, h), i
            }, c.runScripts = function(a, b, c) {
                function d(a) {
                    if (e += a, b.length > 0) {
                        var f = !1;
                        null == b[0].update ? f = !0 : 1 == b[0].update(a) && (f = !0), f && (b.shift(), b.length > 0 && null != b[0].init && b[0].init())
                    } else c.splice(c.indexOf(d), 1)
                }
                var e = (b.length, 0);
                b.length > 0 && b[0].init(), c.push(d)
            }, c
        }();
    a.ScriptDo = c
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.MinMaxCurrent,
        c = bikas.global.Point,
        d = bikas.global.Rectangle,
        e = bikas.global.GlobalFunc,
        f = bikas.global.GlobalProc,
        g = function() {
            function g() {}
            return g.spawn = function(b, c, d, f) {
                void 0 === f && (f = !0);
                var h = g.create(b, c, d, f);
                g.setHitboxGlobalPosition(h.head_hitbox, h.container.position.x, h.container.position.y), g.setHitboxGlobalPosition(h.body_hitbox, h.container.position.x, h.container.position.y), g.setHitboxGlobalPosition(h.legs_hitbox, h.container.position.x, h.container.position.y), g.setHitboxGlobalPosition(h.overall_hitbox, h.container.position.x, h.container.position.y), a.PixiAnimationDo.gotoFrame(h.anim, e.getRandomBetween(h.anim_ranges.idle.start, h.anim_ranges.idle.end));
                var i = 10 / 180 * Math.PI;
                if (h.type == a.ZombieType.Regular)
                    for (var j = 0, k = h.legs; j < k.length; j++) {
                        var l = k[j];
                        l.rotation += e.getRandomBetween(-i, i)
                    }
                for (var m = 0, n = h.hands; m < n.length; m++) {
                    var o = n[m];
                    o.rotation += e.getRandomBetween(-i, i)
                }
                return h.state = a.ZombieState.Standing, b.foreground_container.add(h.container), b.zombies.push(h), h
            }, g.create = function(c, d, h, i) {
                void 0 === i && (i = !0);
                var j = !1,
                    k = null;
                if (i)
                    for (var l = c.garbage.zombies, m = 0; m < l.length; m++)
                        if (l[m].type == d) {
                            k = l[m], l.splice(m, 1), j = !0;
                            break
                        }
                return 0 == j && (k = new a.Zombie), k.type = d, 0 == j && (k.container = a.PixiDo.createGroup(), d == a.ZombieType.Regular ? k.anim = a.PixiAnimationDo.createSpriteAnimation(a.GameAssets.zombie_animation, ["head", "body", "right_hand", "left_hand", "right_leg", "left_leg"], [a.GameAssets.zombie_head, a.GameAssets.zombie_body, a.GameAssets.zombie_hand, a.GameAssets.zombie_hand, a.GameAssets.zombie_leg, a.GameAssets.zombie_leg]) : d == a.ZombieType.Limp ? k.anim = a.PixiAnimationDo.createSpriteAnimation(a.GameAssets.limp_zombie_animation, ["head", "right_hand", "body", "left_hand", "front_upper_leg", "front_lower_leg", "back_leg"], [a.GameAssets.limp_zombie_head, a.GameAssets.limp_zombie_hand, a.GameAssets.limp_zombie_body, a.GameAssets.limp_zombie_hand, a.GameAssets.limp_zombie_front_upper_leg, a.GameAssets.limp_zombie_front_lower_leg, a.GameAssets.limp_zombie_back_leg]) : d == a.ZombieType.Fat ? k.anim = a.PixiAnimationDo.createSpriteAnimation(a.GameAssets.fat_zombie_animation, ["head", "body", "right_hand", "left_hand", "right_leg", "left_leg"], [a.GameAssets.fat_zombie_head, a.GameAssets.fat_zombie_body, a.GameAssets.fat_zombie_hand, a.GameAssets.fat_zombie_hand, a.GameAssets.fat_zombie_leg, a.GameAssets.fat_zombie_leg]) : d == a.ZombieType.Mega && (k.anim = a.PixiAnimationDo.createSpriteAnimation(a.GameAssets.mega_zombie_animation, ["head", "left_arm", "left_forearm", "left_upper_leg", "left_lower_leg", "left_foot", "body", "right_arm", "right_forearm", "right_upper_leg", "right_lower_leg", "right_foot"], [a.GameAssets.mega_zombie_head, a.GameAssets.mega_zombie_arm, a.GameAssets.mega_zombie_forearm, a.GameAssets.mega_zombie_upper_leg, a.GameAssets.mega_zombie_lower_leg, a.GameAssets.mega_zombie_foot, a.GameAssets.mega_zombie_body, a.GameAssets.mega_zombie_arm, a.GameAssets.mega_zombie_forearm, a.GameAssets.mega_zombie_upper_leg, a.GameAssets.mega_zombie_lower_leg, a.GameAssets.mega_zombie_foot]), k.zombie_health_bar = a.PixiDo.createAndAddSprite(k.container, a.GameAssets.zombie_health_bar, .5, .5, 35, -170), k.zombie_health_bar.visible = !1), a.PixiAnimationDo.addToContainer(k.container, k.anim), k.head = a.PixiAnimationDo.findSpriteByName(k.anim, "head"), k.body = a.PixiAnimationDo.findSpriteByName(k.anim, "body"), d != a.ZombieType.Regular && d != a.ZombieType.Limp && d != a.ZombieType.Fat || (k.hands.push(a.PixiAnimationDo.findSpriteByName(k.anim, "left_hand")), k.hands.push(a.PixiAnimationDo.findSpriteByName(k.anim, "right_hand"))), d == a.ZombieType.Regular || d == a.ZombieType.Fat ? (k.legs.push(a.PixiAnimationDo.findSpriteByName(k.anim, "left_leg")), k.legs.push(a.PixiAnimationDo.findSpriteByName(k.anim, "right_leg"))) : d == a.ZombieType.Limp ? (k.legs.push(a.PixiAnimationDo.findSpriteByName(k.anim, "front_upper_leg")), k.legs.push(a.PixiAnimationDo.findSpriteByName(k.anim, "front_lower_leg"))) : d == a.ZombieType.Mega && k.legs.push(a.PixiAnimationDo.findSpriteByName(k.anim, "left_upper_leg"))), d == a.ZombieType.Regular ? (k.walking_speed = -.85, k.walking_coeff = new b(.7, 1, 1), k.total_health = 10, k.weight = 70, k.score_for_kill = 10, k.lethal_targeted_count = 4, k.container.position.y = c.ground_level - 33, k.attack_random_distance = e.getRandomBetween(-10, 10), k.rotation_twitch_max_angle = Math.PI / 24, k.twitch_position_addition = 3, k.walking_penalty_received_coeff = 1, k.attack_damage_coeff = 1, k.head_hitbox = g.createHitbox(-2, -38, 10, 12), k.body_hitbox = g.createHitbox(-3, -24, 14, 20), k.legs_hitbox = g.createHitbox(0, -3, 8, 22), k.anim_ranges.idle = new a.AnimationRange(137, 166, .5), k.anim_ranges.start_walking = new a.AnimationRange(166, 174, .5), k.anim_ranges.walking = new a.AnimationRange(1, 60), k.anim_ranges.starting_attack = new a.AnimationRange(60, 65), k.anim_ranges.attacking = new a.AnimationRange(65, 105), k.anim_ranges.attacking_death = new a.AnimationRange(105, 120), k.anim_ranges.walking_death = new a.AnimationRange(121, 136), k.anim_ranges.feeding = new a.AnimationRange(175, 204, .5)) : d == a.ZombieType.Limp ? (k.walking_speed = -.85, k.walking_coeff = new b(.9, 1.2, 1.2), k.total_health = 30, k.weight = 100, k.score_for_kill = 30, k.lethal_targeted_count = 8, k.container.position.y = c.ground_level - 35, k.attack_random_distance = e.getRandomBetween(5, 15), k.rotation_twitch_max_angle = Math.PI / 24, k.twitch_position_addition = 3, k.walking_penalty_received_coeff = .6, k.attack_damage_coeff = 1, k.head_hitbox = g.createHitbox(-12, -37, 10, 12), k.body_hitbox = g.createHitbox(-5, -24, 13, 20), k.legs_hitbox = g.createHitbox(-5, -3, 8, 22), k.anim_ranges.idle = new a.AnimationRange(96, 120, .4), k.anim_ranges.start_walking = new a.AnimationRange(120, 129, .5), k.anim_ranges.walking = new a.AnimationRange(1, 40), k.anim_ranges.starting_attack = new a.AnimationRange(40, 45), k.anim_ranges.attacking = new a.AnimationRange(45, 65), k.anim_ranges.attacking_death = new a.AnimationRange(65, 80), k.anim_ranges.walking_death = new a.AnimationRange(81, 95)) : d == a.ZombieType.Fat ? (k.walking_speed = -.85, k.walking_coeff = new b(.5, .6, .5), k.total_health = 100, k.weight = 300, k.score_for_kill = 100, k.lethal_targeted_count = 20, k.container.position.y = c.ground_level + 10, k.attack_random_distance = e.getRandomBetween(10, 20), k.rotation_twitch_max_angle = Math.PI / 120, k.twitch_position_addition = 1, k.walking_penalty_received_coeff = .2, k.attack_damage_coeff = 1, k.head_hitbox = g.createHitbox(-2, -115, 12, 12), k.body_hitbox = g.createHitbox(-12, -100, 32, 60), k.legs_hitbox = g.createHitbox(-4, -37, 15, 15), k.anim_ranges.idle = new a.AnimationRange(197, 220, .35), k.anim_ranges.start_walking = new a.AnimationRange(220, 228, .5), k.anim_ranges.walking = new a.AnimationRange(1, 60), k.anim_ranges.starting_attack = new a.AnimationRange(60, 70), k.anim_ranges.attacking = new a.AnimationRange(70, 120), k.anim_ranges.attacking_death = new a.AnimationRange(120, 156, .5), k.anim_ranges.walking_death = new a.AnimationRange(160, 196, .5), k.anim_ranges.feeding = new a.AnimationRange(228, 250, .2)) : d == a.ZombieType.Mega && (k.walking_speed = -.85, k.walking_coeff = new b(.5, .6, .5), k.total_health = 800, k.weight = 1e3, k.score_for_kill = 1e3, k.lethal_targeted_count = 36, k.container.position.y = c.ground_level - 152, k.attack_random_distance = e.getRandomBetween(10, 20), k.rotation_twitch_max_angle = Math.PI / 600, k.twitch_position_addition = .2, k.walking_penalty_received_coeff = .03, k.attack_damage_coeff = 4, k.head_hitbox = g.createHitbox(-10, -120, 40, 30), k.body_hitbox = g.createHitbox(0, -100, 80, 150), k.legs_hitbox = g.createHitbox(50, -50, 1, 1), k.anim_ranges.idle = new a.AnimationRange(160, 180, .35), k.anim_ranges.start_walking = new a.AnimationRange(180, 190, .5), k.anim_ranges.walking = new a.AnimationRange(1, 60, .25), k.anim_ranges.starting_attack = new a.AnimationRange(60, 70), k.anim_ranges.attacking = new a.AnimationRange(70, 80, .2), k.anim_ranges.attacking_death = new a.AnimationRange(80, 115, .5), k.anim_ranges.walking_death = new a.AnimationRange(120, 156, .5), k.zombie_health_bar.scale.x = 1), k.overall_hitbox = g.getTotalHitbox([k.head_hitbox, k.body_hitbox, k.legs_hitbox]), k.global_bounds = e.copyRectangle(k.overall_hitbox.global_rect), k.select_button = a.ButtonDo.createButton(null, null, k.global_bounds), k.select_button.down_callback = function() {
                    a.GameDo.pushZombieSelected(c, k)
                }, f.randomizeMinMaxCurrent(k.walking_coeff), k.container.alpha = 1, k.current_alert_time = 0, k.health = k.total_health, k.curse_coeff = 1, k.stun_coeff = 1, k.targeted_by_defenders_count = 0, k.container.position.x = h, k.velocity.x = k.walking_speed * k.walking_coeff.current, k.stun_decided = !1, k.one_hit_decided = !1, k.one_hit_frames = 0, k.alpha_out_current_time = a.Zombie.alpha_out_time, k
            }, g.remove = function(a, b, c) {
                b.container.parent.remove(b.container), a.garbage.zombies.push(b), c.splice(c.indexOf(b), 1)
            }, g.copyHitbox = function(b) {
                var c = new a.Hitbox;
                return c.global_rect = e.copyRectangle(b.global_rect), c.local_position = e.copyPoint(b.local_position), c
            }, g.createHitbox = function(b, e, f, g) {
                var h = new a.Hitbox;
                return h.local_position = new c(b, e), h.global_rect = new d(0, 0, f, g), h
            }, g.getTotalHitbox = function(a) {
                for (var b = a[0].local_position.x, c = a[0].local_position.y, d = b + a[0].global_rect.width, e = c + a[0].global_rect.height, f = 0, h = a; f < h.length; f++) {
                    var i = h[f];
                    i.local_position.x < b && (b = i.local_position.x), i.local_position.y < c && (c = i.local_position.y), i.local_position.x + i.global_rect.width > d && (d = i.local_position.x + i.global_rect.width), i.local_position.y + i.global_rect.height > e && (e = i.local_position.y + i.global_rect.height)
                }
                return g.createHitbox(b, c, d - b, e - c)
            }, g.setHitboxGlobalPosition = function(a, b, c) {
                a.global_rect.x = a.local_position.x + b, a.global_rect.y = a.local_position.y + c
            }, g.refreshVelocity = function(b) {
                b.state == a.ZombieState.Walking ? b.velocity.x = b.walking_coeff.current * b.walking_speed : b.velocity.x = 0
            }, g
        }();
    a.ZombieDo = g
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.Point,
        c = function() {
            function a(a, c, d, e, f, g, h) {
                void 0 === a && (a = 60), void 0 === c && (c = 1e3 / 120), void 0 === d && (d = 1e3 / 15), void 0 === e && (e = 1024), void 0 === f && (f = 768), void 0 === g && (g = 1382), void 0 === h && (h = 768), this.force_size = null, this.game_position = new b(0, 0), this.height_offset = 0, this.window_scale = 1, this.device_scale = 1, this.fullscreened = !1, this.last_delta = 0, this.total_update_time = 0, this.render_time = 0, this.scale_listeners = new Array, this.game_fps = a, this.min_delta = c, this.max_delta = d, this.min_game_width = e, this.min_game_height = f, this.max_game_width = g, this.max_game_height = h, this.original_max_game_width = g, this.original_max_game_height = h, this.current_game_width = e, this.current_game_height = f, this.canvas_game_width = e, this.canvas_game_height = f
            }
            return a
        }();
    a.JsGameInfo = c;
    var d = function() {
        function a() {
            this.position = new b(0, 0)
        }
        return a
    }();
    a.GameSize = d
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = function() {
        function a() {}
        return a.getTimer = function() {
            return Date.now()
        }, a.delay = function(a, b) {
            setTimeout(b, 1e3 * a)
        }, a
    }();
    a.JsDo = b
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b;
    ! function(a) {
        a[a.FadeIn = 0] = "FadeIn", a[a.FadeOut = 1] = "FadeOut", a[a.Playing = 2] = "Playing", a[a.Paused = 3] = "Paused"
    }(b = a.MusicState || (a.MusicState = {}));
    var c = function() {
        function a(a, c) {
            this.key = "", this.state = b.Paused, this.position = 0, this.played_once = !1, this.key = a, this.max_volume = c, this.current_volume = c
        }
        return a
    }();
    a.Music = c;
    var d = function() {
        function a(a, b) {
            this.key = "", this.sounds = new Array, this.max_simultaneous = 3, this.cursor = 0, this.key = a, this.max_simultaneous = b
        }
        return a
    }();
    a.Sound = d
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = function() {
        function b() {}
        return b.setSoundsEnabled = function(a) {
            b.sounds_enabled = a
        }, b.setMusicEnabled = function(a) {
            b.music_enabled = a
        }, b.createSound = function(b, c, d, e) {
            for (var f = new a.Sound(b, e), g = 0; g < e; g++) f.sounds.push(new Phaser.Sound(a.PhaserObjects.game, b, c, d));
            return f
        }, b.createMusic = function(b, c, d, e) {
            var f = new a.Music(b, e);
            return f.sound = new Phaser.Sound(a.PhaserObjects.game, b, c, d), f
        }, b.playSound = function(a) {
            if (b.sounds_enabled && null != a) {
                for (var c = null, d = -1, e = 0, f = a.sounds; e < f.length; e++) {
                    var g = f[e];
                    if (!g.isPlaying) {
                        c = g;
                        break
                    }
                    null == c ? (c = g, d = g.currentTime) : g.currentTime > c.currentTime && (c = g, d = g.currentTime)
                }
                c.play()
            }
        }, b.stopSound = function(a) {
            if (null != a)
                for (var b = 0, c = a.sounds; b < c.length; b++) {
                    var d = c[b];
                    d.isPlaying && d.stop()
                }
        }, b.playMusicSound = function(a) {
            b.music_enabled && null != a && a.play()
        }, b.playMusic = function(b) {
            null != b && (b.state = a.MusicState.Playing, b.played_once = !0)
        }, b.replayMusic = function(b) {
            null != b && (b.state = a.MusicState.Playing)
        }, b.pauseMusic = function(b) {
            null != b && (b.state = a.MusicState.Paused)
        }, b.fadeInMusic = function(b, c) {
            void 0 === c && (c = 1 / 60), null != b && (b.state = a.MusicState.FadeIn, b.fade_step = c)
        }, b.fadeOutMusic = function(b, c) {
            void 0 === c && (c = 1 / 60), null != b && (b.state = a.MusicState.FadeOut, b.fade_step = c)
        }, b.updateMusic = function(b, c) {
            if (null != b)
                if (c) switch (b.state) {
                    case a.MusicState.FadeIn:
                        b.sound.isPlaying || (b.sound.paused ? b.sound.play("", b.position) : b.sound.play()), b.current_volume < b.max_volume && (b.current_volume += b.fade_step), b.current_volume >= b.max_volume && (b.current_volume = b.max_volume, b.state = a.MusicState.Playing), b.sound.volume = b.current_volume;
                        break;
                    case a.MusicState.FadeOut:
                        b.sound.isPlaying ? (b.current_volume > 0 && (b.current_volume -= b.fade_step), b.current_volume <= 0 && (b.current_volume = 0, b.sound.position = b.sound.position, b.sound.pause(), b.state = a.MusicState.Paused), b.sound.volume = b.current_volume) : (b.state = a.MusicState.Paused, b.current_volume = 0);
                        break;
                    case a.MusicState.Playing:
                        b.sound.isPlaying || (b.sound.paused ? b.sound.play("", b.position) : b.sound.play()), b.current_volume != b.max_volume && (b.current_volume = b.max_volume, b.sound.volume = b.current_volume);
                        break;
                    case a.MusicState.Paused:
                        b.sound.isPlaying && (b.position = b.sound.position, b.sound.pause())
                } else switch (b.sound.isPlaying && (b.position = b.sound.position, b.sound.pause()), b.state) {
                    case a.MusicState.FadeIn:
                        b.state = a.MusicState.Playing;
                        break;
                    case a.MusicState.FadeOut:
                        b.state = a.MusicState.Paused
                }
        }, b
    }();
    b.sounds_enabled = !0, b.music_enabled = !0, a.SoundDo = b
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.Size,
        c = bikas.global.Point,
        d = bikas.global.GlobalFunc,
        e = bikas.pointer.PointerStateType,
        f = function() {
            function a() {
                this.position = null, this.scale = null, this.rotation = null, this.alpha = null
            }
            return a
        }();
    a.ButtonState = f;
    var g = function() {
        function a() {
            this.container = null, this.foreground = null, this.background = null, this.enabled = !0, this.default_state = null, this.over_state = null, this.down_state = null, this.over_callback = null, this.out_callback = null, this.down_callback = null, this.up_callback = null, this.click_callback = null, this.down_sound_callback = null, this.overed = !1, this.downed = !1, this.priority_level = 0, this.last_game_size = new b((-1), (-1)), this.last_position = new c((-1), (-1))
        }
        return a
    }();
    a.Button = g;
    var h = function() {
        function b() {}
        return b.createButton = function(b, c, d) {
            void 0 === b && (b = null), void 0 === c && (c = null), void 0 === d && (d = null);
            var e = new g;
            return null != b && (e.container = a.PixiDo.createGroup()), e.global_bounds = d, e.foreground = b, e.background = c, null != c && e.container.add(c), null != b && e.container.add(b), e
        }, b.setPosition = function(a, b) {
            null == a.container && (a.global_bounds.x = b.x, a.global_bounds.x = b.y), a.container.position.set(b.x, b.y)
        }, b.updateBounds = function(b, c) {
            null != b.foreground && (b.global_bounds = a.PixiDo.getContainerBounds(b.foreground)), b.last_game_size.width = c.last_game_size.width, b.last_game_size.height = c.last_game_size.height, null != b.container && (b.last_position.x = b.container.position.x, b.last_position.y = b.container.position.y)
        }, b.createState = function(a, b, c, d) {
            void 0 === a && (a = null), void 0 === b && (b = null), void 0 === c && (c = null), void 0 === d && (d = null);
            var e = new f;
            return e.position = a, e.scale = b, e.rotation = c, e.alpha = d, e
        }, b.setState = function(a, b) {
            if (null != a.foreground && null != b) {
                var c = a.foreground;
                null != b.position && c.position.set(b.position.x, b.position.y), null != b.scale && c.scale.set(b.scale.x, b.scale.y), null != b.rotation && (c.rotation = b.rotation), null != b.alpha && (c.alpha = b.alpha)
            }
        }, b.resetButton = function(a) {
            a.downed = !1, a.overed = !1, null != a.default_state && b.setState(a, a.default_state)
        }, b.downButton = function(a) {
            a.downed = !0, null != a.down_state && b.setState(a, a.down_state), null != a.down_sound_callback && a.down_sound_callback(), null != a.down_callback && a.down_callback()
        }, b.destroy = function(a) {
            b.resetButton(a), a.down_callback = null, a.up_callback = null, a.click_callback = null, a.over_callback = null, a.out_callback = null, null != a.foreground && a.container.remove(a.foreground), null != a.background && a.background.parent.remove(a.background), a.foreground = null, a.background = null, null != a.container && null != a.container.parent && a.container.parent.remove(a.container), a.container = null
        }, b.updateBoundsIfNeeded = function(a, c) {
            null == a.global_bounds && b.updateBounds(a, c), d.sizesEqual(c.last_game_size, a.last_game_size) || b.updateBounds(a, c), null != a.container && (a.container.position.x == a.last_position.x && a.container.position.y == a.last_position.y || b.updateBounds(a, c))
        }, b.updateButton = function(a, c) {
            if (c.enabled) {
                var f = c.current,
                    g = c.state == e.DOWNED,
                    h = c.state == e.UPPED;
                if (a.enabled) {
                    b.updateBoundsIfNeeded(a, c);
                    var i = d.pointInRectangle(f, a.global_bounds);
                    g ? i && b.downButton(a) : h ? a.downed && (a.downed = !1, null != a.up_callback && a.up_callback(), i ? (null != a.over_state ? b.setState(a, a.over_state) : null != a.default_state && b.setState(a, a.default_state), null != a.click_callback && a.click_callback()) : null != a.default_state && b.setState(a, a.default_state)) : a.downed || (i ? a.overed || (a.overed = !0, a.downed || null != a.over_state && b.setState(a, a.over_state), null != a.over_callback && a.over_callback()) : i || a.overed && (a.overed = !1, null != a.over_state && null != a.default_state && b.setState(a, a.default_state), null != a.out_callback && a.out_callback()))
                }
            }
        }, b
    }();
    a.ButtonDo = h
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = function() {
        function a() {}
        return a.drawRectangle = function(a, b, c, d, e, f, g, h) {
            return void 0 === c && (c = 1), void 0 === d && (d = 16711680), void 0 === e && (e = 1), void 0 === f && (f = !1), void 0 === g && (g = 16777215), void 0 === h && (h = 1), f && a.beginFill(g), a.moveTo(b.x, b.y), a.lineTo(b.width, b.y), a.lineTo(b.width, b.height), a.lineTo(b.x, b.height), a.lineTo(b.x, b.y), f && a.endFill(), a
        }, a
    }();
    a.GraphicsDo = b
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.Point,
        c = bikas.global.Rectangle,
        d = bikas.global.GlobalFunc,
        e = bikas.global.GlobalProc,
        f = bikas.pointer.Pointer,
        g = bikas.pointer.PointerStateType,
        h = Phaser.Group,
        i = Phaser.Sprite,
        j = function() {
            function j() {}
            return j.createSprite = function(b, c, d, e, f) {
                void 0 === c && (c = 0), void 0 === d && (d = 0), void 0 === e && (e = 0), void 0 === f && (f = 0);
                var g = new i(a.PhaserObjects.game, 0, 0, b, 0);
                return g.anchor.set(c, d), g.position.set(e, f), g
            }, j.createAndAddSprite = function(b, c, d, e, f, g, h) {
                void 0 === f && (f = 0), void 0 === g && (g = 0), void 0 === h && (h = 0);
                var j = new i(a.PhaserObjects.game, 0, 0, c, 0);
                return j.anchor.set(d, e), j.position.set(f, g), j.rotation = h, null != j.body, b.add(j), j
            }, j.createAndAddButton = function(b, c, d, e, f, g, h, i) {
                void 0 === f && (f = 0), void 0 === g && (g = 0), void 0 === h && (h = 0), void 0 === i && (i = null);
                var j = new Phaser.Button(a.PhaserObjects.game, 0, 0, "");
                return j.texture = c, null != i && j.onInputDown.add(i), j.anchor.set(d, e), j.position.set(f, g), j.rotation = h, b.add(j), j
            }, j.createGroup = function() {
                var b = new h(a.PhaserObjects.game, null);
                return b
            }, j.convertRectangle = function(a) {
                return new c(a.x, a.y, a.width, a.height)
            }, j.convertRectangleTo = function(a) {
                return new Phaser.Rectangle(a.x, a.y, a.width, a.height)
            }, j.convertRectangleToPixi = function(a) {
                return new PIXI.Rectangle(a.x, a.y, a.width, a.height)
            }, j.convertPoint = function(a) {
                return new b(a.x, a.y)
            }, j.isPointInsideContainer = function(a, b) {
                return Std.is(b, i) ? d.pointInRectangle(a, j.getContainerBounds(b)) : d.pointInRectangle(a, j.getContainerBounds(b))
            }, j.toGlobal = function(a, b) {
                null != a.parent && (b.x = a.x + a.scale.x * b.x, b.y = a.y + a.scale.y * b.y, j.toGlobal(a.parent, b))
            }, j.getContainerBounds = function(b) {
                var d = j.convertRectangle(b.getLocalBounds()),
                    e = new Phaser.Point(d.x, d.y),
                    f = new Phaser.Point(d.x + d.width, d.y + d.height);
                j.toGlobal(b, e), j.toGlobal(b, f);
                var g = e.x,
                    h = e.y,
                    i = f.x,
                    k = f.y;
                f.x < e.x && (g = f.x, i = e.x), f.y < e.y && (h = f.y, k = e.y), d = new c(g, h, i - g, k - h);
                var l = a.PhaserObjects.container;
                return l != b && (d.x /= l.scale.x, d.y /= l.scale.y, d.width /= l.scale.x, d.height /= l.scale.y, d.x -= l.x / l.scale.x, d.y -= l.y / l.scale.y), d
            }, j.getLocalContainerBounds = function(a) {
                for (var b = j.convertRectangle(a.getLocalBounds()), c = a; null != c.parent;) c = c.parent;
                return c != a && (b.x *= c.scale.x, b.y *= c.scale.y, b.width *= c.scale.x, b.height *= c.scale.y), b
            }, j.addPointerEvents = function(b, c, d) {
                function h(a, b, c, d) {
                    isNaN(b) || isNaN(c) || (a.current.x = b / d.window_scale - a.last_game_offset.x, a.current.y = c / d.window_scale - a.last_game_offset.y)
                }

                function i(a, b) {
                    h(c, a, b, d), e.setPoint(c.downed, c.current), c.state = g.DOWNED
                }

                function j(a, b) {
                    h(c, a, b, d), e.setPoint(c.upped, c.current);
                    var i = Math.abs(c.upped.x - c.downed.x),
                        j = Math.abs(c.upped.y - c.downed.y);
                    c.state == g.DOWNED || c.state == g.DRAGGED && i <= f.CLICK_EVENT_DISTANCE && j <= f.CLICK_EVENT_DISTANCE ? c.state = g.CLICKED : c.state = g.UPPED
                }
                a.PhaserObjects.game.input.addMoveCallback(function(a, b, e, f) {
                    h(c, b, e, d)
                }, window), a.PhaserObjects.game.input.onDown.add(function(a, b, c, d) {
                    i(b, c)
                }), a.PhaserObjects.game.input.onUp.add(function(a, b, c, d) {
                    j(b, c)
                })
            }, j.updatePointer = function(a) {
                a.state == g.DOWNED ? a.state = g.DRAGGED : a.state == g.CLICKED ? a.state = g.UPPED : a.state == g.UPPED && (a.state = g.NONE)
            }, j
        }();
    a.PixiDo = j
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b, c = bikas.global.Interpolate;
    ! function(a) {
        a[a.Linear = 0] = "Linear", a[a.SmoothStart = 1] = "SmoothStart", a[a.SmoothEnd = 2] = "SmoothEnd", a[a.SmoothStartEnd = 3] = "SmoothStartEnd", a[a.Random = 4] = "Random", a[a.RandomNearStartEnd = 5] = "RandomNearStartEnd"
    }(b = a.InterpolationType || (a.InterpolationType = {}));
    var d = function() {
        function a() {
            this.type = null, this.time = 0, this.position = null, this.scale = null, this.rotation = null, this.alpha = null
        }
        return a
    }();
    a.TransitionState = d;
    var e;
    ! function(a) {
        a[a.InGame = 0] = "InGame", a[a.Menu = 1] = "Menu"
    }(e = a.TransitionCategoryType || (a.TransitionCategoryType = {}));
    var f = function() {
        function a() {
            this.states = new Array, this.remove_from_container = !0, this.finished = !1, this.on_finish = null
        }
        return a
    }();
    a.Transition = f;
    var g = function() {
        function a() {}
        return a.create = function(a, b, c) {
            void 0 === b && (b = null), void 0 === c && (c = !0);
            var d = new f;
            return d.category = a, d.container = b, d.remove_from_container = c, d.current_time = 0, d
        }, a.createState = function(a, c, e, f, g, h) {
            void 0 === c && (c = null), void 0 === e && (e = null), void 0 === f && (f = null), void 0 === g && (g = null), void 0 === h && (h = null);
            var i = new d;
            return null == h ? i.type = b.Linear : i.type = h, i.time = a, i.position = c, i.scale = e, i.rotation = f, i.alpha = g, i
        }, a.pushState = function(b, c, d, e, f, g, h) {
            void 0 === d && (d = null), void 0 === e && (e = null), void 0 === f && (f = null), void 0 === g && (g = null), void 0 === h && (h = null);
            var i = a.createState(c, d, e, f, g, h);
            return b.states.push(i), i
        }, a.setState = function(a, b) {
            null != b.position && (a.container.position.x = b.position.x, a.container.position.y = b.position.y), null != b.scale && (a.container.scale.x = b.scale.x, a.container.scale.y = b.scale.y), null != b.rotation && (a.container.rotation = b.rotation), null != b.alpha && (a.container.alpha = b.alpha)
        }, a.setLastState = function(b) {
            a.setState(b, b.states[b.states.length - 1])
        }, a.setInitState = function(b) {
            a.setState(b, b.states[0])
        }, a.update = function(d, f, g) {
            for (var h = 0, i = d.length; h < i;) {
                var j = d[h];
                switch (j.category) {
                    case e.InGame:
                        j.current_time += f;
                        break;
                    case e.Menu:
                        j.current_time += g
                }
                if (1 == j.states.length) j.current_time >= j.states[0].time && (j.finished = !0, d.splice(h, 1), h--, i--, null != j.on_finish && (j.on_finish(), j.on_finish = null));
                else if (j.states.length >= 2) {
                    var k = null,
                        l = null;
                    if (null == j.container) break;
                    for (var m = 1; m < j.states.length; m++) {
                        var n = j.states[m];
                        if (n.time > j.current_time) {
                            k = j.states[m - 1], l = n;
                            break
                        }
                    }
                    if (null == k || null == l) j.finished = !0, a.setState(j, j.states[j.states.length - 1]), j.remove_from_container && null != j.container.parent && j.container.parent.remove(j.container), d.splice(h, 1), h--, i--, null != j.on_finish && (j.on_finish(), j.on_finish = null);
                    else {
                        j.finished = !1;
                        var o = (j.current_time - k.time) / (l.time - k.time);
                        if (l.type == b.Linear) null != k.position && null != l.position && (j.container.position.x = c.linear(k.position.x, l.position.x, o), j.container.position.y = c.linear(k.position.y, l.position.y, o)), null != k.scale && null != l.scale && (j.container.scale.x = c.linear(k.scale.x, l.scale.x, o), j.container.scale.y = c.linear(k.scale.y, l.scale.y, o)), null != k.rotation && null != l.rotation && (j.container.rotation = c.linear(k.rotation, l.rotation, o)), null != k.alpha && null != l.alpha && (j.container.alpha = c.linear(k.alpha, l.alpha, o));
                        else if (l.type == b.SmoothStart) null != k.position && null != l.position && (j.container.position.x = c.smoothStart(k.position.x, l.position.x, o), j.container.position.y = c.smoothStart(k.position.y, l.position.y, o)), null != k.scale && null != l.scale && (j.container.scale.x = c.smoothStart(k.scale.x, l.scale.x, o), j.container.scale.y = c.smoothStart(k.scale.y, l.scale.y, o)), null != k.rotation && null != l.rotation && (j.container.rotation = c.smoothStart(k.rotation, l.rotation, o)), null != k.alpha && null != l.alpha && (j.container.alpha = c.smoothStart(k.alpha, l.alpha, o));
                        else if (l.type == b.SmoothEnd) null != k.position && null != l.position && (j.container.position.x = c.smoothEnd(k.position.x, l.position.x, o), j.container.position.y = c.smoothEnd(k.position.y, l.position.y, o)), null != k.scale && null != l.scale && (j.container.scale.x = c.smoothEnd(k.scale.x, l.scale.x, o), j.container.scale.y = c.smoothEnd(k.scale.y, l.scale.y, o)), null != k.rotation && null != l.rotation && (j.container.rotation = c.smoothEnd(k.rotation, l.rotation, o)), null != k.alpha && null != l.alpha && (j.container.alpha = c.smoothEnd(k.alpha, l.alpha, o));
                        else if (l.type == b.SmoothStartEnd) null != k.position && null != l.position && (j.container.position.x = c.smoothStartEnd(k.position.x, l.position.x, o), j.container.position.y = c.smoothStartEnd(k.position.y, l.position.y, o)), null != k.scale && null != l.scale && (j.container.scale.x = c.smoothStartEnd(k.scale.x, l.scale.x, o), j.container.scale.y = c.smoothStartEnd(k.scale.y, l.scale.y, o)), null != k.rotation && null != l.rotation && (j.container.rotation = c.smoothStartEnd(k.rotation, l.rotation, o)), null != k.alpha && null != l.alpha && (j.container.alpha = c.smoothStartEnd(k.alpha, l.alpha, o));
                        else if (l.type == b.Random) null != k.position && null != l.position && (j.container.position.x = c.linear(k.position.x, l.position.x, Math.random()), j.container.position.y = c.linear(k.position.y, l.position.y, Math.random())), null != k.scale && null != l.scale && (j.container.scale.x = c.linear(k.scale.x, l.scale.x, Math.random()), j.container.scale.y = c.linear(k.scale.y, l.scale.y, Math.random())), null != k.rotation && null != l.rotation && (j.container.rotation = c.linear(k.rotation, l.rotation, Math.random())), null != k.alpha && null != l.alpha && (j.container.alpha = c.linear(k.alpha, l.alpha, Math.random()));
                        else if (l.type == b.RandomNearStartEnd) {
                            var p = 0;
                            null != k.position && null != l.position && (p = c.smoothStartEnd(0, 1, Math.random()), j.container.position.x = c.linear(k.position.x, l.position.x, p), p = c.smoothStartEnd(0, 1, Math.random()), j.container.position.y = c.linear(k.position.y, l.position.y, p)), null != k.scale && null != l.scale && (p = c.smoothStartEnd(0, 1, Math.random()), j.container.scale.x = c.linear(k.scale.x, l.scale.x, p), p = c.smoothStartEnd(0, 1, Math.random()), j.container.scale.y = c.linear(k.scale.y, l.scale.y, p)), null != k.rotation && null != l.rotation && (p = c.smoothStartEnd(0, 1, Math.random()), j.container.rotation = c.linear(k.rotation, l.rotation, p)), null != k.alpha && null != l.alpha && (p = c.smoothStartEnd(0, 1, Math.random()), j.container.alpha = c.linear(k.alpha, l.alpha, p))
                        }
                    }
                }
                h++
            }
        }, a
    }();
    a.TransitionDo = g
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = function() {
        function a() {}
        return a
    }();
    b.Development = 1, b.DevelopmentWithSounds = 2, b.DevelopmentTrailer = 3, b.Debug = 4, b.Release = 5, a.ConfigType = b
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.animation.AnimationSerializer,
        c = bikas.global.Rectangle,
        d = haxe.io.Bytes,
        e = PIXI.Texture,
        f = function() {
            function f() {}
            return f.init = function(c, g) {
                g.sounds_enabled && (f.sound_arrow = f.addSound(c, "assets/sounds/", "arrow", !1, .8, 3), f.sound_bell = f.addSound(c, "assets/sounds/", "bell", !1, .7), f.sound_buy = f.addSound(c, "assets/sounds/", "buy", !1, .7), f.sound_click = f.addSound(c, "assets/sounds/", "click", !1, .7), f.sound_coins = f.addSound(c, "assets/sounds/", "coins", !1, .7), f.sound_collapse = f.addSound(c, "assets/sounds/", "collapse", !1, .9), f.sound_drums = f.addSound(c, "assets/sounds/", "drums", !1, .7), f.sound_health_lost = f.addSound(c, "assets/sounds/", "health_lost", !1, 1), f.sound_level_up = f.addSound(c, "assets/sounds/", "level_up", !1, 1), f.sound_power_arrows = f.addSound(c, "assets/sounds/", "power_arrows", !1, 1), f.sound_power_charge = f.addSound(c, "assets/sounds/", "power_charge", !1, .6), f.sound_power_force = f.addSound(c, "assets/sounds/", "power_force", !1, 1), f.sound_power_release = f.addSound(c, "assets/sounds/", "power_release", !1, .8), f.sound_treasure = f.addSound(c, "assets/sounds/", "treasure", !1, .9), f.sound_unlock = f.addSound(c, "assets/sounds/", "unlock", !1, .9), f.sound_zombie_dead = f.addSound(c, "assets/sounds/", "zombie_dead", !1, .4), f.sound_zombie_fat_dead = f.addSound(c, "assets/sounds/", "zombie_fat_dead", !1, .2), f.sound_zombie_mega_dead = f.addSound(c, "assets/sounds/", "zombie_mega_dead", !1, .8), f.sound_zombie_headshot = f.addSound(c, "assets/sounds/", "zombie_headshot", !1, .2), f.sound_zombie_hit = f.addSound(c, "assets/sounds/", "zombie_hit", !1, .7), f.sound_zombie_regular = f.addSound(c, "assets/sounds/", "zombie_regular", !1, .5), f.sound_zombie_small_pack = f.addSound(c, "assets/sounds/", "zombie_small_pack", !1, .7), f.sound_zombie_small_pack_2 = f.addSound(c, "assets/sounds/", "zombie_small_pack_2", !1, .7), f.sound_bang = f.addSound(c, "assets/sounds/", "bang", !1, .7), f.sound_bang_short = f.addSound(c, "assets/sounds/", "bang_short", !1, .7), f.sound_transition_in = f.addSound(c, "assets/sounds/", "transition_in", !1, .9), f.sound_loop_eating = f.addMusic(c, "assets/sounds/", "eating", !0, .9), f.sound_loop_flies = f.addMusic(c, "assets/sounds/", "flies", !0, .3), f.music_medieval = f.addMusic(c, "assets/music/", "medieval", !0, .3), f.music_desert = f.addMusic(c, "assets/music/", "desert", !0, .2));
                var h = b.describeData(),
                    i = new Array;
                f.addBinaryToLoader(c, i, "assets/animations/", "zombie_animation"), f.addBinaryToLoader(c, i, "assets/animations/", "limp_zombie_animation"), f.addBinaryToLoader(c, i, "assets/animations/", "fat_zombie_animation"), f.addBinaryToLoader(c, i, "assets/animations/", "mega_zombie_animation"), f.addBinaryToLoader(c, i, "assets/animations/", "archer_animation"), f.addBinaryToLoader(c, i, "assets/animations/", "king_animation"), f.addBinaryToLoader(c, i, "assets/animations/", "donkey_animation");
                var j = new Array,
                    k = new Array,
                    l = new Array;
                f.addSpriteSheetToLoader(c, k, "assets/spritesheets/", "backgrounds"), f.addSpriteSheetToLoader(c, k, "assets/spritesheets/", "everything"), f.addSpriteSheetToLoader(c, k, "assets/spritesheets/", "colors"), f.addTextureToLoader(c, j, "assets/spritesheets/", "background_extended");
                var m = new Array;
                f.addFontToLoader(c, m, "assets/spritesheets/", "everything", "accidental_presidency_42_light"), f.addFontToLoader(c, m, "assets/spritesheets/", "everything", "accidental_presidency_35_brown"), f.addFontToLoader(c, m, "assets/spritesheets/", "everything", "accidental_presidency_60_brown"), c.onLoadComplete.add(function() {
                    for (var c = 0, g = i; c < g.length; c++) {
                        var n = g[c],
                            o = a.PhaserObjects.game.cache.getBinary(n);
                        Reflect.setField(f, n, b.unserialize(h, d.ofData(o)))
                    }
                    for (var p = 0, q = k; p < q.length; p++) {
                        var r = q[p],
                            s = a.PhaserObjects.game.cache.getText(r + "_description");
                        l.push(f.parseSpriteSheetPackerData(r, s))
                    }
                    f.assignTexturesToVars(a.PhaserObjects.game.cache, j, l);
                    for (var t = a.PhaserObjects.game.cache, u = 0, v = m; u < v.length; u++)
                        for (var w = v[u], x = t.getBitmapFont(w), y = Reflect.fields(x.font.chars), z = Reflect.field(f, w), A = z.frame.x, B = z.frame.y, C = 0, D = y; C < D.length; C++) {
                            var E = D[C],
                                F = Reflect.field(x.font.chars, E),
                                G = Reflect.field(F, "texture");
                            Reflect.setField(F, "texture", new e(z.baseTexture, new PIXI.Rectangle(G.frame.x + A, G.frame.y + B, G.frame.width, G.frame.height)))
                        }
                })
            }, f.assignTexturesToVars = function(b, c, d) {
                for (var g = 0, h = c; g < h.length; g++) {
                    var i = h[g],
                        j = b.getBaseTexture(i),
                        k = new e(j, new PIXI.Rectangle(0, 0, j.width, j.height));
                    Reflect.setField(f, i, k)
                }
                for (var l = 0, m = d; l < m.length; l++) {
                    var n = m[l];
                    n.base_texture = b.getBaseTexture(n.name);
                    for (var o = 0, p = n.sprite_sheet_textures; o < p.length; o++) {
                        var q = p[o],
                            k = new e(n.base_texture, a.PixiDo.convertRectangleToPixi(q.rectangle));
                        Reflect.setField(f, q.name, k)
                    }
                }
            }, f.addTextureToLoader = function(a, b, c, d) {
                b.push(d);
                var e = c + d + ".png";
                a.image(d, e)
            }, f.addBinaryToLoader = function(a, b, c, d) {
                b.push(d);
                var e = c + d + ".bef";
                a.binary(d, e)
            }, f.addSpriteSheetToLoader = function(a, b, c, d) {
                b.push(d), a.text(d + "_description", c + d + ".txt"), a.image(d, c + d + ".png")
            }, f.addFontToLoader = function(a, b, c, d, e) {
                b.push(e);
                var f = c + d + ".png",
                    g = c + e + ".fnt";
                a.bitmapFont(e, f, g, null)
            }, f.parseSpriteSheetPackerData = function(a, b) {
                for (var d, e = b.replace(/\r\n/, "\n").split("\n"), f = /\s+/, i = new Array, j = 0, k = e; j < k.length; j++) {
                    var l = k[j];
                    if (d = l.split(f), d.length > 0) {
                        var m = new h;
                        m.name = d[0], m.rectangle = new c(Std.parseInt(d[2]), Std.parseInt(d[3]), Std.parseInt(d[4]), Std.parseInt(d[5])), i.push(m)
                    }
                }
                var n = new g;
                return n.name = a, n.sprite_sheet_textures = i, n.base_texture = null, n
            }, f.getSourcesBySoundFormat = function(a, b, c) {
                var d = [];
                return null == c && (c = i.OGG_M4A), c == i.OGG_M4A ? d = [a + "ogg/" + b + ".ogg", a + "m4a/" + b + ".m4a"] : c == i.MP3_OGG_M4A ? d = [a + "mp3/" + b + ".mp3", a + "ogg/" + b + ".ogg", a + "m4a/" + b + ".m4a"] : c == i.JUST_MP3 && (d = [a + b + ".mp3"]), d
            }, f.addSound = function(b, c, d, e, g, h, i) {
                void 0 === e && (e = !1), void 0 === g && (g = .7), void 0 === h && (h = 3), void 0 === i && (i = null);
                var j = f.getSourcesBySoundFormat(c, d, i);
                b.audio(d, j);
                var k = a.SoundDo.createSound(d, g, e, h);
                return k
            }, f.addMusic = function(b, c, d, e, g, h) {
                void 0 === e && (e = !0), void 0 === g && (g = .5), void 0 === h && (h = null);
                var i = f.getSourcesBySoundFormat(c, d, h);
                b.audio(d, i);
                var j = a.SoundDo.createMusic(d, g, e, g);
                return j
            }, f
        }();
    f.sound_arrow = null, f.sound_bell = null, f.sound_buy = null, f.sound_click = null, f.sound_coins = null, f.sound_collapse = null, f.sound_drums = null, f.sound_health_lost = null, f.sound_level_up = null, f.sound_power_arrows = null, f.sound_power_charge = null, f.sound_power_force = null, f.sound_power_release = null, f.sound_treasure = null, f.sound_unlock = null, f.sound_zombie_dead = null, f.sound_zombie_fat_dead = null, f.sound_zombie_mega_dead = null, f.sound_zombie_headshot = null, f.sound_zombie_hit = null, f.sound_zombie_regular = null, f.sound_zombie_small_pack = null, f.sound_zombie_small_pack_2 = null, f.sound_bang = null, f.sound_bang_short = null, f.sound_transition_in = null, f.sound_loop_eating = null, f.sound_loop_flies = null, f.music_medieval = null, f.music_desert = null, a.GameAssets = f;
    var g = function() {
        function a() {
            this.sprite_sheet_textures = new Array
        }
        return a
    }();
    a.SpriteSheetTexturePack = g;
    var h = function() {
        function a() {}
        return a
    }();
    a.SpriteSheetSingleTexture = h;
    var i;
    ! function(a) {
        a[a.OGG_M4A = 0] = "OGG_M4A", a[a.MP3_OGG_M4A = 1] = "MP3_OGG_M4A", a[a.JUST_MP3 = 2] = "JUST_MP3"
    }(i = a.SoundFormats || (a.SoundFormats = {}))
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = bikas.global.Size,
        c = bikas.global.GlobalFunc,
        d = bikas.pointer.Pointer,
        e = Phaser.ScaleManager,
        f = function() {
            function f() {}
            return f.initializeAndStart = function(b) {
                function c(a) {
                    var b = "";
                    return b = a.indexOf("://") > -1 ? a.split("/")[2] : a.split("/")[0], b = b.split(":")[0], b = StringTools.replace(b, "www.", "")
                }

                function d(a) {
                    try {
                        if (null != window.location.ancestorOrigins)
                            for (var b = window.location.ancestorOrigins, d = 0; d < b.length;) {
                                var e = b[d];
                                if (c(e) != a) return !1;
                                d++
                            }
                    } catch (f) {}
                    if (window.top != window.self) {
                        var g = "";
                        if (g = c(document.referrer), g != a) return !1
                    }
                    return c(window.location.hostname) == a
                }
                var e = f.getConfig();
                if (!e.sitelocked || e.sitelock_type != g.BikasNet || d("bikas.net")) {
                    switch (e.type) {
                        case a.ConfigType.Development:
                            break;
                        case a.ConfigType.DevelopmentWithSounds:
                            break;
                        case a.ConfigType.DevelopmentTrailer:
                            break;
                        case a.ConfigType.Debug:
                            break;
                        case a.ConfigType.Release:
                    }
                    var h = a.JsDo.getTimer();
                    f.create(e, b, h)
                }
            }, f.getConfig = function() {
                var b = new h;
                return b.type = a.ConfigType.Release, b.sitelock_type = g.None, b.save_separate_levels = !1, b.type == a.ConfigType.Development ? (b.sounds_enabled = !1, b.google_analytics_enabled = !1, b.sitelocked = !1) : b.type == a.ConfigType.DevelopmentWithSounds ? (b.sounds_enabled = !0, b.google_analytics_enabled = !1, b.sitelocked = !1) : b.type == a.ConfigType.DevelopmentTrailer ? (b.sounds_enabled = !1, b.google_analytics_enabled = !1, b.sitelocked = !1) : b.type == a.ConfigType.Debug ? (b.sounds_enabled = !0, b.google_analytics_enabled = !0, b.sitelocked = !1) : b.type == a.ConfigType.Release && (b.sounds_enabled = !0, b.google_analytics_enabled = !0, b.sitelocked = !0), b
            }, f.create = function(c, e, g) {
                var h = a.PixiDo.createGroup();
                h.hitArea = new Phaser.Rectangle(0, 0, 0, 0);
                var i = a.PhaserObjects.game.add.group();
                a.PhaserObjects.container = i;
                var j = !0,
                    k = new a.JsGameInfo(60, 1e3 / 240, 1e3 / 15, 1024, 768, 1382, 768);
                k.gamecanvas = a.PhaserObjects.game.canvas, k.pointer_container = h, c.type == a.ConfigType.DevelopmentTrailer && (k.force_size = new b(640, 360));
                var l = new d(16);
                a.PixiDo.addPointerEvents(i, l, k), f.scaleAndCenter(i, k, l), f.addEvent(window, "load", function() {
                    f.scaleAndCenter(i, k, l)
                }), f.addEvent(window, "resize", function() {
                    f.scaleAndCenter(i, k, l)
                }), f.addEvent(window, "scroll", function() {
                    f.scaleAndCenter(i, k, l)
                }), null != window && (window.addEventListener("gesturestart", function(a) {
                    a.preventDefault(), f.scaleAndCenter(i, k, l)
                }, !1), window.addEventListener("gestureend", function(a) {
                    a.preventDefault(), f.scaleAndCenter(i, k, l)
                }, !1), window.addEventListener("gesturechange", function(a) {
                    a.preventDefault()
                }, !1)), c.type == a.ConfigType.Development || c.type == a.ConfigType.Debug, e.game_data = a.GameDo.createGame(c, k, l, i, j), e.js_info = k, e.game_container = i, f.scaleAndCenter(i, k, l)
            }, f.addEvent = function(a, b, c) {
                null != a && (null != a.addEventListener ? a.addEventListener(b, c, !1) : null != a.attachEvent ? a.attachEvent("on" + b, c) : Reflect.setProperty(a, "on" + b, c))
            }, f.scaleAndCenter = function(b, c, d) {
                var g = window.devicePixelRatio,
                    h = window.innerWidth,
                    i = window.innerHeight;
                null != c.force_size && (h = c.force_size.width, i = c.force_size.height, g = 1);
                var j = h * g,
                    k = i * g,
                    l = f.getGameWindowSize(j, k, c.min_game_width, c.max_game_width, c.min_game_height);
                c.current_game_width = Math.round(l.width), c.current_game_height = Math.round(l.height), c.canvas_game_width = Math.round(l.canvas_width), c.canvas_game_height = Math.round(l.canvas_height), c.device_scale = g, c.window_scale = l.scale, c.game_position = l.position, c.height_offset = c.game_position.y / c.window_scale, d.last_game_size.width = c.current_game_width, d.last_game_size.height = c.current_game_height, d.last_game_offset.x = c.game_position.x / c.window_scale, d.last_game_offset.y = c.game_position.y / c.window_scale, b.position.x = Math.round(l.position.x), b.position.y = Math.round(l.position.y), b.scale.x = b.scale.y = c.window_scale, b.hitArea = new Phaser.Rectangle(-b.position.x / c.window_scale, -b.position.y / c.window_scale, c.current_game_width, c.current_game_height), a.PhaserObjects.game.scale.setGameSize(c.canvas_game_width, c.canvas_game_height);
                for (var m = 0, n = c.scale_listeners; m < n.length; m++) {
                    var o = n[m];
                    o()
                }
                null != c.force_size ? (a.PhaserObjects.game.scale.scaleMode = e.NO_SCALE, a.PhaserObjects.game.scale.fullScreenScaleMode = e.NO_SCALE) : a.PhaserObjects.game.scale.scaleMode != e.SHOW_ALL && (a.PhaserObjects.game.scale.scaleMode = e.SHOW_ALL, a.PhaserObjects.game.scale.fullScreenScaleMode = e.SHOW_ALL)
            }, f.getGameWindowSize = function(b, d, e, f, g) {
                var h = b / d,
                    i = e / g,
                    j = f / g,
                    k = c.clamp(h, i, j),
                    l = new a.GameSize;
                l.width = d * k, l.height = l.width / k;
                var m = g / l.height;
                l.width *= m, l.height *= m;
                var n = b / l.width,
                    o = d / l.height;
                if (l.scale = c.min(n, o), h < 4 / 3) {
                    l.height = l.height * (4 / 3) / h, l.height > 2048 && (l.height = 2048);
                    var p = 1.24;
                    l.position.x = 0, l.position.y = (.5 * l.height - 384) * l.scale * p
                } else l.position.x = 0, l.position.y = 0;
                return l.canvas_width = l.width * l.scale, l.canvas_height = l.height * l.scale, l
            }, f
        }();
    a.InitDo = f;
    var g = function() {
        function a() {}
        return a
    }();
    g.None = 1, g.BikasNet = 2, a.SitelockType = g;
    var h = function() {
        function b() {
            this.type = a.ConfigType.Release, this.sitelock_type = g.None, this.save_separate_levels = !1, this.sounds_enabled = !1, this.google_analytics_enabled = !1, this.sitelocked = !1
        }
        return b
    }();
    a.GameConfig = h;
    var i = function() {
        function b() {
            this.now = 0, this.last = Date.now(), this.delta = 0, this.game_data = null, this.js_info = null
        }
        return b.prototype.update = function() {
            null != this.game_data && null != this.js_info && (this.now = Date.now(), this.delta = this.now - this.last, this.delta > this.js_info.max_delta && (this.delta = this.js_info.max_delta), this.js_info.last_delta = this.delta, this.delta > this.js_info.min_delta && (null != this.game_data && (a.GameDo.update(this.game_data, this.delta), this.js_info.render_time = Date.now() - this.now, a.PixiDo.updatePointer(this.game_data.pointer)), this.last = this.now), this.js_info.total_update_time = Date.now() - this.now)
        }, b
    }();
    a.GameUpdater = i
}(MedievalDefenseZ || (MedievalDefenseZ = {}));
var MedievalDefenseZ;
! function(a) {
    var b = function() {
        function a() {}
        return a
    }();
    a.PhaserObjects = b
}(MedievalDefenseZ || (MedievalDefenseZ = {}));